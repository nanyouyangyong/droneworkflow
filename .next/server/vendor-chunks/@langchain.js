"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@langchain";
exports.ids = ["vendor-chunks/@langchain"];
exports.modules = {

/***/ "(rsc)/./node_modules/@langchain/core/callbacks/base.js":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/core/callbacks/base.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseCallbackHandler: () => (/* reexport safe */ _dist_callbacks_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler),
/* harmony export */   callbackHandlerPrefersStreaming: () => (/* reexport safe */ _dist_callbacks_base_js__WEBPACK_IMPORTED_MODULE_0__.callbackHandlerPrefersStreaming),
/* harmony export */   isBaseCallbackHandler: () => (/* reexport safe */ _dist_callbacks_base_js__WEBPACK_IMPORTED_MODULE_0__.isBaseCallbackHandler)
/* harmony export */ });
/* harmony import */ var _dist_callbacks_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/callbacks/base.js */ "(rsc)/./node_modules/@langchain/core/dist/callbacks/base.js");


/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/agents.js":
/*!*****************************************************!*\
  !*** ./node_modules/@langchain/core/dist/agents.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvYWdlbnRzLmpzIiwibWFwcGluZ3MiOiI7QUFBVSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxhZ2VudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/agents.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/caches/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/caches/base.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCache: () => (/* binding */ BaseCache),\n/* harmony export */   InMemoryCache: () => (/* binding */ InMemoryCache),\n/* harmony export */   deserializeStoredGeneration: () => (/* binding */ deserializeStoredGeneration),\n/* harmony export */   getCacheKey: () => (/* binding */ getCacheKey),\n/* harmony export */   serializeGeneration: () => (/* binding */ serializeGeneration)\n/* harmony export */ });\n/* harmony import */ var _utils_hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/hash.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/hash.js\");\n/* harmony import */ var _messages_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../messages/utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.js\");\n\n\n/**\n * This cache key should be consistent across all versions of LangChain.\n * It is currently NOT consistent across versions of LangChain.\n *\n * A huge benefit of having a remote cache (like redis) is that you can\n * access the cache from different processes/machines. The allows you to\n * separate concerns and scale horizontally.\n *\n * TODO: Make cache key consistent across versions of LangChain.\n *\n * @deprecated Use `makeDefaultKeyEncoder()` to create a custom key encoder.\n * This function will be removed in a future version.\n */\nconst getCacheKey = (...strings) => (0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_0__.insecureHash)(strings.join(\"_\"));\nfunction deserializeStoredGeneration(storedGeneration) {\n    if (storedGeneration.message !== undefined) {\n        return {\n            text: storedGeneration.text,\n            message: (0,_messages_utils_js__WEBPACK_IMPORTED_MODULE_1__.mapStoredMessageToChatMessage)(storedGeneration.message),\n        };\n    }\n    else {\n        return { text: storedGeneration.text };\n    }\n}\nfunction serializeGeneration(generation) {\n    const serializedValue = {\n        text: generation.text,\n    };\n    if (generation.message !== undefined) {\n        serializedValue.message = generation.message.toDict();\n    }\n    return serializedValue;\n}\n/**\n * Base class for all caches. All caches should extend this class.\n */\nclass BaseCache {\n    constructor() {\n        // For backwards compatibility, we use a default key encoder\n        // that uses SHA-1 to hash the prompt and LLM key. This will also print a warning\n        // about the security implications of using SHA-1 as a cache key.\n        Object.defineProperty(this, \"keyEncoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getCacheKey\n        });\n    }\n    /**\n     * Sets a custom key encoder function for the cache.\n     * This function should take a prompt and an LLM key and return a string\n     * that will be used as the cache key.\n     * @param keyEncoderFn The custom key encoder function.\n     */\n    makeDefaultKeyEncoder(keyEncoderFn) {\n        this.keyEncoder = keyEncoderFn;\n    }\n}\nconst GLOBAL_MAP = new Map();\n/**\n * A cache for storing LLM generations that stores data in memory.\n */\nclass InMemoryCache extends BaseCache {\n    constructor(map) {\n        super();\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cache = map ?? new Map();\n    }\n    /**\n     * Retrieves data from the cache using a prompt and an LLM key. If the\n     * data is not found, it returns null.\n     * @param prompt The prompt used to find the data.\n     * @param llmKey The LLM key used to find the data.\n     * @returns The data corresponding to the prompt and LLM key, or null if not found.\n     */\n    lookup(prompt, llmKey) {\n        return Promise.resolve(this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null);\n    }\n    /**\n     * Updates the cache with new data using a prompt and an LLM key.\n     * @param prompt The prompt used to store the data.\n     * @param llmKey The LLM key used to store the data.\n     * @param value The data to be stored.\n     */\n    async update(prompt, llmKey, value) {\n        this.cache.set(this.keyEncoder(prompt, llmKey), value);\n    }\n    /**\n     * Returns a global instance of InMemoryCache using a predefined global\n     * map as the initial cache.\n     * @returns A global instance of InMemoryCache.\n     */\n    static global() {\n        return new InMemoryCache(GLOBAL_MAP);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FjaGVzL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFnRDtBQUNxQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQyw0REFBWTtBQUNoRDtBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpRkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxjYWNoZXNcXGJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5zZWN1cmVIYXNoIH0gZnJvbSBcIi4uL3V0aWxzL2hhc2guanNcIjtcbmltcG9ydCB7IG1hcFN0b3JlZE1lc3NhZ2VUb0NoYXRNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VzL3V0aWxzLmpzXCI7XG4vKipcbiAqIFRoaXMgY2FjaGUga2V5IHNob3VsZCBiZSBjb25zaXN0ZW50IGFjcm9zcyBhbGwgdmVyc2lvbnMgb2YgTGFuZ0NoYWluLlxuICogSXQgaXMgY3VycmVudGx5IE5PVCBjb25zaXN0ZW50IGFjcm9zcyB2ZXJzaW9ucyBvZiBMYW5nQ2hhaW4uXG4gKlxuICogQSBodWdlIGJlbmVmaXQgb2YgaGF2aW5nIGEgcmVtb3RlIGNhY2hlIChsaWtlIHJlZGlzKSBpcyB0aGF0IHlvdSBjYW5cbiAqIGFjY2VzcyB0aGUgY2FjaGUgZnJvbSBkaWZmZXJlbnQgcHJvY2Vzc2VzL21hY2hpbmVzLiBUaGUgYWxsb3dzIHlvdSB0b1xuICogc2VwYXJhdGUgY29uY2VybnMgYW5kIHNjYWxlIGhvcml6b250YWxseS5cbiAqXG4gKiBUT0RPOiBNYWtlIGNhY2hlIGtleSBjb25zaXN0ZW50IGFjcm9zcyB2ZXJzaW9ucyBvZiBMYW5nQ2hhaW4uXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBtYWtlRGVmYXVsdEtleUVuY29kZXIoKWAgdG8gY3JlYXRlIGEgY3VzdG9tIGtleSBlbmNvZGVyLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldENhY2hlS2V5ID0gKC4uLnN0cmluZ3MpID0+IGluc2VjdXJlSGFzaChzdHJpbmdzLmpvaW4oXCJfXCIpKTtcbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZVN0b3JlZEdlbmVyYXRpb24oc3RvcmVkR2VuZXJhdGlvbikge1xuICAgIGlmIChzdG9yZWRHZW5lcmF0aW9uLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogc3RvcmVkR2VuZXJhdGlvbi50ZXh0LFxuICAgICAgICAgICAgbWVzc2FnZTogbWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2Uoc3RvcmVkR2VuZXJhdGlvbi5tZXNzYWdlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IHN0b3JlZEdlbmVyYXRpb24udGV4dCB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVHZW5lcmF0aW9uKGdlbmVyYXRpb24pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVmFsdWUgPSB7XG4gICAgICAgIHRleHQ6IGdlbmVyYXRpb24udGV4dCxcbiAgICB9O1xuICAgIGlmIChnZW5lcmF0aW9uLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJpYWxpemVkVmFsdWUubWVzc2FnZSA9IGdlbmVyYXRpb24ubWVzc2FnZS50b0RpY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRWYWx1ZTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGNhY2hlcy4gQWxsIGNhY2hlcyBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdlIHVzZSBhIGRlZmF1bHQga2V5IGVuY29kZXJcbiAgICAgICAgLy8gdGhhdCB1c2VzIFNIQS0xIHRvIGhhc2ggdGhlIHByb21wdCBhbmQgTExNIGtleS4gVGhpcyB3aWxsIGFsc28gcHJpbnQgYSB3YXJuaW5nXG4gICAgICAgIC8vIGFib3V0IHRoZSBzZWN1cml0eSBpbXBsaWNhdGlvbnMgb2YgdXNpbmcgU0hBLTEgYXMgYSBjYWNoZSBrZXkuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleUVuY29kZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdldENhY2hlS2V5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY3VzdG9tIGtleSBlbmNvZGVyIGZ1bmN0aW9uIGZvciB0aGUgY2FjaGUuXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgdGFrZSBhIHByb21wdCBhbmQgYW4gTExNIGtleSBhbmQgcmV0dXJuIGEgc3RyaW5nXG4gICAgICogdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5RW5jb2RlckZuIFRoZSBjdXN0b20ga2V5IGVuY29kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbWFrZURlZmF1bHRLZXlFbmNvZGVyKGtleUVuY29kZXJGbikge1xuICAgICAgICB0aGlzLmtleUVuY29kZXIgPSBrZXlFbmNvZGVyRm47XG4gICAgfVxufVxuY29uc3QgR0xPQkFMX01BUCA9IG5ldyBNYXAoKTtcbi8qKlxuICogQSBjYWNoZSBmb3Igc3RvcmluZyBMTE0gZ2VuZXJhdGlvbnMgdGhhdCBzdG9yZXMgZGF0YSBpbiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbk1lbW9yeUNhY2hlIGV4dGVuZHMgQmFzZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FjaGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG1hcCA/PyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkYXRhIGZyb20gdGhlIGNhY2hlIHVzaW5nIGEgcHJvbXB0IGFuZCBhbiBMTE0ga2V5LiBJZiB0aGVcbiAgICAgKiBkYXRhIGlzIG5vdCBmb3VuZCwgaXQgcmV0dXJucyBudWxsLlxuICAgICAqIEBwYXJhbSBwcm9tcHQgVGhlIHByb21wdCB1c2VkIHRvIGZpbmQgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIGxsbUtleSBUaGUgTExNIGtleSB1c2VkIHRvIGZpbmQgdGhlIGRhdGEuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvbXB0IGFuZCBMTE0ga2V5LCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsb29rdXAocHJvbXB0LCBsbG1LZXkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNhY2hlLmdldCh0aGlzLmtleUVuY29kZXIocHJvbXB0LCBsbG1LZXkpKSA/PyBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2FjaGUgd2l0aCBuZXcgZGF0YSB1c2luZyBhIHByb21wdCBhbmQgYW4gTExNIGtleS5cbiAgICAgKiBAcGFyYW0gcHJvbXB0IFRoZSBwcm9tcHQgdXNlZCB0byBzdG9yZSB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gbGxtS2V5IFRoZSBMTE0ga2V5IHVzZWQgdG8gc3RvcmUgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBkYXRhIHRvIGJlIHN0b3JlZC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUocHJvbXB0LCBsbG1LZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KHRoaXMua2V5RW5jb2Rlcihwcm9tcHQsIGxsbUtleSksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGdsb2JhbCBpbnN0YW5jZSBvZiBJbk1lbW9yeUNhY2hlIHVzaW5nIGEgcHJlZGVmaW5lZCBnbG9iYWxcbiAgICAgKiBtYXAgYXMgdGhlIGluaXRpYWwgY2FjaGUuXG4gICAgICogQHJldHVybnMgQSBnbG9iYWwgaW5zdGFuY2Ugb2YgSW5NZW1vcnlDYWNoZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2xvYmFsKCkge1xuICAgICAgICByZXR1cm4gbmV3IEluTWVtb3J5Q2FjaGUoR0xPQkFMX01BUCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/caches/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/base.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/base.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCallbackHandler: () => (/* binding */ BaseCallbackHandler),\n/* harmony export */   callbackHandlerPrefersStreaming: () => (/* binding */ callbackHandlerPrefersStreaming),\n/* harmony export */   isBaseCallbackHandler: () => (/* binding */ isBaseCallbackHandler)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../load/serializable.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.js\");\n\n\n\n/**\n * Abstract class that provides a set of optional methods that can be\n * overridden in derived classes to handle various events during the\n * execution of a LangChain application.\n */\nclass BaseCallbackHandlerMethodsClass {\n}\nfunction callbackHandlerPrefersStreaming(x) {\n    return \"lc_prefer_streaming\" in x && x.lc_prefer_streaming;\n}\n/**\n * Abstract base class for creating callback handlers in the LangChain\n * framework. It provides a set of optional methods that can be overridden\n * in derived classes to handle various events during the execution of a\n * LangChain application.\n */\nclass BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {\n    get lc_namespace() {\n        return [\"langchain_core\", \"callbacks\", this.name];\n    }\n    get lc_secrets() {\n        return undefined;\n    }\n    get lc_attributes() {\n        return undefined;\n    }\n    get lc_aliases() {\n        return undefined;\n    }\n    get lc_serializable_keys() {\n        return undefined;\n    }\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            (0,_load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.get_lc_unique_name)(this.constructor),\n        ];\n    }\n    constructor(input) {\n        super();\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ignoreLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreAgent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreRetriever\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreCustomEvent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"raiseError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"awaitHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n        });\n        this.lc_kwargs = input || {};\n        if (input) {\n            this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n            this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n            this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n            this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n            this.ignoreCustomEvent =\n                input.ignoreCustomEvent ?? this.ignoreCustomEvent;\n            this.raiseError = input.raiseError ?? this.raiseError;\n            this.awaitHandlers =\n                this.raiseError || (input._awaitHandler ?? this.awaitHandlers);\n        }\n    }\n    copy() {\n        return new this.constructor(this);\n    }\n    toJSON() {\n        return _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable.prototype.toJSON.call(this);\n    }\n    toJSONNotImplemented() {\n        return _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable.prototype.toJSONNotImplemented.call(this);\n    }\n    static fromMethods(methods) {\n        class Handler extends BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"]()\n                });\n                Object.assign(this, methods);\n            }\n        }\n        return new Handler();\n    }\n}\nconst isBaseCallbackHandler = (x) => {\n    const callbackHandler = x;\n    return (callbackHandler !== undefined &&\n        typeof callbackHandler.copy === \"function\" &&\n        typeof callbackHandler.name === \"string\" &&\n        typeof callbackHandler.awaitHandlers === \"boolean\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTZCO0FBQytDO0FBQ25CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxRUFBc0I7QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFZO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLCtEQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0Q0FBTztBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcY2FsbGJhY2tzXFxiYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IFNlcmlhbGl6YWJsZSwgZ2V0X2xjX3VuaXF1ZV9uYW1lLCB9IGZyb20gXCIuLi9sb2FkL3NlcmlhbGl6YWJsZS5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBwcm92aWRlcyBhIHNldCBvZiBvcHRpb25hbCBtZXRob2RzIHRoYXQgY2FuIGJlXG4gKiBvdmVycmlkZGVuIGluIGRlcml2ZWQgY2xhc3NlcyB0byBoYW5kbGUgdmFyaW91cyBldmVudHMgZHVyaW5nIHRoZVxuICogZXhlY3V0aW9uIG9mIGEgTGFuZ0NoYWluIGFwcGxpY2F0aW9uLlxuICovXG5jbGFzcyBCYXNlQ2FsbGJhY2tIYW5kbGVyTWV0aG9kc0NsYXNzIHtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWxsYmFja0hhbmRsZXJQcmVmZXJzU3RyZWFtaW5nKHgpIHtcbiAgICByZXR1cm4gXCJsY19wcmVmZXJfc3RyZWFtaW5nXCIgaW4geCAmJiB4LmxjX3ByZWZlcl9zdHJlYW1pbmc7XG59XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGNyZWF0aW5nIGNhbGxiYWNrIGhhbmRsZXJzIGluIHRoZSBMYW5nQ2hhaW5cbiAqIGZyYW1ld29yay4gSXQgcHJvdmlkZXMgYSBzZXQgb2Ygb3B0aW9uYWwgbWV0aG9kcyB0aGF0IGNhbiBiZSBvdmVycmlkZGVuXG4gKiBpbiBkZXJpdmVkIGNsYXNzZXMgdG8gaGFuZGxlIHZhcmlvdXMgZXZlbnRzIGR1cmluZyB0aGUgZXhlY3V0aW9uIG9mIGFcbiAqIExhbmdDaGFpbiBhcHBsaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VDYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyTWV0aG9kc0NsYXNzIHtcbiAgICBnZXQgbGNfbmFtZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJjYWxsYmFja3NcIiwgdGhpcy5uYW1lXTtcbiAgICB9XG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBsY19hdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGxjX3NlcmlhbGl6YWJsZV9rZXlzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXphYmxlLiBPdmVycmlkZSB0byBwcm92aWRlIGFuIGFsaWFzIG9yXG4gICAgICogdG8gcHJlc2VydmUgdGhlIHNlcmlhbGl6ZWQgbW9kdWxlIG5hbWUgaW4gbWluaWZpZWQgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgYSBzdGF0aWMgbWV0aG9kIHRvIHN1cHBvcnQgbG9hZGluZyBsb2dpYy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmFsIHNlcmlhbGl6ZWQgaWRlbnRpZmllciBmb3IgdGhlIG1vZHVsZS5cbiAgICAgKi9cbiAgICBnZXQgbGNfaWQoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLmxjX25hbWVzcGFjZSxcbiAgICAgICAgICAgIGdldF9sY191bmlxdWVfbmFtZSh0aGlzLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUxMTVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUNoYWluXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlQWdlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVSZXRyaWV2ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVDdXN0b21FdmVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJhaXNlRXJyb3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhd2FpdEhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0NBTExCQUNLU19CQUNLR1JPVU5EXCIpID09PSBcImZhbHNlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGNfa3dhcmdzID0gaW5wdXQgfHwge307XG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVMTE0gPSBpbnB1dC5pZ25vcmVMTE0gPz8gdGhpcy5pZ25vcmVMTE07XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUNoYWluID0gaW5wdXQuaWdub3JlQ2hhaW4gPz8gdGhpcy5pZ25vcmVDaGFpbjtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQWdlbnQgPSBpbnB1dC5pZ25vcmVBZ2VudCA/PyB0aGlzLmlnbm9yZUFnZW50O1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVSZXRyaWV2ZXIgPSBpbnB1dC5pZ25vcmVSZXRyaWV2ZXIgPz8gdGhpcy5pZ25vcmVSZXRyaWV2ZXI7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUN1c3RvbUV2ZW50ID1cbiAgICAgICAgICAgICAgICBpbnB1dC5pZ25vcmVDdXN0b21FdmVudCA/PyB0aGlzLmlnbm9yZUN1c3RvbUV2ZW50O1xuICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yID0gaW5wdXQucmFpc2VFcnJvciA/PyB0aGlzLnJhaXNlRXJyb3I7XG4gICAgICAgICAgICB0aGlzLmF3YWl0SGFuZGxlcnMgPVxuICAgICAgICAgICAgICAgIHRoaXMucmFpc2VFcnJvciB8fCAoaW5wdXQuX2F3YWl0SGFuZGxlciA/PyB0aGlzLmF3YWl0SGFuZGxlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OTm90SW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBTZXJpYWxpemFibGUucHJvdG90eXBlLnRvSlNPTk5vdEltcGxlbWVudGVkLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTWV0aG9kcyhtZXRob2RzKSB7XG4gICAgICAgIGNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkLnY0KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG1ldGhvZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGFuZGxlcigpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBpc0Jhc2VDYWxsYmFja0hhbmRsZXIgPSAoeCkgPT4ge1xuICAgIGNvbnN0IGNhbGxiYWNrSGFuZGxlciA9IHg7XG4gICAgcmV0dXJuIChjYWxsYmFja0hhbmRsZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgY2FsbGJhY2tIYW5kbGVyLmNvcHkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgY2FsbGJhY2tIYW5kbGVyLm5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgdHlwZW9mIGNhbGxiYWNrSGFuZGxlci5hd2FpdEhhbmRsZXJzID09PSBcImJvb2xlYW5cIik7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/manager.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCallbackManager: () => (/* binding */ BaseCallbackManager),\n/* harmony export */   BaseRunManager: () => (/* binding */ BaseRunManager),\n/* harmony export */   CallbackManager: () => (/* binding */ CallbackManager),\n/* harmony export */   CallbackManagerForChainRun: () => (/* binding */ CallbackManagerForChainRun),\n/* harmony export */   CallbackManagerForLLMRun: () => (/* binding */ CallbackManagerForLLMRun),\n/* harmony export */   CallbackManagerForRetrieverRun: () => (/* binding */ CallbackManagerForRetrieverRun),\n/* harmony export */   CallbackManagerForToolRun: () => (/* binding */ CallbackManagerForToolRun),\n/* harmony export */   TraceGroup: () => (/* binding */ TraceGroup),\n/* harmony export */   ensureHandler: () => (/* binding */ ensureHandler),\n/* harmony export */   parseCallbackConfigArg: () => (/* binding */ parseCallbackConfigArg),\n/* harmony export */   traceAsGroup: () => (/* binding */ traceAsGroup)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.js\");\n/* harmony import */ var _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tracers/console.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/console.js\");\n/* harmony import */ var _messages_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../messages/utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.js\");\n/* harmony import */ var _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tracers/tracer_langchain.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.js\");\n/* harmony import */ var _promises_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./promises.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.js\");\n/* harmony import */ var _utils_callbacks_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/callbacks.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.js\");\n/* harmony import */ var _tracers_base_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tracers/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\");\n/* harmony import */ var _singletons_async_local_storage_context_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../singletons/async_local_storage/context.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/context.js\");\n\n\n\n\n\n\n\n\n\n\nfunction parseCallbackConfigArg(arg) {\n    if (!arg) {\n        return {};\n    }\n    else if (Array.isArray(arg) || \"name\" in arg) {\n        return { callbacks: arg };\n    }\n    else {\n        return arg;\n    }\n}\n/**\n * Manage callbacks from different components of LangChain.\n */\nclass BaseCallbackManager {\n    setHandler(handler) {\n        return this.setHandlers([handler]);\n    }\n}\n/**\n * Base class for run manager in LangChain.\n */\nclass BaseRunManager {\n    constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {\n        Object.defineProperty(this, \"runId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: runId\n        });\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: handlers\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableHandlers\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tags\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableTags\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: metadata\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableMetadata\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _parentRunId\n        });\n    }\n    get parentRunId() {\n        return this._parentRunId;\n    }\n    async handleText(text) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            try {\n                await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, _runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            try {\n                await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\n/**\n * Manages callbacks for retriever runs.\n */\nclass CallbackManagerForRetrieverRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleRetrieverEnd(documents) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleRetrieverError(err) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (error) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nclass CallbackManagerForLLMRun extends BaseRunManager {\n    async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMNewToken?.(token, idx ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags, extraParams);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags, extraParams);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nclass CallbackManagerForChainRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentAction(action) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentEnd(action) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nclass CallbackManagerForToolRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleToolError(err) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nclass CallbackManager extends BaseCallbackManager {\n    constructor(parentRunId, options) {\n        super();\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"callback_manager\"\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.handlers = options?.handlers ?? this.handlers;\n        this.inheritableHandlers =\n            options?.inheritableHandlers ?? this.inheritableHandlers;\n        this.tags = options?.tags ?? this.tags;\n        this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n        this.metadata = options?.metadata ?? this.metadata;\n        this.inheritableMetadata =\n            options?.inheritableMetadata ?? this.inheritableMetadata;\n        this._parentRunId = parentRunId;\n    }\n    /**\n     * Gets the parent run ID, if any.\n     *\n     * @returns The parent run ID.\n     */\n    getParentRunId() {\n        return this._parentRunId;\n    }\n    async handleLLMStart(llm, prompts, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(prompts.map(async (prompt, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n                    try {\n                        await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChatModelStart(llm, messages, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(messages.map(async (messageGroup, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n                    try {\n                        if (handler.handleChatModelStart) {\n                            await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                        else if (handler.handleLLMStart) {\n                            const messageString = (0,_messages_utils_js__WEBPACK_IMPORTED_MODULE_2__.getBufferString)(messageGroup);\n                            await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChainStart(chain, inputs, runId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(), runType = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreChain) {\n                return;\n            }\n            if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n            }\n            return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n                try {\n                    await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleToolStart(tool, input, runId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreAgent) {\n                return;\n            }\n            if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n                try {\n                    await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleRetrieverStart(retriever, query, runId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreRetriever) {\n                return;\n            }\n            if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n                try {\n                    await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreCustomEvent) {\n                try {\n                    await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    addHandler(handler, inherit = true) {\n        this.handlers.push(handler);\n        if (inherit) {\n            this.inheritableHandlers.push(handler);\n        }\n    }\n    removeHandler(handler) {\n        this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n        this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);\n    }\n    setHandlers(handlers, inherit = true) {\n        this.handlers = [];\n        this.inheritableHandlers = [];\n        for (const handler of handlers) {\n            this.addHandler(handler, inherit);\n        }\n    }\n    addTags(tags, inherit = true) {\n        this.removeTags(tags); // Remove duplicates\n        this.tags.push(...tags);\n        if (inherit) {\n            this.inheritableTags.push(...tags);\n        }\n    }\n    removeTags(tags) {\n        this.tags = this.tags.filter((tag) => !tags.includes(tag));\n        this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));\n    }\n    addMetadata(metadata, inherit = true) {\n        this.metadata = { ...this.metadata, ...metadata };\n        if (inherit) {\n            this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n        }\n    }\n    removeMetadata(metadata) {\n        for (const key of Object.keys(metadata)) {\n            delete this.metadata[key];\n            delete this.inheritableMetadata[key];\n        }\n    }\n    copy(additionalHandlers = [], inherit = true) {\n        const manager = new CallbackManager(this._parentRunId);\n        for (const handler of this.handlers) {\n            const inheritable = this.inheritableHandlers.includes(handler);\n            manager.addHandler(handler, inheritable);\n        }\n        for (const tag of this.tags) {\n            const inheritable = this.inheritableTags.includes(tag);\n            manager.addTags([tag], inheritable);\n        }\n        for (const key of Object.keys(this.metadata)) {\n            const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n            manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n        }\n        for (const handler of additionalHandlers) {\n            if (\n            // Prevent multiple copies of console_callback_handler\n            manager.handlers\n                .filter((h) => h.name === \"console_callback_handler\")\n                .some((h) => h.name === handler.name)) {\n                continue;\n            }\n            manager.addHandler(handler, inherit);\n        }\n        return manager;\n    }\n    static fromHandlers(handlers) {\n        class Handler extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])()\n                });\n                Object.assign(this, handlers);\n            }\n        }\n        const manager = new this();\n        manager.addHandler(new Handler());\n        return manager;\n    }\n    static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);\n    }\n    // TODO: Deprecate async method in favor of this one.\n    static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        let callbackManager;\n        if (inheritableHandlers || localHandlers) {\n            if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n                callbackManager = new CallbackManager();\n                callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);\n            }\n            else {\n                callbackManager = inheritableHandlers;\n            }\n            callbackManager = callbackManager.copy(Array.isArray(localHandlers)\n                ? localHandlers.map(ensureHandler)\n                : localHandlers?.handlers, false);\n        }\n        const verboseEnabled = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getEnvironmentVariable)(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n            options?.verbose;\n        const tracingV2Enabled = _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer.getTraceableRunTree()?.tracingEnabled ||\n            (0,_utils_callbacks_js__WEBPACK_IMPORTED_MODULE_6__.isTracingEnabled)();\n        const tracingEnabled = tracingV2Enabled ||\n            ((0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getEnvironmentVariable)(\"LANGCHAIN_TRACING\") ?? false);\n        if (verboseEnabled || tracingEnabled) {\n            if (!callbackManager) {\n                callbackManager = new CallbackManager();\n            }\n            if (verboseEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__.ConsoleCallbackHandler.prototype.name)) {\n                const consoleHandler = new _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__.ConsoleCallbackHandler();\n                callbackManager.addHandler(consoleHandler, true);\n            }\n            if (tracingEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === \"langchain_tracer\")) {\n                if (tracingV2Enabled) {\n                    const tracerV2 = new _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer();\n                    callbackManager.addHandler(tracerV2, true);\n                }\n            }\n            if (tracingV2Enabled) {\n                // handoff between langchain and langsmith/traceable\n                // override the parent run ID\n                const implicitRunTree = _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer.getTraceableRunTree();\n                if (implicitRunTree && callbackManager._parentRunId === undefined) {\n                    callbackManager._parentRunId = implicitRunTree.id;\n                    const tracerV2 = callbackManager.handlers.find((handler) => handler.name === \"langchain_tracer\");\n                    tracerV2?.updateFromRunTree(implicitRunTree);\n                }\n            }\n        }\n        for (const { contextVar, inheritable = true, handlerClass, envVar, } of (0,_singletons_async_local_storage_context_js__WEBPACK_IMPORTED_MODULE_8__._getConfigureHooks)()) {\n            const createIfNotInContext = envVar && (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getEnvironmentVariable)(envVar) === \"true\" && handlerClass;\n            let handler;\n            const contextVarValue = contextVar !== undefined ? (0,_singletons_async_local_storage_context_js__WEBPACK_IMPORTED_MODULE_8__.getContextVariable)(contextVar) : undefined;\n            if (contextVarValue && (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.isBaseCallbackHandler)(contextVarValue)) {\n                handler = contextVarValue;\n            }\n            else if (createIfNotInContext) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                handler = new handlerClass({});\n            }\n            if (handler !== undefined) {\n                if (!callbackManager) {\n                    callbackManager = new CallbackManager();\n                }\n                if (!callbackManager.handlers.some((h) => h.name === handler.name)) {\n                    callbackManager.addHandler(handler, inheritable);\n                }\n            }\n        }\n        if (inheritableTags || localTags) {\n            if (callbackManager) {\n                callbackManager.addTags(inheritableTags ?? []);\n                callbackManager.addTags(localTags ?? [], false);\n            }\n        }\n        if (inheritableMetadata || localMetadata) {\n            if (callbackManager) {\n                callbackManager.addMetadata(inheritableMetadata ?? {});\n                callbackManager.addMetadata(localMetadata ?? {}, false);\n            }\n        }\n        return callbackManager;\n    }\n}\nfunction ensureHandler(handler) {\n    if (\"name\" in handler) {\n        return handler;\n    }\n    return _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler.fromMethods(handler);\n}\n/**\n * @deprecated Use [`traceable`](https://docs.smith.langchain.com/observability/how_to_guides/tracing/annotate_code)\n * from \"langsmith\" instead.\n */\nclass TraceGroup {\n    constructor(groupName, options) {\n        Object.defineProperty(this, \"groupName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: groupName\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        Object.defineProperty(this, \"runManager\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async getTraceGroupCallbackManager(group_name, inputs, options) {\n        const cb = new _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer(options);\n        const cm = await CallbackManager.configure([cb]);\n        const runManager = await cm?.handleChainStart({\n            lc: 1,\n            type: \"not_implemented\",\n            id: [\"langchain\", \"callbacks\", \"groups\", group_name],\n        }, inputs ?? {});\n        if (!runManager) {\n            throw new Error(\"Failed to create run group callback manager.\");\n        }\n        return runManager;\n    }\n    async start(inputs) {\n        if (!this.runManager) {\n            this.runManager = await this.getTraceGroupCallbackManager(this.groupName, inputs, this.options);\n        }\n        return this.runManager.getChild();\n    }\n    async error(err) {\n        if (this.runManager) {\n            await this.runManager.handleChainError(err);\n            this.runManager = undefined;\n        }\n    }\n    async end(output) {\n        if (this.runManager) {\n            await this.runManager.handleChainEnd(output ?? {});\n            this.runManager = undefined;\n        }\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function traceAsGroup(groupOptions, enclosedCode, ...args) {\n    const traceGroup = new TraceGroup(groupOptions.name, groupOptions);\n    const callbackManager = await traceGroup.start({ ...args });\n    try {\n        const result = await enclosedCode(callbackManager, ...args);\n        await traceGroup.end(_coerceToDict(result, \"output\"));\n        return result;\n    }\n    catch (err) {\n        await traceGroup.error(err);\n        throw err;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL21hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ29DO0FBQ1Q7QUFDUjtBQUNFO0FBQ1M7QUFDbEI7QUFDUztBQUNQO0FBQ3FEO0FBQ2hHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCLGdCQUFnQixJQUFJO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUIsdUJBQXVCLElBQUk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QiwwQkFBMEIsTUFBTTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQSxzRUFBc0UsMEJBQTBCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixvQkFBb0IsSUFBSTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsa0JBQWtCLElBQUk7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsc0JBQXNCLElBQUk7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5Qix1QkFBdUIsSUFBSTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIscUJBQXFCLElBQUk7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsbUJBQW1CLElBQUk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFNBQVM7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdDQUF3QztBQUNuRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdEQUFNO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnREFBTTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4REFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZEQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsbUVBQWU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLGtEQUFrRCxnREFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixzQkFBc0IsSUFBSTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQyxnREFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixxQkFBcUIsSUFBSTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCxnREFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QiwwQkFBMEIsSUFBSTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsdUJBQXVCLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJCQUEyQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlEQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQU07QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFFQUFzQjtBQUNyRDtBQUNBLGlDQUFpQyx5RUFBZTtBQUNoRCxZQUFZLHFFQUFnQjtBQUM1QjtBQUNBLGFBQWEscUVBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsdUVBQXNCO0FBQ25HLDJDQUEyQyx1RUFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5RUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MseUVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQXdELEdBQUcsOEZBQWtCO0FBQ2xHLG1EQUFtRCxxRUFBc0I7QUFDekU7QUFDQSwrREFBK0QsOEZBQWtCO0FBQ2pGLG1DQUFtQywrREFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlEQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUIseUVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcY2FsbGJhY2tzXFxtYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBCYXNlQ2FsbGJhY2tIYW5kbGVyLCBpc0Jhc2VDYWxsYmFja0hhbmRsZXIsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgQ29uc29sZUNhbGxiYWNrSGFuZGxlciB9IGZyb20gXCIuLi90cmFjZXJzL2NvbnNvbGUuanNcIjtcbmltcG9ydCB7IGdldEJ1ZmZlclN0cmluZyB9IGZyb20gXCIuLi9tZXNzYWdlcy91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IExhbmdDaGFpblRyYWNlciwgfSBmcm9tIFwiLi4vdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmpzXCI7XG5pbXBvcnQgeyBjb25zdW1lQ2FsbGJhY2sgfSBmcm9tIFwiLi9wcm9taXNlcy5qc1wiO1xuaW1wb3J0IHsgaXNUcmFjaW5nRW5hYmxlZCB9IGZyb20gXCIuLi91dGlscy9jYWxsYmFja3MuanNcIjtcbmltcG9ydCB7IGlzQmFzZVRyYWNlciB9IGZyb20gXCIuLi90cmFjZXJzL2Jhc2UuanNcIjtcbmltcG9ydCB7IGdldENvbnRleHRWYXJpYWJsZSwgX2dldENvbmZpZ3VyZUhvb2tzLCB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2FzeW5jX2xvY2FsX3N0b3JhZ2UvY29udGV4dC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2FsbGJhY2tDb25maWdBcmcoYXJnKSB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHwgXCJuYW1lXCIgaW4gYXJnKSB7XG4gICAgICAgIHJldHVybiB7IGNhbGxiYWNrczogYXJnIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbn1cbi8qKlxuICogTWFuYWdlIGNhbGxiYWNrcyBmcm9tIGRpZmZlcmVudCBjb21wb25lbnRzIG9mIExhbmdDaGFpbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIHNldEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRIYW5kbGVycyhbaGFuZGxlcl0pO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcnVuIG1hbmFnZXIgaW4gTGFuZ0NoYWluLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHJ1bklkLCBoYW5kbGVycywgaW5oZXJpdGFibGVIYW5kbGVycywgdGFncywgaW5oZXJpdGFibGVUYWdzLCBtZXRhZGF0YSwgaW5oZXJpdGFibGVNZXRhZGF0YSwgX3BhcmVudFJ1bklkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBydW5JZFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGhhbmRsZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZUhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmhlcml0YWJsZUhhbmRsZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0YWdzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlVGFnc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZU1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmhlcml0YWJsZU1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGFyZW50UnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IF9wYXJlbnRSdW5JZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudFJ1bklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50UnVuSWQ7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRleHQodGV4dCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVUZXh0Py4odGV4dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVGV4dDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBkYXRhLCBfcnVuSWQsIF90YWdzLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9tZXRhZGF0YSkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDdXN0b21FdmVudD8uKGV2ZW50TmFtZSwgZGF0YSwgdGhpcy5ydW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDdXN0b21FdmVudDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuLyoqXG4gKiBNYW5hZ2VzIGNhbGxiYWNrcyBmb3IgcmV0cmlldmVyIHJ1bnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JSZXRyaWV2ZXJSdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgZ2V0Q2hpbGQodGFnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5ydW5JZCk7XG4gICAgICAgIG1hbmFnZXIuc2V0SGFuZGxlcnModGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzKTtcbiAgICAgICAgbWFuYWdlci5hZGRUYWdzKHRoaXMuaW5oZXJpdGFibGVUYWdzKTtcbiAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEpO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZFRhZ3MoW3RhZ10sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRW5kKGRvY3VtZW50cykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVSZXRyaWV2ZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVJldHJpZXZlckVuZD8uKGRvY3VtZW50cywgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlUmV0cmlldmVyYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFcnJvcihlcnIpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlUmV0cmlldmVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVSZXRyaWV2ZXJFcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJFcnJvcjogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlckZvckxMTVJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBhc3luYyBoYW5kbGVMTE1OZXdUb2tlbih0b2tlbiwgaWR4LCBfcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGZpZWxkcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTU5ld1Rva2VuPy4odG9rZW4sIGlkeCA/PyB7IHByb21wdDogMCwgY29tcGxldGlvbjogMCB9LCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCBmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTU5ld1Rva2VuOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVycm9yKGVyciwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBleHRyYVBhcmFtcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTUVycm9yPy4oZXJyLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCBleHRyYVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRW5kKG91dHB1dCwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBleHRyYVBhcmFtcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTUVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgZXh0cmFQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTUVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBnZXRDaGlsZCh0YWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcih0aGlzLnJ1bklkKTtcbiAgICAgICAgbWFuYWdlci5zZXRIYW5kbGVycyh0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMpO1xuICAgICAgICBtYW5hZ2VyLmFkZFRhZ3ModGhpcy5pbmhlcml0YWJsZVRhZ3MpO1xuICAgICAgICBtYW5hZ2VyLmFkZE1ldGFkYXRhKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVycm9yKGVyciwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYWluRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGt3YXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5FcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVuZChvdXRwdXQsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDaGFpbkVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpbkVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUFnZW50QWN0aW9uPy4oYWN0aW9uLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEFjdGlvbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEVuZChhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUFnZW50RW5kPy4oYWN0aW9uLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JUb29sUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGdldENoaWxkKHRhZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMucnVuSWQpO1xuICAgICAgICBtYW5hZ2VyLnNldEhhbmRsZXJzKHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyk7XG4gICAgICAgIG1hbmFnZXIuYWRkVGFncyh0aGlzLmluaGVyaXRhYmxlVGFncyk7XG4gICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEodGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnIpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVG9vbEVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVuZChvdXRwdXQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRvb2xFbmQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHQgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXCJXaGF0IGlzIHRoZSBhbnN3ZXIgdG8ge3F1ZXN0aW9ufT9cIik7XG4gKlxuICogLy8gRXhhbXBsZSBvZiB1c2luZyBMTE1DaGFpbiB3aXRoIE9wZW5BSSBhbmQgYSBzaW1wbGUgcHJvbXB0XG4gKiBjb25zdCBjaGFpbiA9IG5ldyBMTE1DaGFpbih7XG4gKiAgIGxsbTogbmV3IENoYXRPcGVuQUkoeyBtb2RlbDogXCJncHQtNG8tbWluaVwiLCB0ZW1wZXJhdHVyZTogMC45IH0pLFxuICogICBwcm9tcHQsXG4gKiB9KTtcbiAqXG4gKiAvLyBSdW5uaW5nIHRoZSBjaGFpbiB3aXRoIGEgc2luZ2xlIHF1ZXN0aW9uXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbi5jYWxsKHtcbiAqICAgcXVlc3Rpb246IFwiV2hhdCBpcyB0aGUgYWlyc3BlZWQgdmVsb2NpdHkgb2YgYW4gdW5sYWRlbiBzd2FsbG93P1wiLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhcIlRoZSBhbnN3ZXIgaXM6XCIsIHJlc3VsdCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlciBleHRlbmRzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFJ1bklkLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNhbGxiYWNrX21hbmFnZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBvcHRpb25zPy5oYW5kbGVycyA/PyB0aGlzLmhhbmRsZXJzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPVxuICAgICAgICAgICAgb3B0aW9ucz8uaW5oZXJpdGFibGVIYW5kbGVycyA/PyB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnM7XG4gICAgICAgIHRoaXMudGFncyA9IG9wdGlvbnM/LnRhZ3MgPz8gdGhpcy50YWdzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncyA9IG9wdGlvbnM/LmluaGVyaXRhYmxlVGFncyA/PyB0aGlzLmluaGVyaXRhYmxlVGFncztcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG9wdGlvbnM/Lm1ldGFkYXRhID8/IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSA9XG4gICAgICAgICAgICBvcHRpb25zPy5pbmhlcml0YWJsZU1ldGFkYXRhID8/IHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5fcGFyZW50UnVuSWQgPSBwYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHJ1biBJRCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcmVudCBydW4gSUQuXG4gICAgICovXG4gICAgZ2V0UGFyZW50UnVuSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXB0cy5tYXAoYXN5bmMgKHByb21wdCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAvLyBDYW4ndCBoYXZlIGR1cGxpY2F0ZSBydW5zIHdpdGggdGhlIHNhbWUgcnVuIElEIChpZiBwcm92aWRlZClcbiAgICAgICAgICAgIGNvbnN0IHJ1bklkXyA9IGlkeCA9PT0gMCAmJiBydW5JZCA/IHJ1bklkIDogdXVpZHY0KCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Jhc2VUcmFjZXIoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvckxMTVN0YXJ0KGxsbSwgW3Byb21wdF0sIHJ1bklkXywgdGhpcy5fcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNU3RhcnQ/LihsbG0sIFtwcm9tcHRdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkXywgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobWVzc2FnZXMubWFwKGFzeW5jIChtZXNzYWdlR3JvdXAsIGlkeCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2FuJ3QgaGF2ZSBkdXBsaWNhdGUgcnVucyB3aXRoIHRoZSBzYW1lIHJ1biBJRCAoaWYgcHJvdmlkZWQpXG4gICAgICAgICAgICBjb25zdCBydW5JZF8gPSBpZHggPT09IDAgJiYgcnVuSWQgPyBydW5JZCA6IHV1aWR2NCgpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNCYXNlVHJhY2VyKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHJ1biB0byB0aGUgcnVuIG1hcC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9jcmVhdGVSdW5Gb3JDaGF0TW9kZWxTdGFydChsbG0sIFttZXNzYWdlR3JvdXBdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5oYW5kbGVDaGF0TW9kZWxTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhdE1vZGVsU3RhcnQ/LihsbG0sIFttZXNzYWdlR3JvdXBdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZXIuaGFuZGxlTExNU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlU3RyaW5nID0gZ2V0QnVmZmVyU3RyaW5nKG1lc3NhZ2VHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1TdGFydD8uKGxsbSwgW21lc3NhZ2VTdHJpbmddLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkXywgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkID0gdXVpZHY0KCksIHJ1blR5cGUgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQmFzZVRyYWNlcihoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHJ1biB0byB0aGUgcnVuIG1hcC5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZC5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9jcmVhdGVSdW5Gb3JDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5UeXBlLCBydW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhaW5TdGFydD8uKGNoYWluLCBpbnB1dHMsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5UeXBlLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpblN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkID0gdXVpZHY0KCksIF9wYXJlbnRSdW5JZCA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCYXNlVHJhY2VyKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLlxuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvclRvb2xTdGFydCh0b29sLCBpbnB1dCwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVUb29sU3RhcnQ/Lih0b29sLCBpbnB1dCwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRvb2xTdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JUb29sUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJTdGFydChyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCA9IHV1aWR2NCgpLCBfcGFyZW50UnVuSWQgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Jhc2VUcmFjZXIoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBydW4gdG8gdGhlIHJ1biBtYXAuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgaGFuZGxlci5fY3JlYXRlUnVuRm9yUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVSZXRyaWV2ZXJTdGFydD8uKHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJTdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JSZXRyaWV2ZXJSdW4ocnVuSWQsIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBkYXRhLCBydW5JZCwgX3RhZ3MsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX21ldGFkYXRhKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDdXN0b21FdmVudD8uKGV2ZW50TmFtZSwgZGF0YSwgcnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ3VzdG9tRXZlbnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMuZmlsdGVyKChfaGFuZGxlcikgPT4gX2hhbmRsZXIgIT09IGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPSB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMuZmlsdGVyKChfaGFuZGxlcikgPT4gX2hhbmRsZXIgIT09IGhhbmRsZXIpO1xuICAgIH1cbiAgICBzZXRIYW5kbGVycyhoYW5kbGVycywgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFncyh0YWdzLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRhZ3ModGFncyk7IC8vIFJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MucHVzaCguLi50YWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVUYWdzKHRhZ3MpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiAhdGFncy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MgPSB0aGlzLmluaGVyaXRhYmxlVGFncy5maWx0ZXIoKHRhZykgPT4gIXRhZ3MuaW5jbHVkZXModGFnKSk7XG4gICAgfVxuICAgIGFkZE1ldGFkYXRhKG1ldGFkYXRhLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0geyAuLi50aGlzLm1ldGFkYXRhLCAuLi5tZXRhZGF0YSB9O1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhID0geyAuLi50aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIC4uLm1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tZXRhZGF0YVtrZXldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoYWRkaXRpb25hbEhhbmRsZXJzID0gW10sIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLmluY2x1ZGVzKGhhbmRsZXIpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gdGhpcy5pbmhlcml0YWJsZVRhZ3MuaW5jbHVkZXModGFnKTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmhlcml0YWJsZSA9IE9iamVjdC5rZXlzKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSkuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEoeyBba2V5XTogdGhpcy5tZXRhZGF0YVtrZXldIH0sIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgYWRkaXRpb25hbEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGNvcGllcyBvZiBjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcbiAgICAgICAgICAgIG1hbmFnZXIuaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChoKSA9PiBoLm5hbWUgPT09IFwiY29uc29sZV9jYWxsYmFja19oYW5kbGVyXCIpXG4gICAgICAgICAgICAgICAgLnNvbWUoKGgpID0+IGgubmFtZSA9PT0gaGFuZGxlci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIGNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkdjQoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgaGFuZGxlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgdGhpcygpO1xuICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIobmV3IEhhbmRsZXIoKSk7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgY29uZmlndXJlKGluaGVyaXRhYmxlSGFuZGxlcnMsIGxvY2FsSGFuZGxlcnMsIGluaGVyaXRhYmxlVGFncywgbG9jYWxUYWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBsb2NhbE1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWd1cmVTeW5jKGluaGVyaXRhYmxlSGFuZGxlcnMsIGxvY2FsSGFuZGxlcnMsIGluaGVyaXRhYmxlVGFncywgbG9jYWxUYWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBsb2NhbE1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVE9ETzogRGVwcmVjYXRlIGFzeW5jIG1ldGhvZCBpbiBmYXZvciBvZiB0aGlzIG9uZS5cbiAgICBzdGF0aWMgX2NvbmZpZ3VyZVN5bmMoaW5oZXJpdGFibGVIYW5kbGVycywgbG9jYWxIYW5kbGVycywgaW5oZXJpdGFibGVUYWdzLCBsb2NhbFRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIGxvY2FsTWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGNhbGxiYWNrTWFuYWdlcjtcbiAgICAgICAgaWYgKGluaGVyaXRhYmxlSGFuZGxlcnMgfHwgbG9jYWxIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5oZXJpdGFibGVIYW5kbGVycykgfHwgIWluaGVyaXRhYmxlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLnNldEhhbmRsZXJzKGluaGVyaXRhYmxlSGFuZGxlcnM/Lm1hcChlbnN1cmVIYW5kbGVyKSA/PyBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBpbmhlcml0YWJsZUhhbmRsZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyID0gY2FsbGJhY2tNYW5hZ2VyLmNvcHkoQXJyYXkuaXNBcnJheShsb2NhbEhhbmRsZXJzKVxuICAgICAgICAgICAgICAgID8gbG9jYWxIYW5kbGVycy5tYXAoZW5zdXJlSGFuZGxlcilcbiAgICAgICAgICAgICAgICA6IGxvY2FsSGFuZGxlcnM/LmhhbmRsZXJzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyYm9zZUVuYWJsZWQgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1ZFUkJPU0VcIikgPT09IFwidHJ1ZVwiIHx8XG4gICAgICAgICAgICBvcHRpb25zPy52ZXJib3NlO1xuICAgICAgICBjb25zdCB0cmFjaW5nVjJFbmFibGVkID0gTGFuZ0NoYWluVHJhY2VyLmdldFRyYWNlYWJsZVJ1blRyZWUoKT8udHJhY2luZ0VuYWJsZWQgfHxcbiAgICAgICAgICAgIGlzVHJhY2luZ0VuYWJsZWQoKTtcbiAgICAgICAgY29uc3QgdHJhY2luZ0VuYWJsZWQgPSB0cmFjaW5nVjJFbmFibGVkIHx8XG4gICAgICAgICAgICAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9UUkFDSU5HXCIpID8/IGZhbHNlKTtcbiAgICAgICAgaWYgKHZlcmJvc2VFbmFibGVkIHx8IHRyYWNpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJib3NlRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgICFjYWxsYmFja01hbmFnZXIuaGFuZGxlcnMuc29tZSgoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyLnByb3RvdHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnNvbGVIYW5kbGVyID0gbmV3IENvbnNvbGVDYWxsYmFja0hhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkSGFuZGxlcihjb25zb2xlSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2luZ0VuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAhY2FsbGJhY2tNYW5hZ2VyLmhhbmRsZXJzLnNvbWUoKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNpbmdWMkVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2VyVjIgPSBuZXcgTGFuZ0NoYWluVHJhY2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRIYW5kbGVyKHRyYWNlclYyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2luZ1YyRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRvZmYgYmV0d2VlbiBsYW5nY2hhaW4gYW5kIGxhbmdzbWl0aC90cmFjZWFibGVcbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSB0aGUgcGFyZW50IHJ1biBJRFxuICAgICAgICAgICAgICAgIGNvbnN0IGltcGxpY2l0UnVuVHJlZSA9IExhbmdDaGFpblRyYWNlci5nZXRUcmFjZWFibGVSdW5UcmVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGltcGxpY2l0UnVuVHJlZSAmJiBjYWxsYmFja01hbmFnZXIuX3BhcmVudFJ1bklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLl9wYXJlbnRSdW5JZCA9IGltcGxpY2l0UnVuVHJlZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2VyVjIgPSBjYWxsYmFja01hbmFnZXIuaGFuZGxlcnMuZmluZCgoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlclYyPy51cGRhdGVGcm9tUnVuVHJlZShpbXBsaWNpdFJ1blRyZWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHsgY29udGV4dFZhciwgaW5oZXJpdGFibGUgPSB0cnVlLCBoYW5kbGVyQ2xhc3MsIGVudlZhciwgfSBvZiBfZ2V0Q29uZmlndXJlSG9va3MoKSkge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlSWZOb3RJbkNvbnRleHQgPSBlbnZWYXIgJiYgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShlbnZWYXIpID09PSBcInRydWVcIiAmJiBoYW5kbGVyQ2xhc3M7XG4gICAgICAgICAgICBsZXQgaGFuZGxlcjtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRWYXJWYWx1ZSA9IGNvbnRleHRWYXIgIT09IHVuZGVmaW5lZCA/IGdldENvbnRleHRWYXJpYWJsZShjb250ZXh0VmFyKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb250ZXh0VmFyVmFsdWUgJiYgaXNCYXNlQ2FsbGJhY2tIYW5kbGVyKGNvbnRleHRWYXJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gY29udGV4dFZhclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlSWZOb3RJbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBuZXcgaGFuZGxlckNsYXNzKHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2tNYW5hZ2VyLmhhbmRsZXJzLnNvbWUoKGgpID0+IGgubmFtZSA9PT0gaGFuZGxlci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmhlcml0YWJsZVRhZ3MgfHwgbG9jYWxUYWdzKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZFRhZ3MoaW5oZXJpdGFibGVUYWdzID8/IFtdKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkVGFncyhsb2NhbFRhZ3MgPz8gW10sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5oZXJpdGFibGVNZXRhZGF0YSB8fCBsb2NhbE1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZE1ldGFkYXRhKGluaGVyaXRhYmxlTWV0YWRhdGEgPz8ge30pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRNZXRhZGF0YShsb2NhbE1ldGFkYXRhID8/IHt9LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrTWFuYWdlcjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgaWYgKFwibmFtZVwiIGluIGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiBCYXNlQ2FsbGJhY2tIYW5kbGVyLmZyb21NZXRob2RzKGhhbmRsZXIpO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgW2B0cmFjZWFibGVgXShodHRwczovL2RvY3Muc21pdGgubGFuZ2NoYWluLmNvbS9vYnNlcnZhYmlsaXR5L2hvd190b19ndWlkZXMvdHJhY2luZy9hbm5vdGF0ZV9jb2RlKVxuICogZnJvbSBcImxhbmdzbWl0aFwiIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFjZUdyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcihncm91cE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ3JvdXBOYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBncm91cE5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bk1hbmFnZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhY2VHcm91cENhbGxiYWNrTWFuYWdlcihncm91cF9uYW1lLCBpbnB1dHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2IgPSBuZXcgTGFuZ0NoYWluVHJhY2VyKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjbSA9IGF3YWl0IENhbGxiYWNrTWFuYWdlci5jb25maWd1cmUoW2NiXSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjbT8uaGFuZGxlQ2hhaW5TdGFydCh7XG4gICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgIHR5cGU6IFwibm90X2ltcGxlbWVudGVkXCIsXG4gICAgICAgICAgICBpZDogW1wibGFuZ2NoYWluXCIsIFwiY2FsbGJhY2tzXCIsIFwiZ3JvdXBzXCIsIGdyb3VwX25hbWVdLFxuICAgICAgICB9LCBpbnB1dHMgPz8ge30pO1xuICAgICAgICBpZiAoIXJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgcnVuIGdyb3VwIGNhbGxiYWNrIG1hbmFnZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5NYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBzdGFydChpbnB1dHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMucnVuTWFuYWdlciA9IGF3YWl0IHRoaXMuZ2V0VHJhY2VHcm91cENhbGxiYWNrTWFuYWdlcih0aGlzLmdyb3VwTmFtZSwgaW5wdXRzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bk1hbmFnZXIuZ2V0Q2hpbGQoKTtcbiAgICB9XG4gICAgYXN5bmMgZXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuTWFuYWdlci5oYW5kbGVDaGFpbkVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLnJ1bk1hbmFnZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZW5kKG91dHB1dCkge1xuICAgICAgICBpZiAodGhpcy5ydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bk1hbmFnZXIuaGFuZGxlQ2hhaW5FbmQob3V0cHV0ID8/IHt9KTtcbiAgICAgICAgICAgIHRoaXMucnVuTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFjZUFzR3JvdXAoZ3JvdXBPcHRpb25zLCBlbmNsb3NlZENvZGUsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0cmFjZUdyb3VwID0gbmV3IFRyYWNlR3JvdXAoZ3JvdXBPcHRpb25zLm5hbWUsIGdyb3VwT3B0aW9ucyk7XG4gICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyID0gYXdhaXQgdHJhY2VHcm91cC5zdGFydCh7IC4uLmFyZ3MgfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZW5jbG9zZWRDb2RlKGNhbGxiYWNrTWFuYWdlciwgLi4uYXJncyk7XG4gICAgICAgIGF3YWl0IHRyYWNlR3JvdXAuZW5kKF9jb2VyY2VUb0RpY3QocmVzdWx0LCBcIm91dHB1dFwiKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgYXdhaXQgdHJhY2VHcm91cC5lcnJvcihlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/promises.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   awaitAllCallbacks: () => (/* reexport safe */ _singletons_callbacks_js__WEBPACK_IMPORTED_MODULE_0__.awaitAllCallbacks),\n/* harmony export */   consumeCallback: () => (/* reexport safe */ _singletons_callbacks_js__WEBPACK_IMPORTED_MODULE_0__.consumeCallback)\n/* harmony export */ });\n/* harmony import */ var _singletons_callbacks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/callbacks.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/callbacks.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL3Byb21pc2VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnRjtBQUNsQyIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxjYWxsYmFja3NcXHByb21pc2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF3YWl0QWxsQ2FsbGJhY2tzLCBjb25zdW1lQ2FsbGJhY2sgfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9jYWxsYmFja3MuanNcIjtcbmV4cG9ydCB7IGF3YWl0QWxsQ2FsbGJhY2tzLCBjb25zdW1lQ2FsbGJhY2sgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/chat_history.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/chat_history.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseChatMessageHistory: () => (/* binding */ BaseChatMessageHistory),\n/* harmony export */   BaseListChatMessageHistory: () => (/* binding */ BaseListChatMessageHistory),\n/* harmony export */   InMemoryChatMessageHistory: () => (/* binding */ InMemoryChatMessageHistory)\n/* harmony export */ });\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./load/serializable.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _messages_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./messages/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.js\");\n\n\n// TODO: Combine into one class for 0.2\n/**\n * Base class for all chat message histories. All chat message histories\n * should extend this class.\n */\nclass BaseChatMessageHistory extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable {\n    /**\n     * Add a list of messages.\n     *\n     * Implementations should override this method to handle bulk addition of messages\n     * in an efficient manner to avoid unnecessary round-trips to the underlying store.\n     *\n     * @param messages - A list of BaseMessage objects to store.\n     */\n    async addMessages(messages) {\n        for (const message of messages) {\n            await this.addMessage(message);\n        }\n    }\n}\n/**\n * Base class for all list chat message histories. All list chat message\n * histories should extend this class.\n */\nclass BaseListChatMessageHistory extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable {\n    /**\n     * This is a convenience method for adding a human message string to the store.\n     * Please note that this is a convenience method. Code should favor the\n     * bulk addMessages interface instead to save on round-trips to the underlying\n     * persistence layer.\n     * This method may be deprecated in a future release.\n     */\n    addUserMessage(message) {\n        return this.addMessage(new _messages_index_js__WEBPACK_IMPORTED_MODULE_1__.HumanMessage(message));\n    }\n    /** @deprecated Use addAIMessage instead */\n    addAIChatMessage(message) {\n        return this.addMessage(new _messages_index_js__WEBPACK_IMPORTED_MODULE_1__.AIMessage(message));\n    }\n    /**\n     * This is a convenience method for adding an AI message string to the store.\n     * Please note that this is a convenience method. Code should favor the bulk\n     * addMessages interface instead to save on round-trips to the underlying\n     * persistence layer.\n     * This method may be deprecated in a future release.\n     */\n    addAIMessage(message) {\n        return this.addMessage(new _messages_index_js__WEBPACK_IMPORTED_MODULE_1__.AIMessage(message));\n    }\n    /**\n     * Add a list of messages.\n     *\n     * Implementations should override this method to handle bulk addition of messages\n     * in an efficient manner to avoid unnecessary round-trips to the underlying store.\n     *\n     * @param messages - A list of BaseMessage objects to store.\n     */\n    async addMessages(messages) {\n        for (const message of messages) {\n            await this.addMessage(message);\n        }\n    }\n    /**\n     * Remove all messages from the store.\n     */\n    clear() {\n        throw new Error(\"Not implemented.\");\n    }\n}\n/**\n * Class for storing chat message history in-memory. It extends the\n * BaseListChatMessageHistory class and provides methods to get, add, and\n * clear messages.\n */\nclass InMemoryChatMessageHistory extends BaseListChatMessageHistory {\n    constructor(messages) {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"stores\", \"message\", \"in_memory\"]\n        });\n        Object.defineProperty(this, \"messages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.messages = messages ?? [];\n    }\n    /**\n     * Method to get all the messages stored in the ChatMessageHistory\n     * instance.\n     * @returns Array of stored BaseMessage instances.\n     */\n    async getMessages() {\n        return this.messages;\n    }\n    /**\n     * Method to add a new message to the ChatMessageHistory instance.\n     * @param message The BaseMessage instance to add.\n     * @returns A promise that resolves when the message has been added.\n     */\n    async addMessage(message) {\n        this.messages.push(message);\n    }\n    /**\n     * Method to clear all the messages from the ChatMessageHistory instance.\n     * @returns A promise that resolves when all messages have been cleared.\n     */\n    async clear() {\n        this.messages = [];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2hhdF9oaXN0b3J5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNEO0FBQ1E7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQywrREFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUMsK0RBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0REFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxjaGF0X2hpc3RvcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2VyaWFsaXphYmxlIH0gZnJvbSBcIi4vbG9hZC9zZXJpYWxpemFibGUuanNcIjtcbmltcG9ydCB7IEh1bWFuTWVzc2FnZSwgQUlNZXNzYWdlIH0gZnJvbSBcIi4vbWVzc2FnZXMvaW5kZXguanNcIjtcbi8vIFRPRE86IENvbWJpbmUgaW50byBvbmUgY2xhc3MgZm9yIDAuMlxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgY2hhdCBtZXNzYWdlIGhpc3Rvcmllcy4gQWxsIGNoYXQgbWVzc2FnZSBoaXN0b3JpZXNcbiAqIHNob3VsZCBleHRlbmQgdGhpcyBjbGFzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VDaGF0TWVzc2FnZUhpc3RvcnkgZXh0ZW5kcyBTZXJpYWxpemFibGUge1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3Qgb2YgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRhdGlvbnMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGhhbmRsZSBidWxrIGFkZGl0aW9uIG9mIG1lc3NhZ2VzXG4gICAgICogaW4gYW4gZWZmaWNpZW50IG1hbm5lciB0byBhdm9pZCB1bm5lY2Vzc2FyeSByb3VuZC10cmlwcyB0byB0aGUgdW5kZXJseWluZyBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyAtIEEgbGlzdCBvZiBCYXNlTWVzc2FnZSBvYmplY3RzIHRvIHN0b3JlLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgbGlzdCBjaGF0IG1lc3NhZ2UgaGlzdG9yaWVzLiBBbGwgbGlzdCBjaGF0IG1lc3NhZ2VcbiAqIGhpc3RvcmllcyBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTGlzdENoYXRNZXNzYWdlSGlzdG9yeSBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgYWRkaW5nIGEgaHVtYW4gbWVzc2FnZSBzdHJpbmcgdG8gdGhlIHN0b3JlLlxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZC4gQ29kZSBzaG91bGQgZmF2b3IgdGhlXG4gICAgICogYnVsayBhZGRNZXNzYWdlcyBpbnRlcmZhY2UgaW5zdGVhZCB0byBzYXZlIG9uIHJvdW5kLXRyaXBzIHRvIHRoZSB1bmRlcmx5aW5nXG4gICAgICogcGVyc2lzdGVuY2UgbGF5ZXIuXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGRlcHJlY2F0ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAgICAgKi9cbiAgICBhZGRVc2VyTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE1lc3NhZ2UobmV3IEh1bWFuTWVzc2FnZShtZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgYWRkQUlNZXNzYWdlIGluc3RlYWQgKi9cbiAgICBhZGRBSUNoYXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTWVzc2FnZShuZXcgQUlNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgYWRkaW5nIGFuIEFJIG1lc3NhZ2Ugc3RyaW5nIHRvIHRoZSBzdG9yZS5cbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QuIENvZGUgc2hvdWxkIGZhdm9yIHRoZSBidWxrXG4gICAgICogYWRkTWVzc2FnZXMgaW50ZXJmYWNlIGluc3RlYWQgdG8gc2F2ZSBvbiByb3VuZC10cmlwcyB0byB0aGUgdW5kZXJseWluZ1xuICAgICAqIHBlcnNpc3RlbmNlIGxheWVyLlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBkZXByZWNhdGVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgICovXG4gICAgYWRkQUlNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTWVzc2FnZShuZXcgQUlNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdCBvZiBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGF0aW9ucyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaGFuZGxlIGJ1bGsgYWRkaXRpb24gb2YgbWVzc2FnZXNcbiAgICAgKiBpbiBhbiBlZmZpY2llbnQgbWFubmVyIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJvdW5kLXRyaXBzIHRvIHRoZSB1bmRlcmx5aW5nIHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIC0gQSBsaXN0IG9mIEJhc2VNZXNzYWdlIG9iamVjdHMgdG8gc3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgYWRkTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFkZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBtZXNzYWdlcyBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIGZvciBzdG9yaW5nIGNoYXQgbWVzc2FnZSBoaXN0b3J5IGluLW1lbW9yeS4gSXQgZXh0ZW5kcyB0aGVcbiAqIEJhc2VMaXN0Q2hhdE1lc3NhZ2VIaXN0b3J5IGNsYXNzIGFuZCBwcm92aWRlcyBtZXRob2RzIHRvIGdldCwgYWRkLCBhbmRcbiAqIGNsZWFyIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgY2xhc3MgSW5NZW1vcnlDaGF0TWVzc2FnZUhpc3RvcnkgZXh0ZW5kcyBCYXNlTGlzdENoYXRNZXNzYWdlSGlzdG9yeSB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZXMpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJzdG9yZXNcIiwgXCJtZXNzYWdlXCIsIFwiaW5fbWVtb3J5XCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcyA/PyBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdldCBhbGwgdGhlIG1lc3NhZ2VzIHN0b3JlZCBpbiB0aGUgQ2hhdE1lc3NhZ2VIaXN0b3J5XG4gICAgICogaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMgQXJyYXkgb2Ygc3RvcmVkIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRNZXNzYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBhZGQgYSBuZXcgbWVzc2FnZSB0byB0aGUgQ2hhdE1lc3NhZ2VIaXN0b3J5IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBCYXNlTWVzc2FnZSBpbnN0YW5jZSB0byBhZGQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbWVzc2FnZSBoYXMgYmVlbiBhZGRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gY2xlYXIgYWxsIHRoZSBtZXNzYWdlcyBmcm9tIHRoZSBDaGF0TWVzc2FnZUhpc3RvcnkgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgbWVzc2FnZXMgaGF2ZSBiZWVuIGNsZWFyZWQuXG4gICAgICovXG4gICAgYXN5bmMgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/chat_history.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/document.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/document.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document)\n/* harmony export */ });\n/**\n * Interface for interacting with a document.\n */\nclass Document {\n    constructor(fields) {\n        Object.defineProperty(this, \"pageContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The ID field is optional at the moment.\n        // It will likely become required in a future major release after\n        // it has been adopted by enough vectorstore implementations.\n        /**\n         * An optional identifier for the document.\n         *\n         * Ideally this should be unique across the document collection and formatted\n         * as a UUID, but this will not be enforced.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.pageContent =\n            fields.pageContent !== undefined ? fields.pageContent.toString() : \"\";\n        this.metadata = fields.metadata ?? {};\n        this.id = fields.id;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL2RvY3VtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGRvY3VtZW50c1xcZG9jdW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGludGVyYWN0aW5nIHdpdGggYSBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIERvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFnZUNvbnRlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIElEIGZpZWxkIGlzIG9wdGlvbmFsIGF0IHRoZSBtb21lbnQuXG4gICAgICAgIC8vIEl0IHdpbGwgbGlrZWx5IGJlY29tZSByZXF1aXJlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlIGFmdGVyXG4gICAgICAgIC8vIGl0IGhhcyBiZWVuIGFkb3B0ZWQgYnkgZW5vdWdoIHZlY3RvcnN0b3JlIGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIGlkZW50aWZpZXIgZm9yIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWRlYWxseSB0aGlzIHNob3VsZCBiZSB1bmlxdWUgYWNyb3NzIHRoZSBkb2N1bWVudCBjb2xsZWN0aW9uIGFuZCBmb3JtYXR0ZWRcbiAgICAgICAgICogYXMgYSBVVUlELCBidXQgdGhpcyB3aWxsIG5vdCBiZSBlbmZvcmNlZC5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFnZUNvbnRlbnQgPVxuICAgICAgICAgICAgZmllbGRzLnBhZ2VDb250ZW50ICE9PSB1bmRlZmluZWQgPyBmaWVsZHMucGFnZUNvbnRlbnQudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBmaWVsZHMubWV0YWRhdGEgPz8ge307XG4gICAgICAgIHRoaXMuaWQgPSBmaWVsZHMuaWQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/document.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDocumentTransformer: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_1__.BaseDocumentTransformer),\n/* harmony export */   Document: () => (/* reexport safe */ _document_js__WEBPACK_IMPORTED_MODULE_0__.Document),\n/* harmony export */   MappingDocumentTransformer: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_1__.MappingDocumentTransformer)\n/* harmony export */ });\n/* harmony import */ var _document_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./document.js */ \"(rsc)/./node_modules/@langchain/core/dist/documents/document.js\");\n/* harmony import */ var _transformers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transformers.js */ \"(rsc)/./node_modules/@langchain/core/dist/documents/transformers.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThCO0FBQ0kiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcZG9jdW1lbnRzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLi9kb2N1bWVudC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHJhbnNmb3JtZXJzLmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/transformers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/transformers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDocumentTransformer: () => (/* binding */ BaseDocumentTransformer),\n/* harmony export */   MappingDocumentTransformer: () => (/* binding */ MappingDocumentTransformer)\n/* harmony export */ });\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n\n/**\n * Abstract base class for document transformation systems.\n *\n * A document transformation system takes an array of Documents and returns an\n * array of transformed Documents. These arrays do not necessarily have to have\n * the same length.\n *\n * One example of this is a text splitter that splits a large document into\n * many smaller documents.\n */\nclass BaseDocumentTransformer extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"documents\", \"transformers\"]\n        });\n    }\n    /**\n     * Method to invoke the document transformation. This method calls the\n     * transformDocuments method with the provided input.\n     * @param input The input documents to be transformed.\n     * @param _options Optional configuration object to customize the behavior of callbacks.\n     * @returns A Promise that resolves to the transformed documents.\n     */\n    invoke(input, _options) {\n        return this.transformDocuments(input);\n    }\n}\n/**\n * Class for document transformers that return exactly one transformed document\n * for each input document.\n */\nclass MappingDocumentTransformer extends BaseDocumentTransformer {\n    async transformDocuments(documents) {\n        const newDocuments = [];\n        for (const document of documents) {\n            const transformedDocument = await this._transformDocument(document);\n            newDocuments.push(transformedDocument);\n        }\n        return newDocuments;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL3RyYW5zZm9ybWVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0Msd0RBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxkb2N1bWVudHNcXHRyYW5zZm9ybWVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSdW5uYWJsZSB9IGZyb20gXCIuLi9ydW5uYWJsZXMvYmFzZS5qc1wiO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBkb2N1bWVudCB0cmFuc2Zvcm1hdGlvbiBzeXN0ZW1zLlxuICpcbiAqIEEgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24gc3lzdGVtIHRha2VzIGFuIGFycmF5IG9mIERvY3VtZW50cyBhbmQgcmV0dXJucyBhblxuICogYXJyYXkgb2YgdHJhbnNmb3JtZWQgRG9jdW1lbnRzLiBUaGVzZSBhcnJheXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaGF2ZVxuICogdGhlIHNhbWUgbGVuZ3RoLlxuICpcbiAqIE9uZSBleGFtcGxlIG9mIHRoaXMgaXMgYSB0ZXh0IHNwbGl0dGVyIHRoYXQgc3BsaXRzIGEgbGFyZ2UgZG9jdW1lbnQgaW50b1xuICogbWFueSBzbWFsbGVyIGRvY3VtZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VEb2N1bWVudFRyYW5zZm9ybWVyIGV4dGVuZHMgUnVubmFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwiZG9jdW1lbnRzXCIsIFwidHJhbnNmb3JtZXJzXCJdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gaW52b2tlIHRoZSBkb2N1bWVudCB0cmFuc2Zvcm1hdGlvbi4gVGhpcyBtZXRob2QgY2FsbHMgdGhlXG4gICAgICogdHJhbnNmb3JtRG9jdW1lbnRzIG1ldGhvZCB3aXRoIHRoZSBwcm92aWRlZCBpbnB1dC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGRvY3VtZW50cyB0byBiZSB0cmFuc2Zvcm1lZC5cbiAgICAgKiBAcGFyYW0gX29wdGlvbnMgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZiBjYWxsYmFja3MuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyYW5zZm9ybWVkIGRvY3VtZW50cy5cbiAgICAgKi9cbiAgICBpbnZva2UoaW5wdXQsIF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybURvY3VtZW50cyhpbnB1dCk7XG4gICAgfVxufVxuLyoqXG4gKiBDbGFzcyBmb3IgZG9jdW1lbnQgdHJhbnNmb3JtZXJzIHRoYXQgcmV0dXJuIGV4YWN0bHkgb25lIHRyYW5zZm9ybWVkIGRvY3VtZW50XG4gKiBmb3IgZWFjaCBpbnB1dCBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hcHBpbmdEb2N1bWVudFRyYW5zZm9ybWVyIGV4dGVuZHMgQmFzZURvY3VtZW50VHJhbnNmb3JtZXIge1xuICAgIGFzeW5jIHRyYW5zZm9ybURvY3VtZW50cyhkb2N1bWVudHMpIHtcbiAgICAgICAgY29uc3QgbmV3RG9jdW1lbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZG9jdW1lbnQgb2YgZG9jdW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZERvY3VtZW50ID0gYXdhaXQgdGhpcy5fdHJhbnNmb3JtRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgbmV3RG9jdW1lbnRzLnB1c2godHJhbnNmb3JtZWREb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RvY3VtZW50cztcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/transformers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/embeddings.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/embeddings.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Embeddings: () => (/* binding */ Embeddings)\n/* harmony export */ });\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.js\");\n\n/**\n * An abstract class that provides methods for embedding documents and\n * queries using LangChain.\n */\nclass Embeddings {\n    constructor(params) {\n        /**\n         * The async caller should be used by subclasses to make any async calls,\n         * which will thus benefit from the concurrency and retry logic.\n         */\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(params ?? {});\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZW1iZWRkaW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLCtEQUFXLGFBQWE7QUFDbEQ7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxlbWJlZGRpbmdzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG4vKipcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW1iZWRkaW5nIGRvY3VtZW50cyBhbmRcbiAqIHF1ZXJpZXMgdXNpbmcgTGFuZ0NoYWluLlxuICovXG5leHBvcnQgY2xhc3MgRW1iZWRkaW5ncyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXN5bmMgY2FsbGVyIHNob3VsZCBiZSB1c2VkIGJ5IHN1YmNsYXNzZXMgdG8gbWFrZSBhbnkgYXN5bmMgY2FsbHMsXG4gICAgICAgICAqIHdoaWNoIHdpbGwgdGh1cyBiZW5lZml0IGZyb20gdGhlIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxlciA9IG5ldyBBc3luY0NhbGxlcihwYXJhbXMgPz8ge30pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/embeddings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/errors/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/errors/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addLangChainErrorFields: () => (/* binding */ addLangChainErrorFields)\n/* harmony export */ });\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-param-reassign */\nfunction addLangChainErrorFields(error, lc_error_code) {\n    error.lc_error_code = lc_error_code;\n    error.message = `${error.message}\\n\\nTroubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/\\n`;\n    return error;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZXJyb3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVCQUF1QixjQUFjLGdGQUFnRixjQUFjO0FBQ25JO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcZXJyb3JzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZExhbmdDaGFpbkVycm9yRmllbGRzKGVycm9yLCBsY19lcnJvcl9jb2RlKSB7XG4gICAgZXJyb3IubGNfZXJyb3JfY29kZSA9IGxjX2Vycm9yX2NvZGU7XG4gICAgZXJyb3IubWVzc2FnZSA9IGAke2Vycm9yLm1lc3NhZ2V9XFxuXFxuVHJvdWJsZXNob290aW5nIFVSTDogaHR0cHM6Ly9qcy5sYW5nY2hhaW4uY29tL2RvY3MvdHJvdWJsZXNob290aW5nL2Vycm9ycy8ke2xjX2Vycm9yX2NvZGV9L1xcbmA7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/example_selectors/base.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/example_selectors/base.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseExampleSelector: () => (/* binding */ BaseExampleSelector)\n/* harmony export */ });\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../load/serializable.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\");\n\n/**\n * Base class for example selectors.\n */\nclass BaseExampleSelector extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"example_selectors\", \"base\"]\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZXhhbXBsZV9zZWxlY3RvcnMvYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsK0RBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxleGFtcGxlX3NlbGVjdG9yc1xcYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTZXJpYWxpemFibGUgfSBmcm9tIFwiLi4vbG9hZC9zZXJpYWxpemFibGUuanNcIjtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZXhhbXBsZSBzZWxlY3RvcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlRXhhbXBsZVNlbGVjdG9yIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcImV4YW1wbGVfc2VsZWN0b3JzXCIsIFwiYmFzZVwiXVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/example_selectors/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/example_selectors/conditional.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/example_selectors/conditional.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePromptSelector: () => (/* binding */ BasePromptSelector),\n/* harmony export */   ConditionalPromptSelector: () => (/* binding */ ConditionalPromptSelector),\n/* harmony export */   isChatModel: () => (/* binding */ isChatModel),\n/* harmony export */   isLLM: () => (/* binding */ isLLM)\n/* harmony export */ });\n/**\n * Abstract class that defines the interface for selecting a prompt for a\n * given language model.\n */\nclass BasePromptSelector {\n    /**\n     * Asynchronous version of `getPrompt` that also accepts an options object\n     * for partial variables.\n     * @param llm The language model for which to get a prompt.\n     * @param options Optional object for partial variables.\n     * @returns A Promise that resolves to a prompt template.\n     */\n    async getPromptAsync(llm, options) {\n        const prompt = this.getPrompt(llm);\n        return prompt.partial(options?.partialVariables ?? {});\n    }\n}\n/**\n * Concrete implementation of `BasePromptSelector` that selects a prompt\n * based on a set of conditions. It has a default prompt that it returns\n * if none of the conditions are met.\n */\nclass ConditionalPromptSelector extends BasePromptSelector {\n    constructor(default_prompt, conditionals = []) {\n        super();\n        Object.defineProperty(this, \"defaultPrompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"conditionals\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.defaultPrompt = default_prompt;\n        this.conditionals = conditionals;\n    }\n    /**\n     * Method that selects a prompt based on a set of conditions. If none of\n     * the conditions are met, it returns the default prompt.\n     * @param llm The language model for which to get a prompt.\n     * @returns A prompt template.\n     */\n    getPrompt(llm) {\n        for (const [condition, prompt] of this.conditionals) {\n            if (condition(llm)) {\n                return prompt;\n            }\n        }\n        return this.defaultPrompt;\n    }\n}\n/**\n * Type guard function that checks if a given language model is of type\n * `BaseLLM`.\n */\nfunction isLLM(llm) {\n    return llm._modelType() === \"base_llm\";\n}\n/**\n * Type guard function that checks if a given language model is of type\n * `BaseChatModel`.\n */\nfunction isChatModel(llm) {\n    return llm._modelType() === \"base_chat_model\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZXhhbXBsZV9zZWxlY3RvcnMvY29uZGl0aW9uYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxleGFtcGxlX3NlbGVjdG9yc1xcY29uZGl0aW9uYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IGRlZmluZXMgdGhlIGludGVyZmFjZSBmb3Igc2VsZWN0aW5nIGEgcHJvbXB0IGZvciBhXG4gKiBnaXZlbiBsYW5ndWFnZSBtb2RlbC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VQcm9tcHRTZWxlY3RvciB7XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzIHZlcnNpb24gb2YgYGdldFByb21wdGAgdGhhdCBhbHNvIGFjY2VwdHMgYW4gb3B0aW9ucyBvYmplY3RcbiAgICAgKiBmb3IgcGFydGlhbCB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIGxsbSBUaGUgbGFuZ3VhZ2UgbW9kZWwgZm9yIHdoaWNoIHRvIGdldCBhIHByb21wdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBvYmplY3QgZm9yIHBhcnRpYWwgdmFyaWFibGVzLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgcHJvbXB0IHRlbXBsYXRlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb21wdEFzeW5jKGxsbSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm9tcHQgPSB0aGlzLmdldFByb21wdChsbG0pO1xuICAgICAgICByZXR1cm4gcHJvbXB0LnBhcnRpYWwob3B0aW9ucz8ucGFydGlhbFZhcmlhYmxlcyA/PyB7fSk7XG4gICAgfVxufVxuLyoqXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBgQmFzZVByb21wdFNlbGVjdG9yYCB0aGF0IHNlbGVjdHMgYSBwcm9tcHRcbiAqIGJhc2VkIG9uIGEgc2V0IG9mIGNvbmRpdGlvbnMuIEl0IGhhcyBhIGRlZmF1bHQgcHJvbXB0IHRoYXQgaXQgcmV0dXJuc1xuICogaWYgbm9uZSBvZiB0aGUgY29uZGl0aW9ucyBhcmUgbWV0LlxuICovXG5leHBvcnQgY2xhc3MgQ29uZGl0aW9uYWxQcm9tcHRTZWxlY3RvciBleHRlbmRzIEJhc2VQcm9tcHRTZWxlY3RvciB7XG4gICAgY29uc3RydWN0b3IoZGVmYXVsdF9wcm9tcHQsIGNvbmRpdGlvbmFscyA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRQcm9tcHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZGl0aW9uYWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFByb21wdCA9IGRlZmF1bHRfcHJvbXB0O1xuICAgICAgICB0aGlzLmNvbmRpdGlvbmFscyA9IGNvbmRpdGlvbmFscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgc2VsZWN0cyBhIHByb21wdCBiYXNlZCBvbiBhIHNldCBvZiBjb25kaXRpb25zLiBJZiBub25lIG9mXG4gICAgICogdGhlIGNvbmRpdGlvbnMgYXJlIG1ldCwgaXQgcmV0dXJucyB0aGUgZGVmYXVsdCBwcm9tcHQuXG4gICAgICogQHBhcmFtIGxsbSBUaGUgbGFuZ3VhZ2UgbW9kZWwgZm9yIHdoaWNoIHRvIGdldCBhIHByb21wdC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21wdCB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICBnZXRQcm9tcHQobGxtKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2NvbmRpdGlvbiwgcHJvbXB0XSBvZiB0aGlzLmNvbmRpdGlvbmFscykge1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbihsbG0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21wdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0UHJvbXB0O1xuICAgIH1cbn1cbi8qKlxuICogVHlwZSBndWFyZCBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhIGdpdmVuIGxhbmd1YWdlIG1vZGVsIGlzIG9mIHR5cGVcbiAqIGBCYXNlTExNYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTExNKGxsbSkge1xuICAgIHJldHVybiBsbG0uX21vZGVsVHlwZSgpID09PSBcImJhc2VfbGxtXCI7XG59XG4vKipcbiAqIFR5cGUgZ3VhcmQgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBnaXZlbiBsYW5ndWFnZSBtb2RlbCBpcyBvZiB0eXBlXG4gKiBgQmFzZUNoYXRNb2RlbGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NoYXRNb2RlbChsbG0pIHtcbiAgICByZXR1cm4gbGxtLl9tb2RlbFR5cGUoKSA9PT0gXCJiYXNlX2NoYXRfbW9kZWxcIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/example_selectors/conditional.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/example_selectors/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/example_selectors/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseExampleSelector: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseExampleSelector),\n/* harmony export */   BasePromptSelector: () => (/* reexport safe */ _conditional_js__WEBPACK_IMPORTED_MODULE_1__.BasePromptSelector),\n/* harmony export */   ConditionalPromptSelector: () => (/* reexport safe */ _conditional_js__WEBPACK_IMPORTED_MODULE_1__.ConditionalPromptSelector),\n/* harmony export */   LengthBasedExampleSelector: () => (/* reexport safe */ _length_based_js__WEBPACK_IMPORTED_MODULE_2__.LengthBasedExampleSelector),\n/* harmony export */   SemanticSimilarityExampleSelector: () => (/* reexport safe */ _semantic_similarity_js__WEBPACK_IMPORTED_MODULE_3__.SemanticSimilarityExampleSelector),\n/* harmony export */   isChatModel: () => (/* reexport safe */ _conditional_js__WEBPACK_IMPORTED_MODULE_1__.isChatModel),\n/* harmony export */   isLLM: () => (/* reexport safe */ _conditional_js__WEBPACK_IMPORTED_MODULE_1__.isLLM)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/example_selectors/base.js\");\n/* harmony import */ var _conditional_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conditional.js */ \"(rsc)/./node_modules/@langchain/core/dist/example_selectors/conditional.js\");\n/* harmony import */ var _length_based_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./length_based.js */ \"(rsc)/./node_modules/@langchain/core/dist/example_selectors/length_based.js\");\n/* harmony import */ var _semantic_similarity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./semantic_similarity.js */ \"(rsc)/./node_modules/@langchain/core/dist/example_selectors/semantic_similarity.js\");\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZXhhbXBsZV9zZWxlY3RvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDTztBQUNDO0FBQ08iLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcZXhhbXBsZV9zZWxlY3RvcnNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2Jhc2UuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbmRpdGlvbmFsLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9sZW5ndGhfYmFzZWQuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NlbWFudGljX3NpbWlsYXJpdHkuanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/example_selectors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/example_selectors/length_based.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/example_selectors/length_based.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LengthBasedExampleSelector: () => (/* binding */ LengthBasedExampleSelector)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/example_selectors/base.js\");\n\n/**\n * Calculates the length of a text based on the number of words and lines.\n */\nfunction getLengthBased(text) {\n    return text.split(/\\n| /).length;\n}\n/**\n * A specialized example selector that selects examples based on their\n * length, ensuring that the total length of the selected examples does\n * not exceed a specified maximum length.\n * @example\n * ```typescript\n * const exampleSelector = new LengthBasedExampleSelector(\n *   [\n *     { input: \"happy\", output: \"sad\" },\n *     { input: \"tall\", output: \"short\" },\n *     { input: \"energetic\", output: \"lethargic\" },\n *     { input: \"sunny\", output: \"gloomy\" },\n *     { input: \"windy\", output: \"calm\" },\n *   ],\n *   {\n *     examplePrompt: new PromptTemplate({\n *       inputVariables: [\"input\", \"output\"],\n *       template: \"Input: {input}\\nOutput: {output}\",\n *     }),\n *     maxLength: 25,\n *   },\n * );\n * const dynamicPrompt = new FewShotPromptTemplate({\n *   exampleSelector,\n *   examplePrompt: new PromptTemplate({\n *     inputVariables: [\"input\", \"output\"],\n *     template: \"Input: {input}\\nOutput: {output}\",\n *   }),\n *   prefix: \"Give the antonym of every input\",\n *   suffix: \"Input: {adjective}\\nOutput:\",\n *   inputVariables: [\"adjective\"],\n * });\n * console.log(dynamicPrompt.format({ adjective: \"big\" }));\n * console.log(\n *   dynamicPrompt.format({\n *     adjective:\n *       \"big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else\",\n *   }),\n * );\n * ```\n */\nclass LengthBasedExampleSelector extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseExampleSelector {\n    constructor(data) {\n        super(data);\n        Object.defineProperty(this, \"examples\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"examplePrompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"getTextLength\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getLengthBased\n        });\n        Object.defineProperty(this, \"maxLength\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 2048\n        });\n        Object.defineProperty(this, \"exampleTextLengths\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.examplePrompt = data.examplePrompt;\n        this.maxLength = data.maxLength ?? 2048;\n        this.getTextLength = data.getTextLength ?? getLengthBased;\n    }\n    /**\n     * Adds an example to the list of examples and calculates its length.\n     * @param example The example to be added.\n     * @returns Promise that resolves when the example has been added and its length calculated.\n     */\n    async addExample(example) {\n        this.examples.push(example);\n        const stringExample = await this.examplePrompt.format(example);\n        this.exampleTextLengths.push(this.getTextLength(stringExample));\n    }\n    /**\n     * Calculates the lengths of the examples.\n     * @param v Array of lengths of the examples.\n     * @param values Instance of LengthBasedExampleSelector.\n     * @returns Promise that resolves with an array of lengths of the examples.\n     */\n    async calculateExampleTextLengths(v, values) {\n        if (v.length > 0) {\n            return v;\n        }\n        const { examples, examplePrompt } = values;\n        const stringExamples = await Promise.all(examples.map((eg) => examplePrompt.format(eg)));\n        return stringExamples.map((eg) => this.getTextLength(eg));\n    }\n    /**\n     * Selects examples until the total length of the selected examples\n     * reaches the maxLength.\n     * @param inputVariables The input variables for the examples.\n     * @returns Promise that resolves with an array of selected examples.\n     */\n    async selectExamples(inputVariables) {\n        const inputs = Object.values(inputVariables).join(\" \");\n        let remainingLength = this.maxLength - this.getTextLength(inputs);\n        let i = 0;\n        const examples = [];\n        while (remainingLength > 0 && i < this.examples.length) {\n            const newLength = remainingLength - this.exampleTextLengths[i];\n            if (newLength < 0) {\n                break;\n            }\n            else {\n                examples.push(this.examples[i]);\n                remainingLength = newLength;\n            }\n            i += 1;\n        }\n        return examples;\n    }\n    /**\n     * Creates a new instance of LengthBasedExampleSelector and adds a list of\n     * examples to it.\n     * @param examples Array of examples to be added.\n     * @param args Input parameters for the LengthBasedExampleSelector.\n     * @returns Promise that resolves with a new instance of LengthBasedExampleSelector with the examples added.\n     */\n    static async fromExamples(examples, args) {\n        const selector = new LengthBasedExampleSelector(args);\n        await Promise.all(examples.map((eg) => selector.addExample(eg)));\n        return selector;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZXhhbXBsZV9zZWxlY3RvcnMvbGVuZ3RoX2Jhc2VkLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtCQUErQjtBQUN4QyxTQUFTLGdDQUFnQztBQUN6QyxTQUFTLHlDQUF5QztBQUNsRCxTQUFTLGtDQUFrQztBQUMzQyxTQUFTLGdDQUFnQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNLFdBQVcsT0FBTztBQUNwRCxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLFdBQVcsT0FBTztBQUNsRCxNQUFNO0FBQ047QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBLElBQUk7QUFDSixzQ0FBc0Msa0JBQWtCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNPLHlDQUF5Qyx5REFBbUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGV4YW1wbGVfc2VsZWN0b3JzXFxsZW5ndGhfYmFzZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUV4YW1wbGVTZWxlY3RvciB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdGV4dCBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIHdvcmRzIGFuZCBsaW5lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TGVuZ3RoQmFzZWQodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KC9cXG58IC8pLmxlbmd0aDtcbn1cbi8qKlxuICogQSBzcGVjaWFsaXplZCBleGFtcGxlIHNlbGVjdG9yIHRoYXQgc2VsZWN0cyBleGFtcGxlcyBiYXNlZCBvbiB0aGVpclxuICogbGVuZ3RoLCBlbnN1cmluZyB0aGF0IHRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIHNlbGVjdGVkIGV4YW1wbGVzIGRvZXNcbiAqIG5vdCBleGNlZWQgYSBzcGVjaWZpZWQgbWF4aW11bSBsZW5ndGguXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgZXhhbXBsZVNlbGVjdG9yID0gbmV3IExlbmd0aEJhc2VkRXhhbXBsZVNlbGVjdG9yKFxuICogICBbXG4gKiAgICAgeyBpbnB1dDogXCJoYXBweVwiLCBvdXRwdXQ6IFwic2FkXCIgfSxcbiAqICAgICB7IGlucHV0OiBcInRhbGxcIiwgb3V0cHV0OiBcInNob3J0XCIgfSxcbiAqICAgICB7IGlucHV0OiBcImVuZXJnZXRpY1wiLCBvdXRwdXQ6IFwibGV0aGFyZ2ljXCIgfSxcbiAqICAgICB7IGlucHV0OiBcInN1bm55XCIsIG91dHB1dDogXCJnbG9vbXlcIiB9LFxuICogICAgIHsgaW5wdXQ6IFwid2luZHlcIiwgb3V0cHV0OiBcImNhbG1cIiB9LFxuICogICBdLFxuICogICB7XG4gKiAgICAgZXhhbXBsZVByb21wdDogbmV3IFByb21wdFRlbXBsYXRlKHtcbiAqICAgICAgIGlucHV0VmFyaWFibGVzOiBbXCJpbnB1dFwiLCBcIm91dHB1dFwiXSxcbiAqICAgICAgIHRlbXBsYXRlOiBcIklucHV0OiB7aW5wdXR9XFxuT3V0cHV0OiB7b3V0cHV0fVwiLFxuICogICAgIH0pLFxuICogICAgIG1heExlbmd0aDogMjUsXG4gKiAgIH0sXG4gKiApO1xuICogY29uc3QgZHluYW1pY1Byb21wdCA9IG5ldyBGZXdTaG90UHJvbXB0VGVtcGxhdGUoe1xuICogICBleGFtcGxlU2VsZWN0b3IsXG4gKiAgIGV4YW1wbGVQcm9tcHQ6IG5ldyBQcm9tcHRUZW1wbGF0ZSh7XG4gKiAgICAgaW5wdXRWYXJpYWJsZXM6IFtcImlucHV0XCIsIFwib3V0cHV0XCJdLFxuICogICAgIHRlbXBsYXRlOiBcIklucHV0OiB7aW5wdXR9XFxuT3V0cHV0OiB7b3V0cHV0fVwiLFxuICogICB9KSxcbiAqICAgcHJlZml4OiBcIkdpdmUgdGhlIGFudG9ueW0gb2YgZXZlcnkgaW5wdXRcIixcbiAqICAgc3VmZml4OiBcIklucHV0OiB7YWRqZWN0aXZlfVxcbk91dHB1dDpcIixcbiAqICAgaW5wdXRWYXJpYWJsZXM6IFtcImFkamVjdGl2ZVwiXSxcbiAqIH0pO1xuICogY29uc29sZS5sb2coZHluYW1pY1Byb21wdC5mb3JtYXQoeyBhZGplY3RpdmU6IFwiYmlnXCIgfSkpO1xuICogY29uc29sZS5sb2coXG4gKiAgIGR5bmFtaWNQcm9tcHQuZm9ybWF0KHtcbiAqICAgICBhZGplY3RpdmU6XG4gKiAgICAgICBcImJpZyBhbmQgaHVnZSBhbmQgbWFzc2l2ZSBhbmQgbGFyZ2UgYW5kIGdpZ2FudGljIGFuZCB0YWxsIGFuZCBtdWNoIG11Y2ggbXVjaCBtdWNoIG11Y2ggYmlnZ2VyIHRoYW4gZXZlcnl0aGluZyBlbHNlXCIsXG4gKiAgIH0pLFxuICogKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTGVuZ3RoQmFzZWRFeGFtcGxlU2VsZWN0b3IgZXh0ZW5kcyBCYXNlRXhhbXBsZVNlbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKGRhdGEpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGFtcGxlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4YW1wbGVQcm9tcHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0VGV4dExlbmd0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0TGVuZ3RoQmFzZWRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heExlbmd0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMjA0OFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhhbXBsZVRleHRMZW5ndGhzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5leGFtcGxlUHJvbXB0ID0gZGF0YS5leGFtcGxlUHJvbXB0O1xuICAgICAgICB0aGlzLm1heExlbmd0aCA9IGRhdGEubWF4TGVuZ3RoID8/IDIwNDg7XG4gICAgICAgIHRoaXMuZ2V0VGV4dExlbmd0aCA9IGRhdGEuZ2V0VGV4dExlbmd0aCA/PyBnZXRMZW5ndGhCYXNlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBleGFtcGxlIHRvIHRoZSBsaXN0IG9mIGV4YW1wbGVzIGFuZCBjYWxjdWxhdGVzIGl0cyBsZW5ndGguXG4gICAgICogQHBhcmFtIGV4YW1wbGUgVGhlIGV4YW1wbGUgdG8gYmUgYWRkZWQuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV4YW1wbGUgaGFzIGJlZW4gYWRkZWQgYW5kIGl0cyBsZW5ndGggY2FsY3VsYXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRFeGFtcGxlKGV4YW1wbGUpIHtcbiAgICAgICAgdGhpcy5leGFtcGxlcy5wdXNoKGV4YW1wbGUpO1xuICAgICAgICBjb25zdCBzdHJpbmdFeGFtcGxlID0gYXdhaXQgdGhpcy5leGFtcGxlUHJvbXB0LmZvcm1hdChleGFtcGxlKTtcbiAgICAgICAgdGhpcy5leGFtcGxlVGV4dExlbmd0aHMucHVzaCh0aGlzLmdldFRleHRMZW5ndGgoc3RyaW5nRXhhbXBsZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGhzIG9mIHRoZSBleGFtcGxlcy5cbiAgICAgKiBAcGFyYW0gdiBBcnJheSBvZiBsZW5ndGhzIG9mIHRoZSBleGFtcGxlcy5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIEluc3RhbmNlIG9mIExlbmd0aEJhc2VkRXhhbXBsZVNlbGVjdG9yLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIGxlbmd0aHMgb2YgdGhlIGV4YW1wbGVzLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGN1bGF0ZUV4YW1wbGVUZXh0TGVuZ3Rocyh2LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBleGFtcGxlcywgZXhhbXBsZVByb21wdCB9ID0gdmFsdWVzO1xuICAgICAgICBjb25zdCBzdHJpbmdFeGFtcGxlcyA9IGF3YWl0IFByb21pc2UuYWxsKGV4YW1wbGVzLm1hcCgoZWcpID0+IGV4YW1wbGVQcm9tcHQuZm9ybWF0KGVnKSkpO1xuICAgICAgICByZXR1cm4gc3RyaW5nRXhhbXBsZXMubWFwKChlZykgPT4gdGhpcy5nZXRUZXh0TGVuZ3RoKGVnKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgZXhhbXBsZXMgdW50aWwgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgc2VsZWN0ZWQgZXhhbXBsZXNcbiAgICAgKiByZWFjaGVzIHRoZSBtYXhMZW5ndGguXG4gICAgICogQHBhcmFtIGlucHV0VmFyaWFibGVzIFRoZSBpbnB1dCB2YXJpYWJsZXMgZm9yIHRoZSBleGFtcGxlcy5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBzZWxlY3RlZCBleGFtcGxlcy5cbiAgICAgKi9cbiAgICBhc3luYyBzZWxlY3RFeGFtcGxlcyhpbnB1dFZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBPYmplY3QudmFsdWVzKGlucHV0VmFyaWFibGVzKS5qb2luKFwiIFwiKTtcbiAgICAgICAgbGV0IHJlbWFpbmluZ0xlbmd0aCA9IHRoaXMubWF4TGVuZ3RoIC0gdGhpcy5nZXRUZXh0TGVuZ3RoKGlucHV0cyk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgZXhhbXBsZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbmd0aCA+IDAgJiYgaSA8IHRoaXMuZXhhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdMZW5ndGggPSByZW1haW5pbmdMZW5ndGggLSB0aGlzLmV4YW1wbGVUZXh0TGVuZ3Roc1tpXTtcbiAgICAgICAgICAgIGlmIChuZXdMZW5ndGggPCAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGFtcGxlcy5wdXNoKHRoaXMuZXhhbXBsZXNbaV0pO1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0xlbmd0aCA9IG5ld0xlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhhbXBsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgTGVuZ3RoQmFzZWRFeGFtcGxlU2VsZWN0b3IgYW5kIGFkZHMgYSBsaXN0IG9mXG4gICAgICogZXhhbXBsZXMgdG8gaXQuXG4gICAgICogQHBhcmFtIGV4YW1wbGVzIEFycmF5IG9mIGV4YW1wbGVzIHRvIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSBhcmdzIElucHV0IHBhcmFtZXRlcnMgZm9yIHRoZSBMZW5ndGhCYXNlZEV4YW1wbGVTZWxlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIG5ldyBpbnN0YW5jZSBvZiBMZW5ndGhCYXNlZEV4YW1wbGVTZWxlY3RvciB3aXRoIHRoZSBleGFtcGxlcyBhZGRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUV4YW1wbGVzKGV4YW1wbGVzLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gbmV3IExlbmd0aEJhc2VkRXhhbXBsZVNlbGVjdG9yKGFyZ3MpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChleGFtcGxlcy5tYXAoKGVnKSA9PiBzZWxlY3Rvci5hZGRFeGFtcGxlKGVnKSkpO1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/example_selectors/length_based.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/example_selectors/semantic_similarity.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/example_selectors/semantic_similarity.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SemanticSimilarityExampleSelector: () => (/* binding */ SemanticSimilarityExampleSelector)\n/* harmony export */ });\n/* harmony import */ var _documents_document_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../documents/document.js */ \"(rsc)/./node_modules/@langchain/core/dist/documents/document.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/example_selectors/base.js\");\n\n\nfunction sortedValues(values) {\n    return Object.keys(values)\n        .sort()\n        .map((key) => values[key]);\n}\n/**\n * Class that selects examples based on semantic similarity. It extends\n * the BaseExampleSelector class.\n * @example\n * ```typescript\n * const exampleSelector = await SemanticSimilarityExampleSelector.fromExamples(\n *   [\n *     { input: \"happy\", output: \"sad\" },\n *     { input: \"tall\", output: \"short\" },\n *     { input: \"energetic\", output: \"lethargic\" },\n *     { input: \"sunny\", output: \"gloomy\" },\n *     { input: \"windy\", output: \"calm\" },\n *   ],\n *   new OpenAIEmbeddings(),\n *   HNSWLib,\n *   { k: 1 },\n * );\n * const dynamicPrompt = new FewShotPromptTemplate({\n *   exampleSelector,\n *   examplePrompt: PromptTemplate.fromTemplate(\n *     \"Input: {input}\\nOutput: {output}\",\n *   ),\n *   prefix: \"Give the antonym of every input\",\n *   suffix: \"Input: {adjective}\\nOutput:\",\n *   inputVariables: [\"adjective\"],\n * });\n * console.log(await dynamicPrompt.format({ adjective: \"rainy\" }));\n * ```\n */\nclass SemanticSimilarityExampleSelector extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseExampleSelector {\n    constructor(data) {\n        super(data);\n        Object.defineProperty(this, \"vectorStoreRetriever\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exampleKeys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKeys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.exampleKeys = data.exampleKeys;\n        this.inputKeys = data.inputKeys;\n        if (data.vectorStore !== undefined) {\n            this.vectorStoreRetriever = data.vectorStore.asRetriever({\n                k: data.k ?? 4,\n                filter: data.filter,\n            });\n        }\n        else if (data.vectorStoreRetriever) {\n            this.vectorStoreRetriever = data.vectorStoreRetriever;\n        }\n        else {\n            throw new Error(`You must specify one of \"vectorStore\" and \"vectorStoreRetriever\".`);\n        }\n    }\n    /**\n     * Method that adds a new example to the vectorStore. The example is\n     * converted to a string and added to the vectorStore as a document.\n     * @param example The example to be added to the vectorStore.\n     * @returns Promise that resolves when the example has been added to the vectorStore.\n     */\n    async addExample(example) {\n        const inputKeys = this.inputKeys ?? Object.keys(example);\n        const stringExample = sortedValues(inputKeys.reduce((acc, key) => ({ ...acc, [key]: example[key] }), {})).join(\" \");\n        await this.vectorStoreRetriever.addDocuments([\n            new _documents_document_js__WEBPACK_IMPORTED_MODULE_0__.Document({\n                pageContent: stringExample,\n                metadata: example,\n            }),\n        ]);\n    }\n    /**\n     * Method that selects which examples to use based on semantic similarity.\n     * It performs a similarity search in the vectorStore using the input\n     * variables and returns the examples with the highest similarity.\n     * @param inputVariables The input variables used for the similarity search.\n     * @returns Promise that resolves with an array of the selected examples.\n     */\n    async selectExamples(inputVariables) {\n        const inputKeys = this.inputKeys ?? Object.keys(inputVariables);\n        const query = sortedValues(inputKeys.reduce((acc, key) => ({ ...acc, [key]: inputVariables[key] }), {})).join(\" \");\n        const exampleDocs = await this.vectorStoreRetriever.invoke(query);\n        const examples = exampleDocs.map((doc) => doc.metadata);\n        if (this.exampleKeys) {\n            // If example keys are provided, filter examples to those keys.\n            return examples.map((example) => this.exampleKeys.reduce((acc, key) => ({ ...acc, [key]: example[key] }), {}));\n        }\n        return examples;\n    }\n    /**\n     * Static method that creates a new instance of\n     * SemanticSimilarityExampleSelector. It takes a list of examples, an\n     * instance of Embeddings, a VectorStore class, and an options object as\n     * parameters. It converts the examples to strings, creates a VectorStore\n     * from the strings and the embeddings, and returns a new\n     * SemanticSimilarityExampleSelector with the created VectorStore and the\n     * options provided.\n     * @param examples The list of examples to be used.\n     * @param embeddings The instance of Embeddings to be used.\n     * @param vectorStoreCls The VectorStore class to be used.\n     * @param options The options object for the SemanticSimilarityExampleSelector.\n     * @returns Promise that resolves with a new instance of SemanticSimilarityExampleSelector.\n     */\n    static async fromExamples(examples, embeddings, vectorStoreCls, options = {}) {\n        const inputKeys = options.inputKeys ?? null;\n        const stringExamples = examples.map((example) => sortedValues(inputKeys\n            ? inputKeys.reduce((acc, key) => ({ ...acc, [key]: example[key] }), {})\n            : example).join(\" \"));\n        const vectorStore = await vectorStoreCls.fromTexts(stringExamples, examples, // metadatas\n        embeddings, options);\n        return new SemanticSimilarityExampleSelector({\n            vectorStore,\n            k: options.k ?? 4,\n            exampleKeys: options.exampleKeys,\n            inputKeys: options.inputKeys,\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZXhhbXBsZV9zZWxlY3RvcnMvc2VtYW50aWNfc2ltaWxhcml0eS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0Q7QUFDSjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtCQUErQjtBQUN4QyxTQUFTLGdDQUFnQztBQUN6QyxTQUFTLHlDQUF5QztBQUNsRCxTQUFTLGtDQUFrQztBQUMzQyxTQUFTLGdDQUFnQztBQUN6QztBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQU07QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNLFdBQVcsT0FBTztBQUN4QztBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQSxJQUFJO0FBQ0osNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBO0FBQ08sZ0RBQWdELHlEQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDZCQUE2QixLQUFLO0FBQy9HO0FBQ0EsZ0JBQWdCLDREQUFRO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxvQ0FBb0MsS0FBSztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRiw2QkFBNkIsS0FBSztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSxnREFBZ0QsNkJBQTZCLEtBQUs7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGV4YW1wbGVfc2VsZWN0b3JzXFxzZW1hbnRpY19zaW1pbGFyaXR5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERvY3VtZW50IH0gZnJvbSBcIi4uL2RvY3VtZW50cy9kb2N1bWVudC5qc1wiO1xuaW1wb3J0IHsgQmFzZUV4YW1wbGVTZWxlY3RvciB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmZ1bmN0aW9uIHNvcnRlZFZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWVzKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5tYXAoKGtleSkgPT4gdmFsdWVzW2tleV0pO1xufVxuLyoqXG4gKiBDbGFzcyB0aGF0IHNlbGVjdHMgZXhhbXBsZXMgYmFzZWQgb24gc2VtYW50aWMgc2ltaWxhcml0eS4gSXQgZXh0ZW5kc1xuICogdGhlIEJhc2VFeGFtcGxlU2VsZWN0b3IgY2xhc3MuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgZXhhbXBsZVNlbGVjdG9yID0gYXdhaXQgU2VtYW50aWNTaW1pbGFyaXR5RXhhbXBsZVNlbGVjdG9yLmZyb21FeGFtcGxlcyhcbiAqICAgW1xuICogICAgIHsgaW5wdXQ6IFwiaGFwcHlcIiwgb3V0cHV0OiBcInNhZFwiIH0sXG4gKiAgICAgeyBpbnB1dDogXCJ0YWxsXCIsIG91dHB1dDogXCJzaG9ydFwiIH0sXG4gKiAgICAgeyBpbnB1dDogXCJlbmVyZ2V0aWNcIiwgb3V0cHV0OiBcImxldGhhcmdpY1wiIH0sXG4gKiAgICAgeyBpbnB1dDogXCJzdW5ueVwiLCBvdXRwdXQ6IFwiZ2xvb215XCIgfSxcbiAqICAgICB7IGlucHV0OiBcIndpbmR5XCIsIG91dHB1dDogXCJjYWxtXCIgfSxcbiAqICAgXSxcbiAqICAgbmV3IE9wZW5BSUVtYmVkZGluZ3MoKSxcbiAqICAgSE5TV0xpYixcbiAqICAgeyBrOiAxIH0sXG4gKiApO1xuICogY29uc3QgZHluYW1pY1Byb21wdCA9IG5ldyBGZXdTaG90UHJvbXB0VGVtcGxhdGUoe1xuICogICBleGFtcGxlU2VsZWN0b3IsXG4gKiAgIGV4YW1wbGVQcm9tcHQ6IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcbiAqICAgICBcIklucHV0OiB7aW5wdXR9XFxuT3V0cHV0OiB7b3V0cHV0fVwiLFxuICogICApLFxuICogICBwcmVmaXg6IFwiR2l2ZSB0aGUgYW50b255bSBvZiBldmVyeSBpbnB1dFwiLFxuICogICBzdWZmaXg6IFwiSW5wdXQ6IHthZGplY3RpdmV9XFxuT3V0cHV0OlwiLFxuICogICBpbnB1dFZhcmlhYmxlczogW1wiYWRqZWN0aXZlXCJdLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhhd2FpdCBkeW5hbWljUHJvbXB0LmZvcm1hdCh7IGFkamVjdGl2ZTogXCJyYWlueVwiIH0pKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2VtYW50aWNTaW1pbGFyaXR5RXhhbXBsZVNlbGVjdG9yIGV4dGVuZHMgQmFzZUV4YW1wbGVTZWxlY3RvciB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcihkYXRhKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVjdG9yU3RvcmVSZXRyaWV2ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhhbXBsZUtleXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRLZXlzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXhhbXBsZUtleXMgPSBkYXRhLmV4YW1wbGVLZXlzO1xuICAgICAgICB0aGlzLmlucHV0S2V5cyA9IGRhdGEuaW5wdXRLZXlzO1xuICAgICAgICBpZiAoZGF0YS52ZWN0b3JTdG9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZlY3RvclN0b3JlUmV0cmlldmVyID0gZGF0YS52ZWN0b3JTdG9yZS5hc1JldHJpZXZlcih7XG4gICAgICAgICAgICAgICAgazogZGF0YS5rID8/IDQsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBkYXRhLmZpbHRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEudmVjdG9yU3RvcmVSZXRyaWV2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudmVjdG9yU3RvcmVSZXRyaWV2ZXIgPSBkYXRhLnZlY3RvclN0b3JlUmV0cmlldmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBzcGVjaWZ5IG9uZSBvZiBcInZlY3RvclN0b3JlXCIgYW5kIFwidmVjdG9yU3RvcmVSZXRyaWV2ZXJcIi5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBhZGRzIGEgbmV3IGV4YW1wbGUgdG8gdGhlIHZlY3RvclN0b3JlLiBUaGUgZXhhbXBsZSBpc1xuICAgICAqIGNvbnZlcnRlZCB0byBhIHN0cmluZyBhbmQgYWRkZWQgdG8gdGhlIHZlY3RvclN0b3JlIGFzIGEgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIGV4YW1wbGUgVGhlIGV4YW1wbGUgdG8gYmUgYWRkZWQgdG8gdGhlIHZlY3RvclN0b3JlLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBleGFtcGxlIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB2ZWN0b3JTdG9yZS5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRFeGFtcGxlKGV4YW1wbGUpIHtcbiAgICAgICAgY29uc3QgaW5wdXRLZXlzID0gdGhpcy5pbnB1dEtleXMgPz8gT2JqZWN0LmtleXMoZXhhbXBsZSk7XG4gICAgICAgIGNvbnN0IHN0cmluZ0V4YW1wbGUgPSBzb3J0ZWRWYWx1ZXMoaW5wdXRLZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IGV4YW1wbGVba2V5XSB9KSwge30pKS5qb2luKFwiIFwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy52ZWN0b3JTdG9yZVJldHJpZXZlci5hZGREb2N1bWVudHMoW1xuICAgICAgICAgICAgbmV3IERvY3VtZW50KHtcbiAgICAgICAgICAgICAgICBwYWdlQ29udGVudDogc3RyaW5nRXhhbXBsZSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogZXhhbXBsZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgc2VsZWN0cyB3aGljaCBleGFtcGxlcyB0byB1c2UgYmFzZWQgb24gc2VtYW50aWMgc2ltaWxhcml0eS5cbiAgICAgKiBJdCBwZXJmb3JtcyBhIHNpbWlsYXJpdHkgc2VhcmNoIGluIHRoZSB2ZWN0b3JTdG9yZSB1c2luZyB0aGUgaW5wdXRcbiAgICAgKiB2YXJpYWJsZXMgYW5kIHJldHVybnMgdGhlIGV4YW1wbGVzIHdpdGggdGhlIGhpZ2hlc3Qgc2ltaWxhcml0eS5cbiAgICAgKiBAcGFyYW0gaW5wdXRWYXJpYWJsZXMgVGhlIGlucHV0IHZhcmlhYmxlcyB1c2VkIGZvciB0aGUgc2ltaWxhcml0eSBzZWFyY2guXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgdGhlIHNlbGVjdGVkIGV4YW1wbGVzLlxuICAgICAqL1xuICAgIGFzeW5jIHNlbGVjdEV4YW1wbGVzKGlucHV0VmFyaWFibGVzKSB7XG4gICAgICAgIGNvbnN0IGlucHV0S2V5cyA9IHRoaXMuaW5wdXRLZXlzID8/IE9iamVjdC5rZXlzKGlucHV0VmFyaWFibGVzKTtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBzb3J0ZWRWYWx1ZXMoaW5wdXRLZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IGlucHV0VmFyaWFibGVzW2tleV0gfSksIHt9KSkuam9pbihcIiBcIik7XG4gICAgICAgIGNvbnN0IGV4YW1wbGVEb2NzID0gYXdhaXQgdGhpcy52ZWN0b3JTdG9yZVJldHJpZXZlci5pbnZva2UocXVlcnkpO1xuICAgICAgICBjb25zdCBleGFtcGxlcyA9IGV4YW1wbGVEb2NzLm1hcCgoZG9jKSA9PiBkb2MubWV0YWRhdGEpO1xuICAgICAgICBpZiAodGhpcy5leGFtcGxlS2V5cykge1xuICAgICAgICAgICAgLy8gSWYgZXhhbXBsZSBrZXlzIGFyZSBwcm92aWRlZCwgZmlsdGVyIGV4YW1wbGVzIHRvIHRob3NlIGtleXMuXG4gICAgICAgICAgICByZXR1cm4gZXhhbXBsZXMubWFwKChleGFtcGxlKSA9PiB0aGlzLmV4YW1wbGVLZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IGV4YW1wbGVba2V5XSB9KSwge30pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhhbXBsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QgdGhhdCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mXG4gICAgICogU2VtYW50aWNTaW1pbGFyaXR5RXhhbXBsZVNlbGVjdG9yLiBJdCB0YWtlcyBhIGxpc3Qgb2YgZXhhbXBsZXMsIGFuXG4gICAgICogaW5zdGFuY2Ugb2YgRW1iZWRkaW5ncywgYSBWZWN0b3JTdG9yZSBjbGFzcywgYW5kIGFuIG9wdGlvbnMgb2JqZWN0IGFzXG4gICAgICogcGFyYW1ldGVycy4gSXQgY29udmVydHMgdGhlIGV4YW1wbGVzIHRvIHN0cmluZ3MsIGNyZWF0ZXMgYSBWZWN0b3JTdG9yZVxuICAgICAqIGZyb20gdGhlIHN0cmluZ3MgYW5kIHRoZSBlbWJlZGRpbmdzLCBhbmQgcmV0dXJucyBhIG5ld1xuICAgICAqIFNlbWFudGljU2ltaWxhcml0eUV4YW1wbGVTZWxlY3RvciB3aXRoIHRoZSBjcmVhdGVkIFZlY3RvclN0b3JlIGFuZCB0aGVcbiAgICAgKiBvcHRpb25zIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBleGFtcGxlcyBUaGUgbGlzdCBvZiBleGFtcGxlcyB0byBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSBlbWJlZGRpbmdzIFRoZSBpbnN0YW5jZSBvZiBFbWJlZGRpbmdzIHRvIGJlIHVzZWQuXG4gICAgICogQHBhcmFtIHZlY3RvclN0b3JlQ2xzIFRoZSBWZWN0b3JTdG9yZSBjbGFzcyB0byBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIG9iamVjdCBmb3IgdGhlIFNlbWFudGljU2ltaWxhcml0eUV4YW1wbGVTZWxlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIG5ldyBpbnN0YW5jZSBvZiBTZW1hbnRpY1NpbWlsYXJpdHlFeGFtcGxlU2VsZWN0b3IuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21FeGFtcGxlcyhleGFtcGxlcywgZW1iZWRkaW5ncywgdmVjdG9yU3RvcmVDbHMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBpbnB1dEtleXMgPSBvcHRpb25zLmlucHV0S2V5cyA/PyBudWxsO1xuICAgICAgICBjb25zdCBzdHJpbmdFeGFtcGxlcyA9IGV4YW1wbGVzLm1hcCgoZXhhbXBsZSkgPT4gc29ydGVkVmFsdWVzKGlucHV0S2V5c1xuICAgICAgICAgICAgPyBpbnB1dEtleXMucmVkdWNlKChhY2MsIGtleSkgPT4gKHsgLi4uYWNjLCBba2V5XTogZXhhbXBsZVtrZXldIH0pLCB7fSlcbiAgICAgICAgICAgIDogZXhhbXBsZSkuam9pbihcIiBcIikpO1xuICAgICAgICBjb25zdCB2ZWN0b3JTdG9yZSA9IGF3YWl0IHZlY3RvclN0b3JlQ2xzLmZyb21UZXh0cyhzdHJpbmdFeGFtcGxlcywgZXhhbXBsZXMsIC8vIG1ldGFkYXRhc1xuICAgICAgICBlbWJlZGRpbmdzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZW1hbnRpY1NpbWlsYXJpdHlFeGFtcGxlU2VsZWN0b3Ioe1xuICAgICAgICAgICAgdmVjdG9yU3RvcmUsXG4gICAgICAgICAgICBrOiBvcHRpb25zLmsgPz8gNCxcbiAgICAgICAgICAgIGV4YW1wbGVLZXlzOiBvcHRpb25zLmV4YW1wbGVLZXlzLFxuICAgICAgICAgICAgaW5wdXRLZXlzOiBvcHRpb25zLmlucHV0S2V5cyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/example_selectors/semantic_similarity.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/base.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/base.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseLangChain: () => (/* binding */ BaseLangChain),\n/* harmony export */   BaseLanguageModel: () => (/* binding */ BaseLanguageModel),\n/* harmony export */   calculateMaxTokens: () => (/* binding */ calculateMaxTokens),\n/* harmony export */   getEmbeddingContextSize: () => (/* binding */ getEmbeddingContextSize),\n/* harmony export */   getModelContextSize: () => (/* binding */ getModelContextSize),\n/* harmony export */   getModelNameForTiktoken: () => (/* binding */ getModelNameForTiktoken),\n/* harmony export */   isOpenAITool: () => (/* binding */ isOpenAITool)\n/* harmony export */ });\n/* harmony import */ var _caches_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../caches/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/caches/base.js\");\n/* harmony import */ var _prompt_values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../prompt_values.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.js\");\n/* harmony import */ var _messages_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../messages/utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/async_caller.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_tiktoken_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/tiktoken.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.js\");\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n\n\n\n\n\n\n// https://www.npmjs.com/package/js-tiktoken\nconst getModelNameForTiktoken = (modelName) => {\n    if (modelName.startsWith(\"gpt-3.5-turbo-16k\")) {\n        return \"gpt-3.5-turbo-16k\";\n    }\n    if (modelName.startsWith(\"gpt-3.5-turbo-\")) {\n        return \"gpt-3.5-turbo\";\n    }\n    if (modelName.startsWith(\"gpt-4-32k\")) {\n        return \"gpt-4-32k\";\n    }\n    if (modelName.startsWith(\"gpt-4-\")) {\n        return \"gpt-4\";\n    }\n    if (modelName.startsWith(\"gpt-4o\")) {\n        return \"gpt-4o\";\n    }\n    return modelName;\n};\nconst getEmbeddingContextSize = (modelName) => {\n    switch (modelName) {\n        case \"text-embedding-ada-002\":\n            return 8191;\n        default:\n            return 2046;\n    }\n};\nconst getModelContextSize = (modelName) => {\n    switch (getModelNameForTiktoken(modelName)) {\n        case \"gpt-3.5-turbo-16k\":\n            return 16384;\n        case \"gpt-3.5-turbo\":\n            return 4096;\n        case \"gpt-4-32k\":\n            return 32768;\n        case \"gpt-4\":\n            return 8192;\n        case \"text-davinci-003\":\n            return 4097;\n        case \"text-curie-001\":\n            return 2048;\n        case \"text-babbage-001\":\n            return 2048;\n        case \"text-ada-001\":\n            return 2048;\n        case \"code-davinci-002\":\n            return 8000;\n        case \"code-cushman-001\":\n            return 2048;\n        default:\n            return 4097;\n    }\n};\n/**\n * Whether or not the input matches the OpenAI tool definition.\n * @param {unknown} tool The input to check.\n * @returns {boolean} Whether the input is an OpenAI tool definition.\n */\nfunction isOpenAITool(tool) {\n    if (typeof tool !== \"object\" || !tool)\n        return false;\n    if (\"type\" in tool &&\n        tool.type === \"function\" &&\n        \"function\" in tool &&\n        typeof tool.function === \"object\" &&\n        tool.function &&\n        \"name\" in tool.function &&\n        \"parameters\" in tool.function) {\n        return true;\n    }\n    return false;\n}\nconst calculateMaxTokens = async ({ prompt, modelName, }) => {\n    let numTokens;\n    try {\n        numTokens = (await (0,_utils_tiktoken_js__WEBPACK_IMPORTED_MODULE_4__.encodingForModel)(getModelNameForTiktoken(modelName))).encode(prompt).length;\n    }\n    catch (error) {\n        console.warn(\"Failed to calculate number of tokens, falling back to approximate count\");\n        // fallback to approximate calculation if tiktoken is not available\n        // each token is ~4 characters: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them#\n        numTokens = Math.ceil(prompt.length / 4);\n    }\n    const maxTokens = getModelContextSize(modelName);\n    return maxTokens - numTokens;\n};\nconst getVerbosity = () => false;\n/**\n * Base class for language models, chains, tools.\n */\nclass BaseLangChain extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_5__.Runnable {\n    get lc_attributes() {\n        return {\n            callbacks: undefined,\n            verbose: undefined,\n        };\n    }\n    constructor(params) {\n        super(params);\n        /**\n         * Whether to print out response text.\n         */\n        Object.defineProperty(this, \"verbose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"callbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.verbose = params.verbose ?? getVerbosity();\n        this.callbacks = params.callbacks;\n        this.tags = params.tags ?? [];\n        this.metadata = params.metadata ?? {};\n    }\n}\n/**\n * Base class for language models.\n */\nclass BaseLanguageModel extends BaseLangChain {\n    /**\n     * Keys that the language model accepts as call options.\n     */\n    get callKeys() {\n        return [\"stop\", \"timeout\", \"signal\", \"tags\", \"metadata\", \"callbacks\"];\n    }\n    constructor({ callbacks, callbackManager, ...params }) {\n        const { cache, ...rest } = params;\n        super({\n            callbacks: callbacks ?? callbackManager,\n            ...rest,\n        });\n        /**\n         * The async caller should be used by subclasses to make any async calls,\n         * which will thus benefit from the concurrency and retry logic.\n         */\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_encoding\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof cache === \"object\") {\n            this.cache = cache;\n        }\n        else if (cache) {\n            this.cache = _caches_base_js__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache.global();\n        }\n        else {\n            this.cache = undefined;\n        }\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_3__.AsyncCaller(params ?? {});\n    }\n    /**\n     * Get the number of tokens in the content.\n     * @param content The content to get the number of tokens for.\n     * @returns The number of tokens in the content.\n     */\n    async getNumTokens(content) {\n        // Extract text content from MessageContent\n        let textContent;\n        if (typeof content === \"string\") {\n            textContent = content;\n        }\n        else {\n            /**\n             * Content is an array of MessageContentComplex\n             *\n             * ToDo(@christian-bromann): This is a temporary fix to get the number of tokens for the content.\n             * We need to find a better way to do this.\n             * @see https://github.com/langchain-ai/langchainjs/pull/8341#pullrequestreview-2933713116\n             */\n            textContent = content\n                .map((item) => {\n                if (typeof item === \"string\")\n                    return item;\n                if (item.type === \"text\" && \"text\" in item)\n                    return item.text;\n                return \"\";\n            })\n                .join(\"\");\n        }\n        // fallback to approximate calculation if tiktoken is not available\n        let numTokens = Math.ceil(textContent.length / 4);\n        if (!this._encoding) {\n            try {\n                this._encoding = await (0,_utils_tiktoken_js__WEBPACK_IMPORTED_MODULE_4__.encodingForModel)(\"modelName\" in this\n                    ? getModelNameForTiktoken(this.modelName)\n                    : \"gpt2\");\n            }\n            catch (error) {\n                console.warn(\"Failed to calculate number of tokens, falling back to approximate count\", error);\n            }\n        }\n        if (this._encoding) {\n            try {\n                numTokens = this._encoding.encode(textContent).length;\n            }\n            catch (error) {\n                console.warn(\"Failed to calculate number of tokens, falling back to approximate count\", error);\n            }\n        }\n        return numTokens;\n    }\n    static _convertInputToPromptValue(input) {\n        if (typeof input === \"string\") {\n            return new _prompt_values_js__WEBPACK_IMPORTED_MODULE_1__.StringPromptValue(input);\n        }\n        else if (Array.isArray(input)) {\n            return new _prompt_values_js__WEBPACK_IMPORTED_MODULE_1__.ChatPromptValue(input.map(_messages_utils_js__WEBPACK_IMPORTED_MODULE_2__.coerceMessageLikeToMessage));\n        }\n        else {\n            return input;\n        }\n    }\n    /**\n     * Get the identifying parameters of the LLM.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _identifyingParams() {\n        return {};\n    }\n    /**\n     * Create a unique cache key for a specific call to a specific language model.\n     * @param callOptions Call options for the model\n     * @returns A unique cache key.\n     */\n    _getSerializedCacheKeyParametersForCall(\n    // TODO: Fix when we remove the RunnableLambda backwards compatibility shim.\n    { config, ...callOptions }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const params = {\n            ...this._identifyingParams(),\n            ...callOptions,\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n        const filteredEntries = Object.entries(params).filter(([_, value]) => value !== undefined);\n        const serializedEntries = filteredEntries\n            .map(([key, value]) => `${key}:${JSON.stringify(value)}`)\n            .sort()\n            .join(\",\");\n        return serializedEntries;\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this._identifyingParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    /**\n     * @deprecated\n     * Load an LLM from a json-like object describing it.\n     */\n    static async deserialize(_data) {\n        throw new Error(\"Use .toJSON() instead\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRDtBQUN3QjtBQUNSO0FBQ1g7QUFDQztBQUNSO0FBQ2hEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvQ0FBb0Msb0JBQW9CO0FBQy9EO0FBQ0E7QUFDQSwyQkFBMkIsb0VBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsd0RBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUNBQXVDO0FBQ3pELGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMERBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0RBQVcsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9FQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnRUFBaUI7QUFDeEM7QUFDQTtBQUNBLHVCQUF1Qiw4REFBZSxXQUFXLDBFQUEwQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxJQUFJLEdBQUcsc0JBQXNCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbGFuZ3VhZ2VfbW9kZWxzXFxiYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluTWVtb3J5Q2FjaGUgfSBmcm9tIFwiLi4vY2FjaGVzL2Jhc2UuanNcIjtcbmltcG9ydCB7IFN0cmluZ1Byb21wdFZhbHVlLCBDaGF0UHJvbXB0VmFsdWUsIH0gZnJvbSBcIi4uL3Byb21wdF92YWx1ZXMuanNcIjtcbmltcG9ydCB7IGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuLi91dGlscy9hc3luY19jYWxsZXIuanNcIjtcbmltcG9ydCB7IGVuY29kaW5nRm9yTW9kZWwgfSBmcm9tIFwiLi4vdXRpbHMvdGlrdG9rZW4uanNcIjtcbmltcG9ydCB7IFJ1bm5hYmxlIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9iYXNlLmpzXCI7XG4vLyBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9qcy10aWt0b2tlblxuZXhwb3J0IGNvbnN0IGdldE1vZGVsTmFtZUZvclRpa3Rva2VuID0gKG1vZGVsTmFtZSkgPT4ge1xuICAgIGlmIChtb2RlbE5hbWUuc3RhcnRzV2l0aChcImdwdC0zLjUtdHVyYm8tMTZrXCIpKSB7XG4gICAgICAgIHJldHVybiBcImdwdC0zLjUtdHVyYm8tMTZrXCI7XG4gICAgfVxuICAgIGlmIChtb2RlbE5hbWUuc3RhcnRzV2l0aChcImdwdC0zLjUtdHVyYm8tXCIpKSB7XG4gICAgICAgIHJldHVybiBcImdwdC0zLjUtdHVyYm9cIjtcbiAgICB9XG4gICAgaWYgKG1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ3B0LTQtMzJrXCIpKSB7XG4gICAgICAgIHJldHVybiBcImdwdC00LTMya1wiO1xuICAgIH1cbiAgICBpZiAobW9kZWxOYW1lLnN0YXJ0c1dpdGgoXCJncHQtNC1cIikpIHtcbiAgICAgICAgcmV0dXJuIFwiZ3B0LTRcIjtcbiAgICB9XG4gICAgaWYgKG1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ3B0LTRvXCIpKSB7XG4gICAgICAgIHJldHVybiBcImdwdC00b1wiO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWxOYW1lO1xufTtcbmV4cG9ydCBjb25zdCBnZXRFbWJlZGRpbmdDb250ZXh0U2l6ZSA9IChtb2RlbE5hbWUpID0+IHtcbiAgICBzd2l0Y2ggKG1vZGVsTmFtZSkge1xuICAgICAgICBjYXNlIFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiOlxuICAgICAgICAgICAgcmV0dXJuIDgxOTE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMjA0NjtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGdldE1vZGVsQ29udGV4dFNpemUgPSAobW9kZWxOYW1lKSA9PiB7XG4gICAgc3dpdGNoIChnZXRNb2RlbE5hbWVGb3JUaWt0b2tlbihtb2RlbE5hbWUpKSB7XG4gICAgICAgIGNhc2UgXCJncHQtMy41LXR1cmJvLTE2a1wiOlxuICAgICAgICAgICAgcmV0dXJuIDE2Mzg0O1xuICAgICAgICBjYXNlIFwiZ3B0LTMuNS10dXJib1wiOlxuICAgICAgICAgICAgcmV0dXJuIDQwOTY7XG4gICAgICAgIGNhc2UgXCJncHQtNC0zMmtcIjpcbiAgICAgICAgICAgIHJldHVybiAzMjc2ODtcbiAgICAgICAgY2FzZSBcImdwdC00XCI6XG4gICAgICAgICAgICByZXR1cm4gODE5MjtcbiAgICAgICAgY2FzZSBcInRleHQtZGF2aW5jaS0wMDNcIjpcbiAgICAgICAgICAgIHJldHVybiA0MDk3O1xuICAgICAgICBjYXNlIFwidGV4dC1jdXJpZS0wMDFcIjpcbiAgICAgICAgICAgIHJldHVybiAyMDQ4O1xuICAgICAgICBjYXNlIFwidGV4dC1iYWJiYWdlLTAwMVwiOlxuICAgICAgICAgICAgcmV0dXJuIDIwNDg7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWFkYS0wMDFcIjpcbiAgICAgICAgICAgIHJldHVybiAyMDQ4O1xuICAgICAgICBjYXNlIFwiY29kZS1kYXZpbmNpLTAwMlwiOlxuICAgICAgICAgICAgcmV0dXJuIDgwMDA7XG4gICAgICAgIGNhc2UgXCJjb2RlLWN1c2htYW4tMDAxXCI6XG4gICAgICAgICAgICByZXR1cm4gMjA0ODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiA0MDk3O1xuICAgIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBtYXRjaGVzIHRoZSBPcGVuQUkgdG9vbCBkZWZpbml0aW9uLlxuICogQHBhcmFtIHt1bmtub3dufSB0b29sIFRoZSBpbnB1dCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBpbnB1dCBpcyBhbiBPcGVuQUkgdG9vbCBkZWZpbml0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPcGVuQUlUb29sKHRvb2wpIHtcbiAgICBpZiAodHlwZW9mIHRvb2wgIT09IFwib2JqZWN0XCIgfHwgIXRvb2wpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoXCJ0eXBlXCIgaW4gdG9vbCAmJlxuICAgICAgICB0b29sLnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgaW4gdG9vbCAmJlxuICAgICAgICB0eXBlb2YgdG9vbC5mdW5jdGlvbiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0b29sLmZ1bmN0aW9uICYmXG4gICAgICAgIFwibmFtZVwiIGluIHRvb2wuZnVuY3Rpb24gJiZcbiAgICAgICAgXCJwYXJhbWV0ZXJzXCIgaW4gdG9vbC5mdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZU1heFRva2VucyA9IGFzeW5jICh7IHByb21wdCwgbW9kZWxOYW1lLCB9KSA9PiB7XG4gICAgbGV0IG51bVRva2VucztcbiAgICB0cnkge1xuICAgICAgICBudW1Ub2tlbnMgPSAoYXdhaXQgZW5jb2RpbmdGb3JNb2RlbChnZXRNb2RlbE5hbWVGb3JUaWt0b2tlbihtb2RlbE5hbWUpKSkuZW5jb2RlKHByb21wdCkubGVuZ3RoO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNhbGN1bGF0ZSBudW1iZXIgb2YgdG9rZW5zLCBmYWxsaW5nIGJhY2sgdG8gYXBwcm94aW1hdGUgY291bnRcIik7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcHJveGltYXRlIGNhbGN1bGF0aW9uIGlmIHRpa3Rva2VuIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAgLy8gZWFjaCB0b2tlbiBpcyB+NCBjaGFyYWN0ZXJzOiBodHRwczovL2hlbHAub3BlbmFpLmNvbS9lbi9hcnRpY2xlcy80OTM2ODU2LXdoYXQtYXJlLXRva2Vucy1hbmQtaG93LXRvLWNvdW50LXRoZW0jXG4gICAgICAgIG51bVRva2VucyA9IE1hdGguY2VpbChwcm9tcHQubGVuZ3RoIC8gNCk7XG4gICAgfVxuICAgIGNvbnN0IG1heFRva2VucyA9IGdldE1vZGVsQ29udGV4dFNpemUobW9kZWxOYW1lKTtcbiAgICByZXR1cm4gbWF4VG9rZW5zIC0gbnVtVG9rZW5zO1xufTtcbmNvbnN0IGdldFZlcmJvc2l0eSA9ICgpID0+IGZhbHNlO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYW5ndWFnZSBtb2RlbHMsIGNoYWlucywgdG9vbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTGFuZ0NoYWluIGV4dGVuZHMgUnVubmFibGUge1xuICAgIGdldCBsY19hdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsbGJhY2tzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2ZXJib3NlOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBwcmludCBvdXQgcmVzcG9uc2UgdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcmJvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gcGFyYW1zLnZlcmJvc2UgPz8gZ2V0VmVyYm9zaXR5KCk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gcGFyYW1zLmNhbGxiYWNrcztcbiAgICAgICAgdGhpcy50YWdzID0gcGFyYW1zLnRhZ3MgPz8gW107XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBwYXJhbXMubWV0YWRhdGEgPz8ge307XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYW5ndWFnZSBtb2RlbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTGFuZ3VhZ2VNb2RlbCBleHRlbmRzIEJhc2VMYW5nQ2hhaW4ge1xuICAgIC8qKlxuICAgICAqIEtleXMgdGhhdCB0aGUgbGFuZ3VhZ2UgbW9kZWwgYWNjZXB0cyBhcyBjYWxsIG9wdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IGNhbGxLZXlzKCkge1xuICAgICAgICByZXR1cm4gW1wic3RvcFwiLCBcInRpbWVvdXRcIiwgXCJzaWduYWxcIiwgXCJ0YWdzXCIsIFwibWV0YWRhdGFcIiwgXCJjYWxsYmFja3NcIl07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgY2FsbGJhY2tzLCBjYWxsYmFja01hbmFnZXIsIC4uLnBhcmFtcyB9KSB7XG4gICAgICAgIGNvbnN0IHsgY2FjaGUsIC4uLnJlc3QgfSA9IHBhcmFtcztcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY2FsbGJhY2tzOiBjYWxsYmFja3MgPz8gY2FsbGJhY2tNYW5hZ2VyLFxuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXN5bmMgY2FsbGVyIHNob3VsZCBiZSB1c2VkIGJ5IHN1YmNsYXNzZXMgdG8gbWFrZSBhbnkgYXN5bmMgY2FsbHMsXG4gICAgICAgICAqIHdoaWNoIHdpbGwgdGh1cyBiZW5lZml0IGZyb20gdGhlIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWNoZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZW5jb2RpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWNoZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gSW5NZW1vcnlDYWNoZS5nbG9iYWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIocGFyYW1zID8/IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBjb250ZW50LlxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBjb250ZW50IHRvIGdldCB0aGUgbnVtYmVyIG9mIHRva2VucyBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TnVtVG9rZW5zKGNvbnRlbnQpIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0ZXh0IGNvbnRlbnQgZnJvbSBNZXNzYWdlQ29udGVudFxuICAgICAgICBsZXQgdGV4dENvbnRlbnQ7XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb250ZW50IGlzIGFuIGFycmF5IG9mIE1lc3NhZ2VDb250ZW50Q29tcGxleFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRvRG8oQGNocmlzdGlhbi1icm9tYW5uKTogVGhpcyBpcyBhIHRlbXBvcmFyeSBmaXggdG8gZ2V0IHRoZSBudW1iZXIgb2YgdG9rZW5zIGZvciB0aGUgY29udGVudC5cbiAgICAgICAgICAgICAqIFdlIG5lZWQgdG8gZmluZCBhIGJldHRlciB3YXkgdG8gZG8gdGhpcy5cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2xhbmdjaGFpbi1haS9sYW5nY2hhaW5qcy9wdWxsLzgzNDEjcHVsbHJlcXVlc3RyZXZpZXctMjkzMzcxMzExNlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0ZXh0Q29udGVudCA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50ZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsYmFjayB0byBhcHByb3hpbWF0ZSBjYWxjdWxhdGlvbiBpZiB0aWt0b2tlbiBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgIGxldCBudW1Ub2tlbnMgPSBNYXRoLmNlaWwodGV4dENvbnRlbnQubGVuZ3RoIC8gNCk7XG4gICAgICAgIGlmICghdGhpcy5fZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBhd2FpdCBlbmNvZGluZ0Zvck1vZGVsKFwibW9kZWxOYW1lXCIgaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICA/IGdldE1vZGVsTmFtZUZvclRpa3Rva2VuKHRoaXMubW9kZWxOYW1lKVxuICAgICAgICAgICAgICAgICAgICA6IFwiZ3B0MlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjYWxjdWxhdGUgbnVtYmVyIG9mIHRva2VucywgZmFsbGluZyBiYWNrIHRvIGFwcHJveGltYXRlIGNvdW50XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbnVtVG9rZW5zID0gdGhpcy5fZW5jb2RpbmcuZW5jb2RlKHRleHRDb250ZW50KS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY2FsY3VsYXRlIG51bWJlciBvZiB0b2tlbnMsIGZhbGxpbmcgYmFjayB0byBhcHByb3hpbWF0ZSBjb3VudFwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVRva2VucztcbiAgICB9XG4gICAgc3RhdGljIF9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nUHJvbXB0VmFsdWUoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYXRQcm9tcHRWYWx1ZShpbnB1dC5tYXAoY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkZW50aWZ5aW5nIHBhcmFtZXRlcnMgb2YgdGhlIExMTS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9pZGVudGlmeWluZ1BhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB1bmlxdWUgY2FjaGUga2V5IGZvciBhIHNwZWNpZmljIGNhbGwgdG8gYSBzcGVjaWZpYyBsYW5ndWFnZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0gY2FsbE9wdGlvbnMgQ2FsbCBvcHRpb25zIGZvciB0aGUgbW9kZWxcbiAgICAgKiBAcmV0dXJucyBBIHVuaXF1ZSBjYWNoZSBrZXkuXG4gICAgICovXG4gICAgX2dldFNlcmlhbGl6ZWRDYWNoZUtleVBhcmFtZXRlcnNGb3JDYWxsKFxuICAgIC8vIFRPRE86IEZpeCB3aGVuIHdlIHJlbW92ZSB0aGUgUnVubmFibGVMYW1iZGEgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgc2hpbS5cbiAgICB7IGNvbmZpZywgLi4uY2FsbE9wdGlvbnMgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLl9pZGVudGlmeWluZ1BhcmFtcygpLFxuICAgICAgICAgICAgLi4uY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICBfdHlwZTogdGhpcy5fbGxtVHlwZSgpLFxuICAgICAgICAgICAgX21vZGVsOiB0aGlzLl9tb2RlbFR5cGUoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocGFyYW1zKS5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkRW50cmllcyA9IGZpbHRlcmVkRW50cmllc1xuICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApXG4gICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAuam9pbihcIixcIik7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkRW50cmllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBSZXR1cm4gYSBqc29uLWxpa2Ugb2JqZWN0IHJlcHJlc2VudGluZyB0aGlzIExMTS5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLl9pZGVudGlmeWluZ1BhcmFtcygpLFxuICAgICAgICAgICAgX3R5cGU6IHRoaXMuX2xsbVR5cGUoKSxcbiAgICAgICAgICAgIF9tb2RlbDogdGhpcy5fbW9kZWxUeXBlKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogTG9hZCBhbiBMTE0gZnJvbSBhIGpzb24tbGlrZSBvYmplY3QgZGVzY3JpYmluZyBpdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoX2RhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIC50b0pTT04oKSBpbnN0ZWFkXCIpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/chat_models.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseChatModel: () => (/* binding */ BaseChatModel),\n/* harmony export */   SimpleChatModel: () => (/* binding */ SimpleChatModel),\n/* harmony export */   createChatMessageChunkEncoderStream: () => (/* binding */ createChatMessageChunkEncoderStream)\n/* harmony export */ });\n/* harmony import */ var _messages_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../messages/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.js\");\n/* harmony import */ var _outputs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../outputs.js */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.js\");\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../callbacks/manager.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _runnables_passthrough_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../runnables/passthrough.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.js\");\n/* harmony import */ var _utils_types_zod_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/types/zod.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.js\");\n/* harmony import */ var _callbacks_base_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../callbacks/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.js\");\n/* harmony import */ var _utils_json_schema_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/json_schema.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Creates a transform stream for encoding chat message chunks.\n * @deprecated Use {@link BytesOutputParser} instead\n * @returns A TransformStream instance that encodes chat message chunks.\n */\nfunction createChatMessageChunkEncoderStream() {\n    const textEncoder = new TextEncoder();\n    return new TransformStream({\n        transform(chunk, controller) {\n            controller.enqueue(textEncoder.encode(typeof chunk.content === \"string\"\n                ? chunk.content\n                : JSON.stringify(chunk.content)));\n        },\n    });\n}\nfunction _formatForTracing(messages) {\n    const messagesToTrace = [];\n    for (const message of messages) {\n        let messageToTrace = message;\n        if (Array.isArray(message.content)) {\n            for (let idx = 0; idx < message.content.length; idx++) {\n                const block = message.content[idx];\n                if ((0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isURLContentBlock)(block) || (0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isBase64ContentBlock)(block)) {\n                    if (messageToTrace === message) {\n                        // Also shallow-copy content\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        messageToTrace = new message.constructor({\n                            ...messageToTrace,\n                            content: [\n                                ...message.content.slice(0, idx),\n                                (0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.convertToOpenAIImageBlock)(block),\n                                ...message.content.slice(idx + 1),\n                            ],\n                        });\n                    }\n                }\n            }\n        }\n        messagesToTrace.push(messageToTrace);\n    }\n    return messagesToTrace;\n}\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nclass BaseChatModel extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseLanguageModel {\n    constructor(fields) {\n        super(fields);\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"chat_models\", this._llmType()]\n        });\n        Object.defineProperty(this, \"disableStreaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    _separateRunnableConfigFromCallOptionsCompat(options) {\n        // For backwards compat, keep `signal` in both runnableConfig and callOptions\n        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n        callOptions.signal = runnableConfig.signal;\n        return [runnableConfig, callOptions];\n    }\n    /**\n     * Invokes the chat model with a single input.\n     * @param input The input for the language model.\n     * @param options The call options.\n     * @returns A Promise that resolves to a BaseMessageChunk.\n     */\n    async invoke(input, options) {\n        const promptValue = BaseChatModel._convertInputToPromptValue(input);\n        const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n        const chatGeneration = result.generations[0][0];\n        // TODO: Remove cast after figuring out inheritance\n        return chatGeneration.message;\n    }\n    // eslint-disable-next-line require-yield\n    async *_streamResponseChunks(_messages, _options, _runManager) {\n        throw new Error(\"Not implemented.\");\n    }\n    async *_streamIterator(input, options) {\n        // Subclass check required to avoid double callbacks with default implementation\n        if (this._streamResponseChunks ===\n            BaseChatModel.prototype._streamResponseChunks ||\n            this.disableStreaming) {\n            yield this.invoke(input, options);\n        }\n        else {\n            const prompt = BaseChatModel._convertInputToPromptValue(input);\n            const messages = prompt.toChatMessages();\n            const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);\n            const inheritableMetadata = {\n                ...runnableConfig.metadata,\n                ...this.getLsParams(callOptions),\n            };\n            const callbackManager_ = await _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_3__.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: callOptions,\n                invocation_params: this?.invocationParams(callOptions),\n                batch_size: 1,\n            };\n            const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), [_formatForTracing(messages)], runnableConfig.runId, undefined, extra, undefined, undefined, runnableConfig.runName);\n            let generationChunk;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let llmOutput;\n            try {\n                for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers?.[0])) {\n                    if (chunk.message.id == null) {\n                        const runId = runManagers?.at(0)?.runId;\n                        if (runId != null)\n                            chunk.message._updateId(`run-${runId}`);\n                    }\n                    chunk.message.response_metadata = {\n                        ...chunk.generationInfo,\n                        ...chunk.message.response_metadata,\n                    };\n                    yield chunk.message;\n                    if (!generationChunk) {\n                        generationChunk = chunk;\n                    }\n                    else {\n                        generationChunk = generationChunk.concat(chunk);\n                    }\n                    if ((0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isAIMessageChunk)(chunk.message) &&\n                        chunk.message.usage_metadata !== undefined) {\n                        llmOutput = {\n                            tokenUsage: {\n                                promptTokens: chunk.message.usage_metadata.input_tokens,\n                                completionTokens: chunk.message.usage_metadata.output_tokens,\n                                totalTokens: chunk.message.usage_metadata.total_tokens,\n                            },\n                        };\n                    }\n                }\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                // TODO: Remove cast after figuring out inheritance\n                generations: [[generationChunk]],\n                llmOutput,\n            })));\n        }\n    }\n    getLsParams(options) {\n        const providerName = this.getName().startsWith(\"Chat\")\n            ? this.getName().replace(\"Chat\", \"\")\n            : this.getName();\n        return {\n            ls_model_type: \"chat\",\n            ls_stop: options.stop,\n            ls_provider: providerName,\n        };\n    }\n    /** @ignore */\n    async _generateUncached(messages, parsedOptions, handledOptions, startedRunManagers) {\n        const baseMessages = messages.map((messageList) => messageList.map(_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage));\n        let runManagers;\n        if (startedRunManagers !== undefined &&\n            startedRunManagers.length === baseMessages.length) {\n            runManagers = startedRunManagers;\n        }\n        else {\n            const inheritableMetadata = {\n                ...handledOptions.metadata,\n                ...this.getLsParams(parsedOptions),\n            };\n            // create callback manager and start run\n            const callbackManager_ = await _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_3__.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: parsedOptions,\n                invocation_params: this?.invocationParams(parsedOptions),\n                batch_size: 1,\n            };\n            runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, undefined, extra, undefined, undefined, handledOptions.runName);\n        }\n        const generations = [];\n        const llmOutputs = [];\n        // Even if stream is not explicitly called, check if model is implicitly\n        // called from streamEvents() or streamLog() to get all streamed events.\n        // Bail out if _streamResponseChunks not overridden\n        const hasStreamingHandler = !!runManagers?.[0].handlers.find(_callbacks_base_js__WEBPACK_IMPORTED_MODULE_8__.callbackHandlerPrefersStreaming);\n        if (hasStreamingHandler &&\n            !this.disableStreaming &&\n            baseMessages.length === 1 &&\n            this._streamResponseChunks !==\n                BaseChatModel.prototype._streamResponseChunks) {\n            try {\n                const stream = await this._streamResponseChunks(baseMessages[0], parsedOptions, runManagers?.[0]);\n                let aggregated;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let llmOutput;\n                for await (const chunk of stream) {\n                    if (chunk.message.id == null) {\n                        const runId = runManagers?.at(0)?.runId;\n                        if (runId != null)\n                            chunk.message._updateId(`run-${runId}`);\n                    }\n                    if (aggregated === undefined) {\n                        aggregated = chunk;\n                    }\n                    else {\n                        aggregated = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(aggregated, chunk);\n                    }\n                    if ((0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isAIMessageChunk)(chunk.message) &&\n                        chunk.message.usage_metadata !== undefined) {\n                        llmOutput = {\n                            tokenUsage: {\n                                promptTokens: chunk.message.usage_metadata.input_tokens,\n                                completionTokens: chunk.message.usage_metadata.output_tokens,\n                                totalTokens: chunk.message.usage_metadata.total_tokens,\n                            },\n                        };\n                    }\n                }\n                if (aggregated === undefined) {\n                    throw new Error(\"Received empty response from chat model call.\");\n                }\n                generations.push([aggregated]);\n                await runManagers?.[0].handleLLMEnd({\n                    generations,\n                    llmOutput,\n                });\n            }\n            catch (e) {\n                await runManagers?.[0].handleLLMError(e);\n                throw e;\n            }\n        }\n        else {\n            // generate results\n            const results = await Promise.allSettled(baseMessages.map((messageList, i) => this._generate(messageList, { ...parsedOptions, promptIndex: i }, runManagers?.[i])));\n            // handle results\n            await Promise.all(results.map(async (pResult, i) => {\n                if (pResult.status === \"fulfilled\") {\n                    const result = pResult.value;\n                    for (const generation of result.generations) {\n                        if (generation.message.id == null) {\n                            const runId = runManagers?.at(0)?.runId;\n                            if (runId != null)\n                                generation.message._updateId(`run-${runId}`);\n                        }\n                        generation.message.response_metadata = {\n                            ...generation.generationInfo,\n                            ...generation.message.response_metadata,\n                        };\n                    }\n                    if (result.generations.length === 1) {\n                        result.generations[0].message.response_metadata = {\n                            ...result.llmOutput,\n                            ...result.generations[0].message.response_metadata,\n                        };\n                    }\n                    generations[i] = result.generations;\n                    llmOutputs[i] = result.llmOutput;\n                    return runManagers?.[i]?.handleLLMEnd({\n                        generations: [result.generations],\n                        llmOutput: result.llmOutput,\n                    });\n                }\n                else {\n                    // status === \"rejected\"\n                    await runManagers?.[i]?.handleLLMError(pResult.reason);\n                    return Promise.reject(pResult.reason);\n                }\n            }));\n        }\n        // create combined output\n        const output = {\n            generations,\n            llmOutput: llmOutputs.length\n                ? this._combineLLMOutput?.(...llmOutputs)\n                : undefined,\n        };\n        Object.defineProperty(output, _outputs_js__WEBPACK_IMPORTED_MODULE_1__.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    async _generateCached({ messages, cache, llmStringKey, parsedOptions, handledOptions, }) {\n        const baseMessages = messages.map((messageList) => messageList.map(_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage));\n        const inheritableMetadata = {\n            ...handledOptions.metadata,\n            ...this.getLsParams(parsedOptions),\n        };\n        // create callback manager and start run\n        const callbackManager_ = await _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_3__.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: 1,\n        };\n        const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, undefined, extra, undefined, undefined, handledOptions.runName);\n        // generate results\n        const missingPromptIndices = [];\n        const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {\n            // Join all content into one string for the prompt index\n            const prompt = BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n            const result = await cache.lookup(prompt, llmStringKey);\n            if (result == null) {\n                missingPromptIndices.push(index);\n            }\n            return result;\n        }));\n        // Map run managers to the results before filtering out null results\n        // Null results are just absent from the cache.\n        const cachedResults = results\n            .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n            .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n            result.status === \"rejected\");\n        // Handle results and call run managers\n        const generations = [];\n        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n            if (promiseResult.status === \"fulfilled\") {\n                const result = promiseResult.value;\n                generations[i] = result.map((result) => {\n                    if (\"message\" in result &&\n                        (0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isBaseMessage)(result.message) &&\n                        (0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isAIMessage)(result.message)) {\n                        // eslint-disable-next-line no-param-reassign\n                        result.message.usage_metadata = {\n                            input_tokens: 0,\n                            output_tokens: 0,\n                            total_tokens: 0,\n                        };\n                    }\n                    // eslint-disable-next-line no-param-reassign\n                    result.generationInfo = {\n                        ...result.generationInfo,\n                        tokenUsage: {},\n                    };\n                    return result;\n                });\n                if (result.length) {\n                    await runManager?.handleLLMNewToken(result[0].text);\n                }\n                return runManager?.handleLLMEnd({\n                    generations: [result],\n                }, undefined, undefined, undefined, {\n                    cached: true,\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManager?.handleLLMError(promiseResult.reason, undefined, undefined, undefined, {\n                    cached: true,\n                });\n                return Promise.reject(promiseResult.reason);\n            }\n        }));\n        const output = {\n            generations,\n            missingPromptIndices,\n            startedRunManagers: runManagers,\n        };\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, _outputs_js__WEBPACK_IMPORTED_MODULE_1__.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    /**\n     * Generates chat based on the input messages.\n     * @param messages An array of arrays of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to an LLMResult.\n     */\n    async generate(messages, options, callbacks) {\n        // parse call options\n        let parsedOptions;\n        if (Array.isArray(options)) {\n            parsedOptions = { stop: options };\n        }\n        else {\n            parsedOptions = options;\n        }\n        const baseMessages = messages.map((messageList) => messageList.map(_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage));\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n        if (!this.cache) {\n            return this._generateUncached(baseMessages, callOptions, runnableConfig);\n        }\n        const { cache } = this;\n        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n        const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({\n            messages: baseMessages,\n            cache,\n            llmStringKey,\n            parsedOptions: callOptions,\n            handledOptions: runnableConfig,\n        });\n        let llmOutput = {};\n        if (missingPromptIndices.length > 0) {\n            const results = await this._generateUncached(missingPromptIndices.map((i) => baseMessages[i]), callOptions, runnableConfig, startedRunManagers !== undefined\n                ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n                : undefined);\n            await Promise.all(results.generations.map(async (generation, index) => {\n                const promptIndex = missingPromptIndices[index];\n                generations[promptIndex] = generation;\n                // Join all content into one string for the prompt index\n                const prompt = BaseChatModel._convertInputToPromptValue(baseMessages[promptIndex]).toString();\n                return cache.update(prompt, llmStringKey, generation);\n            }));\n            llmOutput = results.llmOutput ?? {};\n        }\n        return { generations, llmOutput };\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    invocationParams(_options) {\n        return {};\n    }\n    _modelType() {\n        return \"base_chat_model\";\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this.invocationParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    /**\n     * Generates a prompt based on the input prompt values.\n     * @param promptValues An array of BasePromptValue instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to an LLMResult.\n     */\n    async generatePrompt(promptValues, options, callbacks) {\n        const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());\n        return this.generate(promptMessages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Makes a single call to the chat model.\n     * @param messages An array of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async call(messages, options, callbacks) {\n        const result = await this.generate([messages.map(_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage)], options, callbacks);\n        const generations = result.generations;\n        return generations[0][0].message;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Makes a single call to the chat model with a prompt value.\n     * @param promptValue The value of the prompt.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async callPrompt(promptValue, options, callbacks) {\n        const promptMessages = promptValue.toChatMessages();\n        return this.call(promptMessages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Predicts the next message based on the input messages.\n     * @param messages An array of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async predictMessages(messages, options, callbacks) {\n        return this.call(messages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Predicts the next message based on a text input.\n     * @param text The text input.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a string.\n     */\n    async predict(text, options, callbacks) {\n        const message = new _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.HumanMessage(text);\n        const result = await this.call([message], options, callbacks);\n        if (typeof result.content !== \"string\") {\n            throw new Error(\"Cannot use predict when output is not a string.\");\n        }\n        return result.content;\n    }\n    withStructuredOutput(outputSchema, config) {\n        if (typeof this.bindTools !== \"function\") {\n            throw new Error(`Chat model must implement \".bindTools()\" to use withStructuredOutput.`);\n        }\n        if (config?.strict) {\n            throw new Error(`\"strict\" mode is not supported for this model by default.`);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const schema = outputSchema;\n        const name = config?.name;\n        const description = (0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_7__.getSchemaDescription)(schema) ?? \"A function available to call.\";\n        const method = config?.method;\n        const includeRaw = config?.includeRaw;\n        if (method === \"jsonMode\") {\n            throw new Error(`Base withStructuredOutput implementation only supports \"functionCalling\" as a method.`);\n        }\n        let functionName = name ?? \"extract\";\n        let tools;\n        if ((0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_7__.isInteropZodSchema)(schema)) {\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: (0,_utils_json_schema_js__WEBPACK_IMPORTED_MODULE_9__.toJsonSchema)(schema),\n                    },\n                },\n            ];\n        }\n        else {\n            if (\"name\" in schema) {\n                functionName = schema.name;\n            }\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: schema,\n                    },\n                },\n            ];\n        }\n        const llm = this.bindTools(tools);\n        const outputParser = _runnables_base_js__WEBPACK_IMPORTED_MODULE_4__.RunnableLambda.from((input) => {\n            if (!input.tool_calls || input.tool_calls.length === 0) {\n                throw new Error(\"No tool calls found in the response.\");\n            }\n            const toolCall = input.tool_calls.find((tc) => tc.name === functionName);\n            if (!toolCall) {\n                throw new Error(`No tool call found with name ${functionName}.`);\n            }\n            return toolCall.args;\n        });\n        if (!includeRaw) {\n            return llm.pipe(outputParser).withConfig({\n                runName: \"StructuredOutput\",\n            });\n        }\n        const parserAssign = _runnables_passthrough_js__WEBPACK_IMPORTED_MODULE_6__.RunnablePassthrough.assign({\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parsed: (input, config) => outputParser.invoke(input.raw, config),\n        });\n        const parserNone = _runnables_passthrough_js__WEBPACK_IMPORTED_MODULE_6__.RunnablePassthrough.assign({\n            parsed: () => null,\n        });\n        const parsedWithFallback = parserAssign.withFallbacks({\n            fallbacks: [parserNone],\n        });\n        return _runnables_base_js__WEBPACK_IMPORTED_MODULE_4__.RunnableSequence.from([\n            {\n                raw: llm,\n            },\n            parsedWithFallback,\n        ]).withConfig({\n            runName: \"StructuredOutputRunnable\",\n        });\n    }\n}\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nclass SimpleChatModel extends BaseChatModel {\n    async _generate(messages, options, runManager) {\n        const text = await this._call(messages, options, runManager);\n        const message = new _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.AIMessage(text);\n        if (typeof message.content !== \"string\") {\n            throw new Error(\"Cannot generate with a simple chat model when output is not a string.\");\n        }\n        return {\n            generations: [\n                {\n                    text: message.content,\n                    message,\n                },\n            ],\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOE07QUFDcks7QUFDTTtBQUNZO0FBQ2M7QUFDN0I7QUFDc0I7QUFDZ0I7QUFDWDtBQUNoQjtBQUN2RDtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQSxvQkFBb0IscUVBQWlCLFdBQVcsd0VBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZFQUF5QjtBQUN6RDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDRCQUE0Qix1REFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrRUFBZSwySEFBMkgsdUJBQXVCO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsTUFBTTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0VBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSwwRUFBMEI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrRUFBZSwySEFBMkgsdUJBQXVCO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSwrRUFBK0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0RBQU07QUFDM0M7QUFDQSx3QkFBd0Isb0VBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILGtDQUFrQztBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnREFBTztBQUM3QztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStEO0FBQzNGLDJFQUEyRSwwRUFBMEI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrRUFBZSwySEFBMkgsdUJBQXVCO0FBQ3hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQ0FBMEM7QUFDakYsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1DQUFtQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpRUFBYTtBQUNyQyx3QkFBd0IsK0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdEQUFPO0FBQzdDO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsMEVBQTBCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMEVBQTBCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNERBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUVBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1RUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1FQUFZO0FBQ2hELHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4REFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkIsMEVBQW1CO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCLDBFQUFtQjtBQUM5QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsZ0VBQWdCO0FBQy9CO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDRCQUE0Qix5REFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGxhbmd1YWdlX21vZGVsc1xcY2hhdF9tb2RlbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQUlNZXNzYWdlLCBIdW1hbk1lc3NhZ2UsIGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlLCBpc0FJTWVzc2FnZUNodW5rLCBpc0Jhc2VNZXNzYWdlLCBpc0FJTWVzc2FnZSwgY29udmVydFRvT3BlbkFJSW1hZ2VCbG9jaywgaXNVUkxDb250ZW50QmxvY2ssIGlzQmFzZTY0Q29udGVudEJsb2NrLCB9IGZyb20gXCIuLi9tZXNzYWdlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUlVOX0tFWSwgfSBmcm9tIFwiLi4vb3V0cHV0cy5qc1wiO1xuaW1wb3J0IHsgQmFzZUxhbmd1YWdlTW9kZWwsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgQ2FsbGJhY2tNYW5hZ2VyLCB9IGZyb20gXCIuLi9jYWxsYmFja3MvbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgUnVubmFibGVMYW1iZGEsIFJ1bm5hYmxlU2VxdWVuY2UsIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBjb25jYXQgfSBmcm9tIFwiLi4vdXRpbHMvc3RyZWFtLmpzXCI7XG5pbXBvcnQgeyBSdW5uYWJsZVBhc3N0aHJvdWdoIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9wYXNzdGhyb3VnaC5qc1wiO1xuaW1wb3J0IHsgZ2V0U2NoZW1hRGVzY3JpcHRpb24sIGlzSW50ZXJvcFpvZFNjaGVtYSwgfSBmcm9tIFwiLi4vdXRpbHMvdHlwZXMvem9kLmpzXCI7XG5pbXBvcnQgeyBjYWxsYmFja0hhbmRsZXJQcmVmZXJzU3RyZWFtaW5nIH0gZnJvbSBcIi4uL2NhbGxiYWNrcy9iYXNlLmpzXCI7XG5pbXBvcnQgeyB0b0pzb25TY2hlbWEgfSBmcm9tIFwiLi4vdXRpbHMvanNvbl9zY2hlbWEuanNcIjtcbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBzdHJlYW0gZm9yIGVuY29kaW5nIGNoYXQgbWVzc2FnZSBjaHVua3MuXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIEJ5dGVzT3V0cHV0UGFyc2VyfSBpbnN0ZWFkXG4gKiBAcmV0dXJucyBBIFRyYW5zZm9ybVN0cmVhbSBpbnN0YW5jZSB0aGF0IGVuY29kZXMgY2hhdCBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNoYXRNZXNzYWdlQ2h1bmtFbmNvZGVyU3RyZWFtKCkge1xuICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUodHlwZW9mIGNodW5rLmNvbnRlbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGNodW5rLmNvbnRlbnRcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGNodW5rLmNvbnRlbnQpKSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBfZm9ybWF0Rm9yVHJhY2luZyhtZXNzYWdlcykge1xuICAgIGNvbnN0IG1lc3NhZ2VzVG9UcmFjZSA9IFtdO1xuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICBsZXQgbWVzc2FnZVRvVHJhY2UgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBtZXNzYWdlLmNvbnRlbnQubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gbWVzc2FnZS5jb250ZW50W2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKGlzVVJMQ29udGVudEJsb2NrKGJsb2NrKSB8fCBpc0Jhc2U2NENvbnRlbnRCbG9jayhibG9jaykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VUb1RyYWNlID09PSBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIHNoYWxsb3ctY29weSBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVRvVHJhY2UgPSBuZXcgbWVzc2FnZS5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZVRvVHJhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tZXNzYWdlLmNvbnRlbnQuc2xpY2UoMCwgaWR4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydFRvT3BlbkFJSW1hZ2VCbG9jayhibG9jayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2UuY29udGVudC5zbGljZShpZHggKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZXNUb1RyYWNlLnB1c2gobWVzc2FnZVRvVHJhY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXNUb1RyYWNlO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBjaGF0IG1vZGVscy4gSXQgZXh0ZW5kcyB0aGUgQmFzZUxhbmd1YWdlTW9kZWwgY2xhc3MgYW5kXG4gKiBwcm92aWRlcyBtZXRob2RzIGZvciBnZW5lcmF0aW5nIGNoYXQgYmFzZWQgb24gaW5wdXQgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlQ2hhdE1vZGVsIGV4dGVuZHMgQmFzZUxhbmd1YWdlTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICAvLyBPbmx5IGV2ZXIgaW5zdGFudGlhdGVkIGluIG1haW4gTGFuZ0NoYWluXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwiY2hhdF9tb2RlbHNcIiwgdGhpcy5fbGxtVHlwZSgpXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlzYWJsZVN0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zQ29tcGF0KG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQsIGtlZXAgYHNpZ25hbGAgaW4gYm90aCBydW5uYWJsZUNvbmZpZyBhbmQgY2FsbE9wdGlvbnNcbiAgICAgICAgY29uc3QgW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc10gPSBzdXBlci5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY2FsbE9wdGlvbnMuc2lnbmFsID0gcnVubmFibGVDb25maWcuc2lnbmFsO1xuICAgICAgICByZXR1cm4gW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGNoYXQgbW9kZWwgd2l0aCBhIHNpbmdsZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNhbGwgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEJhc2VNZXNzYWdlQ2h1bmsuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb21wdFZhbHVlID0gQmFzZUNoYXRNb2RlbC5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVQcm9tcHQoW3Byb21wdFZhbHVlXSwgb3B0aW9ucywgb3B0aW9ucz8uY2FsbGJhY2tzKTtcbiAgICAgICAgY29uc3QgY2hhdEdlbmVyYXRpb24gPSByZXN1bHQuZ2VuZXJhdGlvbnNbMF1bMF07XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBjYXN0IGFmdGVyIGZpZ3VyaW5nIG91dCBpbmhlcml0YW5jZVxuICAgICAgICByZXR1cm4gY2hhdEdlbmVyYXRpb24ubWVzc2FnZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUteWllbGRcbiAgICBhc3luYyAqX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKF9tZXNzYWdlcywgX29wdGlvbnMsIF9ydW5NYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gU3ViY2xhc3MgY2hlY2sgcmVxdWlyZWQgdG8gYXZvaWQgZG91YmxlIGNhbGxiYWNrcyB3aXRoIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzID09PVxuICAgICAgICAgICAgQmFzZUNoYXRNb2RlbC5wcm90b3R5cGUuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzIHx8XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuaW52b2tlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21wdCA9IEJhc2VDaGF0TW9kZWwuX2NvbnZlcnRJbnB1dFRvUHJvbXB0VmFsdWUoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBwcm9tcHQudG9DaGF0TWVzc2FnZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgLi4ucnVubmFibGVDb25maWcubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5nZXRMc1BhcmFtcyhjYWxsT3B0aW9ucyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IENhbGxiYWNrTWFuYWdlci5jb25maWd1cmUocnVubmFibGVDb25maWcuY2FsbGJhY2tzLCB0aGlzLmNhbGxiYWNrcywgcnVubmFibGVDb25maWcudGFncywgdGhpcy50YWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKGNhbGxPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhdE1vZGVsU3RhcnQodGhpcy50b0pTT04oKSwgW19mb3JtYXRGb3JUcmFjaW5nKG1lc3NhZ2VzKV0sIHJ1bm5hYmxlQ29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcnVubmFibGVDb25maWcucnVuTmFtZSk7XG4gICAgICAgICAgICBsZXQgZ2VuZXJhdGlvbkNodW5rO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGxldCBsbG1PdXRwdXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MobWVzc2FnZXMsIGNhbGxPcHRpb25zLCBydW5NYW5hZ2Vycz8uWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsubWVzc2FnZS5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydW5JZCA9IHJ1bk1hbmFnZXJzPy5hdCgwKT8ucnVuSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVuSWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5tZXNzYWdlLl91cGRhdGVJZChgcnVuLSR7cnVuSWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2h1bmsubWVzc2FnZS5yZXNwb25zZV9tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNodW5rLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2h1bmsubWVzc2FnZS5yZXNwb25zZV9tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgY2h1bmsubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnZW5lcmF0aW9uQ2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25DaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkNodW5rID0gZ2VuZXJhdGlvbkNodW5rLmNvbmNhdChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQUlNZXNzYWdlQ2h1bmsoY2h1bmsubWVzc2FnZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXNhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLmlucHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS5vdXRwdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS50b3RhbF90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoKHJ1bk1hbmFnZXJzID8/IFtdKS5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVycm9yKGVycikpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRW5kKHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgY2FzdCBhZnRlciBmaWd1cmluZyBvdXQgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW1tnZW5lcmF0aW9uQ2h1bmtdXSxcbiAgICAgICAgICAgICAgICBsbG1PdXRwdXQsXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldExzUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJOYW1lID0gdGhpcy5nZXROYW1lKCkuc3RhcnRzV2l0aChcIkNoYXRcIilcbiAgICAgICAgICAgID8gdGhpcy5nZXROYW1lKCkucmVwbGFjZShcIkNoYXRcIiwgXCJcIilcbiAgICAgICAgICAgIDogdGhpcy5nZXROYW1lKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsc19tb2RlbF90eXBlOiBcImNoYXRcIixcbiAgICAgICAgICAgIGxzX3N0b3A6IG9wdGlvbnMuc3RvcCxcbiAgICAgICAgICAgIGxzX3Byb3ZpZGVyOiBwcm92aWRlck5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaWdub3JlICovXG4gICAgYXN5bmMgX2dlbmVyYXRlVW5jYWNoZWQobWVzc2FnZXMsIHBhcnNlZE9wdGlvbnMsIGhhbmRsZWRPcHRpb25zLCBzdGFydGVkUnVuTWFuYWdlcnMpIHtcbiAgICAgICAgY29uc3QgYmFzZU1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlTGlzdCkgPT4gbWVzc2FnZUxpc3QubWFwKGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKSk7XG4gICAgICAgIGxldCBydW5NYW5hZ2VycztcbiAgICAgICAgaWYgKHN0YXJ0ZWRSdW5NYW5hZ2VycyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGFydGVkUnVuTWFuYWdlcnMubGVuZ3RoID09PSBiYXNlTWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBydW5NYW5hZ2VycyA9IHN0YXJ0ZWRSdW5NYW5hZ2VycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgLi4uaGFuZGxlZE9wdGlvbnMubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5nZXRMc1BhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBjcmVhdGUgY2FsbGJhY2sgbWFuYWdlciBhbmQgc3RhcnQgcnVuXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShoYW5kbGVkT3B0aW9ucy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBoYW5kbGVkT3B0aW9ucy50YWdzLCB0aGlzLnRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogcGFyc2VkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhdE1vZGVsU3RhcnQodGhpcy50b0pTT04oKSwgYmFzZU1lc3NhZ2VzLm1hcChfZm9ybWF0Rm9yVHJhY2luZyksIGhhbmRsZWRPcHRpb25zLnJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGFuZGxlZE9wdGlvbnMucnVuTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgbGxtT3V0cHV0cyA9IFtdO1xuICAgICAgICAvLyBFdmVuIGlmIHN0cmVhbSBpcyBub3QgZXhwbGljaXRseSBjYWxsZWQsIGNoZWNrIGlmIG1vZGVsIGlzIGltcGxpY2l0bHlcbiAgICAgICAgLy8gY2FsbGVkIGZyb20gc3RyZWFtRXZlbnRzKCkgb3Igc3RyZWFtTG9nKCkgdG8gZ2V0IGFsbCBzdHJlYW1lZCBldmVudHMuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIF9zdHJlYW1SZXNwb25zZUNodW5rcyBub3Qgb3ZlcnJpZGRlblxuICAgICAgICBjb25zdCBoYXNTdHJlYW1pbmdIYW5kbGVyID0gISFydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZXJzLmZpbmQoY2FsbGJhY2tIYW5kbGVyUHJlZmVyc1N0cmVhbWluZyk7XG4gICAgICAgIGlmIChoYXNTdHJlYW1pbmdIYW5kbGVyICYmXG4gICAgICAgICAgICAhdGhpcy5kaXNhYmxlU3RyZWFtaW5nICYmXG4gICAgICAgICAgICBiYXNlTWVzc2FnZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyAhPT1cbiAgICAgICAgICAgICAgICBCYXNlQ2hhdE1vZGVsLnByb3RvdHlwZS5fc3RyZWFtUmVzcG9uc2VDaHVua3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MoYmFzZU1lc3NhZ2VzWzBdLCBwYXJzZWRPcHRpb25zLCBydW5NYW5hZ2Vycz8uWzBdKTtcbiAgICAgICAgICAgICAgICBsZXQgYWdncmVnYXRlZDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGxldCBsbG1PdXRwdXQ7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2UuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVuSWQgPSBydW5NYW5hZ2Vycz8uYXQoMCk/LnJ1bklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bklkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsubWVzc2FnZS5fdXBkYXRlSWQoYHJ1bi0ke3J1bklkfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWQgPSBjb25jYXQoYWdncmVnYXRlZCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FJTWVzc2FnZUNodW5rKGNodW5rLm1lc3NhZ2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxsbU91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblVzYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS5pbnB1dF90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEub3V0cHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEudG90YWxfdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjZWl2ZWQgZW1wdHkgcmVzcG9uc2UgZnJvbSBjaGF0IG1vZGVsIGNhbGwuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9ucy5wdXNoKFthZ2dyZWdhdGVkXSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcnM/LlswXS5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZUxMTUVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSByZXN1bHRzXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGJhc2VNZXNzYWdlcy5tYXAoKG1lc3NhZ2VMaXN0LCBpKSA9PiB0aGlzLl9nZW5lcmF0ZShtZXNzYWdlTGlzdCwgeyAuLi5wYXJzZWRPcHRpb25zLCBwcm9tcHRJbmRleDogaSB9LCBydW5NYW5hZ2Vycz8uW2ldKSkpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIHJlc3VsdHNcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMubWFwKGFzeW5jIChwUmVzdWx0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBSZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZ2VuZXJhdGlvbiBvZiByZXN1bHQuZ2VuZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uLm1lc3NhZ2UuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bklkID0gcnVuTWFuYWdlcnM/LmF0KDApPy5ydW5JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVuSWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbi5tZXNzYWdlLl91cGRhdGVJZChgcnVuLSR7cnVuSWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZ2VuZXJhdGlvbi5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5nZW5lcmF0aW9uLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZ2VuZXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ2VuZXJhdGlvbnNbMF0ubWVzc2FnZS5yZXNwb25zZV9tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQubGxtT3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdC5nZW5lcmF0aW9uc1swXS5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uc1tpXSA9IHJlc3VsdC5nZW5lcmF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0c1tpXSA9IHJlc3VsdC5sbG1PdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5NYW5hZ2Vycz8uW2ldPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtyZXN1bHQuZ2VuZXJhdGlvbnNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0OiByZXN1bHQubGxtT3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXR1cyA9PT0gXCJyZWplY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXJzPy5baV0/LmhhbmRsZUxMTUVycm9yKHBSZXN1bHQucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHBSZXN1bHQucmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGNvbWJpbmVkIG91dHB1dFxuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICBnZW5lcmF0aW9ucyxcbiAgICAgICAgICAgIGxsbU91dHB1dDogbGxtT3V0cHV0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2NvbWJpbmVMTE1PdXRwdXQ/LiguLi5sbG1PdXRwdXRzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3V0cHV0LCBSVU5fS0VZLCB7XG4gICAgICAgICAgICB2YWx1ZTogcnVuTWFuYWdlcnNcbiAgICAgICAgICAgICAgICA/IHsgcnVuSWRzOiBydW5NYW5hZ2Vycz8ubWFwKChtYW5hZ2VyKSA9PiBtYW5hZ2VyLnJ1bklkKSB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBhc3luYyBfZ2VuZXJhdGVDYWNoZWQoeyBtZXNzYWdlcywgY2FjaGUsIGxsbVN0cmluZ0tleSwgcGFyc2VkT3B0aW9ucywgaGFuZGxlZE9wdGlvbnMsIH0pIHtcbiAgICAgICAgY29uc3QgYmFzZU1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlTGlzdCkgPT4gbWVzc2FnZUxpc3QubWFwKGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKSk7XG4gICAgICAgIGNvbnN0IGluaGVyaXRhYmxlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAuLi5oYW5kbGVkT3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0THNQYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgICAgIC8vIGNyZWF0ZSBjYWxsYmFjayBtYW5hZ2VyIGFuZCBzdGFydCBydW5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IENhbGxiYWNrTWFuYWdlci5jb25maWd1cmUoaGFuZGxlZE9wdGlvbnMuY2FsbGJhY2tzLCB0aGlzLmNhbGxiYWNrcywgaGFuZGxlZE9wdGlvbnMudGFncywgdGhpcy50YWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgY29uc3QgZXh0cmEgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiBwYXJzZWRPcHRpb25zLFxuICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYXRNb2RlbFN0YXJ0KHRoaXMudG9KU09OKCksIGJhc2VNZXNzYWdlcy5tYXAoX2Zvcm1hdEZvclRyYWNpbmcpLCBoYW5kbGVkT3B0aW9ucy5ydW5JZCwgdW5kZWZpbmVkLCBleHRyYSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhhbmRsZWRPcHRpb25zLnJ1bk5hbWUpO1xuICAgICAgICAvLyBnZW5lcmF0ZSByZXN1bHRzXG4gICAgICAgIGNvbnN0IG1pc3NpbmdQcm9tcHRJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYmFzZU1lc3NhZ2VzLm1hcChhc3luYyAoYmFzZU1lc3NhZ2UsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBKb2luIGFsbCBjb250ZW50IGludG8gb25lIHN0cmluZyBmb3IgdGhlIHByb21wdCBpbmRleFxuICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gQmFzZUNoYXRNb2RlbC5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShiYXNlTWVzc2FnZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlLmxvb2t1cChwcm9tcHQsIGxsbVN0cmluZ0tleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nUHJvbXB0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gTWFwIHJ1biBtYW5hZ2VycyB0byB0aGUgcmVzdWx0cyBiZWZvcmUgZmlsdGVyaW5nIG91dCBudWxsIHJlc3VsdHNcbiAgICAgICAgLy8gTnVsbCByZXN1bHRzIGFyZSBqdXN0IGFic2VudCBmcm9tIHRoZSBjYWNoZS5cbiAgICAgICAgY29uc3QgY2FjaGVkUmVzdWx0cyA9IHJlc3VsdHNcbiAgICAgICAgICAgIC5tYXAoKHJlc3VsdCwgaW5kZXgpID0+ICh7IHJlc3VsdCwgcnVuTWFuYWdlcjogcnVuTWFuYWdlcnM/LltpbmRleF0gfSkpXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHJlc3VsdCB9KSA9PiAocmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAmJiByZXN1bHQudmFsdWUgIT0gbnVsbCkgfHxcbiAgICAgICAgICAgIHJlc3VsdC5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIik7XG4gICAgICAgIC8vIEhhbmRsZSByZXN1bHRzIGFuZCBjYWxsIHJ1biBtYW5hZ2Vyc1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IFtdO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWNoZWRSZXN1bHRzLm1hcChhc3luYyAoeyByZXN1bHQ6IHByb21pc2VSZXN1bHQsIHJ1bk1hbmFnZXIgfSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb21pc2VSZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvbWlzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uc1tpXSA9IHJlc3VsdC5tYXAoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gcmVzdWx0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Jhc2VNZXNzYWdlKHJlc3VsdC5tZXNzYWdlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBSU1lc3NhZ2UocmVzdWx0Lm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tZXNzYWdlLnVzYWdlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZW5lcmF0aW9uSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdC5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXNhZ2U6IHt9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTU5ld1Rva2VuKHJlc3VsdFswXS50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbcmVzdWx0XSxcbiAgICAgICAgICAgICAgICB9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN0YXR1cyA9PT0gXCJyZWplY3RlZFwiXG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IocHJvbWlzZVJlc3VsdC5yZWFzb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwcm9taXNlUmVzdWx0LnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnMsXG4gICAgICAgICAgICBtaXNzaW5nUHJvbXB0SW5kaWNlcyxcbiAgICAgICAgICAgIHN0YXJ0ZWRSdW5NYW5hZ2VyczogcnVuTWFuYWdlcnMsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgZGVmaW5lcyBSVU5fS0VZIGFzIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG91dHB1dCBvYmplY3RcbiAgICAgICAgLy8gc28gdGhhdCBpdCBpcyBub3Qgc2VyaWFsaXplZCB3aGVuIHRoZSBvdXRwdXQgaXMgc3RyaW5naWZpZWQsIGFuZCBzbyB0aGF0XG4gICAgICAgIC8vIGl0IGlzbnQgaW5jbHVkZWQgd2hlbiBsaXN0aW5nIHRoZSBrZXlzIG9mIHRoZSBvdXRwdXQgb2JqZWN0LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3V0cHV0LCBSVU5fS0VZLCB7XG4gICAgICAgICAgICB2YWx1ZTogcnVuTWFuYWdlcnNcbiAgICAgICAgICAgICAgICA/IHsgcnVuSWRzOiBydW5NYW5hZ2Vycz8ubWFwKChtYW5hZ2VyKSA9PiBtYW5hZ2VyLnJ1bklkKSB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgY2hhdCBiYXNlZCBvbiB0aGUgaW5wdXQgbWVzc2FnZXMuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIEFuIGFycmF5IG9mIGFycmF5cyBvZiBCYXNlTWVzc2FnZSBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNhbGwgb3B0aW9ucyBvciBhbiBhcnJheSBvZiBzdG9wIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIFRoZSBjYWxsYmFja3MgZm9yIHRoZSBsYW5ndWFnZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBMTE1SZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUobWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICAvLyBwYXJzZSBjYWxsIG9wdGlvbnNcbiAgICAgICAgbGV0IHBhcnNlZE9wdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBwYXJzZWRPcHRpb25zID0geyBzdG9wOiBvcHRpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlTWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2VMaXN0KSA9PiBtZXNzYWdlTGlzdC5tYXAoY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpKTtcbiAgICAgICAgY29uc3QgW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zQ29tcGF0KHBhcnNlZE9wdGlvbnMpO1xuICAgICAgICBydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MgPSBydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MgPz8gY2FsbGJhY2tzO1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuY2FjaGVkKGJhc2VNZXNzYWdlcywgY2FsbE9wdGlvbnMsIHJ1bm5hYmxlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsbG1TdHJpbmdLZXkgPSB0aGlzLl9nZXRTZXJpYWxpemVkQ2FjaGVLZXlQYXJhbWV0ZXJzRm9yQ2FsbChjYWxsT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgZ2VuZXJhdGlvbnMsIG1pc3NpbmdQcm9tcHRJbmRpY2VzLCBzdGFydGVkUnVuTWFuYWdlcnMgfSA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlQ2FjaGVkKHtcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBiYXNlTWVzc2FnZXMsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGxsbVN0cmluZ0tleSxcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgaGFuZGxlZE9wdGlvbnM6IHJ1bm5hYmxlQ29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxsbU91dHB1dCA9IHt9O1xuICAgICAgICBpZiAobWlzc2luZ1Byb21wdEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlVW5jYWNoZWQobWlzc2luZ1Byb21wdEluZGljZXMubWFwKChpKSA9PiBiYXNlTWVzc2FnZXNbaV0pLCBjYWxsT3B0aW9ucywgcnVubmFibGVDb25maWcsIHN0YXJ0ZWRSdW5NYW5hZ2VycyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtaXNzaW5nUHJvbXB0SW5kaWNlcy5tYXAoKGkpID0+IHN0YXJ0ZWRSdW5NYW5hZ2Vycz8uW2ldKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMuZ2VuZXJhdGlvbnMubWFwKGFzeW5jIChnZW5lcmF0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21wdEluZGV4ID0gbWlzc2luZ1Byb21wdEluZGljZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zW3Byb21wdEluZGV4XSA9IGdlbmVyYXRpb247XG4gICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgY29udGVudCBpbnRvIG9uZSBzdHJpbmcgZm9yIHRoZSBwcm9tcHQgaW5kZXhcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9tcHQgPSBCYXNlQ2hhdE1vZGVsLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGJhc2VNZXNzYWdlc1twcm9tcHRJbmRleF0pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLnVwZGF0ZShwcm9tcHQsIGxsbVN0cmluZ0tleSwgZ2VuZXJhdGlvbik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsbG1PdXRwdXQgPSByZXN1bHRzLmxsbU91dHB1dCA/PyB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBnZW5lcmF0aW9ucywgbGxtT3V0cHV0IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyYW1ldGVycyB1c2VkIHRvIGludm9rZSB0aGUgbW9kZWxcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGludm9jYXRpb25QYXJhbXMoX29wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBfbW9kZWxUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJiYXNlX2NoYXRfbW9kZWxcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBSZXR1cm4gYSBqc29uLWxpa2Ugb2JqZWN0IHJlcHJlc2VudGluZyB0aGlzIExMTS5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLmludm9jYXRpb25QYXJhbXMoKSxcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9sbG1UeXBlKCksXG4gICAgICAgICAgICBfbW9kZWw6IHRoaXMuX21vZGVsVHlwZSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBwcm9tcHQgYmFzZWQgb24gdGhlIGlucHV0IHByb21wdCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHByb21wdFZhbHVlcyBBbiBhcnJheSBvZiBCYXNlUHJvbXB0VmFsdWUgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMgb3IgYW4gYXJyYXkgb2Ygc3RvcCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBUaGUgY2FsbGJhY2tzIGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gTExNUmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlUHJvbXB0KHByb21wdFZhbHVlcywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gcHJvbXB0VmFsdWVzLm1hcCgocHJvbXB0VmFsdWUpID0+IHByb21wdFZhbHVlLnRvQ2hhdE1lc3NhZ2VzKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZShwcm9tcHRNZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBNYWtlcyBhIHNpbmdsZSBjYWxsIHRvIHRoZSBjaGF0IG1vZGVsLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyBBbiBhcnJheSBvZiBCYXNlTWVzc2FnZSBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNhbGwgb3B0aW9ucyBvciBhbiBhcnJheSBvZiBzdG9wIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIFRoZSBjYWxsYmFja3MgZm9yIHRoZSBsYW5ndWFnZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEJhc2VNZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGwobWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdlbmVyYXRlKFttZXNzYWdlcy5tYXAoY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpXSwgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSByZXN1bHQuZ2VuZXJhdGlvbnM7XG4gICAgICAgIHJldHVybiBnZW5lcmF0aW9uc1swXVswXS5tZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKlxuICAgICAqIE1ha2VzIGEgc2luZ2xlIGNhbGwgdG8gdGhlIGNoYXQgbW9kZWwgd2l0aCBhIHByb21wdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gcHJvbXB0VmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9tcHQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNhbGwgb3B0aW9ucyBvciBhbiBhcnJheSBvZiBzdG9wIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIFRoZSBjYWxsYmFja3MgZm9yIHRoZSBsYW5ndWFnZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEJhc2VNZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGxQcm9tcHQocHJvbXB0VmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IHByb21wdFZhbHVlLnRvQ2hhdE1lc3NhZ2VzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwocHJvbXB0TWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqXG4gICAgICogUHJlZGljdHMgdGhlIG5leHQgbWVzc2FnZSBiYXNlZCBvbiB0aGUgaW5wdXQgbWVzc2FnZXMuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIEFuIGFycmF5IG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgQmFzZU1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdE1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBQcmVkaWN0cyB0aGUgbmV4dCBtZXNzYWdlIGJhc2VkIG9uIGEgdGV4dCBpbnB1dC5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCBpbnB1dC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHByZWRpY3QodGV4dCwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgSHVtYW5NZXNzYWdlKHRleHQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGwoW21lc3NhZ2VdLCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHByZWRpY3Qgd2hlbiBvdXRwdXQgaXMgbm90IGEgc3RyaW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbnRlbnQ7XG4gICAgfVxuICAgIHdpdGhTdHJ1Y3R1cmVkT3V0cHV0KG91dHB1dFNjaGVtYSwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5iaW5kVG9vbHMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGF0IG1vZGVsIG11c3QgaW1wbGVtZW50IFwiLmJpbmRUb29scygpXCIgdG8gdXNlIHdpdGhTdHJ1Y3R1cmVkT3V0cHV0LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWc/LnN0cmljdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcInN0cmljdFwiIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBtb2RlbCBieSBkZWZhdWx0LmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IG91dHB1dFNjaGVtYTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGNvbmZpZz8ubmFtZTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBnZXRTY2hlbWFEZXNjcmlwdGlvbihzY2hlbWEpID8/IFwiQSBmdW5jdGlvbiBhdmFpbGFibGUgdG8gY2FsbC5cIjtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gY29uZmlnPy5tZXRob2Q7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVSYXcgPSBjb25maWc/LmluY2x1ZGVSYXc7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwianNvbk1vZGVcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYXNlIHdpdGhTdHJ1Y3R1cmVkT3V0cHV0IGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgXCJmdW5jdGlvbkNhbGxpbmdcIiBhcyBhIG1ldGhvZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVuY3Rpb25OYW1lID0gbmFtZSA/PyBcImV4dHJhY3RcIjtcbiAgICAgICAgbGV0IHRvb2xzO1xuICAgICAgICBpZiAoaXNJbnRlcm9wWm9kU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHRvb2xzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0b0pzb25TY2hlbWEoc2NoZW1hKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChcIm5hbWVcIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBzY2hlbWEubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvb2xzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGxtID0gdGhpcy5iaW5kVG9vbHModG9vbHMpO1xuICAgICAgICBjb25zdCBvdXRwdXRQYXJzZXIgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dC50b29sX2NhbGxzIHx8IGlucHV0LnRvb2xfY2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBjYWxscyBmb3VuZCBpbiB0aGUgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBpbnB1dC50b29sX2NhbGxzLmZpbmQoKHRjKSA9PiB0Yy5uYW1lID09PSBmdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgaWYgKCF0b29sQ2FsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gdG9vbCBjYWxsIGZvdW5kIHdpdGggbmFtZSAke2Z1bmN0aW9uTmFtZX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbENhbGwuYXJncztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaW5jbHVkZVJhdykge1xuICAgICAgICAgICAgcmV0dXJuIGxsbS5waXBlKG91dHB1dFBhcnNlcikud2l0aENvbmZpZyh7XG4gICAgICAgICAgICAgICAgcnVuTmFtZTogXCJTdHJ1Y3R1cmVkT3V0cHV0XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZXJBc3NpZ24gPSBSdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbih7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcGFyc2VkOiAoaW5wdXQsIGNvbmZpZykgPT4gb3V0cHV0UGFyc2VyLmludm9rZShpbnB1dC5yYXcsIGNvbmZpZyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZXJOb25lID0gUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAgICAgICAgcGFyc2VkOiAoKSA9PiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VkV2l0aEZhbGxiYWNrID0gcGFyc2VyQXNzaWduLndpdGhGYWxsYmFja3Moe1xuICAgICAgICAgICAgZmFsbGJhY2tzOiBbcGFyc2VyTm9uZV0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByYXc6IGxsbSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZWRXaXRoRmFsbGJhY2ssXG4gICAgICAgIF0pLndpdGhDb25maWcoe1xuICAgICAgICAgICAgcnVuTmFtZTogXCJTdHJ1Y3R1cmVkT3V0cHV0UnVubmFibGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGV4dGVuZHMgQmFzZUNoYXRNb2RlbCBhbmQgcHJvdmlkZXMgYSBzaW1wbGVcbiAqIGltcGxlbWVudGF0aW9uIG9mIF9nZW5lcmF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXBsZUNoYXRNb2RlbCBleHRlbmRzIEJhc2VDaGF0TW9kZWwge1xuICAgIGFzeW5jIF9nZW5lcmF0ZShtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5fY2FsbChtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcik7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgQUlNZXNzYWdlKHRleHQpO1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdlbmVyYXRlIHdpdGggYSBzaW1wbGUgY2hhdCBtb2RlbCB3aGVuIG91dHB1dCBpcyBub3QgYSBzdHJpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZW5lcmF0aW9uczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/llms.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/llms.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseLLM: () => (/* binding */ BaseLLM),\n/* harmony export */   LLM: () => (/* binding */ LLM)\n/* harmony export */ });\n/* harmony import */ var _messages_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../messages/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.js\");\n/* harmony import */ var _outputs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../outputs.js */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.js\");\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../callbacks/manager.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _callbacks_base_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../callbacks/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.js\");\n\n\n\n\n\n\n/**\n * LLM Wrapper. Takes in a prompt (or prompts) and returns a string.\n */\nclass BaseLLM extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseLanguageModel {\n    constructor({ concurrency, ...rest }) {\n        super(concurrency ? { maxConcurrency: concurrency, ...rest } : rest);\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"llms\", this._llmType()]\n        });\n    }\n    /**\n     * This method takes an input and options, and returns a string. It\n     * converts the input to a prompt value and generates a result based on\n     * the prompt.\n     * @param input Input for the LLM.\n     * @param options Options for the LLM call.\n     * @returns A string result based on the prompt.\n     */\n    async invoke(input, options) {\n        const promptValue = BaseLLM._convertInputToPromptValue(input);\n        const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n        return result.generations[0][0].text;\n    }\n    // eslint-disable-next-line require-yield\n    async *_streamResponseChunks(_input, _options, _runManager) {\n        throw new Error(\"Not implemented.\");\n    }\n    _separateRunnableConfigFromCallOptionsCompat(options) {\n        // For backwards compat, keep `signal` in both runnableConfig and callOptions\n        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n        callOptions.signal = runnableConfig.signal;\n        return [runnableConfig, callOptions];\n    }\n    async *_streamIterator(input, options) {\n        // Subclass check required to avoid double callbacks with default implementation\n        if (this._streamResponseChunks === BaseLLM.prototype._streamResponseChunks) {\n            yield this.invoke(input, options);\n        }\n        else {\n            const prompt = BaseLLM._convertInputToPromptValue(input);\n            const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);\n            const callbackManager_ = await _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_2__.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: callOptions,\n                invocation_params: this?.invocationParams(callOptions),\n                batch_size: 1,\n            };\n            const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], runnableConfig.runId, undefined, extra, undefined, undefined, runnableConfig.runName);\n            let generation = new _outputs_js__WEBPACK_IMPORTED_MODULE_1__.GenerationChunk({\n                text: \"\",\n            });\n            try {\n                for await (const chunk of this._streamResponseChunks(prompt.toString(), callOptions, runManagers?.[0])) {\n                    if (!generation) {\n                        generation = chunk;\n                    }\n                    else {\n                        generation = generation.concat(chunk);\n                    }\n                    if (typeof chunk.text === \"string\") {\n                        yield chunk.text;\n                    }\n                }\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                generations: [[generation]],\n            })));\n        }\n    }\n    /**\n     * This method takes prompt values, options, and callbacks, and generates\n     * a result based on the prompts.\n     * @param promptValues Prompt values for the LLM.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns An LLMResult based on the prompts.\n     */\n    async generatePrompt(promptValues, options, callbacks) {\n        const prompts = promptValues.map((promptValue) => promptValue.toString());\n        return this.generate(prompts, options, callbacks);\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    invocationParams(_options) {\n        return {};\n    }\n    _flattenLLMResult(llmResult) {\n        const llmResults = [];\n        for (let i = 0; i < llmResult.generations.length; i += 1) {\n            const genList = llmResult.generations[i];\n            if (i === 0) {\n                llmResults.push({\n                    generations: [genList],\n                    llmOutput: llmResult.llmOutput,\n                });\n            }\n            else {\n                const llmOutput = llmResult.llmOutput\n                    ? { ...llmResult.llmOutput, tokenUsage: {} }\n                    : undefined;\n                llmResults.push({\n                    generations: [genList],\n                    llmOutput,\n                });\n            }\n        }\n        return llmResults;\n    }\n    /** @ignore */\n    async _generateUncached(prompts, parsedOptions, handledOptions, startedRunManagers) {\n        let runManagers;\n        if (startedRunManagers !== undefined &&\n            startedRunManagers.length === prompts.length) {\n            runManagers = startedRunManagers;\n        }\n        else {\n            const callbackManager_ = await _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_2__.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: parsedOptions,\n                invocation_params: this?.invocationParams(parsedOptions),\n                batch_size: prompts.length,\n            };\n            runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, handledOptions.runId, undefined, extra, undefined, undefined, handledOptions?.runName);\n        }\n        // Even if stream is not explicitly called, check if model is implicitly\n        // called from streamEvents() or streamLog() to get all streamed events.\n        // Bail out if _streamResponseChunks not overridden\n        const hasStreamingHandler = !!runManagers?.[0].handlers.find(_callbacks_base_js__WEBPACK_IMPORTED_MODULE_5__.callbackHandlerPrefersStreaming);\n        let output;\n        if (hasStreamingHandler &&\n            prompts.length === 1 &&\n            this._streamResponseChunks !== BaseLLM.prototype._streamResponseChunks) {\n            try {\n                const stream = await this._streamResponseChunks(prompts[0], parsedOptions, runManagers?.[0]);\n                let aggregated;\n                for await (const chunk of stream) {\n                    if (aggregated === undefined) {\n                        aggregated = chunk;\n                    }\n                    else {\n                        aggregated = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.concat)(aggregated, chunk);\n                    }\n                }\n                if (aggregated === undefined) {\n                    throw new Error(\"Received empty response from chat model call.\");\n                }\n                output = { generations: [[aggregated]], llmOutput: {} };\n                await runManagers?.[0].handleLLMEnd(output);\n            }\n            catch (e) {\n                await runManagers?.[0].handleLLMError(e);\n                throw e;\n            }\n        }\n        else {\n            try {\n                output = await this._generate(prompts, parsedOptions, runManagers?.[0]);\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            const flattenedOutputs = this._flattenLLMResult(output);\n            await Promise.all((runManagers ?? []).map((runManager, i) => runManager?.handleLLMEnd(flattenedOutputs[i])));\n        }\n        const runIds = runManagers?.map((manager) => manager.runId) || undefined;\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, _outputs_js__WEBPACK_IMPORTED_MODULE_1__.RUN_KEY, {\n            value: runIds ? { runIds } : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    async _generateCached({ prompts, cache, llmStringKey, parsedOptions, handledOptions, runId, }) {\n        const callbackManager_ = await _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_2__.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: prompts.length,\n        };\n        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, runId, undefined, extra, undefined, undefined, handledOptions?.runName);\n        // generate results\n        const missingPromptIndices = [];\n        const results = await Promise.allSettled(prompts.map(async (prompt, index) => {\n            const result = await cache.lookup(prompt, llmStringKey);\n            if (result == null) {\n                missingPromptIndices.push(index);\n            }\n            return result;\n        }));\n        // Map run managers to the results before filtering out null results\n        // Null results are just absent from the cache.\n        const cachedResults = results\n            .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n            .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n            result.status === \"rejected\");\n        // Handle results and call run managers\n        const generations = [];\n        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n            if (promiseResult.status === \"fulfilled\") {\n                const result = promiseResult.value;\n                generations[i] = result.map((result) => {\n                    // eslint-disable-next-line no-param-reassign\n                    result.generationInfo = {\n                        ...result.generationInfo,\n                        tokenUsage: {},\n                    };\n                    return result;\n                });\n                if (result.length) {\n                    await runManager?.handleLLMNewToken(result[0].text);\n                }\n                return runManager?.handleLLMEnd({\n                    generations: [result],\n                }, undefined, undefined, undefined, {\n                    cached: true,\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManager?.handleLLMError(promiseResult.reason, undefined, undefined, undefined, {\n                    cached: true,\n                });\n                return Promise.reject(promiseResult.reason);\n            }\n        }));\n        const output = {\n            generations,\n            missingPromptIndices,\n            startedRunManagers: runManagers,\n        };\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, _outputs_js__WEBPACK_IMPORTED_MODULE_1__.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    /**\n     * Run the LLM on the given prompts and input, handling caching.\n     */\n    async generate(prompts, options, callbacks) {\n        if (!Array.isArray(prompts)) {\n            throw new Error(\"Argument 'prompts' is expected to be a string[]\");\n        }\n        let parsedOptions;\n        if (Array.isArray(options)) {\n            parsedOptions = { stop: options };\n        }\n        else {\n            parsedOptions = options;\n        }\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n        if (!this.cache) {\n            return this._generateUncached(prompts, callOptions, runnableConfig);\n        }\n        const { cache } = this;\n        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n        const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({\n            prompts,\n            cache,\n            llmStringKey,\n            parsedOptions: callOptions,\n            handledOptions: runnableConfig,\n            runId: runnableConfig.runId,\n        });\n        let llmOutput = {};\n        if (missingPromptIndices.length > 0) {\n            const results = await this._generateUncached(missingPromptIndices.map((i) => prompts[i]), callOptions, runnableConfig, startedRunManagers !== undefined\n                ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n                : undefined);\n            await Promise.all(results.generations.map(async (generation, index) => {\n                const promptIndex = missingPromptIndices[index];\n                generations[promptIndex] = generation;\n                return cache.update(prompts[promptIndex], llmStringKey, generation);\n            }));\n            llmOutput = results.llmOutput ?? {};\n        }\n        return { generations, llmOutput };\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     * Convenience wrapper for {@link generate} that takes in a single string prompt and returns a single string output.\n     */\n    async call(prompt, options, callbacks) {\n        const { generations } = await this.generate([prompt], options, callbacks);\n        return generations[0][0].text;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * This method is similar to `call`, but it's used for making predictions\n     * based on the input text.\n     * @param text Input text for the prediction.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns A prediction based on the input text.\n     */\n    async predict(text, options, callbacks) {\n        return this.call(text, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * This method takes a list of messages, options, and callbacks, and\n     * returns a predicted message.\n     * @param messages A list of messages for the prediction.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns A predicted message based on the list of messages.\n     */\n    async predictMessages(messages, options, callbacks) {\n        const text = (0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.getBufferString)(messages);\n        const prediction = await this.call(text, options, callbacks);\n        return new _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.AIMessage(prediction);\n    }\n    /**\n     * Get the identifying parameters of the LLM.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _identifyingParams() {\n        return {};\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this._identifyingParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    _modelType() {\n        return \"base_llm\";\n    }\n}\n/**\n * LLM class that provides a simpler interface to subclass than {@link BaseLLM}.\n *\n * Requires only implementing a simpler {@link _call} method instead of {@link _generate}.\n *\n * @augments BaseLLM\n */\nclass LLM extends BaseLLM {\n    async _generate(prompts, options, runManager) {\n        const generations = await Promise.all(prompts.map((prompt, promptIndex) => this._call(prompt, { ...options, promptIndex }, runManager).then((text) => [{ text }])));\n        return { generations };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2xsbXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBbUU7QUFDVDtBQUNDO0FBQ1o7QUFDSDtBQUMyQjtBQUN2RTtBQUNBO0FBQ0E7QUFDTyxzQkFBc0IsdURBQWlCO0FBQzlDLGtCQUFrQixzQkFBc0I7QUFDeEMsOEJBQThCLHVDQUF1QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrRUFBZSwrSEFBK0gsdUJBQXVCO0FBQ2hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3REFBZTtBQUNoRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsa0VBQWUsK0hBQStILHVCQUF1QjtBQUNoTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSwrRUFBK0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHdEQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0RBQU87QUFDN0MsOEJBQThCLFNBQVM7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QixxRUFBcUU7QUFDakcsdUNBQXVDLGtFQUFlLCtIQUErSCx1QkFBdUI7QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMENBQTBDO0FBQ2pGLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxtQ0FBbUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnREFBTztBQUM3QztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxnQkFBZ0Isd0RBQXdEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFlO0FBQ3BDO0FBQ0EsbUJBQW1CLHlEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxjQUFjO0FBQy9FO0FBQ0EseUNBQXlDLGFBQWEsbUJBQW1CLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esd0dBQXdHLHlCQUF5QixnQ0FBZ0MsTUFBTTtBQUN2SyxpQkFBaUI7QUFDakI7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxsYW5ndWFnZV9tb2RlbHNcXGxsbXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQUlNZXNzYWdlLCBnZXRCdWZmZXJTdHJpbmcsIH0gZnJvbSBcIi4uL21lc3NhZ2VzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBSVU5fS0VZLCBHZW5lcmF0aW9uQ2h1bmssIH0gZnJvbSBcIi4uL291dHB1dHMuanNcIjtcbmltcG9ydCB7IENhbGxiYWNrTWFuYWdlciwgfSBmcm9tIFwiLi4vY2FsbGJhY2tzL21hbmFnZXIuanNcIjtcbmltcG9ydCB7IEJhc2VMYW5ndWFnZU1vZGVsLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gXCIuLi91dGlscy9zdHJlYW0uanNcIjtcbmltcG9ydCB7IGNhbGxiYWNrSGFuZGxlclByZWZlcnNTdHJlYW1pbmcgfSBmcm9tIFwiLi4vY2FsbGJhY2tzL2Jhc2UuanNcIjtcbi8qKlxuICogTExNIFdyYXBwZXIuIFRha2VzIGluIGEgcHJvbXB0IChvciBwcm9tcHRzKSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VMTE0gZXh0ZW5kcyBCYXNlTGFuZ3VhZ2VNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoeyBjb25jdXJyZW5jeSwgLi4ucmVzdCB9KSB7XG4gICAgICAgIHN1cGVyKGNvbmN1cnJlbmN5ID8geyBtYXhDb25jdXJyZW5jeTogY29uY3VycmVuY3ksIC4uLnJlc3QgfSA6IHJlc3QpO1xuICAgICAgICAvLyBPbmx5IGV2ZXIgaW5zdGFudGlhdGVkIGluIG1haW4gTGFuZ0NoYWluXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwibGxtc1wiLCB0aGlzLl9sbG1UeXBlKCldXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhbiBpbnB1dCBhbmQgb3B0aW9ucywgYW5kIHJldHVybnMgYSBzdHJpbmcuIEl0XG4gICAgICogY29udmVydHMgdGhlIGlucHV0IHRvIGEgcHJvbXB0IHZhbHVlIGFuZCBnZW5lcmF0ZXMgYSByZXN1bHQgYmFzZWQgb25cbiAgICAgKiB0aGUgcHJvbXB0LlxuICAgICAqIEBwYXJhbSBpbnB1dCBJbnB1dCBmb3IgdGhlIExMTS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVzdWx0IGJhc2VkIG9uIHRoZSBwcm9tcHQuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb21wdFZhbHVlID0gQmFzZUxMTS5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVQcm9tcHQoW3Byb21wdFZhbHVlXSwgb3B0aW9ucywgb3B0aW9ucz8uY2FsbGJhY2tzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5nZW5lcmF0aW9uc1swXVswXS50ZXh0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS15aWVsZFxuICAgIGFzeW5jICpfc3RyZWFtUmVzcG9uc2VDaHVua3MoX2lucHV0LCBfb3B0aW9ucywgX3J1bk1hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnNDb21wYXQob3B0aW9ucykge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdCwga2VlcCBgc2lnbmFsYCBpbiBib3RoIHJ1bm5hYmxlQ29uZmlnIGFuZCBjYWxsT3B0aW9uc1xuICAgICAgICBjb25zdCBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXSA9IHN1cGVyLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjYWxsT3B0aW9ucy5zaWduYWwgPSBydW5uYWJsZUNvbmZpZy5zaWduYWw7XG4gICAgICAgIHJldHVybiBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBTdWJjbGFzcyBjaGVjayByZXF1aXJlZCB0byBhdm9pZCBkb3VibGUgY2FsbGJhY2tzIHdpdGggZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAodGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MgPT09IEJhc2VMTE0ucHJvdG90eXBlLl9zdHJlYW1SZXNwb25zZUNodW5rcykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gQmFzZUxMTS5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXSA9IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnNDb21wYXQob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBydW5uYWJsZUNvbmZpZy50YWdzLCB0aGlzLnRhZ3MsIHJ1bm5hYmxlQ29uZmlnLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKGNhbGxPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlTExNU3RhcnQodGhpcy50b0pTT04oKSwgW3Byb21wdC50b1N0cmluZygpXSwgcnVubmFibGVDb25maWcucnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBydW5uYWJsZUNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgICAgIGxldCBnZW5lcmF0aW9uID0gbmV3IEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKHByb21wdC50b1N0cmluZygpLCBjYWxsT3B0aW9ucywgcnVuTWFuYWdlcnM/LlswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uID0gZ2VuZXJhdGlvbi5jb25jYXQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgY2h1bmsudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IoZXJyKSkpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbW2dlbmVyYXRpb25dXSxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdGFrZXMgcHJvbXB0IHZhbHVlcywgb3B0aW9ucywgYW5kIGNhbGxiYWNrcywgYW5kIGdlbmVyYXRlc1xuICAgICAqIGEgcmVzdWx0IGJhc2VkIG9uIHRoZSBwcm9tcHRzLlxuICAgICAqIEBwYXJhbSBwcm9tcHRWYWx1ZXMgUHJvbXB0IHZhbHVlcyBmb3IgdGhlIExMTS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBDYWxsYmFja3MgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcmV0dXJucyBBbiBMTE1SZXN1bHQgYmFzZWQgb24gdGhlIHByb21wdHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVQcm9tcHQocHJvbXB0VmFsdWVzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0cyA9IHByb21wdFZhbHVlcy5tYXAoKHByb21wdFZhbHVlKSA9PiBwcm9tcHRWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUocHJvbXB0cywgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXJhbWV0ZXJzIHVzZWQgdG8gaW52b2tlIHRoZSBtb2RlbFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaW52b2NhdGlvblBhcmFtcyhfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIF9mbGF0dGVuTExNUmVzdWx0KGxsbVJlc3VsdCkge1xuICAgICAgICBjb25zdCBsbG1SZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGxtUmVzdWx0LmdlbmVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5MaXN0ID0gbGxtUmVzdWx0LmdlbmVyYXRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsbG1SZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW2dlbkxpc3RdLFxuICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQ6IGxsbVJlc3VsdC5sbG1PdXRwdXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsbG1PdXRwdXQgPSBsbG1SZXN1bHQubGxtT3V0cHV0XG4gICAgICAgICAgICAgICAgICAgID8geyAuLi5sbG1SZXN1bHQubGxtT3V0cHV0LCB0b2tlblVzYWdlOiB7fSB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxsbVJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbZ2VuTGlzdF0sXG4gICAgICAgICAgICAgICAgICAgIGxsbU91dHB1dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGxtUmVzdWx0cztcbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhc3luYyBfZ2VuZXJhdGVVbmNhY2hlZChwcm9tcHRzLCBwYXJzZWRPcHRpb25zLCBoYW5kbGVkT3B0aW9ucywgc3RhcnRlZFJ1bk1hbmFnZXJzKSB7XG4gICAgICAgIGxldCBydW5NYW5hZ2VycztcbiAgICAgICAgaWYgKHN0YXJ0ZWRSdW5NYW5hZ2VycyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGFydGVkUnVuTWFuYWdlcnMubGVuZ3RoID09PSBwcm9tcHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcnVuTWFuYWdlcnMgPSBzdGFydGVkUnVuTWFuYWdlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShoYW5kbGVkT3B0aW9ucy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBoYW5kbGVkT3B0aW9ucy50YWdzLCB0aGlzLnRhZ3MsIGhhbmRsZWRPcHRpb25zLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHBhcnNlZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgICAgICAgICAgYmF0Y2hfc2l6ZTogcHJvbXB0cy5sZW5ndGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVMTE1TdGFydCh0aGlzLnRvSlNPTigpLCBwcm9tcHRzLCBoYW5kbGVkT3B0aW9ucy5ydW5JZCwgdW5kZWZpbmVkLCBleHRyYSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhhbmRsZWRPcHRpb25zPy5ydW5OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFdmVuIGlmIHN0cmVhbSBpcyBub3QgZXhwbGljaXRseSBjYWxsZWQsIGNoZWNrIGlmIG1vZGVsIGlzIGltcGxpY2l0bHlcbiAgICAgICAgLy8gY2FsbGVkIGZyb20gc3RyZWFtRXZlbnRzKCkgb3Igc3RyZWFtTG9nKCkgdG8gZ2V0IGFsbCBzdHJlYW1lZCBldmVudHMuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIF9zdHJlYW1SZXNwb25zZUNodW5rcyBub3Qgb3ZlcnJpZGRlblxuICAgICAgICBjb25zdCBoYXNTdHJlYW1pbmdIYW5kbGVyID0gISFydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZXJzLmZpbmQoY2FsbGJhY2tIYW5kbGVyUHJlZmVyc1N0cmVhbWluZyk7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIGlmIChoYXNTdHJlYW1pbmdIYW5kbGVyICYmXG4gICAgICAgICAgICBwcm9tcHRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgdGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MgIT09IEJhc2VMTE0ucHJvdG90eXBlLl9zdHJlYW1SZXNwb25zZUNodW5rcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhwcm9tcHRzWzBdLCBwYXJzZWRPcHRpb25zLCBydW5NYW5hZ2Vycz8uWzBdKTtcbiAgICAgICAgICAgICAgICBsZXQgYWdncmVnYXRlZDtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkID0gY29uY2F0KGFnZ3JlZ2F0ZWQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY2VpdmVkIGVtcHR5IHJlc3BvbnNlIGZyb20gY2hhdCBtb2RlbCBjYWxsLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0geyBnZW5lcmF0aW9uczogW1thZ2dyZWdhdGVkXV0sIGxsbU91dHB1dDoge30gfTtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZUxMTUVuZChvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZUxMTUVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlKHByb21wdHMsIHBhcnNlZE9wdGlvbnMsIHJ1bk1hbmFnZXJzPy5bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FcnJvcihlcnIpKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkT3V0cHV0cyA9IHRoaXMuX2ZsYXR0ZW5MTE1SZXN1bHQob3V0cHV0KTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyLCBpKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoZmxhdHRlbmVkT3V0cHV0c1tpXSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5JZHMgPSBydW5NYW5hZ2Vycz8ubWFwKChtYW5hZ2VyKSA9PiBtYW5hZ2VyLnJ1bklkKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoaXMgZGVmaW5lcyBSVU5fS0VZIGFzIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG91dHB1dCBvYmplY3RcbiAgICAgICAgLy8gc28gdGhhdCBpdCBpcyBub3Qgc2VyaWFsaXplZCB3aGVuIHRoZSBvdXRwdXQgaXMgc3RyaW5naWZpZWQsIGFuZCBzbyB0aGF0XG4gICAgICAgIC8vIGl0IGlzbnQgaW5jbHVkZWQgd2hlbiBsaXN0aW5nIHRoZSBrZXlzIG9mIHRoZSBvdXRwdXQgb2JqZWN0LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3V0cHV0LCBSVU5fS0VZLCB7XG4gICAgICAgICAgICB2YWx1ZTogcnVuSWRzID8geyBydW5JZHMgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZW5lcmF0ZUNhY2hlZCh7IHByb21wdHMsIGNhY2hlLCBsbG1TdHJpbmdLZXksIHBhcnNlZE9wdGlvbnMsIGhhbmRsZWRPcHRpb25zLCBydW5JZCwgfSkge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShoYW5kbGVkT3B0aW9ucy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBoYW5kbGVkT3B0aW9ucy50YWdzLCB0aGlzLnRhZ3MsIGhhbmRsZWRPcHRpb25zLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgY29uc3QgZXh0cmEgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiBwYXJzZWRPcHRpb25zLFxuICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgICAgICBiYXRjaF9zaXplOiBwcm9tcHRzLmxlbmd0aCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVMTE1TdGFydCh0aGlzLnRvSlNPTigpLCBwcm9tcHRzLCBydW5JZCwgdW5kZWZpbmVkLCBleHRyYSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhhbmRsZWRPcHRpb25zPy5ydW5OYW1lKTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgcmVzdWx0c1xuICAgICAgICBjb25zdCBtaXNzaW5nUHJvbXB0SW5kaWNlcyA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21wdHMubWFwKGFzeW5jIChwcm9tcHQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZS5sb29rdXAocHJvbXB0LCBsbG1TdHJpbmdLZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1Byb21wdEluZGljZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIE1hcCBydW4gbWFuYWdlcnMgdG8gdGhlIHJlc3VsdHMgYmVmb3JlIGZpbHRlcmluZyBvdXQgbnVsbCByZXN1bHRzXG4gICAgICAgIC8vIE51bGwgcmVzdWx0cyBhcmUganVzdCBhYnNlbnQgZnJvbSB0aGUgY2FjaGUuXG4gICAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdHMgPSByZXN1bHRzXG4gICAgICAgICAgICAubWFwKChyZXN1bHQsIGluZGV4KSA9PiAoeyByZXN1bHQsIHJ1bk1hbmFnZXI6IHJ1bk1hbmFnZXJzPy5baW5kZXhdIH0pKVxuICAgICAgICAgICAgLmZpbHRlcigoeyByZXN1bHQgfSkgPT4gKHJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgJiYgcmVzdWx0LnZhbHVlICE9IG51bGwpIHx8XG4gICAgICAgICAgICByZXN1bHQuc3RhdHVzID09PSBcInJlamVjdGVkXCIpO1xuICAgICAgICAvLyBIYW5kbGUgcmVzdWx0cyBhbmQgY2FsbCBydW4gbWFuYWdlcnNcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FjaGVkUmVzdWx0cy5tYXAoYXN5bmMgKHsgcmVzdWx0OiBwcm9taXNlUmVzdWx0LCBydW5NYW5hZ2VyIH0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlUmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb21pc2VSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnNbaV0gPSByZXN1bHQubWFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZW5lcmF0aW9uSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdC5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXNhZ2U6IHt9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTU5ld1Rva2VuKHJlc3VsdFswXS50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbcmVzdWx0XSxcbiAgICAgICAgICAgICAgICB9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN0YXR1cyA9PT0gXCJyZWplY3RlZFwiXG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IocHJvbWlzZVJlc3VsdC5yZWFzb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwcm9taXNlUmVzdWx0LnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnMsXG4gICAgICAgICAgICBtaXNzaW5nUHJvbXB0SW5kaWNlcyxcbiAgICAgICAgICAgIHN0YXJ0ZWRSdW5NYW5hZ2VyczogcnVuTWFuYWdlcnMsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgZGVmaW5lcyBSVU5fS0VZIGFzIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG91dHB1dCBvYmplY3RcbiAgICAgICAgLy8gc28gdGhhdCBpdCBpcyBub3Qgc2VyaWFsaXplZCB3aGVuIHRoZSBvdXRwdXQgaXMgc3RyaW5naWZpZWQsIGFuZCBzbyB0aGF0XG4gICAgICAgIC8vIGl0IGlzbnQgaW5jbHVkZWQgd2hlbiBsaXN0aW5nIHRoZSBrZXlzIG9mIHRoZSBvdXRwdXQgb2JqZWN0LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3V0cHV0LCBSVU5fS0VZLCB7XG4gICAgICAgICAgICB2YWx1ZTogcnVuTWFuYWdlcnNcbiAgICAgICAgICAgICAgICA/IHsgcnVuSWRzOiBydW5NYW5hZ2Vycz8ubWFwKChtYW5hZ2VyKSA9PiBtYW5hZ2VyLnJ1bklkKSB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIExMTSBvbiB0aGUgZ2l2ZW4gcHJvbXB0cyBhbmQgaW5wdXQsIGhhbmRsaW5nIGNhY2hpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUocHJvbXB0cywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9tcHRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgJ3Byb21wdHMnIGlzIGV4cGVjdGVkIHRvIGJlIGEgc3RyaW5nW11cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZE9wdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBwYXJzZWRPcHRpb25zID0geyBzdG9wOiBvcHRpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXSA9IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnNDb21wYXQocGFyc2VkT3B0aW9ucyk7XG4gICAgICAgIHJ1bm5hYmxlQ29uZmlnLmNhbGxiYWNrcyA9IHJ1bm5hYmxlQ29uZmlnLmNhbGxiYWNrcyA/PyBjYWxsYmFja3M7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRlVW5jYWNoZWQocHJvbXB0cywgY2FsbE9wdGlvbnMsIHJ1bm5hYmxlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsbG1TdHJpbmdLZXkgPSB0aGlzLl9nZXRTZXJpYWxpemVkQ2FjaGVLZXlQYXJhbWV0ZXJzRm9yQ2FsbChjYWxsT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgZ2VuZXJhdGlvbnMsIG1pc3NpbmdQcm9tcHRJbmRpY2VzLCBzdGFydGVkUnVuTWFuYWdlcnMgfSA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlQ2FjaGVkKHtcbiAgICAgICAgICAgIHByb21wdHMsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGxsbVN0cmluZ0tleSxcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgaGFuZGxlZE9wdGlvbnM6IHJ1bm5hYmxlQ29uZmlnLFxuICAgICAgICAgICAgcnVuSWQ6IHJ1bm5hYmxlQ29uZmlnLnJ1bklkLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxsbU91dHB1dCA9IHt9O1xuICAgICAgICBpZiAobWlzc2luZ1Byb21wdEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlVW5jYWNoZWQobWlzc2luZ1Byb21wdEluZGljZXMubWFwKChpKSA9PiBwcm9tcHRzW2ldKSwgY2FsbE9wdGlvbnMsIHJ1bm5hYmxlQ29uZmlnLCBzdGFydGVkUnVuTWFuYWdlcnMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWlzc2luZ1Byb21wdEluZGljZXMubWFwKChpKSA9PiBzdGFydGVkUnVuTWFuYWdlcnM/LltpXSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzLmdlbmVyYXRpb25zLm1hcChhc3luYyAoZ2VuZXJhdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9tcHRJbmRleCA9IG1pc3NpbmdQcm9tcHRJbmRpY2VzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uc1twcm9tcHRJbmRleF0gPSBnZW5lcmF0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS51cGRhdGUocHJvbXB0c1twcm9tcHRJbmRleF0sIGxsbVN0cmluZ0tleSwgZ2VuZXJhdGlvbik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsbG1PdXRwdXQgPSByZXN1bHRzLmxsbU91dHB1dCA/PyB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBnZW5lcmF0aW9ucywgbGxtT3V0cHV0IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqIENvbnZlbmllbmNlIHdyYXBwZXIgZm9yIHtAbGluayBnZW5lcmF0ZX0gdGhhdCB0YWtlcyBpbiBhIHNpbmdsZSBzdHJpbmcgcHJvbXB0IGFuZCByZXR1cm5zIGEgc2luZ2xlIHN0cmluZyBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgY2FsbChwcm9tcHQsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCB7IGdlbmVyYXRpb25zIH0gPSBhd2FpdCB0aGlzLmdlbmVyYXRlKFtwcm9tcHRdLCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGlvbnNbMF1bMF0udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGBjYWxsYCwgYnV0IGl0J3MgdXNlZCBmb3IgbWFraW5nIHByZWRpY3Rpb25zXG4gICAgICogYmFzZWQgb24gdGhlIGlucHV0IHRleHQuXG4gICAgICogQHBhcmFtIHRleHQgSW5wdXQgdGV4dCBmb3IgdGhlIHByZWRpY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHJldHVybnMgQSBwcmVkaWN0aW9uIGJhc2VkIG9uIHRoZSBpbnB1dCB0ZXh0LlxuICAgICAqL1xuICAgIGFzeW5jIHByZWRpY3QodGV4dCwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwodGV4dCwgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhIGxpc3Qgb2YgbWVzc2FnZXMsIG9wdGlvbnMsIGFuZCBjYWxsYmFja3MsIGFuZFxuICAgICAqIHJldHVybnMgYSBwcmVkaWN0ZWQgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgQSBsaXN0IG9mIG1lc3NhZ2VzIGZvciB0aGUgcHJlZGljdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBDYWxsYmFja3MgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcmV0dXJucyBBIHByZWRpY3RlZCBtZXNzYWdlIGJhc2VkIG9uIHRoZSBsaXN0IG9mIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIGFzeW5jIHByZWRpY3RNZXNzYWdlcyhtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBnZXRCdWZmZXJTdHJpbmcobWVzc2FnZXMpO1xuICAgICAgICBjb25zdCBwcmVkaWN0aW9uID0gYXdhaXQgdGhpcy5jYWxsKHRleHQsIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgICAgIHJldHVybiBuZXcgQUlNZXNzYWdlKHByZWRpY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkZW50aWZ5aW5nIHBhcmFtZXRlcnMgb2YgdGhlIExMTS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9pZGVudGlmeWluZ1BhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIFJldHVybiBhIGpzb24tbGlrZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgTExNLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2lkZW50aWZ5aW5nUGFyYW1zKCksXG4gICAgICAgICAgICBfdHlwZTogdGhpcy5fbGxtVHlwZSgpLFxuICAgICAgICAgICAgX21vZGVsOiB0aGlzLl9tb2RlbFR5cGUoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX21vZGVsVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiYmFzZV9sbG1cIjtcbiAgICB9XG59XG4vKipcbiAqIExMTSBjbGFzcyB0aGF0IHByb3ZpZGVzIGEgc2ltcGxlciBpbnRlcmZhY2UgdG8gc3ViY2xhc3MgdGhhbiB7QGxpbmsgQmFzZUxMTX0uXG4gKlxuICogUmVxdWlyZXMgb25seSBpbXBsZW1lbnRpbmcgYSBzaW1wbGVyIHtAbGluayBfY2FsbH0gbWV0aG9kIGluc3RlYWQgb2Yge0BsaW5rIF9nZW5lcmF0ZX0uXG4gKlxuICogQGF1Z21lbnRzIEJhc2VMTE1cbiAqL1xuZXhwb3J0IGNsYXNzIExMTSBleHRlbmRzIEJhc2VMTE0ge1xuICAgIGFzeW5jIF9nZW5lcmF0ZShwcm9tcHRzLCBvcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbXB0cy5tYXAoKHByb21wdCwgcHJvbXB0SW5kZXgpID0+IHRoaXMuX2NhbGwocHJvbXB0LCB7IC4uLm9wdGlvbnMsIHByb21wdEluZGV4IH0sIHJ1bk1hbmFnZXIpLnRoZW4oKHRleHQpID0+IFt7IHRleHQgfV0pKSk7XG4gICAgICAgIHJldHVybiB7IGdlbmVyYXRpb25zIH07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/llms.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/import_constants.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/import_constants.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   optionalImportEntrypoints: () => (/* binding */ optionalImportEntrypoints)\n/* harmony export */ });\n// Auto-generated by `scripts/create-entrypoints.js`. Do not edit manually.\nconst optionalImportEntrypoints = [];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9pbXBvcnRfY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNPIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGxvYWRcXGltcG9ydF9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQXV0by1nZW5lcmF0ZWQgYnkgYHNjcmlwdHMvY3JlYXRlLWVudHJ5cG9pbnRzLmpzYC4gRG8gbm90IGVkaXQgbWFudWFsbHkuXG5leHBvcnQgY29uc3Qgb3B0aW9uYWxJbXBvcnRFbnRyeXBvaW50cyA9IFtdO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/import_constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/import_map.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/import_map.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   agents: () => (/* reexport module object */ _agents_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   caches: () => (/* reexport module object */ _caches_base_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   callbacks__base: () => (/* reexport module object */ _callbacks_base_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   callbacks__manager: () => (/* reexport module object */ _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   callbacks__promises: () => (/* reexport module object */ _callbacks_promises_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   chat_history: () => (/* reexport module object */ _chat_history_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   documents: () => (/* reexport module object */ _documents_index_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   embeddings: () => (/* reexport module object */ _embeddings_js__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   example_selectors: () => (/* reexport module object */ _example_selectors_index_js__WEBPACK_IMPORTED_MODULE_8__),\n/* harmony export */   language_models__base: () => (/* reexport module object */ _language_models_base_js__WEBPACK_IMPORTED_MODULE_9__),\n/* harmony export */   language_models__chat_models: () => (/* reexport module object */ _language_models_chat_models_js__WEBPACK_IMPORTED_MODULE_10__),\n/* harmony export */   language_models__llms: () => (/* reexport module object */ _language_models_llms_js__WEBPACK_IMPORTED_MODULE_11__),\n/* harmony export */   load__serializable: () => (/* reexport module object */ _load_serializable_js__WEBPACK_IMPORTED_MODULE_12__),\n/* harmony export */   memory: () => (/* reexport module object */ _memory_js__WEBPACK_IMPORTED_MODULE_13__),\n/* harmony export */   messages: () => (/* reexport module object */ _messages_index_js__WEBPACK_IMPORTED_MODULE_14__),\n/* harmony export */   output_parsers: () => (/* reexport module object */ _output_parsers_index_js__WEBPACK_IMPORTED_MODULE_15__),\n/* harmony export */   outputs: () => (/* reexport module object */ _outputs_js__WEBPACK_IMPORTED_MODULE_16__),\n/* harmony export */   prompt_values: () => (/* reexport module object */ _prompt_values_js__WEBPACK_IMPORTED_MODULE_18__),\n/* harmony export */   prompts: () => (/* reexport module object */ _prompts_index_js__WEBPACK_IMPORTED_MODULE_17__),\n/* harmony export */   retrievers: () => (/* reexport module object */ _retrievers_index_js__WEBPACK_IMPORTED_MODULE_20__),\n/* harmony export */   runnables: () => (/* reexport module object */ _runnables_index_js__WEBPACK_IMPORTED_MODULE_19__),\n/* harmony export */   stores: () => (/* reexport module object */ _stores_js__WEBPACK_IMPORTED_MODULE_21__),\n/* harmony export */   tools: () => (/* reexport module object */ _tools_index_js__WEBPACK_IMPORTED_MODULE_22__),\n/* harmony export */   tracers__base: () => (/* reexport module object */ _tracers_base_js__WEBPACK_IMPORTED_MODULE_23__),\n/* harmony export */   tracers__console: () => (/* reexport module object */ _tracers_console_js__WEBPACK_IMPORTED_MODULE_24__),\n/* harmony export */   tracers__initialize: () => (/* reexport module object */ _tracers_initialize_js__WEBPACK_IMPORTED_MODULE_25__),\n/* harmony export */   tracers__log_stream: () => (/* reexport module object */ _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_26__),\n/* harmony export */   tracers__run_collector: () => (/* reexport module object */ _tracers_run_collector_js__WEBPACK_IMPORTED_MODULE_27__),\n/* harmony export */   tracers__tracer_langchain: () => (/* reexport module object */ _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_28__),\n/* harmony export */   tracers__tracer_langchain_v1: () => (/* reexport module object */ _tracers_tracer_langchain_v1_js__WEBPACK_IMPORTED_MODULE_29__),\n/* harmony export */   utils__async_caller: () => (/* reexport module object */ _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_30__),\n/* harmony export */   utils__chunk_array: () => (/* reexport module object */ _utils_chunk_array_js__WEBPACK_IMPORTED_MODULE_31__),\n/* harmony export */   utils__env: () => (/* reexport module object */ _utils_env_js__WEBPACK_IMPORTED_MODULE_32__),\n/* harmony export */   utils__function_calling: () => (/* reexport module object */ _utils_function_calling_js__WEBPACK_IMPORTED_MODULE_33__),\n/* harmony export */   utils__hash: () => (/* reexport module object */ _utils_hash_js__WEBPACK_IMPORTED_MODULE_34__),\n/* harmony export */   utils__json_patch: () => (/* reexport module object */ _utils_json_patch_js__WEBPACK_IMPORTED_MODULE_35__),\n/* harmony export */   utils__json_schema: () => (/* reexport module object */ _utils_json_schema_js__WEBPACK_IMPORTED_MODULE_36__),\n/* harmony export */   utils__math: () => (/* reexport module object */ _utils_math_js__WEBPACK_IMPORTED_MODULE_37__),\n/* harmony export */   utils__stream: () => (/* reexport module object */ _utils_stream_js__WEBPACK_IMPORTED_MODULE_38__),\n/* harmony export */   utils__testing: () => (/* reexport module object */ _utils_testing_index_js__WEBPACK_IMPORTED_MODULE_39__),\n/* harmony export */   utils__tiktoken: () => (/* reexport module object */ _utils_tiktoken_js__WEBPACK_IMPORTED_MODULE_40__),\n/* harmony export */   utils__types: () => (/* reexport module object */ _utils_types_index_js__WEBPACK_IMPORTED_MODULE_41__),\n/* harmony export */   vectorstores: () => (/* reexport module object */ _vectorstores_js__WEBPACK_IMPORTED_MODULE_42__)\n/* harmony export */ });\n/* harmony import */ var _agents_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../agents.js */ \"(rsc)/./node_modules/@langchain/core/dist/agents.js\");\n/* harmony import */ var _caches_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../caches/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/caches/base.js\");\n/* harmony import */ var _callbacks_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../callbacks/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.js\");\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../callbacks/manager.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* harmony import */ var _callbacks_promises_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../callbacks/promises.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.js\");\n/* harmony import */ var _chat_history_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../chat_history.js */ \"(rsc)/./node_modules/@langchain/core/dist/chat_history.js\");\n/* harmony import */ var _documents_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../documents/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/documents/index.js\");\n/* harmony import */ var _embeddings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../embeddings.js */ \"(rsc)/./node_modules/@langchain/core/dist/embeddings.js\");\n/* harmony import */ var _example_selectors_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../example_selectors/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/example_selectors/index.js\");\n/* harmony import */ var _language_models_base_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../language_models/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.js\");\n/* harmony import */ var _language_models_chat_models_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../language_models/chat_models.js */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.js\");\n/* harmony import */ var _language_models_llms_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../language_models/llms.js */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/llms.js\");\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../load/serializable.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _memory_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../memory.js */ \"(rsc)/./node_modules/@langchain/core/dist/memory.js\");\n/* harmony import */ var _messages_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../messages/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.js\");\n/* harmony import */ var _output_parsers_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../output_parsers/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/index.js\");\n/* harmony import */ var _outputs_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../outputs.js */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.js\");\n/* harmony import */ var _prompts_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../prompts/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/index.js\");\n/* harmony import */ var _prompt_values_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../prompt_values.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.js\");\n/* harmony import */ var _runnables_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../runnables/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/index.js\");\n/* harmony import */ var _retrievers_index_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../retrievers/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/retrievers/index.js\");\n/* harmony import */ var _stores_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../stores.js */ \"(rsc)/./node_modules/@langchain/core/dist/stores.js\");\n/* harmony import */ var _tools_index_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../tools/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/tools/index.js\");\n/* harmony import */ var _tracers_base_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../tracers/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\");\n/* harmony import */ var _tracers_console_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../tracers/console.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/console.js\");\n/* harmony import */ var _tracers_initialize_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../tracers/initialize.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/initialize.js\");\n/* harmony import */ var _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../tracers/log_stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.js\");\n/* harmony import */ var _tracers_run_collector_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../tracers/run_collector.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/run_collector.js\");\n/* harmony import */ var _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../tracers/tracer_langchain.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.js\");\n/* harmony import */ var _tracers_tracer_langchain_v1_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../tracers/tracer_langchain_v1.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain_v1.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../utils/async_caller.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_chunk_array_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../utils/chunk_array.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.js\");\n/* harmony import */ var _utils_function_calling_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../utils/function_calling.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.js\");\n/* harmony import */ var _utils_hash_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../utils/hash.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/hash.js\");\n/* harmony import */ var _utils_json_patch_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ../utils/json_patch.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.js\");\n/* harmony import */ var _utils_json_schema_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../utils/json_schema.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ../utils/math.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/math.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ../utils/stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _utils_testing_index_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ../utils/testing/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/testing/index.js\");\n/* harmony import */ var _utils_tiktoken_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ../utils/tiktoken.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.js\");\n/* harmony import */ var _utils_types_index_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ../utils/types/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/index.js\");\n/* harmony import */ var _vectorstores_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ../vectorstores.js */ \"(rsc)/./node_modules/@langchain/core/dist/vectorstores.js\");\n// Auto-generated by `scripts/create-entrypoints.js`. Do not edit manually.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9pbXBvcnRfbWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDdUM7QUFDSztBQUNZO0FBQ007QUFDRTtBQUNiO0FBQ0E7QUFDSjtBQUNvQjtBQUNDO0FBQ2M7QUFDZDtBQUNOO0FBQ3ZCO0FBQ1U7QUFDWTtBQUNwQjtBQUNNO0FBQ007QUFDRjtBQUNFO0FBQ2Q7QUFDSTtBQUNTO0FBQ007QUFDTTtBQUNBO0FBQ007QUFDTTtBQUNNO0FBQ2xCO0FBQ0Y7QUFDaEI7QUFDMEI7QUFDeEI7QUFDWTtBQUNFO0FBQ2Q7QUFDSTtBQUNRO0FBQ0o7QUFDQTtBQUNMIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGxvYWRcXGltcG9ydF9tYXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQXV0by1nZW5lcmF0ZWQgYnkgYHNjcmlwdHMvY3JlYXRlLWVudHJ5cG9pbnRzLmpzYC4gRG8gbm90IGVkaXQgbWFudWFsbHkuXG5leHBvcnQgKiBhcyBhZ2VudHMgZnJvbSBcIi4uL2FnZW50cy5qc1wiO1xuZXhwb3J0ICogYXMgY2FjaGVzIGZyb20gXCIuLi9jYWNoZXMvYmFzZS5qc1wiO1xuZXhwb3J0ICogYXMgY2FsbGJhY2tzX19iYXNlIGZyb20gXCIuLi9jYWxsYmFja3MvYmFzZS5qc1wiO1xuZXhwb3J0ICogYXMgY2FsbGJhY2tzX19tYW5hZ2VyIGZyb20gXCIuLi9jYWxsYmFja3MvbWFuYWdlci5qc1wiO1xuZXhwb3J0ICogYXMgY2FsbGJhY2tzX19wcm9taXNlcyBmcm9tIFwiLi4vY2FsbGJhY2tzL3Byb21pc2VzLmpzXCI7XG5leHBvcnQgKiBhcyBjaGF0X2hpc3RvcnkgZnJvbSBcIi4uL2NoYXRfaGlzdG9yeS5qc1wiO1xuZXhwb3J0ICogYXMgZG9jdW1lbnRzIGZyb20gXCIuLi9kb2N1bWVudHMvaW5kZXguanNcIjtcbmV4cG9ydCAqIGFzIGVtYmVkZGluZ3MgZnJvbSBcIi4uL2VtYmVkZGluZ3MuanNcIjtcbmV4cG9ydCAqIGFzIGV4YW1wbGVfc2VsZWN0b3JzIGZyb20gXCIuLi9leGFtcGxlX3NlbGVjdG9ycy9pbmRleC5qc1wiO1xuZXhwb3J0ICogYXMgbGFuZ3VhZ2VfbW9kZWxzX19iYXNlIGZyb20gXCIuLi9sYW5ndWFnZV9tb2RlbHMvYmFzZS5qc1wiO1xuZXhwb3J0ICogYXMgbGFuZ3VhZ2VfbW9kZWxzX19jaGF0X21vZGVscyBmcm9tIFwiLi4vbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzLmpzXCI7XG5leHBvcnQgKiBhcyBsYW5ndWFnZV9tb2RlbHNfX2xsbXMgZnJvbSBcIi4uL2xhbmd1YWdlX21vZGVscy9sbG1zLmpzXCI7XG5leHBvcnQgKiBhcyBsb2FkX19zZXJpYWxpemFibGUgZnJvbSBcIi4uL2xvYWQvc2VyaWFsaXphYmxlLmpzXCI7XG5leHBvcnQgKiBhcyBtZW1vcnkgZnJvbSBcIi4uL21lbW9yeS5qc1wiO1xuZXhwb3J0ICogYXMgbWVzc2FnZXMgZnJvbSBcIi4uL21lc3NhZ2VzL2luZGV4LmpzXCI7XG5leHBvcnQgKiBhcyBvdXRwdXRfcGFyc2VycyBmcm9tIFwiLi4vb3V0cHV0X3BhcnNlcnMvaW5kZXguanNcIjtcbmV4cG9ydCAqIGFzIG91dHB1dHMgZnJvbSBcIi4uL291dHB1dHMuanNcIjtcbmV4cG9ydCAqIGFzIHByb21wdHMgZnJvbSBcIi4uL3Byb21wdHMvaW5kZXguanNcIjtcbmV4cG9ydCAqIGFzIHByb21wdF92YWx1ZXMgZnJvbSBcIi4uL3Byb21wdF92YWx1ZXMuanNcIjtcbmV4cG9ydCAqIGFzIHJ1bm5hYmxlcyBmcm9tIFwiLi4vcnVubmFibGVzL2luZGV4LmpzXCI7XG5leHBvcnQgKiBhcyByZXRyaWV2ZXJzIGZyb20gXCIuLi9yZXRyaWV2ZXJzL2luZGV4LmpzXCI7XG5leHBvcnQgKiBhcyBzdG9yZXMgZnJvbSBcIi4uL3N0b3Jlcy5qc1wiO1xuZXhwb3J0ICogYXMgdG9vbHMgZnJvbSBcIi4uL3Rvb2xzL2luZGV4LmpzXCI7XG5leHBvcnQgKiBhcyB0cmFjZXJzX19iYXNlIGZyb20gXCIuLi90cmFjZXJzL2Jhc2UuanNcIjtcbmV4cG9ydCAqIGFzIHRyYWNlcnNfX2NvbnNvbGUgZnJvbSBcIi4uL3RyYWNlcnMvY29uc29sZS5qc1wiO1xuZXhwb3J0ICogYXMgdHJhY2Vyc19faW5pdGlhbGl6ZSBmcm9tIFwiLi4vdHJhY2Vycy9pbml0aWFsaXplLmpzXCI7XG5leHBvcnQgKiBhcyB0cmFjZXJzX19sb2dfc3RyZWFtIGZyb20gXCIuLi90cmFjZXJzL2xvZ19zdHJlYW0uanNcIjtcbmV4cG9ydCAqIGFzIHRyYWNlcnNfX3J1bl9jb2xsZWN0b3IgZnJvbSBcIi4uL3RyYWNlcnMvcnVuX2NvbGxlY3Rvci5qc1wiO1xuZXhwb3J0ICogYXMgdHJhY2Vyc19fdHJhY2VyX2xhbmdjaGFpbiBmcm9tIFwiLi4vdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmpzXCI7XG5leHBvcnQgKiBhcyB0cmFjZXJzX190cmFjZXJfbGFuZ2NoYWluX3YxIGZyb20gXCIuLi90cmFjZXJzL3RyYWNlcl9sYW5nY2hhaW5fdjEuanNcIjtcbmV4cG9ydCAqIGFzIHV0aWxzX19hc3luY19jYWxsZXIgZnJvbSBcIi4uL3V0aWxzL2FzeW5jX2NhbGxlci5qc1wiO1xuZXhwb3J0ICogYXMgdXRpbHNfX2NodW5rX2FycmF5IGZyb20gXCIuLi91dGlscy9jaHVua19hcnJheS5qc1wiO1xuZXhwb3J0ICogYXMgdXRpbHNfX2VudiBmcm9tIFwiLi4vdXRpbHMvZW52LmpzXCI7XG5leHBvcnQgKiBhcyB1dGlsc19fZnVuY3Rpb25fY2FsbGluZyBmcm9tIFwiLi4vdXRpbHMvZnVuY3Rpb25fY2FsbGluZy5qc1wiO1xuZXhwb3J0ICogYXMgdXRpbHNfX2hhc2ggZnJvbSBcIi4uL3V0aWxzL2hhc2guanNcIjtcbmV4cG9ydCAqIGFzIHV0aWxzX19qc29uX3BhdGNoIGZyb20gXCIuLi91dGlscy9qc29uX3BhdGNoLmpzXCI7XG5leHBvcnQgKiBhcyB1dGlsc19fanNvbl9zY2hlbWEgZnJvbSBcIi4uL3V0aWxzL2pzb25fc2NoZW1hLmpzXCI7XG5leHBvcnQgKiBhcyB1dGlsc19fbWF0aCBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuZXhwb3J0ICogYXMgdXRpbHNfX3N0cmVhbSBmcm9tIFwiLi4vdXRpbHMvc3RyZWFtLmpzXCI7XG5leHBvcnQgKiBhcyB1dGlsc19fdGVzdGluZyBmcm9tIFwiLi4vdXRpbHMvdGVzdGluZy9pbmRleC5qc1wiO1xuZXhwb3J0ICogYXMgdXRpbHNfX3Rpa3Rva2VuIGZyb20gXCIuLi91dGlscy90aWt0b2tlbi5qc1wiO1xuZXhwb3J0ICogYXMgdXRpbHNfX3R5cGVzIGZyb20gXCIuLi91dGlscy90eXBlcy9pbmRleC5qc1wiO1xuZXhwb3J0ICogYXMgdmVjdG9yc3RvcmVzIGZyb20gXCIuLi92ZWN0b3JzdG9yZXMuanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/import_map.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   load: () => (/* binding */ load)\n/* harmony export */ });\n/* harmony import */ var _serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./serializable.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _import_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./import_constants.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/import_constants.js\");\n/* harmony import */ var _import_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./import_map.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/import_map.js\");\n/* harmony import */ var _map_keys_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map_keys.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/map_keys.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.js\");\n/* harmony import */ var _validation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./validation.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/validation.js\");\n/**\n * Load LangChain objects from JSON strings or objects.\n *\n * ## How it works\n *\n * Each `Serializable` LangChain object has a unique identifier (its \"class path\"),\n * which is a list of strings representing the module path and class name. For example:\n *\n * - `AIMessage` -> `[\"langchain_core\", \"messages\", \"ai\", \"AIMessage\"]`\n * - `ChatPromptTemplate` -> `[\"langchain_core\", \"prompts\", \"chat\", \"ChatPromptTemplate\"]`\n *\n * When deserializing, the class path is validated against supported namespaces.\n *\n * ## Security model\n *\n * The `secretsFromEnv` parameter controls whether secrets can be loaded from environment\n * variables:\n *\n * - `false` (default): Secrets must be provided in `secretsMap`. If a secret is not\n *   found, `null` is returned instead of loading from environment variables.\n * - `true`: If a secret is not found in `secretsMap`, it will be loaded from\n *   environment variables. Use this only in trusted environments.\n *\n * ### Injection protection (escape-based)\n *\n * During serialization, plain objects that contain an `'lc'` key are escaped by wrapping\n * them: `{\"__lc_escaped__\": {...}}`. During deserialization, escaped objects are unwrapped\n * and returned as plain objects, NOT instantiated as LC objects.\n *\n * This is an allowlist approach: only objects explicitly produced by\n * `Serializable.toJSON()` (which are NOT escaped) are treated as LC objects;\n * everything else is user data.\n *\n * @module\n */\n\n\n\n\n\n\n/**\n * Default maximum recursion depth for deserialization.\n * This provides protection against DoS attacks via deeply nested structures.\n */\nconst DEFAULT_MAX_DEPTH = 50;\nfunction combineAliasesAndInvert(constructor) {\n    const aliases = {};\n    for (\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let current = constructor; current && current.prototype; current = Object.getPrototypeOf(current)) {\n        Object.assign(aliases, Reflect.get(current.prototype, \"lc_aliases\"));\n    }\n    return Object.entries(aliases).reduce((acc, [key, value]) => {\n        acc[value] = key;\n        return acc;\n    }, {});\n}\n/**\n * Recursively revive a value, handling escape markers and LC objects.\n *\n * This function handles:\n * 1. Escaped dicts - unwrapped and returned as plain objects\n * 2. LC secret objects - resolved from secretsMap or env\n * 3. LC constructor objects - instantiated\n * 4. Regular objects/arrays - recursed into\n */\nasync function reviver(value) {\n    const { optionalImportsMap, optionalImportEntrypoints, importMap, secretsMap, secretsFromEnv, path, depth, maxDepth, } = this;\n    const pathStr = path.join(\".\");\n    // Check recursion depth to prevent DoS via deeply nested structures\n    if (depth > maxDepth) {\n        throw new Error(`Maximum recursion depth (${maxDepth}) exceeded during deserialization. ` +\n            `This may indicate a malicious payload or you may need to increase maxDepth.`);\n    }\n    // If not an object, return as-is\n    if (typeof value !== \"object\" || value == null) {\n        return value;\n    }\n    // Handle arrays - recurse into elements\n    if (Array.isArray(value)) {\n        return Promise.all(value.map((v, i) => reviver.call({ ...this, path: [...path, `${i}`], depth: depth + 1 }, v)));\n    }\n    // It's an object - check for escape marker FIRST\n    const record = value;\n    if ((0,_validation_js__WEBPACK_IMPORTED_MODULE_5__.isEscapedObject)(record)) {\n        // This is an escaped user object - unwrap and return as-is (no LC processing)\n        return (0,_validation_js__WEBPACK_IMPORTED_MODULE_5__.unescapeValue)(record);\n    }\n    // Check for LC secret object\n    if (\"lc\" in record &&\n        \"type\" in record &&\n        \"id\" in record &&\n        record.lc === 1 &&\n        record.type === \"secret\") {\n        const serialized = record;\n        const [key] = serialized.id;\n        if (key in secretsMap) {\n            return secretsMap[key];\n        }\n        else if (secretsFromEnv) {\n            const secretValueInEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(key);\n            if (secretValueInEnv) {\n                return secretValueInEnv;\n            }\n        }\n        throw new Error(`Missing secret \"${key}\" at ${pathStr}`);\n    }\n    // Check for LC not_implemented object\n    if (\"lc\" in record &&\n        \"type\" in record &&\n        \"id\" in record &&\n        record.lc === 1 &&\n        record.type === \"not_implemented\") {\n        const serialized = record;\n        const str = JSON.stringify(serialized);\n        throw new Error(`Trying to load an object that doesn't implement serialization: ${pathStr} -> ${str}`);\n    }\n    // Check for LC constructor object\n    if (\"lc\" in record &&\n        \"type\" in record &&\n        \"id\" in record &&\n        \"kwargs\" in record &&\n        record.lc === 1 &&\n        record.type === \"constructor\") {\n        const serialized = record;\n        const str = JSON.stringify(serialized);\n        const [name, ...namespaceReverse] = serialized.id.slice().reverse();\n        const namespace = namespaceReverse.reverse();\n        const importMaps = { langchain_core: _import_map_js__WEBPACK_IMPORTED_MODULE_2__, langchain: importMap };\n        let module = null;\n        const optionalImportNamespaceAliases = [namespace.join(\"/\")];\n        if (namespace[0] === \"langchain_community\") {\n            optionalImportNamespaceAliases.push([\"langchain\", ...namespace.slice(1)].join(\"/\"));\n        }\n        const matchingNamespaceAlias = optionalImportNamespaceAliases.find((alias) => alias in optionalImportsMap);\n        if (_import_constants_js__WEBPACK_IMPORTED_MODULE_1__.optionalImportEntrypoints\n            .concat(optionalImportEntrypoints)\n            .includes(namespace.join(\"/\")) ||\n            matchingNamespaceAlias) {\n            if (matchingNamespaceAlias !== undefined) {\n                module = await optionalImportsMap[matchingNamespaceAlias];\n            }\n            else {\n                throw new Error(`Missing key \"${namespace.join(\"/\")}\" for ${pathStr} in load(optionalImportsMap={})`);\n            }\n        }\n        else {\n            let finalImportMap;\n            // Currently, we only support langchain and langchain_core imports.\n            if (namespace[0] === \"langchain\" || namespace[0] === \"langchain_core\") {\n                finalImportMap = importMaps[namespace[0]];\n                namespace.shift();\n            }\n            else {\n                throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n            }\n            // The root namespace \"langchain\" is not a valid import.\n            if (namespace.length === 0) {\n                throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n            }\n            // Find the longest matching namespace.\n            let importMapKey;\n            do {\n                importMapKey = namespace.join(\"__\");\n                if (importMapKey in finalImportMap) {\n                    break;\n                }\n                else {\n                    namespace.pop();\n                }\n            } while (namespace.length > 0);\n            // If no matching namespace is found, throw an error.\n            if (importMapKey in finalImportMap) {\n                module = finalImportMap[importMapKey];\n            }\n        }\n        if (typeof module !== \"object\" || module === null) {\n            throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n        }\n        // Extract the builder from the import map.\n        const builder = \n        // look for a named export with the same name as the class\n        module[name] ??\n            // look for an export with a lc_name property matching the class name\n            // this is necessary for classes that are minified\n            Object.values(module).find((v) => typeof v === \"function\" &&\n                (0,_serializable_js__WEBPACK_IMPORTED_MODULE_0__.get_lc_unique_name)(v) === name);\n        if (typeof builder !== \"function\") {\n            throw new Error(`Invalid identifer: ${pathStr} -> ${str}`);\n        }\n        // Recurse on the arguments, which may be serialized objects themselves\n        const kwargs = await reviver.call({ ...this, path: [...path, \"kwargs\"], depth: depth + 1 }, serialized.kwargs);\n        // Construct the object\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const instance = new builder((0,_map_keys_js__WEBPACK_IMPORTED_MODULE_3__.mapKeys)(kwargs, _map_keys_js__WEBPACK_IMPORTED_MODULE_3__.keyFromJson, combineAliasesAndInvert(builder)));\n        // Minification in severless/edge runtimes will mange the\n        // name of classes presented in traces. As the names in import map\n        // are present as-is even with minification, use these names instead\n        Object.defineProperty(instance.constructor, \"name\", { value: name });\n        return instance;\n    }\n    // Regular object - recurse into values\n    const result = {};\n    for (const [key, val] of Object.entries(record)) {\n        result[key] = await reviver.call({ ...this, path: [...path, key], depth: depth + 1 }, val);\n    }\n    return result;\n}\n/**\n * Load a LangChain object from a JSON string.\n *\n * @param text - The JSON string to parse and load.\n * @param options - Options for loading.\n * @returns The loaded LangChain object.\n *\n * @example\n * ```typescript\n * import { load } from \"@langchain/core/load\";\n * import { AIMessage } from \"@langchain/core/messages\";\n *\n * // Basic usage - secrets must be provided explicitly\n * const msg = await load<AIMessage>(jsonString);\n *\n * // With secrets from a map\n * const msg = await load<AIMessage>(jsonString, {\n *   secretsMap: { OPENAI_API_KEY: \"sk-...\" }\n * });\n *\n * // Allow loading secrets from environment (use with caution)\n * const msg = await load<AIMessage>(jsonString, {\n *   secretsFromEnv: true\n * });\n * ```\n */\nasync function load(text, options) {\n    const json = JSON.parse(text);\n    const context = {\n        optionalImportsMap: options?.optionalImportsMap ?? {},\n        optionalImportEntrypoints: options?.optionalImportEntrypoints ?? [],\n        secretsMap: options?.secretsMap ?? {},\n        secretsFromEnv: options?.secretsFromEnv ?? false,\n        importMap: options?.importMap ?? {},\n        path: [\"$\"],\n        depth: 0,\n        maxDepth: options?.maxDepth ?? DEFAULT_MAX_DEPTH,\n    };\n    return reviver.call(context, json);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3RDtBQUM4QztBQUNyRDtBQUNJO0FBQ0k7QUFDUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOEJBQThCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrR0FBK0c7QUFDM0g7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw0QkFBNEIsRUFBRSxzQkFBc0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBZTtBQUN2QjtBQUNBLGVBQWUsNkRBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUVBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUksT0FBTyxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixTQUFTLEtBQUssSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCLDJDQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkVBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQixRQUFRLFNBQVMsNkJBQTZCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVMsS0FBSyxJQUFJO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTLEtBQUssSUFBSTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTLEtBQUssSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9FQUFrQjtBQUNsQztBQUNBLGtEQUFrRCxTQUFTLEtBQUssSUFBSTtBQUNwRTtBQUNBO0FBQ0EsNENBQTRDLHNEQUFzRDtBQUNsRztBQUNBO0FBQ0EscUNBQXFDLHFEQUFPLFNBQVMscURBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpREFBaUQ7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGxvYWRcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTG9hZCBMYW5nQ2hhaW4gb2JqZWN0cyBmcm9tIEpTT04gc3RyaW5ncyBvciBvYmplY3RzLlxuICpcbiAqICMjIEhvdyBpdCB3b3Jrc1xuICpcbiAqIEVhY2ggYFNlcmlhbGl6YWJsZWAgTGFuZ0NoYWluIG9iamVjdCBoYXMgYSB1bmlxdWUgaWRlbnRpZmllciAoaXRzIFwiY2xhc3MgcGF0aFwiKSxcbiAqIHdoaWNoIGlzIGEgbGlzdCBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgbW9kdWxlIHBhdGggYW5kIGNsYXNzIG5hbWUuIEZvciBleGFtcGxlOlxuICpcbiAqIC0gYEFJTWVzc2FnZWAgLT4gYFtcImxhbmdjaGFpbl9jb3JlXCIsIFwibWVzc2FnZXNcIiwgXCJhaVwiLCBcIkFJTWVzc2FnZVwiXWBcbiAqIC0gYENoYXRQcm9tcHRUZW1wbGF0ZWAgLT4gYFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicHJvbXB0c1wiLCBcImNoYXRcIiwgXCJDaGF0UHJvbXB0VGVtcGxhdGVcIl1gXG4gKlxuICogV2hlbiBkZXNlcmlhbGl6aW5nLCB0aGUgY2xhc3MgcGF0aCBpcyB2YWxpZGF0ZWQgYWdhaW5zdCBzdXBwb3J0ZWQgbmFtZXNwYWNlcy5cbiAqXG4gKiAjIyBTZWN1cml0eSBtb2RlbFxuICpcbiAqIFRoZSBgc2VjcmV0c0Zyb21FbnZgIHBhcmFtZXRlciBjb250cm9scyB3aGV0aGVyIHNlY3JldHMgY2FuIGJlIGxvYWRlZCBmcm9tIGVudmlyb25tZW50XG4gKiB2YXJpYWJsZXM6XG4gKlxuICogLSBgZmFsc2VgIChkZWZhdWx0KTogU2VjcmV0cyBtdXN0IGJlIHByb3ZpZGVkIGluIGBzZWNyZXRzTWFwYC4gSWYgYSBzZWNyZXQgaXMgbm90XG4gKiAgIGZvdW5kLCBgbnVsbGAgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBsb2FkaW5nIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICogLSBgdHJ1ZWA6IElmIGEgc2VjcmV0IGlzIG5vdCBmb3VuZCBpbiBgc2VjcmV0c01hcGAsIGl0IHdpbGwgYmUgbG9hZGVkIGZyb21cbiAqICAgZW52aXJvbm1lbnQgdmFyaWFibGVzLiBVc2UgdGhpcyBvbmx5IGluIHRydXN0ZWQgZW52aXJvbm1lbnRzLlxuICpcbiAqICMjIyBJbmplY3Rpb24gcHJvdGVjdGlvbiAoZXNjYXBlLWJhc2VkKVxuICpcbiAqIER1cmluZyBzZXJpYWxpemF0aW9uLCBwbGFpbiBvYmplY3RzIHRoYXQgY29udGFpbiBhbiBgJ2xjJ2Aga2V5IGFyZSBlc2NhcGVkIGJ5IHdyYXBwaW5nXG4gKiB0aGVtOiBge1wiX19sY19lc2NhcGVkX19cIjogey4uLn19YC4gRHVyaW5nIGRlc2VyaWFsaXphdGlvbiwgZXNjYXBlZCBvYmplY3RzIGFyZSB1bndyYXBwZWRcbiAqIGFuZCByZXR1cm5lZCBhcyBwbGFpbiBvYmplY3RzLCBOT1QgaW5zdGFudGlhdGVkIGFzIExDIG9iamVjdHMuXG4gKlxuICogVGhpcyBpcyBhbiBhbGxvd2xpc3QgYXBwcm9hY2g6IG9ubHkgb2JqZWN0cyBleHBsaWNpdGx5IHByb2R1Y2VkIGJ5XG4gKiBgU2VyaWFsaXphYmxlLnRvSlNPTigpYCAod2hpY2ggYXJlIE5PVCBlc2NhcGVkKSBhcmUgdHJlYXRlZCBhcyBMQyBvYmplY3RzO1xuICogZXZlcnl0aGluZyBlbHNlIGlzIHVzZXIgZGF0YS5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGdldF9sY191bmlxdWVfbmFtZSwgfSBmcm9tIFwiLi9zZXJpYWxpemFibGUuanNcIjtcbmltcG9ydCB7IG9wdGlvbmFsSW1wb3J0RW50cnlwb2ludHMgYXMgZGVmYXVsdE9wdGlvbmFsSW1wb3J0RW50cnlwb2ludHMgfSBmcm9tIFwiLi9pbXBvcnRfY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgKiBhcyBjb3JlSW1wb3J0TWFwIGZyb20gXCIuL2ltcG9ydF9tYXAuanNcIjtcbmltcG9ydCB7IGtleUZyb21Kc29uLCBtYXBLZXlzIH0gZnJvbSBcIi4vbWFwX2tleXMuanNcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBpc0VzY2FwZWRPYmplY3QsIHVuZXNjYXBlVmFsdWUgfSBmcm9tIFwiLi92YWxpZGF0aW9uLmpzXCI7XG4vKipcbiAqIERlZmF1bHQgbWF4aW11bSByZWN1cnNpb24gZGVwdGggZm9yIGRlc2VyaWFsaXphdGlvbi5cbiAqIFRoaXMgcHJvdmlkZXMgcHJvdGVjdGlvbiBhZ2FpbnN0IERvUyBhdHRhY2tzIHZpYSBkZWVwbHkgbmVzdGVkIHN0cnVjdHVyZXMuXG4gKi9cbmNvbnN0IERFRkFVTFRfTUFYX0RFUFRIID0gNTA7XG5mdW5jdGlvbiBjb21iaW5lQWxpYXNlc0FuZEludmVydChjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGFsaWFzZXMgPSB7fTtcbiAgICBmb3IgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgIGxldCBjdXJyZW50ID0gY29uc3RydWN0b3I7IGN1cnJlbnQgJiYgY3VycmVudC5wcm90b3R5cGU7IGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudCkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhbGlhc2VzLCBSZWZsZWN0LmdldChjdXJyZW50LnByb3RvdHlwZSwgXCJsY19hbGlhc2VzXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGFsaWFzZXMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgYWNjW3ZhbHVlXSA9IGtleTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJldml2ZSBhIHZhbHVlLCBoYW5kbGluZyBlc2NhcGUgbWFya2VycyBhbmQgTEMgb2JqZWN0cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhbmRsZXM6XG4gKiAxLiBFc2NhcGVkIGRpY3RzIC0gdW53cmFwcGVkIGFuZCByZXR1cm5lZCBhcyBwbGFpbiBvYmplY3RzXG4gKiAyLiBMQyBzZWNyZXQgb2JqZWN0cyAtIHJlc29sdmVkIGZyb20gc2VjcmV0c01hcCBvciBlbnZcbiAqIDMuIExDIGNvbnN0cnVjdG9yIG9iamVjdHMgLSBpbnN0YW50aWF0ZWRcbiAqIDQuIFJlZ3VsYXIgb2JqZWN0cy9hcnJheXMgLSByZWN1cnNlZCBpbnRvXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJldml2ZXIodmFsdWUpIHtcbiAgICBjb25zdCB7IG9wdGlvbmFsSW1wb3J0c01hcCwgb3B0aW9uYWxJbXBvcnRFbnRyeXBvaW50cywgaW1wb3J0TWFwLCBzZWNyZXRzTWFwLCBzZWNyZXRzRnJvbUVudiwgcGF0aCwgZGVwdGgsIG1heERlcHRoLCB9ID0gdGhpcztcbiAgICBjb25zdCBwYXRoU3RyID0gcGF0aC5qb2luKFwiLlwiKTtcbiAgICAvLyBDaGVjayByZWN1cnNpb24gZGVwdGggdG8gcHJldmVudCBEb1MgdmlhIGRlZXBseSBuZXN0ZWQgc3RydWN0dXJlc1xuICAgIGlmIChkZXB0aCA+IG1heERlcHRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWF4aW11bSByZWN1cnNpb24gZGVwdGggKCR7bWF4RGVwdGh9KSBleGNlZWRlZCBkdXJpbmcgZGVzZXJpYWxpemF0aW9uLiBgICtcbiAgICAgICAgICAgIGBUaGlzIG1heSBpbmRpY2F0ZSBhIG1hbGljaW91cyBwYXlsb2FkIG9yIHlvdSBtYXkgbmVlZCB0byBpbmNyZWFzZSBtYXhEZXB0aC5gKTtcbiAgICB9XG4gICAgLy8gSWYgbm90IGFuIG9iamVjdCwgcmV0dXJuIGFzLWlzXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGFycmF5cyAtIHJlY3Vyc2UgaW50byBlbGVtZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsdWUubWFwKCh2LCBpKSA9PiByZXZpdmVyLmNhbGwoeyAuLi50aGlzLCBwYXRoOiBbLi4ucGF0aCwgYCR7aX1gXSwgZGVwdGg6IGRlcHRoICsgMSB9LCB2KSkpO1xuICAgIH1cbiAgICAvLyBJdCdzIGFuIG9iamVjdCAtIGNoZWNrIGZvciBlc2NhcGUgbWFya2VyIEZJUlNUXG4gICAgY29uc3QgcmVjb3JkID0gdmFsdWU7XG4gICAgaWYgKGlzRXNjYXBlZE9iamVjdChyZWNvcmQpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gZXNjYXBlZCB1c2VyIG9iamVjdCAtIHVud3JhcCBhbmQgcmV0dXJuIGFzLWlzIChubyBMQyBwcm9jZXNzaW5nKVxuICAgICAgICByZXR1cm4gdW5lc2NhcGVWYWx1ZShyZWNvcmQpO1xuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgTEMgc2VjcmV0IG9iamVjdFxuICAgIGlmIChcImxjXCIgaW4gcmVjb3JkICYmXG4gICAgICAgIFwidHlwZVwiIGluIHJlY29yZCAmJlxuICAgICAgICBcImlkXCIgaW4gcmVjb3JkICYmXG4gICAgICAgIHJlY29yZC5sYyA9PT0gMSAmJlxuICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJzZWNyZXRcIikge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gcmVjb3JkO1xuICAgICAgICBjb25zdCBba2V5XSA9IHNlcmlhbGl6ZWQuaWQ7XG4gICAgICAgIGlmIChrZXkgaW4gc2VjcmV0c01hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3JldHNNYXBba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWNyZXRzRnJvbUVudikge1xuICAgICAgICAgICAgY29uc3Qgc2VjcmV0VmFsdWVJbkVudiA9IGdldEVudmlyb25tZW50VmFyaWFibGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChzZWNyZXRWYWx1ZUluRW52KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlY3JldFZhbHVlSW5FbnY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHNlY3JldCBcIiR7a2V5fVwiIGF0ICR7cGF0aFN0cn1gKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIExDIG5vdF9pbXBsZW1lbnRlZCBvYmplY3RcbiAgICBpZiAoXCJsY1wiIGluIHJlY29yZCAmJlxuICAgICAgICBcInR5cGVcIiBpbiByZWNvcmQgJiZcbiAgICAgICAgXCJpZFwiIGluIHJlY29yZCAmJlxuICAgICAgICByZWNvcmQubGMgPT09IDEgJiZcbiAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwibm90X2ltcGxlbWVudGVkXCIpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHJlY29yZDtcbiAgICAgICAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplZCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIGxvYWQgYW4gb2JqZWN0IHRoYXQgZG9lc24ndCBpbXBsZW1lbnQgc2VyaWFsaXphdGlvbjogJHtwYXRoU3RyfSAtPiAke3N0cn1gKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIExDIGNvbnN0cnVjdG9yIG9iamVjdFxuICAgIGlmIChcImxjXCIgaW4gcmVjb3JkICYmXG4gICAgICAgIFwidHlwZVwiIGluIHJlY29yZCAmJlxuICAgICAgICBcImlkXCIgaW4gcmVjb3JkICYmXG4gICAgICAgIFwia3dhcmdzXCIgaW4gcmVjb3JkICYmXG4gICAgICAgIHJlY29yZC5sYyA9PT0gMSAmJlxuICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSByZWNvcmQ7XG4gICAgICAgIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpO1xuICAgICAgICBjb25zdCBbbmFtZSwgLi4ubmFtZXNwYWNlUmV2ZXJzZV0gPSBzZXJpYWxpemVkLmlkLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBuYW1lc3BhY2VSZXZlcnNlLnJldmVyc2UoKTtcbiAgICAgICAgY29uc3QgaW1wb3J0TWFwcyA9IHsgbGFuZ2NoYWluX2NvcmU6IGNvcmVJbXBvcnRNYXAsIGxhbmdjaGFpbjogaW1wb3J0TWFwIH07XG4gICAgICAgIGxldCBtb2R1bGUgPSBudWxsO1xuICAgICAgICBjb25zdCBvcHRpb25hbEltcG9ydE5hbWVzcGFjZUFsaWFzZXMgPSBbbmFtZXNwYWNlLmpvaW4oXCIvXCIpXTtcbiAgICAgICAgaWYgKG5hbWVzcGFjZVswXSA9PT0gXCJsYW5nY2hhaW5fY29tbXVuaXR5XCIpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsSW1wb3J0TmFtZXNwYWNlQWxpYXNlcy5wdXNoKFtcImxhbmdjaGFpblwiLCAuLi5uYW1lc3BhY2Uuc2xpY2UoMSldLmpvaW4oXCIvXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaGluZ05hbWVzcGFjZUFsaWFzID0gb3B0aW9uYWxJbXBvcnROYW1lc3BhY2VBbGlhc2VzLmZpbmQoKGFsaWFzKSA9PiBhbGlhcyBpbiBvcHRpb25hbEltcG9ydHNNYXApO1xuICAgICAgICBpZiAoZGVmYXVsdE9wdGlvbmFsSW1wb3J0RW50cnlwb2ludHNcbiAgICAgICAgICAgIC5jb25jYXQob3B0aW9uYWxJbXBvcnRFbnRyeXBvaW50cylcbiAgICAgICAgICAgIC5pbmNsdWRlcyhuYW1lc3BhY2Uuam9pbihcIi9cIikpIHx8XG4gICAgICAgICAgICBtYXRjaGluZ05hbWVzcGFjZUFsaWFzKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdOYW1lc3BhY2VBbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlID0gYXdhaXQgb3B0aW9uYWxJbXBvcnRzTWFwW21hdGNoaW5nTmFtZXNwYWNlQWxpYXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGtleSBcIiR7bmFtZXNwYWNlLmpvaW4oXCIvXCIpfVwiIGZvciAke3BhdGhTdHJ9IGluIGxvYWQob3B0aW9uYWxJbXBvcnRzTWFwPXt9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZpbmFsSW1wb3J0TWFwO1xuICAgICAgICAgICAgLy8gQ3VycmVudGx5LCB3ZSBvbmx5IHN1cHBvcnQgbGFuZ2NoYWluIGFuZCBsYW5nY2hhaW5fY29yZSBpbXBvcnRzLlxuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZVswXSA9PT0gXCJsYW5nY2hhaW5cIiB8fCBuYW1lc3BhY2VbMF0gPT09IFwibGFuZ2NoYWluX2NvcmVcIikge1xuICAgICAgICAgICAgICAgIGZpbmFsSW1wb3J0TWFwID0gaW1wb3J0TWFwc1tuYW1lc3BhY2VbMF1dO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZS5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5hbWVzcGFjZTogJHtwYXRoU3RyfSAtPiAke3N0cn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSByb290IG5hbWVzcGFjZSBcImxhbmdjaGFpblwiIGlzIG5vdCBhIHZhbGlkIGltcG9ydC5cbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5hbWVzcGFjZTogJHtwYXRoU3RyfSAtPiAke3N0cn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2hpbmcgbmFtZXNwYWNlLlxuICAgICAgICAgICAgbGV0IGltcG9ydE1hcEtleTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRNYXBLZXkgPSBuYW1lc3BhY2Uuam9pbihcIl9fXCIpO1xuICAgICAgICAgICAgICAgIGlmIChpbXBvcnRNYXBLZXkgaW4gZmluYWxJbXBvcnRNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2UucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAobmFtZXNwYWNlLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgLy8gSWYgbm8gbWF0Y2hpbmcgbmFtZXNwYWNlIGlzIGZvdW5kLCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmIChpbXBvcnRNYXBLZXkgaW4gZmluYWxJbXBvcnRNYXApIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgPSBmaW5hbEltcG9ydE1hcFtpbXBvcnRNYXBLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcIm9iamVjdFwiIHx8IG1vZHVsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5hbWVzcGFjZTogJHtwYXRoU3RyfSAtPiAke3N0cn1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IHRoZSBidWlsZGVyIGZyb20gdGhlIGltcG9ydCBtYXAuXG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBcbiAgICAgICAgLy8gbG9vayBmb3IgYSBuYW1lZCBleHBvcnQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBjbGFzc1xuICAgICAgICBtb2R1bGVbbmFtZV0gPz9cbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIGFuIGV4cG9ydCB3aXRoIGEgbGNfbmFtZSBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgY2xhc3MgbmFtZVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNsYXNzZXMgdGhhdCBhcmUgbWluaWZpZWRcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMobW9kdWxlKS5maW5kKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgZ2V0X2xjX3VuaXF1ZV9uYW1lKHYpID09PSBuYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWlsZGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpZGVudGlmZXI6ICR7cGF0aFN0cn0gLT4gJHtzdHJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzZSBvbiB0aGUgYXJndW1lbnRzLCB3aGljaCBtYXkgYmUgc2VyaWFsaXplZCBvYmplY3RzIHRoZW1zZWx2ZXNcbiAgICAgICAgY29uc3Qga3dhcmdzID0gYXdhaXQgcmV2aXZlci5jYWxsKHsgLi4udGhpcywgcGF0aDogWy4uLnBhdGgsIFwia3dhcmdzXCJdLCBkZXB0aDogZGVwdGggKyAxIH0sIHNlcmlhbGl6ZWQua3dhcmdzKTtcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBvYmplY3RcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgYnVpbGRlcihtYXBLZXlzKGt3YXJncywga2V5RnJvbUpzb24sIGNvbWJpbmVBbGlhc2VzQW5kSW52ZXJ0KGJ1aWxkZXIpKSk7XG4gICAgICAgIC8vIE1pbmlmaWNhdGlvbiBpbiBzZXZlcmxlc3MvZWRnZSBydW50aW1lcyB3aWxsIG1hbmdlIHRoZVxuICAgICAgICAvLyBuYW1lIG9mIGNsYXNzZXMgcHJlc2VudGVkIGluIHRyYWNlcy4gQXMgdGhlIG5hbWVzIGluIGltcG9ydCBtYXBcbiAgICAgICAgLy8gYXJlIHByZXNlbnQgYXMtaXMgZXZlbiB3aXRoIG1pbmlmaWNhdGlvbiwgdXNlIHRoZXNlIG5hbWVzIGluc3RlYWRcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbmNlLmNvbnN0cnVjdG9yLCBcIm5hbWVcIiwgeyB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvLyBSZWd1bGFyIG9iamVjdCAtIHJlY3Vyc2UgaW50byB2YWx1ZXNcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMocmVjb3JkKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGF3YWl0IHJldml2ZXIuY2FsbCh7IC4uLnRoaXMsIHBhdGg6IFsuLi5wYXRoLCBrZXldLCBkZXB0aDogZGVwdGggKyAxIH0sIHZhbCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIExvYWQgYSBMYW5nQ2hhaW4gb2JqZWN0IGZyb20gYSBKU09OIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdGV4dCAtIFRoZSBKU09OIHN0cmluZyB0byBwYXJzZSBhbmQgbG9hZC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgbG9hZGluZy5cbiAqIEByZXR1cm5zIFRoZSBsb2FkZWQgTGFuZ0NoYWluIG9iamVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgbG9hZCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvbG9hZFwiO1xuICogaW1wb3J0IHsgQUlNZXNzYWdlIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiO1xuICpcbiAqIC8vIEJhc2ljIHVzYWdlIC0gc2VjcmV0cyBtdXN0IGJlIHByb3ZpZGVkIGV4cGxpY2l0bHlcbiAqIGNvbnN0IG1zZyA9IGF3YWl0IGxvYWQ8QUlNZXNzYWdlPihqc29uU3RyaW5nKTtcbiAqXG4gKiAvLyBXaXRoIHNlY3JldHMgZnJvbSBhIG1hcFxuICogY29uc3QgbXNnID0gYXdhaXQgbG9hZDxBSU1lc3NhZ2U+KGpzb25TdHJpbmcsIHtcbiAqICAgc2VjcmV0c01hcDogeyBPUEVOQUlfQVBJX0tFWTogXCJzay0uLi5cIiB9XG4gKiB9KTtcbiAqXG4gKiAvLyBBbGxvdyBsb2FkaW5nIHNlY3JldHMgZnJvbSBlbnZpcm9ubWVudCAodXNlIHdpdGggY2F1dGlvbilcbiAqIGNvbnN0IG1zZyA9IGF3YWl0IGxvYWQ8QUlNZXNzYWdlPihqc29uU3RyaW5nLCB7XG4gKiAgIHNlY3JldHNGcm9tRW52OiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgb3B0aW9uYWxJbXBvcnRzTWFwOiBvcHRpb25zPy5vcHRpb25hbEltcG9ydHNNYXAgPz8ge30sXG4gICAgICAgIG9wdGlvbmFsSW1wb3J0RW50cnlwb2ludHM6IG9wdGlvbnM/Lm9wdGlvbmFsSW1wb3J0RW50cnlwb2ludHMgPz8gW10sXG4gICAgICAgIHNlY3JldHNNYXA6IG9wdGlvbnM/LnNlY3JldHNNYXAgPz8ge30sXG4gICAgICAgIHNlY3JldHNGcm9tRW52OiBvcHRpb25zPy5zZWNyZXRzRnJvbUVudiA/PyBmYWxzZSxcbiAgICAgICAgaW1wb3J0TWFwOiBvcHRpb25zPy5pbXBvcnRNYXAgPz8ge30sXG4gICAgICAgIHBhdGg6IFtcIiRcIl0sXG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICBtYXhEZXB0aDogb3B0aW9ucz8ubWF4RGVwdGggPz8gREVGQVVMVF9NQVhfREVQVEgsXG4gICAgfTtcbiAgICByZXR1cm4gcmV2aXZlci5jYWxsKGNvbnRleHQsIGpzb24pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/map_keys.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/map_keys.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keyFromJson: () => (/* binding */ keyFromJson),\n/* harmony export */   keyToJson: () => (/* binding */ keyToJson),\n/* harmony export */   mapKeys: () => (/* binding */ mapKeys)\n/* harmony export */ });\n/* harmony import */ var decamelize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! decamelize */ \"(rsc)/./node_modules/decamelize/index.js\");\n/* harmony import */ var camelcase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! camelcase */ \"(rsc)/./node_modules/camelcase/index.js\");\n\n\nfunction keyToJson(key, map) {\n    return map?.[key] || decamelize__WEBPACK_IMPORTED_MODULE_0__(key);\n}\nfunction keyFromJson(key, map) {\n    return map?.[key] || camelcase__WEBPACK_IMPORTED_MODULE_1__(key);\n}\nfunction mapKeys(fields, mapper, map) {\n    const mapped = {};\n    for (const key in fields) {\n        if (Object.hasOwn(fields, key)) {\n            mapped[mapper(key, map)] = fields[key];\n        }\n    }\n    return mapped;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9tYXBfa2V5cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtQztBQUNEO0FBQzNCO0FBQ1AseUJBQXlCLHVDQUFTO0FBQ2xDO0FBQ087QUFDUCx5QkFBeUIsc0NBQVM7QUFDbEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbG9hZFxcbWFwX2tleXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNuYWtlQ2FzZSBmcm9tIFwiZGVjYW1lbGl6ZVwiO1xuaW1wb3J0IGNhbWVsQ2FzZSBmcm9tIFwiY2FtZWxjYXNlXCI7XG5leHBvcnQgZnVuY3Rpb24ga2V5VG9Kc29uKGtleSwgbWFwKSB7XG4gICAgcmV0dXJuIG1hcD8uW2tleV0gfHwgc25ha2VDYXNlKGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24ga2V5RnJvbUpzb24oa2V5LCBtYXApIHtcbiAgICByZXR1cm4gbWFwPy5ba2V5XSB8fCBjYW1lbENhc2Uoa2V5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXBLZXlzKGZpZWxkcywgbWFwcGVyLCBtYXApIHtcbiAgICBjb25zdCBtYXBwZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZHMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGRzLCBrZXkpKSB7XG4gICAgICAgICAgICBtYXBwZWRbbWFwcGVyKGtleSwgbWFwKV0gPSBmaWVsZHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/map_keys.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/serializable.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/serializable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Serializable: () => (/* binding */ Serializable),\n/* harmony export */   get_lc_unique_name: () => (/* binding */ get_lc_unique_name)\n/* harmony export */ });\n/* harmony import */ var _map_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map_keys.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/map_keys.js\");\n/* harmony import */ var _validation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validation.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/validation.js\");\n\n\nfunction shallowCopy(obj) {\n    return Array.isArray(obj) ? [...obj] : { ...obj };\n}\nfunction replaceSecrets(root, secretsMap) {\n    const result = shallowCopy(root);\n    for (const [path, secretId] of Object.entries(secretsMap)) {\n        const [last, ...partsReverse] = path.split(\".\").reverse();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let current = result;\n        for (const part of partsReverse.reverse()) {\n            if (current[part] === undefined) {\n                break;\n            }\n            current[part] = shallowCopy(current[part]);\n            current = current[part];\n        }\n        if (current[last] !== undefined) {\n            current[last] = {\n                lc: 1,\n                type: \"secret\",\n                id: [secretId],\n            };\n        }\n    }\n    return result;\n}\n/**\n * Get a unique name for the module, rather than parent class implementations.\n * Should not be subclassed, subclass lc_name above instead.\n */\nfunction get_lc_unique_name(\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nserializableClass) {\n    // \"super\" here would refer to the parent class of Serializable,\n    // when we want the parent class of the module actually calling this method.\n    const parentClass = Object.getPrototypeOf(serializableClass);\n    const lcNameIsSubclassed = typeof serializableClass.lc_name === \"function\" &&\n        (typeof parentClass.lc_name !== \"function\" ||\n            serializableClass.lc_name() !== parentClass.lc_name());\n    if (lcNameIsSubclassed) {\n        return serializableClass.lc_name();\n    }\n    else {\n        return serializableClass.name;\n    }\n}\nclass Serializable {\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            get_lc_unique_name(this.constructor),\n        ];\n    }\n    /**\n     * A map of secrets, which will be omitted from serialization.\n     * Keys are paths to the secret in constructor args, e.g. \"foo.bar.baz\".\n     * Values are the secret ids, which will be used when deserializing.\n     */\n    get lc_secrets() {\n        return undefined;\n    }\n    /**\n     * A map of additional attributes to merge with constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the attribute values, which will be serialized.\n     * These attributes need to be accepted by the constructor as arguments.\n     */\n    get lc_attributes() {\n        return undefined;\n    }\n    /**\n     * A map of aliases for constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the alias that will replace the key in serialization.\n     * This is used to eg. make argument names match Python.\n     */\n    get lc_aliases() {\n        return undefined;\n    }\n    /**\n     * A manual list of keys that should be serialized.\n     * If not overridden, all fields passed into the constructor will be serialized.\n     */\n    get lc_serializable_keys() {\n        return undefined;\n    }\n    constructor(kwargs, ..._args) {\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (this.lc_serializable_keys !== undefined) {\n            this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key]) => this.lc_serializable_keys?.includes(key)));\n        }\n        else {\n            this.lc_kwargs = kwargs ?? {};\n        }\n    }\n    toJSON() {\n        if (!this.lc_serializable) {\n            return this.toJSONNotImplemented();\n        }\n        if (\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        this.lc_kwargs instanceof Serializable ||\n            typeof this.lc_kwargs !== \"object\" ||\n            Array.isArray(this.lc_kwargs)) {\n            // We do not support serialization of classes with arg not a POJO\n            // I'm aware the check above isn't as strict as it could be\n            return this.toJSONNotImplemented();\n        }\n        const aliases = {};\n        const secrets = {};\n        const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n            acc[key] = key in this ? this[key] : this.lc_kwargs[key];\n            return acc;\n        }, {});\n        // get secrets, attributes and aliases from all superclasses\n        for (\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {\n            Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n            Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n            Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n        }\n        // include all secrets used, even if not in kwargs,\n        // will be replaced with sentinel value in replaceSecrets\n        Object.keys(secrets).forEach((keyPath) => {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias, @typescript-eslint/no-explicit-any\n            let read = this;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let write = kwargs;\n            const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n            for (const key of partsReverse.reverse()) {\n                if (!(key in read) || read[key] === undefined)\n                    return;\n                if (!(key in write) || write[key] === undefined) {\n                    if (typeof read[key] === \"object\" && read[key] != null) {\n                        write[key] = {};\n                    }\n                    else if (Array.isArray(read[key])) {\n                        write[key] = [];\n                    }\n                }\n                read = read[key];\n                write = write[key];\n            }\n            if (last in read && read[last] !== undefined) {\n                write[last] = write[last] || read[last];\n            }\n        });\n        const escapedKwargs = {};\n        for (const [key, value] of Object.entries(kwargs)) {\n            escapedKwargs[key] = (0,_validation_js__WEBPACK_IMPORTED_MODULE_1__.escapeIfNeeded)(value);\n        }\n        // Now add secret markers - these are added AFTER escaping so they won't be escaped\n        const kwargsWithSecrets = Object.keys(secrets).length\n            ? replaceSecrets(escapedKwargs, secrets)\n            : escapedKwargs;\n        // Finally transform keys to JSON format\n        const processedKwargs = (0,_map_keys_js__WEBPACK_IMPORTED_MODULE_0__.mapKeys)(kwargsWithSecrets, _map_keys_js__WEBPACK_IMPORTED_MODULE_0__.keyToJson, aliases);\n        return {\n            lc: 1,\n            type: \"constructor\",\n            id: this.lc_id,\n            kwargs: processedKwargs,\n        };\n    }\n    toJSONNotImplemented() {\n        return {\n            lc: 1,\n            type: \"not_implemented\",\n            id: this.lc_id,\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9zZXJpYWxpemFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtRDtBQUNGO0FBQ2pEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUMsOERBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFEQUFPLG9CQUFvQixtREFBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbG9hZFxcc2VyaWFsaXphYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtleVRvSnNvbiwgbWFwS2V5cyB9IGZyb20gXCIuL21hcF9rZXlzLmpzXCI7XG5pbXBvcnQgeyBlc2NhcGVJZk5lZWRlZCB9IGZyb20gXCIuL3ZhbGlkYXRpb24uanNcIjtcbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgPyBbLi4ub2JqXSA6IHsgLi4ub2JqIH07XG59XG5mdW5jdGlvbiByZXBsYWNlU2VjcmV0cyhyb290LCBzZWNyZXRzTWFwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc2hhbGxvd0NvcHkocm9vdCk7XG4gICAgZm9yIChjb25zdCBbcGF0aCwgc2VjcmV0SWRdIG9mIE9iamVjdC5lbnRyaWVzKHNlY3JldHNNYXApKSB7XG4gICAgICAgIGNvbnN0IFtsYXN0LCAuLi5wYXJ0c1JldmVyc2VdID0gcGF0aC5zcGxpdChcIi5cIikucmV2ZXJzZSgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgY3VycmVudCA9IHJlc3VsdDtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzUmV2ZXJzZS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50W3BhcnRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRbcGFydF0gPSBzaGFsbG93Q29weShjdXJyZW50W3BhcnRdKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50W2xhc3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRbbGFzdF0gPSB7XG4gICAgICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZWNyZXRcIixcbiAgICAgICAgICAgICAgICBpZDogW3NlY3JldElkXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogR2V0IGEgdW5pcXVlIG5hbWUgZm9yIHRoZSBtb2R1bGUsIHJhdGhlciB0aGFuIHBhcmVudCBjbGFzcyBpbXBsZW1lbnRhdGlvbnMuXG4gKiBTaG91bGQgbm90IGJlIHN1YmNsYXNzZWQsIHN1YmNsYXNzIGxjX25hbWUgYWJvdmUgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9sY191bmlxdWVfbmFtZShcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbnNlcmlhbGl6YWJsZUNsYXNzKSB7XG4gICAgLy8gXCJzdXBlclwiIGhlcmUgd291bGQgcmVmZXIgdG8gdGhlIHBhcmVudCBjbGFzcyBvZiBTZXJpYWxpemFibGUsXG4gICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBwYXJlbnQgY2xhc3Mgb2YgdGhlIG1vZHVsZSBhY3R1YWxseSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgIGNvbnN0IHBhcmVudENsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNlcmlhbGl6YWJsZUNsYXNzKTtcbiAgICBjb25zdCBsY05hbWVJc1N1YmNsYXNzZWQgPSB0eXBlb2Ygc2VyaWFsaXphYmxlQ2xhc3MubGNfbmFtZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICh0eXBlb2YgcGFyZW50Q2xhc3MubGNfbmFtZSAhPT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lKCkgIT09IHBhcmVudENsYXNzLmxjX25hbWUoKSk7XG4gICAgaWYgKGxjTmFtZUlzU3ViY2xhc3NlZCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXphYmxlQ2xhc3MubGNfbmFtZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZUNsYXNzLm5hbWU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNlcmlhbGl6YWJsZSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6YWJsZS4gT3ZlcnJpZGUgdG8gcHJvdmlkZSBhbiBhbGlhcyBvclxuICAgICAqIHRvIHByZXNlcnZlIHRoZSBzZXJpYWxpemVkIG1vZHVsZSBuYW1lIGluIG1pbmlmaWVkIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGVkIGFzIGEgc3RhdGljIG1ldGhvZCB0byBzdXBwb3J0IGxvYWRpbmcgbG9naWMuXG4gICAgICovXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaW5hbCBzZXJpYWxpemVkIGlkZW50aWZpZXIgZm9yIHRoZSBtb2R1bGUuXG4gICAgICovXG4gICAgZ2V0IGxjX2lkKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5sY19uYW1lc3BhY2UsXG4gICAgICAgICAgICBnZXRfbGNfdW5pcXVlX25hbWUodGhpcy5jb25zdHJ1Y3RvciksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHNlY3JldHMsIHdoaWNoIHdpbGwgYmUgb21pdHRlZCBmcm9tIHNlcmlhbGl6YXRpb24uXG4gICAgICogS2V5cyBhcmUgcGF0aHMgdG8gdGhlIHNlY3JldCBpbiBjb25zdHJ1Y3RvciBhcmdzLCBlLmcuIFwiZm9vLmJhci5iYXpcIi5cbiAgICAgKiBWYWx1ZXMgYXJlIHRoZSBzZWNyZXQgaWRzLCB3aGljaCB3aWxsIGJlIHVzZWQgd2hlbiBkZXNlcmlhbGl6aW5nLlxuICAgICAqL1xuICAgIGdldCBsY19zZWNyZXRzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMgdG8gbWVyZ2Ugd2l0aCBjb25zdHJ1Y3RvciBhcmdzLlxuICAgICAqIEtleXMgYXJlIHRoZSBhdHRyaWJ1dGUgbmFtZXMsIGUuZy4gXCJmb29cIi5cbiAgICAgKiBWYWx1ZXMgYXJlIHRoZSBhdHRyaWJ1dGUgdmFsdWVzLCB3aGljaCB3aWxsIGJlIHNlcmlhbGl6ZWQuXG4gICAgICogVGhlc2UgYXR0cmlidXRlcyBuZWVkIHRvIGJlIGFjY2VwdGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBhcyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZ2V0IGxjX2F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGFsaWFzZXMgZm9yIGNvbnN0cnVjdG9yIGFyZ3MuXG4gICAgICogS2V5cyBhcmUgdGhlIGF0dHJpYnV0ZSBuYW1lcywgZS5nLiBcImZvb1wiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIGFsaWFzIHRoYXQgd2lsbCByZXBsYWNlIHRoZSBrZXkgaW4gc2VyaWFsaXphdGlvbi5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gZWcuIG1ha2UgYXJndW1lbnQgbmFtZXMgbWF0Y2ggUHl0aG9uLlxuICAgICAqL1xuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1hbnVhbCBsaXN0IG9mIGtleXMgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZC5cbiAgICAgKiBJZiBub3Qgb3ZlcnJpZGRlbiwgYWxsIGZpZWxkcyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3Igd2lsbCBiZSBzZXJpYWxpemVkLlxuICAgICAqL1xuICAgIGdldCBsY19zZXJpYWxpemFibGVfa2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioa3dhcmdzLCAuLi5fYXJncykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19rd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMubGNfc2VyaWFsaXphYmxlX2tleXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5sY19rd2FyZ3MgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoa3dhcmdzIHx8IHt9KS5maWx0ZXIoKFtrZXldKSA9PiB0aGlzLmxjX3NlcmlhbGl6YWJsZV9rZXlzPy5pbmNsdWRlcyhrZXkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxjX2t3YXJncyA9IGt3YXJncyA/PyB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5sY19zZXJpYWxpemFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIHRoaXMubGNfa3dhcmdzIGluc3RhbmNlb2YgU2VyaWFsaXphYmxlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5sY19rd2FyZ3MgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5sY19rd2FyZ3MpKSB7XG4gICAgICAgICAgICAvLyBXZSBkbyBub3Qgc3VwcG9ydCBzZXJpYWxpemF0aW9uIG9mIGNsYXNzZXMgd2l0aCBhcmcgbm90IGEgUE9KT1xuICAgICAgICAgICAgLy8gSSdtIGF3YXJlIHRoZSBjaGVjayBhYm92ZSBpc24ndCBhcyBzdHJpY3QgYXMgaXQgY291bGQgYmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IHt9O1xuICAgICAgICBjb25zdCBzZWNyZXRzID0ge307XG4gICAgICAgIGNvbnN0IGt3YXJncyA9IE9iamVjdC5rZXlzKHRoaXMubGNfa3dhcmdzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGtleSBpbiB0aGlzID8gdGhpc1trZXldIDogdGhpcy5sY19rd2FyZ3Nba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gZ2V0IHNlY3JldHMsIGF0dHJpYnV0ZXMgYW5kIGFsaWFzZXMgZnJvbSBhbGwgc3VwZXJjbGFzc2VzXG4gICAgICAgIGZvciAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBsZXQgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTsgY3VycmVudDsgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50KSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhbGlhc2VzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX2FsaWFzZXNcIiwgdGhpcykpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWNyZXRzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX3NlY3JldHNcIiwgdGhpcykpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihrd2FyZ3MsIFJlZmxlY3QuZ2V0KGN1cnJlbnQsIFwibGNfYXR0cmlidXRlc1wiLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5jbHVkZSBhbGwgc2VjcmV0cyB1c2VkLCBldmVuIGlmIG5vdCBpbiBrd2FyZ3MsXG4gICAgICAgIC8vIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBzZW50aW5lbCB2YWx1ZSBpbiByZXBsYWNlU2VjcmV0c1xuICAgICAgICBPYmplY3Qua2V5cyhzZWNyZXRzKS5mb3JFYWNoKChrZXlQYXRoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGxldCByZWFkID0gdGhpcztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBsZXQgd3JpdGUgPSBrd2FyZ3M7XG4gICAgICAgICAgICBjb25zdCBbbGFzdCwgLi4ucGFydHNSZXZlcnNlXSA9IGtleVBhdGguc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhcnRzUmV2ZXJzZS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gcmVhZCkgfHwgcmVhZFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gd3JpdGUpIHx8IHdyaXRlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRba2V5XSA9PT0gXCJvYmplY3RcIiAmJiByZWFkW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVhZFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYWQgPSByZWFkW2tleV07XG4gICAgICAgICAgICAgICAgd3JpdGUgPSB3cml0ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3QgaW4gcmVhZCAmJiByZWFkW2xhc3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZVtsYXN0XSA9IHdyaXRlW2xhc3RdIHx8IHJlYWRbbGFzdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlc2NhcGVkS3dhcmdzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGt3YXJncykpIHtcbiAgICAgICAgICAgIGVzY2FwZWRLd2FyZ3Nba2V5XSA9IGVzY2FwZUlmTmVlZGVkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgYWRkIHNlY3JldCBtYXJrZXJzIC0gdGhlc2UgYXJlIGFkZGVkIEFGVEVSIGVzY2FwaW5nIHNvIHRoZXkgd29uJ3QgYmUgZXNjYXBlZFxuICAgICAgICBjb25zdCBrd2FyZ3NXaXRoU2VjcmV0cyA9IE9iamVjdC5rZXlzKHNlY3JldHMpLmxlbmd0aFxuICAgICAgICAgICAgPyByZXBsYWNlU2VjcmV0cyhlc2NhcGVkS3dhcmdzLCBzZWNyZXRzKVxuICAgICAgICAgICAgOiBlc2NhcGVkS3dhcmdzO1xuICAgICAgICAvLyBGaW5hbGx5IHRyYW5zZm9ybSBrZXlzIHRvIEpTT04gZm9ybWF0XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZEt3YXJncyA9IG1hcEtleXMoa3dhcmdzV2l0aFNlY3JldHMsIGtleVRvSnNvbiwgYWxpYXNlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgIGlkOiB0aGlzLmxjX2lkLFxuICAgICAgICAgICAga3dhcmdzOiBwcm9jZXNzZWRLd2FyZ3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvSlNPTk5vdEltcGxlbWVudGVkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICB0eXBlOiBcIm5vdF9pbXBsZW1lbnRlZFwiLFxuICAgICAgICAgICAgaWQ6IHRoaXMubGNfaWQsXG4gICAgICAgIH07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/validation.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/validation.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LC_ESCAPED_KEY: () => (/* binding */ LC_ESCAPED_KEY),\n/* harmony export */   escapeIfNeeded: () => (/* binding */ escapeIfNeeded),\n/* harmony export */   escapeObject: () => (/* binding */ escapeObject),\n/* harmony export */   isEscapedObject: () => (/* binding */ isEscapedObject),\n/* harmony export */   needsEscaping: () => (/* binding */ needsEscaping),\n/* harmony export */   serializeLcObject: () => (/* binding */ serializeLcObject),\n/* harmony export */   serializeValue: () => (/* binding */ serializeValue),\n/* harmony export */   unescapeValue: () => (/* binding */ unescapeValue)\n/* harmony export */ });\n/**\n * Sentinel key used to mark escaped user objects during serialization.\n *\n * When a plain object contains 'lc' key (which could be confused with LC objects),\n * we wrap it as `{\"__lc_escaped__\": {...original...}}`.\n */\nconst LC_ESCAPED_KEY = \"__lc_escaped__\";\n/**\n * Check if an object needs escaping to prevent confusion with LC objects.\n *\n * An object needs escaping if:\n * 1. It has an `'lc'` key (could be confused with LC serialization format)\n * 2. It has only the escape key (would be mistaken for an escaped object)\n */\nfunction needsEscaping(obj) {\n    return (\"lc\" in obj || (Object.keys(obj).length === 1 && LC_ESCAPED_KEY in obj));\n}\n/**\n * Wrap an object in the escape marker.\n *\n * @example\n * ```typescript\n * {\"key\": \"value\"}  // becomes {\"__lc_escaped__\": {\"key\": \"value\"}}\n * ```\n */\nfunction escapeObject(obj) {\n    return { [LC_ESCAPED_KEY]: obj };\n}\n/**\n * Check if an object is an escaped user object.\n *\n * @example\n * ```typescript\n * {\"__lc_escaped__\": {...}}  // is an escaped object\n * ```\n */\nfunction isEscapedObject(obj) {\n    return Object.keys(obj).length === 1 && LC_ESCAPED_KEY in obj;\n}\n/**\n * Check if an object looks like a Serializable instance (duck typing).\n */\nfunction isSerializableLike(obj) {\n    return (obj !== null &&\n        typeof obj === \"object\" &&\n        \"lc_serializable\" in obj &&\n        typeof obj.toJSON === \"function\");\n}\n/**\n * Create a \"not_implemented\" serialization result for objects that cannot be serialized.\n */\nfunction createNotImplemented(obj) {\n    let id;\n    if (obj !== null && typeof obj === \"object\") {\n        if (\"lc_id\" in obj && Array.isArray(obj.lc_id)) {\n            id = obj.lc_id;\n        }\n        else {\n            id = [obj.constructor?.name ?? \"Object\"];\n        }\n    }\n    else {\n        id = [typeof obj];\n    }\n    return {\n        lc: 1,\n        type: \"not_implemented\",\n        id,\n    };\n}\n/**\n * Serialize a value with escaping of user objects.\n *\n * Called recursively on kwarg values to escape any plain objects that could be\n * confused with LC objects.\n *\n * @param obj - The value to serialize.\n * @returns The serialized value with user objects escaped as needed.\n */\nfunction serializeValue(obj) {\n    if (isSerializableLike(obj)) {\n        // This is an LC object - serialize it properly (not escaped)\n        return serializeLcObject(obj);\n    }\n    if (obj !== null && typeof obj === \"object\" && !Array.isArray(obj)) {\n        const record = obj;\n        // Check if object needs escaping BEFORE recursing into values.\n        // If it needs escaping, wrap it as-is - the contents are user data that\n        // will be returned as-is during deserialization (no instantiation).\n        // This prevents re-escaping of already-escaped nested content.\n        if (needsEscaping(record)) {\n            return escapeObject(record);\n        }\n        // Safe object (no 'lc' key) - recurse into values\n        const result = {};\n        for (const [key, value] of Object.entries(record)) {\n            result[key] = serializeValue(value);\n        }\n        return result;\n    }\n    if (Array.isArray(obj)) {\n        return obj.map((item) => serializeValue(item));\n    }\n    if (typeof obj === \"string\" ||\n        typeof obj === \"number\" ||\n        typeof obj === \"boolean\" ||\n        obj === null) {\n        return obj;\n    }\n    // Non-JSON-serializable object (Date, custom objects, etc.)\n    return createNotImplemented(obj);\n}\n/**\n * Serialize a `Serializable` object with escaping of user data in kwargs.\n *\n * @param obj - The `Serializable` object to serialize.\n * @returns The serialized object with user data in kwargs escaped as needed.\n *\n * @remarks\n * Kwargs values are processed with `serializeValue` to escape user data (like\n * metadata) that contains `'lc'` keys. Secret fields (from `lc_secrets`) are\n * skipped because `toJSON()` replaces their values with secret markers.\n */\nfunction serializeLcObject(obj) {\n    // Secret fields are handled by toJSON() - it replaces values with secret markers\n    const secretFields = new Set(Object.keys(obj.lc_secrets ?? {}));\n    const serialized = { ...obj.toJSON() };\n    // Process kwargs to escape user data that could be confused with LC objects\n    // Skip secret fields - toJSON() already converted them to secret markers\n    if (serialized.type === \"constructor\" && serialized.kwargs) {\n        const newKwargs = {};\n        for (const [key, value] of Object.entries(serialized.kwargs)) {\n            if (secretFields.has(key)) {\n                newKwargs[key] = value;\n            }\n            else {\n                newKwargs[key] = serializeValue(value);\n            }\n        }\n        serialized.kwargs = newKwargs;\n    }\n    return serialized;\n}\n/**\n * Escape a value if it needs escaping (contains `lc` key).\n *\n * This is a simpler version of `serializeValue` that doesn't handle Serializable\n * objects - it's meant to be called on kwargs values that have already been\n * processed by `toJSON()`.\n *\n * @param value - The value to potentially escape.\n * @returns The value with any `lc`-containing objects wrapped in escape markers.\n */\nfunction escapeIfNeeded(value) {\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\n        // Preserve Serializable objects - they have their own toJSON() that will be\n        // called by JSON.stringify. We don't want to convert them to plain objects.\n        if (isSerializableLike(value)) {\n            return value;\n        }\n        const record = value;\n        // Check if object needs escaping BEFORE recursing into values.\n        // If it needs escaping, wrap it as-is - the contents are user data that\n        // will be returned as-is during deserialization (no instantiation).\n        if (needsEscaping(record)) {\n            return escapeObject(record);\n        }\n        // Safe object (no 'lc' key) - recurse into values\n        const result = {};\n        for (const [key, val] of Object.entries(record)) {\n            result[key] = escapeIfNeeded(val);\n        }\n        return result;\n    }\n    if (Array.isArray(value)) {\n        return value.map((item) => escapeIfNeeded(item));\n    }\n    return value;\n}\n/**\n * Unescape a value, processing escape markers in object values and arrays.\n *\n * When an escaped object is encountered (`{\"__lc_escaped__\": ...}`), it's\n * unwrapped and the contents are returned AS-IS (no further processing).\n * The contents represent user data that should not be modified.\n *\n * For regular objects and arrays, we recurse to find any nested escape markers.\n *\n * @param obj - The value to unescape.\n * @returns The unescaped value.\n */\nfunction unescapeValue(obj) {\n    if (obj !== null && typeof obj === \"object\" && !Array.isArray(obj)) {\n        const record = obj;\n        if (isEscapedObject(record)) {\n            // Unwrap and return the user data as-is (no further unescaping).\n            // The contents are user data that may contain more escape keys,\n            // but those are part of the user's actual data.\n            return record[LC_ESCAPED_KEY];\n        }\n        // Regular object - recurse into values to find nested escape markers\n        const result = {};\n        for (const [key, value] of Object.entries(record)) {\n            result[key] = unescapeValue(value);\n        }\n        return result;\n    }\n    if (Array.isArray(obj)) {\n        return obj.map((item) => unescapeValue(item));\n    }\n    return obj;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC92YWxpZGF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CLGdCQUFnQjtBQUN0RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUIsWUFBWSxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNPO0FBQ1AsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUJBQW1CLE9BQU87QUFDOUI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpRUFBaUU7QUFDakUseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGxvYWRcXHZhbGlkYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTZW50aW5lbCBrZXkgdXNlZCB0byBtYXJrIGVzY2FwZWQgdXNlciBvYmplY3RzIGR1cmluZyBzZXJpYWxpemF0aW9uLlxuICpcbiAqIFdoZW4gYSBwbGFpbiBvYmplY3QgY29udGFpbnMgJ2xjJyBrZXkgKHdoaWNoIGNvdWxkIGJlIGNvbmZ1c2VkIHdpdGggTEMgb2JqZWN0cyksXG4gKiB3ZSB3cmFwIGl0IGFzIGB7XCJfX2xjX2VzY2FwZWRfX1wiOiB7Li4ub3JpZ2luYWwuLi59fWAuXG4gKi9cbmV4cG9ydCBjb25zdCBMQ19FU0NBUEVEX0tFWSA9IFwiX19sY19lc2NhcGVkX19cIjtcbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IG5lZWRzIGVzY2FwaW5nIHRvIHByZXZlbnQgY29uZnVzaW9uIHdpdGggTEMgb2JqZWN0cy5cbiAqXG4gKiBBbiBvYmplY3QgbmVlZHMgZXNjYXBpbmcgaWY6XG4gKiAxLiBJdCBoYXMgYW4gYCdsYydgIGtleSAoY291bGQgYmUgY29uZnVzZWQgd2l0aCBMQyBzZXJpYWxpemF0aW9uIGZvcm1hdClcbiAqIDIuIEl0IGhhcyBvbmx5IHRoZSBlc2NhcGUga2V5ICh3b3VsZCBiZSBtaXN0YWtlbiBmb3IgYW4gZXNjYXBlZCBvYmplY3QpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZWVkc0VzY2FwaW5nKG9iaikge1xuICAgIHJldHVybiAoXCJsY1wiIGluIG9iaiB8fCAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDEgJiYgTENfRVNDQVBFRF9LRVkgaW4gb2JqKSk7XG59XG4vKipcbiAqIFdyYXAgYW4gb2JqZWN0IGluIHRoZSBlc2NhcGUgbWFya2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiB7XCJrZXlcIjogXCJ2YWx1ZVwifSAgLy8gYmVjb21lcyB7XCJfX2xjX2VzY2FwZWRfX1wiOiB7XCJrZXlcIjogXCJ2YWx1ZVwifX1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlT2JqZWN0KG9iaikge1xuICAgIHJldHVybiB7IFtMQ19FU0NBUEVEX0tFWV06IG9iaiB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gZXNjYXBlZCB1c2VyIG9iamVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICoge1wiX19sY19lc2NhcGVkX19cIjogey4uLn19ICAvLyBpcyBhbiBlc2NhcGVkIG9iamVjdFxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VzY2FwZWRPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAxICYmIExDX0VTQ0FQRURfS0VZIGluIG9iajtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGxvb2tzIGxpa2UgYSBTZXJpYWxpemFibGUgaW5zdGFuY2UgKGR1Y2sgdHlwaW5nKS5cbiAqL1xuZnVuY3Rpb24gaXNTZXJpYWxpemFibGVMaWtlKG9iaikge1xuICAgIHJldHVybiAob2JqICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgXCJsY19zZXJpYWxpemFibGVcIiBpbiBvYmogJiZcbiAgICAgICAgdHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIik7XG59XG4vKipcbiAqIENyZWF0ZSBhIFwibm90X2ltcGxlbWVudGVkXCIgc2VyaWFsaXphdGlvbiByZXN1bHQgZm9yIG9iamVjdHMgdGhhdCBjYW5ub3QgYmUgc2VyaWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm90SW1wbGVtZW50ZWQob2JqKSB7XG4gICAgbGV0IGlkO1xuICAgIGlmIChvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoXCJsY19pZFwiIGluIG9iaiAmJiBBcnJheS5pc0FycmF5KG9iai5sY19pZCkpIHtcbiAgICAgICAgICAgIGlkID0gb2JqLmxjX2lkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBbb2JqLmNvbnN0cnVjdG9yPy5uYW1lID8/IFwiT2JqZWN0XCJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZCA9IFt0eXBlb2Ygb2JqXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGM6IDEsXG4gICAgICAgIHR5cGU6IFwibm90X2ltcGxlbWVudGVkXCIsXG4gICAgICAgIGlkLFxuICAgIH07XG59XG4vKipcbiAqIFNlcmlhbGl6ZSBhIHZhbHVlIHdpdGggZXNjYXBpbmcgb2YgdXNlciBvYmplY3RzLlxuICpcbiAqIENhbGxlZCByZWN1cnNpdmVseSBvbiBrd2FyZyB2YWx1ZXMgdG8gZXNjYXBlIGFueSBwbGFpbiBvYmplY3RzIHRoYXQgY291bGQgYmVcbiAqIGNvbmZ1c2VkIHdpdGggTEMgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gVGhlIHZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHZhbHVlIHdpdGggdXNlciBvYmplY3RzIGVzY2FwZWQgYXMgbmVlZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplVmFsdWUob2JqKSB7XG4gICAgaWYgKGlzU2VyaWFsaXphYmxlTGlrZShvYmopKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gTEMgb2JqZWN0IC0gc2VyaWFsaXplIGl0IHByb3Blcmx5IChub3QgZXNjYXBlZClcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUxjT2JqZWN0KG9iaik7XG4gICAgfVxuICAgIGlmIChvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IG9iajtcbiAgICAgICAgLy8gQ2hlY2sgaWYgb2JqZWN0IG5lZWRzIGVzY2FwaW5nIEJFRk9SRSByZWN1cnNpbmcgaW50byB2YWx1ZXMuXG4gICAgICAgIC8vIElmIGl0IG5lZWRzIGVzY2FwaW5nLCB3cmFwIGl0IGFzLWlzIC0gdGhlIGNvbnRlbnRzIGFyZSB1c2VyIGRhdGEgdGhhdFxuICAgICAgICAvLyB3aWxsIGJlIHJldHVybmVkIGFzLWlzIGR1cmluZyBkZXNlcmlhbGl6YXRpb24gKG5vIGluc3RhbnRpYXRpb24pLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHJlLWVzY2FwaW5nIG9mIGFscmVhZHktZXNjYXBlZCBuZXN0ZWQgY29udGVudC5cbiAgICAgICAgaWYgKG5lZWRzRXNjYXBpbmcocmVjb3JkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZU9iamVjdChyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNhZmUgb2JqZWN0IChubyAnbGMnIGtleSkgLSByZWN1cnNlIGludG8gdmFsdWVzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZWNvcmQpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHNlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBvYmoubWFwKChpdGVtKSA9PiBzZXJpYWxpemVWYWx1ZShpdGVtKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgdHlwZW9mIG9iaiA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAgICAgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8vIE5vbi1KU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgKERhdGUsIGN1c3RvbSBvYmplY3RzLCBldGMuKVxuICAgIHJldHVybiBjcmVhdGVOb3RJbXBsZW1lbnRlZChvYmopO1xufVxuLyoqXG4gKiBTZXJpYWxpemUgYSBgU2VyaWFsaXphYmxlYCBvYmplY3Qgd2l0aCBlc2NhcGluZyBvZiB1c2VyIGRhdGEgaW4ga3dhcmdzLlxuICpcbiAqIEBwYXJhbSBvYmogLSBUaGUgYFNlcmlhbGl6YWJsZWAgb2JqZWN0IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIG9iamVjdCB3aXRoIHVzZXIgZGF0YSBpbiBrd2FyZ3MgZXNjYXBlZCBhcyBuZWVkZWQuXG4gKlxuICogQHJlbWFya3NcbiAqIEt3YXJncyB2YWx1ZXMgYXJlIHByb2Nlc3NlZCB3aXRoIGBzZXJpYWxpemVWYWx1ZWAgdG8gZXNjYXBlIHVzZXIgZGF0YSAobGlrZVxuICogbWV0YWRhdGEpIHRoYXQgY29udGFpbnMgYCdsYydgIGtleXMuIFNlY3JldCBmaWVsZHMgKGZyb20gYGxjX3NlY3JldHNgKSBhcmVcbiAqIHNraXBwZWQgYmVjYXVzZSBgdG9KU09OKClgIHJlcGxhY2VzIHRoZWlyIHZhbHVlcyB3aXRoIHNlY3JldCBtYXJrZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplTGNPYmplY3Qob2JqKSB7XG4gICAgLy8gU2VjcmV0IGZpZWxkcyBhcmUgaGFuZGxlZCBieSB0b0pTT04oKSAtIGl0IHJlcGxhY2VzIHZhbHVlcyB3aXRoIHNlY3JldCBtYXJrZXJzXG4gICAgY29uc3Qgc2VjcmV0RmllbGRzID0gbmV3IFNldChPYmplY3Qua2V5cyhvYmoubGNfc2VjcmV0cyA/PyB7fSkpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7IC4uLm9iai50b0pTT04oKSB9O1xuICAgIC8vIFByb2Nlc3Mga3dhcmdzIHRvIGVzY2FwZSB1c2VyIGRhdGEgdGhhdCBjb3VsZCBiZSBjb25mdXNlZCB3aXRoIExDIG9iamVjdHNcbiAgICAvLyBTa2lwIHNlY3JldCBmaWVsZHMgLSB0b0pTT04oKSBhbHJlYWR5IGNvbnZlcnRlZCB0aGVtIHRvIHNlY3JldCBtYXJrZXJzXG4gICAgaWYgKHNlcmlhbGl6ZWQudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiICYmIHNlcmlhbGl6ZWQua3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5ld0t3YXJncyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzZXJpYWxpemVkLmt3YXJncykpIHtcbiAgICAgICAgICAgIGlmIChzZWNyZXRGaWVsZHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBuZXdLd2FyZ3Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3S3dhcmdzW2tleV0gPSBzZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWFsaXplZC5rd2FyZ3MgPSBuZXdLd2FyZ3M7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xufVxuLyoqXG4gKiBFc2NhcGUgYSB2YWx1ZSBpZiBpdCBuZWVkcyBlc2NhcGluZyAoY29udGFpbnMgYGxjYCBrZXkpLlxuICpcbiAqIFRoaXMgaXMgYSBzaW1wbGVyIHZlcnNpb24gb2YgYHNlcmlhbGl6ZVZhbHVlYCB0aGF0IGRvZXNuJ3QgaGFuZGxlIFNlcmlhbGl6YWJsZVxuICogb2JqZWN0cyAtIGl0J3MgbWVhbnQgdG8gYmUgY2FsbGVkIG9uIGt3YXJncyB2YWx1ZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlblxuICogcHJvY2Vzc2VkIGJ5IGB0b0pTT04oKWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHBvdGVudGlhbGx5IGVzY2FwZS5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSB3aXRoIGFueSBgbGNgLWNvbnRhaW5pbmcgb2JqZWN0cyB3cmFwcGVkIGluIGVzY2FwZSBtYXJrZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlSWZOZWVkZWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBQcmVzZXJ2ZSBTZXJpYWxpemFibGUgb2JqZWN0cyAtIHRoZXkgaGF2ZSB0aGVpciBvd24gdG9KU09OKCkgdGhhdCB3aWxsIGJlXG4gICAgICAgIC8vIGNhbGxlZCBieSBKU09OLnN0cmluZ2lmeS4gV2UgZG9uJ3Qgd2FudCB0byBjb252ZXJ0IHRoZW0gdG8gcGxhaW4gb2JqZWN0cy5cbiAgICAgICAgaWYgKGlzU2VyaWFsaXphYmxlTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWNvcmQgPSB2YWx1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgb2JqZWN0IG5lZWRzIGVzY2FwaW5nIEJFRk9SRSByZWN1cnNpbmcgaW50byB2YWx1ZXMuXG4gICAgICAgIC8vIElmIGl0IG5lZWRzIGVzY2FwaW5nLCB3cmFwIGl0IGFzLWlzIC0gdGhlIGNvbnRlbnRzIGFyZSB1c2VyIGRhdGEgdGhhdFxuICAgICAgICAvLyB3aWxsIGJlIHJldHVybmVkIGFzLWlzIGR1cmluZyBkZXNlcmlhbGl6YXRpb24gKG5vIGluc3RhbnRpYXRpb24pLlxuICAgICAgICBpZiAobmVlZHNFc2NhcGluZyhyZWNvcmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlT2JqZWN0KHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2FmZSBvYmplY3QgKG5vICdsYycga2V5KSAtIHJlY3Vyc2UgaW50byB2YWx1ZXNcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhyZWNvcmQpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGVzY2FwZUlmTmVlZGVkKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKGl0ZW0pID0+IGVzY2FwZUlmTmVlZGVkKGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBVbmVzY2FwZSBhIHZhbHVlLCBwcm9jZXNzaW5nIGVzY2FwZSBtYXJrZXJzIGluIG9iamVjdCB2YWx1ZXMgYW5kIGFycmF5cy5cbiAqXG4gKiBXaGVuIGFuIGVzY2FwZWQgb2JqZWN0IGlzIGVuY291bnRlcmVkIChge1wiX19sY19lc2NhcGVkX19cIjogLi4ufWApLCBpdCdzXG4gKiB1bndyYXBwZWQgYW5kIHRoZSBjb250ZW50cyBhcmUgcmV0dXJuZWQgQVMtSVMgKG5vIGZ1cnRoZXIgcHJvY2Vzc2luZykuXG4gKiBUaGUgY29udGVudHMgcmVwcmVzZW50IHVzZXIgZGF0YSB0aGF0IHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgb2JqZWN0cyBhbmQgYXJyYXlzLCB3ZSByZWN1cnNlIHRvIGZpbmQgYW55IG5lc3RlZCBlc2NhcGUgbWFya2Vycy5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gVGhlIHZhbHVlIHRvIHVuZXNjYXBlLlxuICogQHJldHVybnMgVGhlIHVuZXNjYXBlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlVmFsdWUob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gb2JqO1xuICAgICAgICBpZiAoaXNFc2NhcGVkT2JqZWN0KHJlY29yZCkpIHtcbiAgICAgICAgICAgIC8vIFVud3JhcCBhbmQgcmV0dXJuIHRoZSB1c2VyIGRhdGEgYXMtaXMgKG5vIGZ1cnRoZXIgdW5lc2NhcGluZykuXG4gICAgICAgICAgICAvLyBUaGUgY29udGVudHMgYXJlIHVzZXIgZGF0YSB0aGF0IG1heSBjb250YWluIG1vcmUgZXNjYXBlIGtleXMsXG4gICAgICAgICAgICAvLyBidXQgdGhvc2UgYXJlIHBhcnQgb2YgdGhlIHVzZXIncyBhY3R1YWwgZGF0YS5cbiAgICAgICAgICAgIHJldHVybiByZWNvcmRbTENfRVNDQVBFRF9LRVldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlZ3VsYXIgb2JqZWN0IC0gcmVjdXJzZSBpbnRvIHZhbHVlcyB0byBmaW5kIG5lc3RlZCBlc2NhcGUgbWFya2Vyc1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVjb3JkKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB1bmVzY2FwZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBvYmoubWFwKChpdGVtKSA9PiB1bmVzY2FwZVZhbHVlKGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/memory.js":
/*!*****************************************************!*\
  !*** ./node_modules/@langchain/core/dist/memory.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMemory: () => (/* binding */ BaseMemory),\n/* harmony export */   getInputValue: () => (/* binding */ getInputValue),\n/* harmony export */   getOutputValue: () => (/* binding */ getOutputValue),\n/* harmony export */   getPromptInputKey: () => (/* binding */ getPromptInputKey)\n/* harmony export */ });\n/**\n * Abstract base class for memory in LangChain's Chains. Memory refers to\n * the state in Chains. It can be used to store information about past\n * executions of a Chain and inject that information into the inputs of\n * future executions of the Chain.\n */\nclass BaseMemory {\n}\nconst getValue = (values, key) => {\n    if (key !== undefined) {\n        return values[key];\n    }\n    const keys = Object.keys(values);\n    if (keys.length === 1) {\n        return values[keys[0]];\n    }\n};\n/**\n * This function is used by memory classes to select the input value\n * to use for the memory. If there is only one input value, it is used.\n * If there are multiple input values, the inputKey must be specified.\n */\nconst getInputValue = (inputValues, inputKey) => {\n    const value = getValue(inputValues, inputKey);\n    if (!value) {\n        const keys = Object.keys(inputValues);\n        throw new Error(`input values have ${keys.length} keys, you must specify an input key or pass only 1 key as input`);\n    }\n    return value;\n};\n/**\n * This function is used by memory classes to select the output value\n * to use for the memory. If there is only one output value, it is used.\n * If there are multiple output values, the outputKey must be specified.\n * If no outputKey is specified, an error is thrown.\n */\nconst getOutputValue = (outputValues, outputKey) => {\n    const value = getValue(outputValues, outputKey);\n    if (!value && value !== \"\") {\n        const keys = Object.keys(outputValues);\n        throw new Error(`output values have ${keys.length} keys, you must specify an output key or pass only 1 key as output`);\n    }\n    return value;\n};\n/**\n * Function used by memory classes to get the key of the prompt input,\n * excluding any keys that are memory variables or the \"stop\" key. If\n * there is not exactly one prompt input key, an error is thrown.\n */\nfunction getPromptInputKey(inputs, memoryVariables) {\n    const promptInputKeys = Object.keys(inputs).filter((key) => !memoryVariables.includes(key) && key !== \"stop\");\n    if (promptInputKeys.length !== 1) {\n        throw new Error(`One input key expected, but got ${promptInputKeys.length}`);\n    }\n    return promptInputKeys[0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVtb3J5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkRBQTJELHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVtb3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgbWVtb3J5IGluIExhbmdDaGFpbidzIENoYWlucy4gTWVtb3J5IHJlZmVycyB0b1xuICogdGhlIHN0YXRlIGluIENoYWlucy4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgcGFzdFxuICogZXhlY3V0aW9ucyBvZiBhIENoYWluIGFuZCBpbmplY3QgdGhhdCBpbmZvcm1hdGlvbiBpbnRvIHRoZSBpbnB1dHMgb2ZcbiAqIGZ1dHVyZSBleGVjdXRpb25zIG9mIHRoZSBDaGFpbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VNZW1vcnkge1xufVxuY29uc3QgZ2V0VmFsdWUgPSAodmFsdWVzLCBrZXkpID0+IHtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1trZXldO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1trZXlzWzBdXTtcbiAgICB9XG59O1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgbWVtb3J5IGNsYXNzZXMgdG8gc2VsZWN0IHRoZSBpbnB1dCB2YWx1ZVxuICogdG8gdXNlIGZvciB0aGUgbWVtb3J5LiBJZiB0aGVyZSBpcyBvbmx5IG9uZSBpbnB1dCB2YWx1ZSwgaXQgaXMgdXNlZC5cbiAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBpbnB1dCB2YWx1ZXMsIHRoZSBpbnB1dEtleSBtdXN0IGJlIHNwZWNpZmllZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldElucHV0VmFsdWUgPSAoaW5wdXRWYWx1ZXMsIGlucHV0S2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZShpbnB1dFZhbHVlcywgaW5wdXRLZXkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGlucHV0VmFsdWVzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB2YWx1ZXMgaGF2ZSAke2tleXMubGVuZ3RofSBrZXlzLCB5b3UgbXVzdCBzcGVjaWZ5IGFuIGlucHV0IGtleSBvciBwYXNzIG9ubHkgMSBrZXkgYXMgaW5wdXRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IG1lbW9yeSBjbGFzc2VzIHRvIHNlbGVjdCB0aGUgb3V0cHV0IHZhbHVlXG4gKiB0byB1c2UgZm9yIHRoZSBtZW1vcnkuIElmIHRoZXJlIGlzIG9ubHkgb25lIG91dHB1dCB2YWx1ZSwgaXQgaXMgdXNlZC5cbiAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBvdXRwdXQgdmFsdWVzLCB0aGUgb3V0cHV0S2V5IG11c3QgYmUgc3BlY2lmaWVkLlxuICogSWYgbm8gb3V0cHV0S2V5IGlzIHNwZWNpZmllZCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICovXG5leHBvcnQgY29uc3QgZ2V0T3V0cHV0VmFsdWUgPSAob3V0cHV0VmFsdWVzLCBvdXRwdXRLZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKG91dHB1dFZhbHVlcywgb3V0cHV0S2V5KTtcbiAgICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvdXRwdXRWYWx1ZXMpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCB2YWx1ZXMgaGF2ZSAke2tleXMubGVuZ3RofSBrZXlzLCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dCBrZXkgb3IgcGFzcyBvbmx5IDEga2V5IGFzIG91dHB1dGApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIGJ5IG1lbW9yeSBjbGFzc2VzIHRvIGdldCB0aGUga2V5IG9mIHRoZSBwcm9tcHQgaW5wdXQsXG4gKiBleGNsdWRpbmcgYW55IGtleXMgdGhhdCBhcmUgbWVtb3J5IHZhcmlhYmxlcyBvciB0aGUgXCJzdG9wXCIga2V5LiBJZlxuICogdGhlcmUgaXMgbm90IGV4YWN0bHkgb25lIHByb21wdCBpbnB1dCBrZXksIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFByb21wdElucHV0S2V5KGlucHV0cywgbWVtb3J5VmFyaWFibGVzKSB7XG4gICAgY29uc3QgcHJvbXB0SW5wdXRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRzKS5maWx0ZXIoKGtleSkgPT4gIW1lbW9yeVZhcmlhYmxlcy5pbmNsdWRlcyhrZXkpICYmIGtleSAhPT0gXCJzdG9wXCIpO1xuICAgIGlmIChwcm9tcHRJbnB1dEtleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT25lIGlucHV0IGtleSBleHBlY3RlZCwgYnV0IGdvdCAke3Byb21wdElucHV0S2V5cy5sZW5ndGh9YCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9tcHRJbnB1dEtleXNbMF07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/memory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/ai.js":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/ai.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIMessage: () => (/* binding */ AIMessage),\n/* harmony export */   AIMessageChunk: () => (/* binding */ AIMessageChunk),\n/* harmony export */   isAIMessage: () => (/* binding */ isAIMessage),\n/* harmony export */   isAIMessageChunk: () => (/* binding */ isAIMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _utils_json_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/json.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tool.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.js\");\n\n\n\n/**\n * Represents an AI message in a conversation.\n */\nclass AIMessage extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessage {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n        };\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                additional_kwargs: kwargs ?? {},\n            };\n        }\n        else {\n            initParams = fields;\n            const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n            const toolCalls = initParams.tool_calls;\n            if (!(rawToolCalls == null) &&\n                rawToolCalls.length > 0 &&\n                (toolCalls === undefined || toolCalls.length === 0)) {\n                console.warn([\n                    \"New LangChain packages are available that more efficiently handle\",\n                    \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n                    \"message tool calls. e.g., `yarn add @langchain/anthropic`,\",\n                    \"yarn add @langchain/openai`, etc.\",\n                ].join(\" \"));\n            }\n            try {\n                if (!(rawToolCalls == null) && toolCalls === undefined) {\n                    const [toolCalls, invalidToolCalls] = (0,_tool_js__WEBPACK_IMPORTED_MODULE_2__.defaultToolCallParser)(rawToolCalls);\n                    initParams.tool_calls = toolCalls ?? [];\n                    initParams.invalid_tool_calls = invalidToolCalls ?? [];\n                }\n                else {\n                    initParams.tool_calls = initParams.tool_calls ?? [];\n                    initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n                }\n            }\n            catch (e) {\n                // Do nothing if parsing fails\n                initParams.tool_calls = [];\n                initParams.invalid_tool_calls = [];\n            }\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof initParams !== \"string\") {\n            this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n            this.invalid_tool_calls =\n                initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        }\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    static lc_name() {\n        return \"AIMessage\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n}\nfunction isAIMessage(x) {\n    return x._getType() === \"ai\";\n}\nfunction isAIMessageChunk(x) {\n    return x._getType() === \"ai\";\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nclass AIMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessageChunk {\n    constructor(fields) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n            };\n        }\n        else if (fields.tool_call_chunks === undefined ||\n            fields.tool_call_chunks.length === 0) {\n            initParams = {\n                ...fields,\n                tool_calls: fields.tool_calls ?? [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n                usage_metadata: fields.usage_metadata !== undefined\n                    ? fields.usage_metadata\n                    : undefined,\n            };\n        }\n        else {\n            const toolCallChunks = fields.tool_call_chunks ?? [];\n            const groupedToolCallChunks = toolCallChunks.reduce((acc, chunk) => {\n                const matchedChunkIndex = acc.findIndex(([match]) => {\n                    // If chunk has an id and index, match if both are present\n                    if (\"id\" in chunk &&\n                        chunk.id &&\n                        \"index\" in chunk &&\n                        chunk.index !== undefined) {\n                        return chunk.id === match.id && chunk.index === match.index;\n                    }\n                    // If chunk has an id, we match on id\n                    if (\"id\" in chunk && chunk.id) {\n                        return chunk.id === match.id;\n                    }\n                    // If chunk has an index, we match on index\n                    if (\"index\" in chunk && chunk.index !== undefined) {\n                        return chunk.index === match.index;\n                    }\n                    return false;\n                });\n                if (matchedChunkIndex !== -1) {\n                    acc[matchedChunkIndex].push(chunk);\n                }\n                else {\n                    acc.push([chunk]);\n                }\n                return acc;\n            }, []);\n            const toolCalls = [];\n            const invalidToolCalls = [];\n            for (const chunks of groupedToolCallChunks) {\n                let parsedArgs = {};\n                const name = chunks[0]?.name ?? \"\";\n                const joinedArgs = chunks.map((c) => c.args || \"\").join(\"\");\n                const argsStr = joinedArgs.length ? joinedArgs : \"{}\";\n                const id = chunks[0]?.id;\n                try {\n                    parsedArgs = (0,_utils_json_js__WEBPACK_IMPORTED_MODULE_0__.parsePartialJson)(argsStr);\n                    if (!id ||\n                        parsedArgs === null ||\n                        typeof parsedArgs !== \"object\" ||\n                        Array.isArray(parsedArgs)) {\n                        throw new Error(\"Malformed tool call chunk args.\");\n                    }\n                    toolCalls.push({\n                        name,\n                        args: parsedArgs,\n                        id,\n                        type: \"tool_call\",\n                    });\n                }\n                catch (e) {\n                    invalidToolCalls.push({\n                        name,\n                        args: argsStr,\n                        id,\n                        error: \"Malformed args.\",\n                        type: \"invalid_tool_call\",\n                    });\n                }\n            }\n            initParams = {\n                ...fields,\n                tool_calls: toolCalls,\n                invalid_tool_calls: invalidToolCalls,\n                usage_metadata: fields.usage_metadata !== undefined\n                    ? fields.usage_metadata\n                    : undefined,\n            };\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // Must redeclare tool call fields since there is no multiple inheritance in JS.\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tool_call_chunks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_chunks =\n            initParams.tool_call_chunks ?? this.tool_call_chunks;\n        this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n        this.invalid_tool_calls =\n            initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n            tool_call_chunks: \"tool_call_chunks\",\n        };\n    }\n    static lc_name() {\n        return \"AIMessageChunk\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            tool_call_chunks: this.tool_call_chunks,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n    concat(chunk) {\n        const combinedFields = {\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            tool_call_chunks: [],\n            id: this.id ?? chunk.id,\n        };\n        if (this.tool_call_chunks !== undefined ||\n            chunk.tool_call_chunks !== undefined) {\n            const rawToolCalls = (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeLists)(this.tool_call_chunks, chunk.tool_call_chunks);\n            if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n                combinedFields.tool_call_chunks = rawToolCalls;\n            }\n        }\n        if (this.usage_metadata !== undefined ||\n            chunk.usage_metadata !== undefined) {\n            const inputTokenDetails = {\n                ...((this.usage_metadata?.input_token_details?.audio !== undefined ||\n                    chunk.usage_metadata?.input_token_details?.audio !== undefined) && {\n                    audio: (this.usage_metadata?.input_token_details?.audio ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.audio ?? 0),\n                }),\n                ...((this.usage_metadata?.input_token_details?.cache_read !==\n                    undefined ||\n                    chunk.usage_metadata?.input_token_details?.cache_read !==\n                        undefined) && {\n                    cache_read: (this.usage_metadata?.input_token_details?.cache_read ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.cache_read ?? 0),\n                }),\n                ...((this.usage_metadata?.input_token_details?.cache_creation !==\n                    undefined ||\n                    chunk.usage_metadata?.input_token_details?.cache_creation !==\n                        undefined) && {\n                    cache_creation: (this.usage_metadata?.input_token_details?.cache_creation ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.cache_creation ?? 0),\n                }),\n            };\n            const outputTokenDetails = {\n                ...((this.usage_metadata?.output_token_details?.audio !== undefined ||\n                    chunk.usage_metadata?.output_token_details?.audio !== undefined) && {\n                    audio: (this.usage_metadata?.output_token_details?.audio ?? 0) +\n                        (chunk.usage_metadata?.output_token_details?.audio ?? 0),\n                }),\n                ...((this.usage_metadata?.output_token_details?.reasoning !==\n                    undefined ||\n                    chunk.usage_metadata?.output_token_details?.reasoning !==\n                        undefined) && {\n                    reasoning: (this.usage_metadata?.output_token_details?.reasoning ?? 0) +\n                        (chunk.usage_metadata?.output_token_details?.reasoning ?? 0),\n                }),\n            };\n            const left = this.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const right = chunk.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const usage_metadata = {\n                input_tokens: left.input_tokens + right.input_tokens,\n                output_tokens: left.output_tokens + right.output_tokens,\n                total_tokens: left.total_tokens + right.total_tokens,\n                // Do not include `input_token_details` / `output_token_details` keys in combined fields\n                // unless their values are defined.\n                ...(Object.keys(inputTokenDetails).length > 0 && {\n                    input_token_details: inputTokenDetails,\n                }),\n                ...(Object.keys(outputTokenDetails).length > 0 && {\n                    output_token_details: outputTokenDetails,\n                }),\n            };\n            combinedFields.usage_metadata = usage_metadata;\n        }\n        return new AIMessageChunk(combinedFields);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYWkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvRDtBQUMrQztBQUNoRDtBQUNuRDtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsaURBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsK0RBQXFCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2QixzREFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0EsaUNBQWlDLGdFQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFZO0FBQ2pDLCtCQUErQixxREFBVztBQUMxQywrQkFBK0IscURBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxtZXNzYWdlc1xcYWkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VQYXJ0aWFsSnNvbiB9IGZyb20gXCIuLi91dGlscy9qc29uLmpzXCI7XG5pbXBvcnQgeyBCYXNlTWVzc2FnZSwgQmFzZU1lc3NhZ2VDaHVuaywgbWVyZ2VDb250ZW50LCBfbWVyZ2VEaWN0cywgX21lcmdlTGlzdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFRvb2xDYWxsUGFyc2VyLCB9IGZyb20gXCIuL3Rvb2wuanNcIjtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBBSSBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQUlNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICAvLyBleGNsdWRlIHNuYWtlIGNhc2UgY29udmVyc2lvbiB0byBwYXNjYWwgY2FzZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIubGNfYWxpYXNlcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBcImludmFsaWRfdG9vbF9jYWxsc1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBsZXQgaW5pdFBhcmFtcztcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IGt3YXJncyA/PyB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0gZmllbGRzO1xuICAgICAgICAgICAgY29uc3QgcmF3VG9vbENhbGxzID0gaW5pdFBhcmFtcy5hZGRpdGlvbmFsX2t3YXJncz8udG9vbF9jYWxscztcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IGluaXRQYXJhbXMudG9vbF9jYWxscztcbiAgICAgICAgICAgIGlmICghKHJhd1Rvb2xDYWxscyA9PSBudWxsKSAmJlxuICAgICAgICAgICAgICAgIHJhd1Rvb2xDYWxscy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgKHRvb2xDYWxscyA9PT0gdW5kZWZpbmVkIHx8IHRvb2xDYWxscy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFtcbiAgICAgICAgICAgICAgICAgICAgXCJOZXcgTGFuZ0NoYWluIHBhY2thZ2VzIGFyZSBhdmFpbGFibGUgdGhhdCBtb3JlIGVmZmljaWVudGx5IGhhbmRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInRvb2wgY2FsbGluZy5cXG5cXG5QbGVhc2UgdXBncmFkZSB5b3VyIHBhY2thZ2VzIHRvIHZlcnNpb25zIHRoYXQgc2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWVzc2FnZSB0b29sIGNhbGxzLiBlLmcuLCBgeWFybiBhZGQgQGxhbmdjaGFpbi9hbnRocm9waWNgLFwiLFxuICAgICAgICAgICAgICAgICAgICBcInlhcm4gYWRkIEBsYW5nY2hhaW4vb3BlbmFpYCwgZXRjLlwiLFxuICAgICAgICAgICAgICAgIF0uam9pbihcIiBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIShyYXdUb29sQ2FsbHMgPT0gbnVsbCkgJiYgdG9vbENhbGxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Rvb2xDYWxscywgaW52YWxpZFRvb2xDYWxsc10gPSBkZWZhdWx0VG9vbENhbGxQYXJzZXIocmF3VG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxzID0gdG9vbENhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA9IGludmFsaWRUb29sQ2FsbHMgPz8gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPSBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPz8gW107XG4gICAgICAgICAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID0gaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPz8gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHBhcnNpbmcgZmFpbHNcbiAgICAgICAgICAgICAgICBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNhZGx5LCBUeXBlU2NyaXB0IG9ubHkgYWxsb3dzIHN1cGVyKCkgY2FsbHMgYXQgcm9vdCBpZiB0aGUgY2xhc3MgaGFzXG4gICAgICAgIC8vIHByb3BlcnRpZXMgd2l0aCBpbml0aWFsaXplcnMsIHNvIHdlIGhhdmUgdG8gY2hlY2sgdHlwZXMgdHdpY2UuXG4gICAgICAgIHN1cGVyKGluaXRQYXJhbXMpO1xuICAgICAgICAvLyBUaGVzZSBhcmUgdHlwZWQgYXMgb3B0aW9uYWwgdG8gYXZvaWQgYnJlYWtpbmcgY2hhbmdlcyBhbmQgYWxsb3cgZm9yIGNhc3RpbmdcbiAgICAgICAgLy8gZnJvbSBCYXNlTWVzc2FnZS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbF9jYWxsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImludmFsaWRfdG9vbF9jYWxsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwcm92aWRlZCwgdG9rZW4gdXNhZ2UgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNhZ2VfbWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0UGFyYW1zICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2xfY2FsbHMgPSBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPz8gdGhpcy50b29sX2NhbGxzO1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPVxuICAgICAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID8/IHRoaXMuaW52YWxpZF90b29sX2NhbGxzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNhZ2VfbWV0YWRhdGEgPSBpbml0UGFyYW1zLnVzYWdlX21ldGFkYXRhO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQUlNZXNzYWdlXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJhaVwiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiB0aGlzLnRvb2xfY2FsbHMsXG4gICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IHRoaXMuaW52YWxpZF90b29sX2NhbGxzLFxuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHRoaXMudXNhZ2VfbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQUlNZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImFpXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBSU1lc3NhZ2VDaHVuayh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJhaVwiO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYW4gQUkgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBBSSBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFJTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGxldCBpbml0UGFyYW1zO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmaWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRzLnRvb2xfY2FsbF9jaHVua3MgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgZmllbGRzLnRvb2xfY2FsbF9jaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBmaWVsZHMudG9vbF9jYWxscyA/PyBbXSxcbiAgICAgICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IFtdLFxuICAgICAgICAgICAgICAgIHVzYWdlX21ldGFkYXRhOiBmaWVsZHMudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkcy51c2FnZV9tZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbENodW5rcyA9IGZpZWxkcy50b29sX2NhbGxfY2h1bmtzID8/IFtdO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBlZFRvb2xDYWxsQ2h1bmtzID0gdG9vbENhbGxDaHVua3MucmVkdWNlKChhY2MsIGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZENodW5rSW5kZXggPSBhY2MuZmluZEluZGV4KChbbWF0Y2hdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGNodW5rIGhhcyBhbiBpZCBhbmQgaW5kZXgsIG1hdGNoIGlmIGJvdGggYXJlIHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiaWRcIiBpbiBjaHVuayAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5kZXhcIiBpbiBjaHVuayAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLmlkID09PSBtYXRjaC5pZCAmJiBjaHVuay5pbmRleCA9PT0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgY2h1bmsgaGFzIGFuIGlkLCB3ZSBtYXRjaCBvbiBpZFxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJpZFwiIGluIGNodW5rICYmIGNodW5rLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuaWQgPT09IG1hdGNoLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGNodW5rIGhhcyBhbiBpbmRleCwgd2UgbWF0Y2ggb24gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiaW5kZXhcIiBpbiBjaHVuayAmJiBjaHVuay5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuaW5kZXggPT09IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZENodW5rSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1ttYXRjaGVkQ2h1bmtJbmRleF0ucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2MucHVzaChbY2h1bmtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgaW52YWxpZFRvb2xDYWxscyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaHVua3Mgb2YgZ3JvdXBlZFRvb2xDYWxsQ2h1bmtzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZEFyZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gY2h1bmtzWzBdPy5uYW1lID8/IFwiXCI7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkQXJncyA9IGNodW5rcy5tYXAoKGMpID0+IGMuYXJncyB8fCBcIlwiKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3NTdHIgPSBqb2luZWRBcmdzLmxlbmd0aCA/IGpvaW5lZEFyZ3MgOiBcInt9XCI7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBjaHVua3NbMF0/LmlkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFyZ3MgPSBwYXJzZVBhcnRpYWxKc29uKGFyZ3NTdHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcmdzID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcGFyc2VkQXJncyAhPT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShwYXJzZWRBcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHRvb2wgY2FsbCBjaHVuayBhcmdzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogcGFyc2VkQXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRUb29sQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1N0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiTWFsZm9ybWVkIGFyZ3MuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWRfdG9vbF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IGludmFsaWRUb29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IGZpZWxkcy51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gZmllbGRzLnVzYWdlX21ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWRseSwgVHlwZVNjcmlwdCBvbmx5IGFsbG93cyBzdXBlcigpIGNhbGxzIGF0IHJvb3QgaWYgdGhlIGNsYXNzIGhhc1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIHdpdGggaW5pdGlhbGl6ZXJzLCBzbyB3ZSBoYXZlIHRvIGNoZWNrIHR5cGVzIHR3aWNlLlxuICAgICAgICBzdXBlcihpbml0UGFyYW1zKTtcbiAgICAgICAgLy8gTXVzdCByZWRlY2xhcmUgdG9vbCBjYWxsIGZpZWxkcyBzaW5jZSB0aGVyZSBpcyBubyBtdWx0aXBsZSBpbmhlcml0YW5jZSBpbiBKUy5cbiAgICAgICAgLy8gVGhlc2UgYXJlIHR5cGVkIGFzIG9wdGlvbmFsIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXMgYW5kIGFsbG93IGZvciBjYXN0aW5nXG4gICAgICAgIC8vIGZyb20gQmFzZU1lc3NhZ2UuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfY2h1bmtzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHByb3ZpZGVkLCB0b2tlbiB1c2FnZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1c2FnZV9tZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvb2xfY2FsbF9jaHVua3MgPVxuICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxfY2h1bmtzID8/IHRoaXMudG9vbF9jYWxsX2NodW5rcztcbiAgICAgICAgdGhpcy50b29sX2NhbGxzID0gaW5pdFBhcmFtcy50b29sX2NhbGxzID8/IHRoaXMudG9vbF9jYWxscztcbiAgICAgICAgdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPVxuICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPz8gdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHM7XG4gICAgICAgIHRoaXMudXNhZ2VfbWV0YWRhdGEgPSBpbml0UGFyYW1zLnVzYWdlX21ldGFkYXRhO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLmxjX2FsaWFzZXMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IFwidG9vbF9jYWxsX2NodW5rc1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQUlNZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImFpXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRoaXMudG9vbF9jYWxscyxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IHRoaXMudG9vbF9jYWxsX2NodW5rcyxcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMsXG4gICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogdGhpcy51c2FnZV9tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkRmllbGRzID0ge1xuICAgICAgICAgICAgY29udGVudDogbWVyZ2VDb250ZW50KHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogX21lcmdlRGljdHModGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IF9tZXJnZURpY3RzKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IFtdLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQgPz8gY2h1bmsuaWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnRvb2xfY2FsbF9jaHVua3MgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgY2h1bmsudG9vbF9jYWxsX2NodW5rcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByYXdUb29sQ2FsbHMgPSBfbWVyZ2VMaXN0cyh0aGlzLnRvb2xfY2FsbF9jaHVua3MsIGNodW5rLnRvb2xfY2FsbF9jaHVua3MpO1xuICAgICAgICAgICAgaWYgKHJhd1Rvb2xDYWxscyAhPT0gdW5kZWZpbmVkICYmIHJhd1Rvb2xDYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZWRGaWVsZHMudG9vbF9jYWxsX2NodW5rcyA9IHJhd1Rvb2xDYWxscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjaHVuay51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFRva2VuRGV0YWlscyA9IHtcbiAgICAgICAgICAgICAgICAuLi4oKHRoaXMudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86ICh0aGlzLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyA/PyAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvID8/IDApLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLigodGhpcy51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfcmVhZCAhPT1cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9yZWFkICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlX3JlYWQ6ICh0aGlzLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9yZWFkID8/IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaHVuay51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfcmVhZCA/PyAwKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi4oKHRoaXMudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX2NyZWF0aW9uICE9PVxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX2NyZWF0aW9uICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlX2NyZWF0aW9uOiAodGhpcy51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfY3JlYXRpb24gPz8gMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9jcmVhdGlvbiA/PyAwKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRUb2tlbkRldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uKCh0aGlzLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBjaHVuay51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86ICh0aGlzLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gPz8gMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNodW5rLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gPz8gMCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uKCh0aGlzLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8ucmVhc29uaW5nICE9PVxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/Lm91dHB1dF90b2tlbl9kZXRhaWxzPy5yZWFzb25pbmcgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uaW5nOiAodGhpcy51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LnJlYXNvbmluZyA/PyAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2h1bmsudXNhZ2VfbWV0YWRhdGE/Lm91dHB1dF90b2tlbl9kZXRhaWxzPy5yZWFzb25pbmcgPz8gMCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMudXNhZ2VfbWV0YWRhdGEgPz8ge1xuICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGNodW5rLnVzYWdlX21ldGFkYXRhID8/IHtcbiAgICAgICAgICAgICAgICBpbnB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdXNhZ2VfbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiBsZWZ0LmlucHV0X3Rva2VucyArIHJpZ2h0LmlucHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiBsZWZ0Lm91dHB1dF90b2tlbnMgKyByaWdodC5vdXRwdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogbGVmdC50b3RhbF90b2tlbnMgKyByaWdodC50b3RhbF90b2tlbnMsXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgYGlucHV0X3Rva2VuX2RldGFpbHNgIC8gYG91dHB1dF90b2tlbl9kZXRhaWxzYCBrZXlzIGluIGNvbWJpbmVkIGZpZWxkc1xuICAgICAgICAgICAgICAgIC8vIHVubGVzcyB0aGVpciB2YWx1ZXMgYXJlIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgLi4uKE9iamVjdC5rZXlzKGlucHV0VG9rZW5EZXRhaWxzKS5sZW5ndGggPiAwICYmIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5fZGV0YWlsczogaW5wdXRUb2tlbkRldGFpbHMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uKE9iamVjdC5rZXlzKG91dHB1dFRva2VuRGV0YWlscykubGVuZ3RoID4gMCAmJiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF90b2tlbl9kZXRhaWxzOiBvdXRwdXRUb2tlbkRldGFpbHMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29tYmluZWRGaWVsZHMudXNhZ2VfbWV0YWRhdGEgPSB1c2FnZV9tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFJTWVzc2FnZUNodW5rKGNvbWJpbmVkRmllbGRzKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/ai.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/base.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/base.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMessage: () => (/* binding */ BaseMessage),\n/* harmony export */   BaseMessageChunk: () => (/* binding */ BaseMessageChunk),\n/* harmony export */   _isMessageFieldWithRole: () => (/* binding */ _isMessageFieldWithRole),\n/* harmony export */   _mergeDicts: () => (/* binding */ _mergeDicts),\n/* harmony export */   _mergeLists: () => (/* binding */ _mergeLists),\n/* harmony export */   _mergeObj: () => (/* binding */ _mergeObj),\n/* harmony export */   _mergeStatus: () => (/* binding */ _mergeStatus),\n/* harmony export */   isBaseMessage: () => (/* binding */ isBaseMessage),\n/* harmony export */   isBaseMessageChunk: () => (/* binding */ isBaseMessageChunk),\n/* harmony export */   isOpenAIToolCallArray: () => (/* binding */ isOpenAIToolCallArray),\n/* harmony export */   mergeContent: () => (/* binding */ mergeContent)\n/* harmony export */ });\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../load/serializable.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _content_blocks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./content_blocks.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.js\");\n\n\nfunction mergeContent(firstContent, secondContent) {\n    // If first content is a string\n    if (typeof firstContent === \"string\") {\n        if (firstContent === \"\") {\n            return secondContent;\n        }\n        if (typeof secondContent === \"string\") {\n            return firstContent + secondContent;\n        }\n        else if (Array.isArray(secondContent) &&\n            secondContent.some((c) => (0,_content_blocks_js__WEBPACK_IMPORTED_MODULE_1__.isDataContentBlock)(c))) {\n            return [\n                {\n                    type: \"text\",\n                    source_type: \"text\",\n                    text: firstContent,\n                },\n                ...secondContent,\n            ];\n        }\n        else {\n            return [{ type: \"text\", text: firstContent }, ...secondContent];\n        }\n        // If both are arrays\n    }\n    else if (Array.isArray(secondContent)) {\n        return (_mergeLists(firstContent, secondContent) ?? [\n            ...firstContent,\n            ...secondContent,\n        ]);\n    }\n    else {\n        if (secondContent === \"\") {\n            return firstContent;\n        }\n        else if (Array.isArray(firstContent) &&\n            firstContent.some((c) => (0,_content_blocks_js__WEBPACK_IMPORTED_MODULE_1__.isDataContentBlock)(c))) {\n            return [\n                ...firstContent,\n                {\n                    type: \"file\",\n                    source_type: \"text\",\n                    text: secondContent,\n                },\n            ];\n        }\n        else {\n            return [...firstContent, { type: \"text\", text: secondContent }];\n        }\n    }\n}\n/**\n * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n * it will return 'success'.\n *\n * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n * @returns {\"success\" | \"error\"} The 'merged' value.\n */\nfunction _mergeStatus(left, right) {\n    if (left === \"error\" || right === \"error\") {\n        return \"error\";\n    }\n    return \"success\";\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction stringifyWithDepthLimit(obj, depthLimit) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function helper(obj, currentDepth) {\n        if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n            return obj;\n        }\n        if (currentDepth >= depthLimit) {\n            if (Array.isArray(obj)) {\n                return \"[Array]\";\n            }\n            return \"[Object]\";\n        }\n        if (Array.isArray(obj)) {\n            return obj.map((item) => helper(item, currentDepth + 1));\n        }\n        const result = {};\n        for (const key of Object.keys(obj)) {\n            result[key] = helper(obj[key], currentDepth + 1);\n        }\n        return result;\n    }\n    return JSON.stringify(helper(obj, 0), null, 2);\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nclass BaseMessage extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            additional_kwargs: \"additional_kwargs\",\n            response_metadata: \"response_metadata\",\n        };\n    }\n    /**\n     * Get text content of the message.\n     */\n    get text() {\n        if (typeof this.content === \"string\") {\n            return this.content;\n        }\n        if (!Array.isArray(this.content))\n            return \"\";\n        return this.content\n            .map((c) => {\n            if (typeof c === \"string\")\n                return c;\n            if (c.type === \"text\")\n                return c.text;\n            return \"\";\n        })\n            .join(\"\");\n    }\n    /** The type of the message. */\n    getType() {\n        return this._getType();\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            fields = {\n                content: fields,\n                additional_kwargs: kwargs,\n                response_metadata: {},\n            };\n        }\n        // Make sure the default value for additional_kwargs is passed into super() for serialization\n        if (!fields.additional_kwargs) {\n            // eslint-disable-next-line no-param-reassign\n            fields.additional_kwargs = {};\n        }\n        if (!fields.response_metadata) {\n            // eslint-disable-next-line no-param-reassign\n            fields.response_metadata = {};\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"messages\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The content of the message. */\n        Object.defineProperty(this, \"content\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The name of the message sender in a multi-user chat. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Additional keyword arguments */\n        Object.defineProperty(this, \"additional_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Response metadata. For example: response headers, logprobs, token counts, model name. */\n        Object.defineProperty(this, \"response_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * An optional unique identifier for the message. This should ideally be\n         * provided by the provider/model which created the message.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.content = fields.content;\n        this.additional_kwargs = fields.additional_kwargs;\n        this.response_metadata = fields.response_metadata;\n        this.id = fields.id;\n    }\n    toDict() {\n        return {\n            type: this._getType(),\n            data: this.toJSON()\n                .kwargs,\n        };\n    }\n    static lc_name() {\n        return \"BaseMessage\";\n    }\n    // Can't be protected for silly reasons\n    get _printableFields() {\n        return {\n            id: this.id,\n            content: this.content,\n            name: this.name,\n            additional_kwargs: this.additional_kwargs,\n            response_metadata: this.response_metadata,\n        };\n    }\n    // this private method is used to update the ID for the runtime\n    // value as well as in lc_kwargs for serialisation\n    _updateId(value) {\n        this.id = value;\n        // lc_attributes wouldn't work here, because jest compares the\n        // whole object\n        this.lc_kwargs.id = value;\n    }\n    get [Symbol.toStringTag]() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return this.constructor.lc_name();\n    }\n    // Override the default behavior of console.log\n    [Symbol.for(\"nodejs.util.inspect.custom\")](depth) {\n        if (depth === null) {\n            return this;\n        }\n        const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return `${this.constructor.lc_name()} ${printable}`;\n    }\n}\nfunction isOpenAIToolCallArray(value) {\n    return (Array.isArray(value) &&\n        value.every((v) => typeof v.index === \"number\"));\n}\nfunction _mergeDicts(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nleft, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nright\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const merged = { ...left };\n    for (const [key, value] of Object.entries(right)) {\n        if (merged[key] == null) {\n            merged[key] = value;\n        }\n        else if (value == null) {\n            continue;\n        }\n        else if (typeof merged[key] !== typeof value ||\n            Array.isArray(merged[key]) !== Array.isArray(value)) {\n            throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);\n        }\n        else if (typeof merged[key] === \"string\") {\n            if (key === \"type\") {\n                // Do not merge 'type' fields\n                continue;\n            }\n            else if ([\"id\", \"name\", \"output_version\", \"model_provider\"].includes(key)) {\n                // Keep the incoming value for these fields\n                merged[key] = value;\n            }\n            else {\n                merged[key] += value;\n            }\n        }\n        else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n            merged[key] = _mergeDicts(merged[key], value);\n        }\n        else if (Array.isArray(merged[key])) {\n            merged[key] = _mergeLists(merged[key], value);\n        }\n        else if (merged[key] === value) {\n            continue;\n        }\n        else {\n            console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);\n        }\n    }\n    return merged;\n}\nfunction _mergeLists(left, right) {\n    if (left === undefined && right === undefined) {\n        return undefined;\n    }\n    else if (left === undefined || right === undefined) {\n        return left || right;\n    }\n    else {\n        const merged = [...left];\n        for (const item of right) {\n            if (typeof item === \"object\" &&\n                item !== null &&\n                \"index\" in item &&\n                typeof item.index === \"number\") {\n                const toMerge = merged.findIndex((leftItem) => {\n                    const isObject = typeof leftItem === \"object\";\n                    const indiciesMatch = \"index\" in leftItem && leftItem.index === item.index;\n                    const idsMatch = \"id\" in leftItem && \"id\" in item && leftItem?.id === item?.id;\n                    const eitherItemMissingID = !(\"id\" in leftItem) ||\n                        !leftItem?.id ||\n                        !(\"id\" in item) ||\n                        !item?.id;\n                    return isObject && indiciesMatch && (idsMatch || eitherItemMissingID);\n                });\n                if (toMerge !== -1 &&\n                    typeof merged[toMerge] === \"object\" &&\n                    merged[toMerge] !== null) {\n                    merged[toMerge] = _mergeDicts(merged[toMerge], item);\n                }\n                else {\n                    merged.push(item);\n                }\n            }\n            else if (typeof item === \"object\" &&\n                item !== null &&\n                \"text\" in item &&\n                item.text === \"\") {\n                // No-op - skip empty text blocks\n                continue;\n            }\n            else {\n                merged.push(item);\n            }\n        }\n        return merged;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _mergeObj(left, right) {\n    if (!left && !right) {\n        throw new Error(\"Cannot merge two undefined objects.\");\n    }\n    if (!left || !right) {\n        return left || right;\n    }\n    else if (typeof left !== typeof right) {\n        throw new Error(`Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`);\n    }\n    else if (typeof left === \"string\" && typeof right === \"string\") {\n        return (left + right);\n    }\n    else if (Array.isArray(left) && Array.isArray(right)) {\n        return _mergeLists(left, right);\n    }\n    else if (typeof left === \"object\" && typeof right === \"object\") {\n        return _mergeDicts(left, right);\n    }\n    else if (left === right) {\n        return left;\n    }\n    else {\n        throw new Error(`Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`);\n    }\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nclass BaseMessageChunk extends BaseMessage {\n}\nfunction _isMessageFieldWithRole(x) {\n    return typeof x.role === \"string\";\n}\nfunction isBaseMessage(messageLike) {\n    return typeof messageLike?._getType === \"function\";\n}\nfunction isBaseMessageChunk(messageLike) {\n    return (isBaseMessage(messageLike) &&\n        typeof messageLike.concat === \"function\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ0c7QUFDbkQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0VBQWtCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0VBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUNBQW1DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYSxxQkFBcUI7QUFDbEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMEJBQTBCLCtEQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCLEVBQUUsVUFBVTtBQUMxRDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZLFVBQVUsYUFBYTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLEtBQUssVUFBVSxNQUFNO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxtZXNzYWdlc1xcYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTZXJpYWxpemFibGUgfSBmcm9tIFwiLi4vbG9hZC9zZXJpYWxpemFibGUuanNcIjtcbmltcG9ydCB7IGlzRGF0YUNvbnRlbnRCbG9jaywgfSBmcm9tIFwiLi9jb250ZW50X2Jsb2Nrcy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ29udGVudChmaXJzdENvbnRlbnQsIHNlY29uZENvbnRlbnQpIHtcbiAgICAvLyBJZiBmaXJzdCBjb250ZW50IGlzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBmaXJzdENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGZpcnN0Q29udGVudCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHNlY29uZENvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3RDb250ZW50ICsgc2Vjb25kQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlY29uZENvbnRlbnQpICYmXG4gICAgICAgICAgICBzZWNvbmRDb250ZW50LnNvbWUoKGMpID0+IGlzRGF0YUNvbnRlbnRCbG9jayhjKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgc291cmNlX3R5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmaXJzdENvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5zZWNvbmRDb250ZW50LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogZmlyc3RDb250ZW50IH0sIC4uLnNlY29uZENvbnRlbnRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGJvdGggYXJlIGFycmF5c1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlY29uZENvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiAoX21lcmdlTGlzdHMoZmlyc3RDb250ZW50LCBzZWNvbmRDb250ZW50KSA/PyBbXG4gICAgICAgICAgICAuLi5maXJzdENvbnRlbnQsXG4gICAgICAgICAgICAuLi5zZWNvbmRDb250ZW50LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzZWNvbmRDb250ZW50ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3RDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3RDb250ZW50KSAmJlxuICAgICAgICAgICAgZmlyc3RDb250ZW50LnNvbWUoKGMpID0+IGlzRGF0YUNvbnRlbnRCbG9jayhjKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLi4uZmlyc3RDb250ZW50LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZV90eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc2Vjb25kQ29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4uZmlyc3RDb250ZW50LCB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBzZWNvbmRDb250ZW50IH1dO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAnTWVyZ2UnIHR3byBzdGF0dXNlcy4gSWYgZWl0aGVyIHZhbHVlIHBhc3NlZCBpcyAnZXJyb3InLCBpdCB3aWxsIHJldHVybiAnZXJyb3InLiBFbHNlXG4gKiBpdCB3aWxsIHJldHVybiAnc3VjY2VzcycuXG4gKlxuICogQHBhcmFtIHtcInN1Y2Nlc3NcIiB8IFwiZXJyb3JcIiB8IHVuZGVmaW5lZH0gbGVmdCBUaGUgZXhpc3RpbmcgdmFsdWUgdG8gJ21lcmdlJyB3aXRoIHRoZSBuZXcgdmFsdWUuXG4gKiBAcGFyYW0ge1wic3VjY2Vzc1wiIHwgXCJlcnJvclwiIHwgdW5kZWZpbmVkfSByaWdodCBUaGUgbmV3IHZhbHVlIHRvICdtZXJnZScgd2l0aCB0aGUgZXhpc3RpbmcgdmFsdWVcbiAqIEByZXR1cm5zIHtcInN1Y2Nlc3NcIiB8IFwiZXJyb3JcIn0gVGhlICdtZXJnZWQnIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlU3RhdHVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IFwiZXJyb3JcIiB8fCByaWdodCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgfVxuICAgIHJldHVybiBcInN1Y2Nlc3NcIjtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBzdHJpbmdpZnlXaXRoRGVwdGhMaW1pdChvYmosIGRlcHRoTGltaXQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGZ1bmN0aW9uIGhlbHBlcihvYmosIGN1cnJlbnREZXB0aCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnREZXB0aCA+PSBkZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW0FycmF5XVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiW09iamVjdF1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLm1hcCgoaXRlbSkgPT4gaGVscGVyKGl0ZW0sIGN1cnJlbnREZXB0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZWxwZXIob2JqW2tleV0sIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShoZWxwZXIob2JqLCAwKSwgbnVsbCwgMik7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCB0eXBlcyBvZiBtZXNzYWdlcyBpbiBhIGNvbnZlcnNhdGlvbi4gSXQgaW5jbHVkZXNcbiAqIHByb3BlcnRpZXMgbGlrZSBgY29udGVudGAsIGBuYW1lYCwgYW5kIGBhZGRpdGlvbmFsX2t3YXJnc2AuIEl0IGFsc29cbiAqIGluY2x1ZGVzIG1ldGhvZHMgbGlrZSBgdG9EaWN0KClgIGFuZCBgX2dldFR5cGUoKWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTWVzc2FnZSBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogXCJhZGRpdGlvbmFsX2t3YXJnc1wiLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IFwicmVzcG9uc2VfbWV0YWRhdGFcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRleHQgY29udGVudCBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuY29udGVudCkpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFxuICAgICAgICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgaWYgKGMudHlwZSA9PT0gXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMudGV4dDtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGUgbWVzc2FnZS4gKi9cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHlwZSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogZmllbGRzLFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBrd2FyZ3MsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGFkZGl0aW9uYWxfa3dhcmdzIGlzIHBhc3NlZCBpbnRvIHN1cGVyKCkgZm9yIHNlcmlhbGl6YXRpb25cbiAgICAgICAgaWYgKCFmaWVsZHMuYWRkaXRpb25hbF9rd2FyZ3MpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzLmFkZGl0aW9uYWxfa3dhcmdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaWVsZHMucmVzcG9uc2VfbWV0YWRhdGEpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzLnJlc3BvbnNlX21ldGFkYXRhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm1lc3NhZ2VzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZS4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2Ugc2VuZGVyIGluIGEgbXVsdGktdXNlciBjaGF0LiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBBZGRpdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZGl0aW9uYWxfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBSZXNwb25zZSBtZXRhZGF0YS4gRm9yIGV4YW1wbGU6IHJlc3BvbnNlIGhlYWRlcnMsIGxvZ3Byb2JzLCB0b2tlbiBjb3VudHMsIG1vZGVsIG5hbWUuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNlX21ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvcHRpb25hbCB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIG1lc3NhZ2UuIFRoaXMgc2hvdWxkIGlkZWFsbHkgYmVcbiAgICAgICAgICogcHJvdmlkZWQgYnkgdGhlIHByb3ZpZGVyL21vZGVsIHdoaWNoIGNyZWF0ZWQgdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gZmllbGRzLmNvbnRlbnQ7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MgPSBmaWVsZHMuYWRkaXRpb25hbF9rd2FyZ3M7XG4gICAgICAgIHRoaXMucmVzcG9uc2VfbWV0YWRhdGEgPSBmaWVsZHMucmVzcG9uc2VfbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuaWQgPSBmaWVsZHMuaWQ7XG4gICAgfVxuICAgIHRvRGljdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGUoKSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMudG9KU09OKClcbiAgICAgICAgICAgICAgICAua3dhcmdzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQmFzZU1lc3NhZ2VcIjtcbiAgICB9XG4gICAgLy8gQ2FuJ3QgYmUgcHJvdGVjdGVkIGZvciBzaWxseSByZWFzb25zXG4gICAgZ2V0IF9wcmludGFibGVGaWVsZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiB0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHRoaXMgcHJpdmF0ZSBtZXRob2QgaXMgdXNlZCB0byB1cGRhdGUgdGhlIElEIGZvciB0aGUgcnVudGltZVxuICAgIC8vIHZhbHVlIGFzIHdlbGwgYXMgaW4gbGNfa3dhcmdzIGZvciBzZXJpYWxpc2F0aW9uXG4gICAgX3VwZGF0ZUlkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaWQgPSB2YWx1ZTtcbiAgICAgICAgLy8gbGNfYXR0cmlidXRlcyB3b3VsZG4ndCB3b3JrIGhlcmUsIGJlY2F1c2UgamVzdCBjb21wYXJlcyB0aGVcbiAgICAgICAgLy8gd2hvbGUgb2JqZWN0XG4gICAgICAgIHRoaXMubGNfa3dhcmdzLmlkID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubGNfbmFtZSgpO1xuICAgIH1cbiAgICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBjb25zb2xlLmxvZ1xuICAgIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKGRlcHRoKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpbnRhYmxlID0gc3RyaW5naWZ5V2l0aERlcHRoTGltaXQodGhpcy5fcHJpbnRhYmxlRmllbGRzLCBNYXRoLm1heCg0LCBkZXB0aCkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5sY19uYW1lKCl9ICR7cHJpbnRhYmxlfWA7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzT3BlbkFJVG9vbENhbGxBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgdmFsdWUuZXZlcnkoKHYpID0+IHR5cGVvZiB2LmluZGV4ID09PSBcIm51bWJlclwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gX21lcmdlRGljdHMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubGVmdCwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucmlnaHRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICBjb25zdCBtZXJnZWQgPSB7IC4uLmxlZnQgfTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyaWdodCkpIHtcbiAgICAgICAgaWYgKG1lcmdlZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lcmdlZFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lcmdlZFtrZXldICE9PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkobWVyZ2VkW2tleV0pICE9PSBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmaWVsZFske2tleX1dIGFscmVhZHkgZXhpc3RzIGluIHRoZSBtZXNzYWdlIGNodW5rLCBidXQgd2l0aCBhIGRpZmZlcmVudCB0eXBlLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXJnZWRba2V5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgbWVyZ2UgJ3R5cGUnIGZpZWxkc1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoW1wiaWRcIiwgXCJuYW1lXCIsIFwib3V0cHV0X3ZlcnNpb25cIiwgXCJtb2RlbF9wcm92aWRlclwiXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgaW5jb21pbmcgdmFsdWUgZm9yIHRoZXNlIGZpZWxkc1xuICAgICAgICAgICAgICAgIG1lcmdlZFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRba2V5XSArPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVyZ2VkW2tleV0gPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkobWVyZ2VkW2tleV0pKSB7XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IF9tZXJnZURpY3RzKG1lcmdlZFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXJnZWRba2V5XSkpIHtcbiAgICAgICAgICAgIG1lcmdlZFtrZXldID0gX21lcmdlTGlzdHMobWVyZ2VkW2tleV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXJnZWRba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBmaWVsZFske2tleX1dIGFscmVhZHkgZXhpc3RzIGluIHRoaXMgbWVzc2FnZSBjaHVuayBhbmQgdmFsdWUgaGFzIHVuc3VwcG9ydGVkIHR5cGUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VMaXN0cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0ID09PSB1bmRlZmluZWQgfHwgcmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IFsuLi5sZWZ0XTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHJpZ2h0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBpdGVtICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgXCJpbmRleFwiIGluIGl0ZW0gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgaXRlbS5pbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvTWVyZ2UgPSBtZXJnZWQuZmluZEluZGV4KChsZWZ0SXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc09iamVjdCA9IHR5cGVvZiBsZWZ0SXRlbSA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kaWNpZXNNYXRjaCA9IFwiaW5kZXhcIiBpbiBsZWZ0SXRlbSAmJiBsZWZ0SXRlbS5pbmRleCA9PT0gaXRlbS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRzTWF0Y2ggPSBcImlkXCIgaW4gbGVmdEl0ZW0gJiYgXCJpZFwiIGluIGl0ZW0gJiYgbGVmdEl0ZW0/LmlkID09PSBpdGVtPy5pZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWl0aGVySXRlbU1pc3NpbmdJRCA9ICEoXCJpZFwiIGluIGxlZnRJdGVtKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWxlZnRJdGVtPy5pZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIShcImlkXCIgaW4gaXRlbSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFpdGVtPy5pZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0ICYmIGluZGljaWVzTWF0Y2ggJiYgKGlkc01hdGNoIHx8IGVpdGhlckl0ZW1NaXNzaW5nSUQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0b01lcmdlICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbWVyZ2VkW3RvTWVyZ2VdID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFt0b01lcmdlXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRbdG9NZXJnZV0gPSBfbWVyZ2VEaWN0cyhtZXJnZWRbdG9NZXJnZV0sIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBpdGVtICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCIgaW4gaXRlbSAmJlxuICAgICAgICAgICAgICAgIGl0ZW0udGV4dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIC8vIE5vLW9wIC0gc2tpcCBlbXB0eSB0ZXh0IGJsb2Nrc1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIF9tZXJnZU9iaihsZWZ0LCByaWdodCkge1xuICAgIGlmICghbGVmdCAmJiAhcmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHR3byB1bmRlZmluZWQgb2JqZWN0cy5cIik7XG4gICAgfVxuICAgIGlmICghbGVmdCB8fCAhcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQgfHwgcmlnaHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsZWZ0ICE9PSB0eXBlb2YgcmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbWVyZ2Ugb2JqZWN0cyBvZiBkaWZmZXJlbnQgdHlwZXMuXFxuTGVmdCAke3R5cGVvZiBsZWZ0fVxcblJpZ2h0ICR7dHlwZW9mIHJpZ2h0fWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGVmdCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmlnaHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0ICsgcmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGxlZnQpICYmIEFycmF5LmlzQXJyYXkocmlnaHQpKSB7XG4gICAgICAgIHJldHVybiBfbWVyZ2VMaXN0cyhsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsZWZ0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiByaWdodCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gX21lcmdlRGljdHMobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBtZXJnZSBvYmplY3RzIG9mIGRpZmZlcmVudCB0eXBlcy5cXG5MZWZ0ICR7bGVmdH1cXG5SaWdodCAke3JpZ2h0fWApO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4gKiBtZXNzYWdlIGNodW5rcy4gSXQgaW5jbHVkZXMgYSBtZXRob2QgYF9tZXJnZV9rd2FyZ3NfZGljdCgpYCBmb3IgbWVyZ2luZ1xuICogYWRkaXRpb25hbCBrZXl3b3JkIGFyZ3VtZW50cyBmcm9tIGFub3RoZXIgYEJhc2VNZXNzYWdlQ2h1bmtgIGludG8gdGhpc1xuICogb25lLiBJdCBhbHNvIG92ZXJyaWRlcyB0aGUgYF9fYWRkX18oKWAgbWV0aG9kIHRvIHN1cHBvcnQgY29uY2F0ZW5hdGlvblxuICogb2YgYEJhc2VNZXNzYWdlQ2h1bmtgIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VNZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG59XG5leHBvcnQgZnVuY3Rpb24gX2lzTWVzc2FnZUZpZWxkV2l0aFJvbGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeC5yb2xlID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFzZU1lc3NhZ2UobWVzc2FnZUxpa2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2VMaWtlPy5fZ2V0VHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFzZU1lc3NhZ2VDaHVuayhtZXNzYWdlTGlrZSkge1xuICAgIHJldHVybiAoaXNCYXNlTWVzc2FnZShtZXNzYWdlTGlrZSkgJiZcbiAgICAgICAgdHlwZW9mIG1lc3NhZ2VMaWtlLmNvbmNhdCA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/chat.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/chat.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatMessage: () => (/* binding */ ChatMessage),\n/* harmony export */   ChatMessageChunk: () => (/* binding */ ChatMessageChunk),\n/* harmony export */   isChatMessage: () => (/* binding */ isChatMessage),\n/* harmony export */   isChatMessageChunk: () => (/* binding */ isChatMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a chat message in a conversation.\n */\nclass ChatMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"ChatMessage\";\n    }\n    static _chatMessageClass() {\n        return ChatMessage;\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"generic\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            role: this.role,\n        };\n    }\n}\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nclass ChatMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"ChatMessageChunk\";\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    concat(chunk) {\n        return new ChatMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            role: this.role,\n            id: this.id ?? chunk.id,\n        });\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            role: this.role,\n        };\n    }\n}\nfunction isChatMessage(x) {\n    return x._getType() === \"generic\";\n}\nfunction isChatMessageChunk(x) {\n    return x._getType() === \"generic\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY2hhdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsaURBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLHNEQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQVk7QUFDakMsK0JBQStCLHFEQUFXO0FBQzFDLCtCQUErQixxREFBVztBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXGNoYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhdCBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQ2hhdE1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRNZXNzYWdlXCI7XG4gICAgfVxuICAgIHN0YXRpYyBfY2hhdE1lc3NhZ2VDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIENoYXRNZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHJvbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIHJvbGU6IHJvbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb2xlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm9sZSA9IGZpZWxkcy5yb2xlO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBzdGF0aWMgaXNJbnN0YW5jZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICByb2xlOiB0aGlzLnJvbGUsXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBjaGF0IG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgY2hhdCBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIENoYXRNZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdE1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHJvbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIHJvbGU6IHJvbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb2xlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm9sZSA9IGZpZWxkcy5yb2xlO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICByb2xlOiB0aGlzLnJvbGUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDaGF0TWVzc2FnZSh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJnZW5lcmljXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDaGF0TWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImdlbmVyaWNcIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/chat.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/content_blocks.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToOpenAIImageBlock: () => (/* binding */ convertToOpenAIImageBlock),\n/* harmony export */   convertToProviderContentBlock: () => (/* binding */ convertToProviderContentBlock),\n/* harmony export */   isBase64ContentBlock: () => (/* binding */ isBase64ContentBlock),\n/* harmony export */   isDataContentBlock: () => (/* binding */ isDataContentBlock),\n/* harmony export */   isIDContentBlock: () => (/* binding */ isIDContentBlock),\n/* harmony export */   isPlainTextContentBlock: () => (/* binding */ isPlainTextContentBlock),\n/* harmony export */   isURLContentBlock: () => (/* binding */ isURLContentBlock),\n/* harmony export */   parseBase64DataUrl: () => (/* binding */ parseBase64DataUrl),\n/* harmony export */   parseMimeType: () => (/* binding */ parseMimeType)\n/* harmony export */ });\nfunction isDataContentBlock(content_block) {\n    return (typeof content_block === \"object\" &&\n        content_block !== null &&\n        \"type\" in content_block &&\n        typeof content_block.type === \"string\" &&\n        \"source_type\" in content_block &&\n        (content_block.source_type === \"url\" ||\n            content_block.source_type === \"base64\" ||\n            content_block.source_type === \"text\" ||\n            content_block.source_type === \"id\"));\n}\nfunction isURLContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"url\" &&\n        \"url\" in content_block &&\n        typeof content_block.url === \"string\");\n}\nfunction isBase64ContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"base64\" &&\n        \"data\" in content_block &&\n        typeof content_block.data === \"string\");\n}\nfunction isPlainTextContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"text\" &&\n        \"text\" in content_block &&\n        typeof content_block.text === \"string\");\n}\nfunction isIDContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"id\" &&\n        \"id\" in content_block &&\n        typeof content_block.id === \"string\");\n}\nfunction convertToOpenAIImageBlock(content_block) {\n    if (isDataContentBlock(content_block)) {\n        if (content_block.source_type === \"url\") {\n            return {\n                type: \"image_url\",\n                image_url: {\n                    url: content_block.url,\n                },\n            };\n        }\n        if (content_block.source_type === \"base64\") {\n            if (!content_block.mime_type) {\n                throw new Error(\"mime_type key is required for base64 data.\");\n            }\n            const mime_type = content_block.mime_type;\n            return {\n                type: \"image_url\",\n                image_url: {\n                    url: `data:${mime_type};base64,${content_block.data}`,\n                },\n            };\n        }\n    }\n    throw new Error(\"Unsupported source type. Only 'url' and 'base64' are supported.\");\n}\n/**\n * Utility function for ChatModelProviders. Parses a mime type into a type, subtype, and parameters.\n *\n * @param mime_type - The mime type to parse.\n * @returns An object containing the type, subtype, and parameters.\n */\nfunction parseMimeType(mime_type) {\n    const parts = mime_type.split(\";\")[0].split(\"/\");\n    if (parts.length !== 2) {\n        throw new Error(`Invalid mime type: \"${mime_type}\" - does not match type/subtype format.`);\n    }\n    const type = parts[0].trim();\n    const subtype = parts[1].trim();\n    if (type === \"\" || subtype === \"\") {\n        throw new Error(`Invalid mime type: \"${mime_type}\" - type or subtype is empty.`);\n    }\n    const parameters = {};\n    for (const parameterKvp of mime_type.split(\";\").slice(1)) {\n        const parameterParts = parameterKvp.split(\"=\");\n        if (parameterParts.length !== 2) {\n            throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n        }\n        const key = parameterParts[0].trim();\n        const value = parameterParts[1].trim();\n        if (key === \"\") {\n            throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n        }\n        parameters[key] = value;\n    }\n    return {\n        type,\n        subtype,\n        parameters,\n    };\n}\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n */\nfunction parseBase64DataUrl({ dataUrl: data_url, asTypedArray = false, }) {\n    const formatMatch = data_url.match(/^data:(\\w+\\/\\w+);base64,([A-Za-z0-9+/]+=*)$/);\n    let mime_type;\n    if (formatMatch) {\n        mime_type = formatMatch[1].toLowerCase();\n        const data = asTypedArray\n            ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0))\n            : formatMatch[2];\n        return {\n            mime_type,\n            data,\n        };\n    }\n    return undefined;\n}\n/**\n * Convert from a standard data content block to a provider's proprietary data content block format.\n *\n * Don't override this method. Instead, override the more specific conversion methods and use this\n * method unmodified.\n *\n * @param block - The standard data content block to convert.\n * @returns The provider data content block.\n * @throws An error if the standard data content block type is not supported.\n */\nfunction convertToProviderContentBlock(block, converter) {\n    if (block.type === \"text\") {\n        if (!converter.fromStandardTextBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardTextBlock\\` method.`);\n        }\n        return converter.fromStandardTextBlock(block);\n    }\n    if (block.type === \"image\") {\n        if (!converter.fromStandardImageBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardImageBlock\\` method.`);\n        }\n        return converter.fromStandardImageBlock(block);\n    }\n    if (block.type === \"audio\") {\n        if (!converter.fromStandardAudioBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardAudioBlock\\` method.`);\n        }\n        return converter.fromStandardAudioBlock(block);\n    }\n    if (block.type === \"file\") {\n        if (!converter.fromStandardFileBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardFileBlock\\` method.`);\n        }\n        return converter.fromStandardFileBlock(block);\n    }\n    throw new Error(`Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY29udGVudF9ibG9ja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsU0FBUyxtQkFBbUI7QUFDeEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG9DQUFvQztBQUNwQztBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsdUVBQXVFLFVBQVU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsVUFBVTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDhCQUE4QiwwQ0FBMEM7QUFDL0UseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxXQUFXO0FBQ3hFIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG1lc3NhZ2VzXFxjb250ZW50X2Jsb2Nrcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNEYXRhQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spIHtcbiAgICByZXR1cm4gKHR5cGVvZiBjb250ZW50X2Jsb2NrID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGNvbnRlbnRfYmxvY2sgIT09IG51bGwgJiZcbiAgICAgICAgXCJ0eXBlXCIgaW4gY29udGVudF9ibG9jayAmJlxuICAgICAgICB0eXBlb2YgY29udGVudF9ibG9jay50eXBlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIFwic291cmNlX3R5cGVcIiBpbiBjb250ZW50X2Jsb2NrICYmXG4gICAgICAgIChjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcInVybFwiIHx8XG4gICAgICAgICAgICBjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcImJhc2U2NFwiIHx8XG4gICAgICAgICAgICBjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcInRleHRcIiB8fFxuICAgICAgICAgICAgY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJpZFwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNVUkxDb250ZW50QmxvY2soY29udGVudF9ibG9jaykge1xuICAgIHJldHVybiAoaXNEYXRhQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spICYmXG4gICAgICAgIGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwidXJsXCIgJiZcbiAgICAgICAgXCJ1cmxcIiBpbiBjb250ZW50X2Jsb2NrICYmXG4gICAgICAgIHR5cGVvZiBjb250ZW50X2Jsb2NrLnVybCA9PT0gXCJzdHJpbmdcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCYXNlNjRDb250ZW50QmxvY2soY29udGVudF9ibG9jaykge1xuICAgIHJldHVybiAoaXNEYXRhQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spICYmXG4gICAgICAgIGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwiYmFzZTY0XCIgJiZcbiAgICAgICAgXCJkYXRhXCIgaW4gY29udGVudF9ibG9jayAmJlxuICAgICAgICB0eXBlb2YgY29udGVudF9ibG9jay5kYXRhID09PSBcInN0cmluZ1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluVGV4dENvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSB7XG4gICAgcmV0dXJuIChpc0RhdGFDb250ZW50QmxvY2soY29udGVudF9ibG9jaykgJiZcbiAgICAgICAgY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgXCJ0ZXh0XCIgaW4gY29udGVudF9ibG9jayAmJlxuICAgICAgICB0eXBlb2YgY29udGVudF9ibG9jay50ZXh0ID09PSBcInN0cmluZ1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0lEQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spIHtcbiAgICByZXR1cm4gKGlzRGF0YUNvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSAmJlxuICAgICAgICBjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcImlkXCIgJiZcbiAgICAgICAgXCJpZFwiIGluIGNvbnRlbnRfYmxvY2sgJiZcbiAgICAgICAgdHlwZW9mIGNvbnRlbnRfYmxvY2suaWQgPT09IFwic3RyaW5nXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb09wZW5BSUltYWdlQmxvY2soY29udGVudF9ibG9jaykge1xuICAgIGlmIChpc0RhdGFDb250ZW50QmxvY2soY29udGVudF9ibG9jaykpIHtcbiAgICAgICAgaWYgKGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZV91cmxcIixcbiAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjb250ZW50X2Jsb2NrLnVybCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgaWYgKCFjb250ZW50X2Jsb2NrLm1pbWVfdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pbWVfdHlwZSBrZXkgaXMgcmVxdWlyZWQgZm9yIGJhc2U2NCBkYXRhLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pbWVfdHlwZSA9IGNvbnRlbnRfYmxvY2subWltZV90eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgIGltYWdlX3VybDoge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGBkYXRhOiR7bWltZV90eXBlfTtiYXNlNjQsJHtjb250ZW50X2Jsb2NrLmRhdGF9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzb3VyY2UgdHlwZS4gT25seSAndXJsJyBhbmQgJ2Jhc2U2NCcgYXJlIHN1cHBvcnRlZC5cIik7XG59XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIENoYXRNb2RlbFByb3ZpZGVycy4gUGFyc2VzIGEgbWltZSB0eXBlIGludG8gYSB0eXBlLCBzdWJ0eXBlLCBhbmQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0gbWltZV90eXBlIC0gVGhlIG1pbWUgdHlwZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0eXBlLCBzdWJ0eXBlLCBhbmQgcGFyYW1ldGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWltZVR5cGUobWltZV90eXBlKSB7XG4gICAgY29uc3QgcGFydHMgPSBtaW1lX3R5cGUuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiL1wiKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtaW1lIHR5cGU6IFwiJHttaW1lX3R5cGV9XCIgLSBkb2VzIG5vdCBtYXRjaCB0eXBlL3N1YnR5cGUgZm9ybWF0LmApO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gcGFydHNbMF0udHJpbSgpO1xuICAgIGNvbnN0IHN1YnR5cGUgPSBwYXJ0c1sxXS50cmltKCk7XG4gICAgaWYgKHR5cGUgPT09IFwiXCIgfHwgc3VidHlwZSA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWltZSB0eXBlOiBcIiR7bWltZV90eXBlfVwiIC0gdHlwZSBvciBzdWJ0eXBlIGlzIGVtcHR5LmApO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0ge307XG4gICAgZm9yIChjb25zdCBwYXJhbWV0ZXJLdnAgb2YgbWltZV90eXBlLnNwbGl0KFwiO1wiKS5zbGljZSgxKSkge1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJQYXJ0cyA9IHBhcmFtZXRlckt2cC5zcGxpdChcIj1cIik7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJQYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbWV0ZXIgc3ludGF4IGluIG1pbWUgdHlwZTogXCIke21pbWVfdHlwZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBwYXJhbWV0ZXJQYXJ0c1swXS50cmltKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1ldGVyUGFydHNbMV0udHJpbSgpO1xuICAgICAgICBpZiAoa2V5ID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW1ldGVyIHN5bnRheCBpbiBtaW1lIHR5cGU6IFwiJHttaW1lX3R5cGV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1ldGVyc1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHN1YnR5cGUsXG4gICAgICAgIHBhcmFtZXRlcnMsXG4gICAgfTtcbn1cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgQ2hhdE1vZGVsUHJvdmlkZXJzLiBQYXJzZXMgYSBiYXNlNjQgZGF0YSBVUkwgaW50byBhIHR5cGVkIGFycmF5IG9yIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gZGF0YVVybCAtIFRoZSBiYXNlNjQgZGF0YSBVUkwgdG8gcGFyc2UuXG4gKiBAcGFyYW0gYXNUeXBlZEFycmF5IC0gV2hldGhlciB0byByZXR1cm4gdGhlIGRhdGEgYXMgYSB0eXBlZCBhcnJheS5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgZGF0YSBhbmQgbWltZSB0eXBlLCBvciB1bmRlZmluZWQgaWYgdGhlIGRhdGEgVVJMIGlzIGludmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJhc2U2NERhdGFVcmwoeyBkYXRhVXJsOiBkYXRhX3VybCwgYXNUeXBlZEFycmF5ID0gZmFsc2UsIH0pIHtcbiAgICBjb25zdCBmb3JtYXRNYXRjaCA9IGRhdGFfdXJsLm1hdGNoKC9eZGF0YTooXFx3K1xcL1xcdyspO2Jhc2U2NCwoW0EtWmEtejAtOSsvXSs9KikkLyk7XG4gICAgbGV0IG1pbWVfdHlwZTtcbiAgICBpZiAoZm9ybWF0TWF0Y2gpIHtcbiAgICAgICAgbWltZV90eXBlID0gZm9ybWF0TWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGFzVHlwZWRBcnJheVxuICAgICAgICAgICAgPyBVaW50OEFycmF5LmZyb20oYXRvYihmb3JtYXRNYXRjaFsyXSksIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgICAgICA6IGZvcm1hdE1hdGNoWzJdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWltZV90eXBlLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQ29udmVydCBmcm9tIGEgc3RhbmRhcmQgZGF0YSBjb250ZW50IGJsb2NrIHRvIGEgcHJvdmlkZXIncyBwcm9wcmlldGFyeSBkYXRhIGNvbnRlbnQgYmxvY2sgZm9ybWF0LlxuICpcbiAqIERvbid0IG92ZXJyaWRlIHRoaXMgbWV0aG9kLiBJbnN0ZWFkLCBvdmVycmlkZSB0aGUgbW9yZSBzcGVjaWZpYyBjb252ZXJzaW9uIG1ldGhvZHMgYW5kIHVzZSB0aGlzXG4gKiBtZXRob2QgdW5tb2RpZmllZC5cbiAqXG4gKiBAcGFyYW0gYmxvY2sgLSBUaGUgc3RhbmRhcmQgZGF0YSBjb250ZW50IGJsb2NrIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgcHJvdmlkZXIgZGF0YSBjb250ZW50IGJsb2NrLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgc3RhbmRhcmQgZGF0YSBjb250ZW50IGJsb2NrIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1Byb3ZpZGVyQ29udGVudEJsb2NrKGJsb2NrLCBjb252ZXJ0ZXIpIHtcbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgaWYgKCFjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkVGV4dEJsb2NrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnRlciBmb3IgJHtjb252ZXJ0ZXIucHJvdmlkZXJOYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgXFxgZnJvbVN0YW5kYXJkVGV4dEJsb2NrXFxgIG1ldGhvZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydGVyLmZyb21TdGFuZGFyZFRleHRCbG9jayhibG9jayk7XG4gICAgfVxuICAgIGlmIChibG9jay50eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgaWYgKCFjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkSW1hZ2VCbG9jaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJ0ZXIgZm9yICR7Y29udmVydGVyLnByb3ZpZGVyTmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IFxcYGZyb21TdGFuZGFyZEltYWdlQmxvY2tcXGAgbWV0aG9kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkSW1hZ2VCbG9jayhibG9jayk7XG4gICAgfVxuICAgIGlmIChibG9jay50eXBlID09PSBcImF1ZGlvXCIpIHtcbiAgICAgICAgaWYgKCFjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkQXVkaW9CbG9jaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJ0ZXIgZm9yICR7Y29udmVydGVyLnByb3ZpZGVyTmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IFxcYGZyb21TdGFuZGFyZEF1ZGlvQmxvY2tcXGAgbWV0aG9kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkQXVkaW9CbG9jayhibG9jayk7XG4gICAgfVxuICAgIGlmIChibG9jay50eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICBpZiAoIWNvbnZlcnRlci5mcm9tU3RhbmRhcmRGaWxlQmxvY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udmVydGVyIGZvciAke2NvbnZlcnRlci5wcm92aWRlck5hbWV9IGRvZXMgbm90IGltcGxlbWVudCBcXGBmcm9tU3RhbmRhcmRGaWxlQmxvY2tcXGAgbWV0aG9kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkRmlsZUJsb2NrKGJsb2NrKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29udmVydCBjb250ZW50IGJsb2NrIHR5cGUgJyR7YmxvY2sudHlwZX0nIHRvIHByb3ZpZGVyLXNwZWNpZmljIGZvcm1hdDogbm90IHJlY29nbml6ZWQuYCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/function.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/function.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionMessage: () => (/* binding */ FunctionMessage),\n/* harmony export */   FunctionMessageChunk: () => (/* binding */ FunctionMessageChunk),\n/* harmony export */   isFunctionMessage: () => (/* binding */ isFunctionMessage),\n/* harmony export */   isFunctionMessageChunk: () => (/* binding */ isFunctionMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a function message in a conversation.\n */\nclass FunctionMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"FunctionMessage\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name: name };\n        }\n        super(fields);\n    }\n    _getType() {\n        return \"function\";\n    }\n}\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nclass FunctionMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"FunctionMessageChunk\";\n    }\n    _getType() {\n        return \"function\";\n    }\n    concat(chunk) {\n        return new FunctionMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            name: this.name ?? \"\",\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nfunction isFunctionMessage(x) {\n    return x._getType() === \"function\";\n}\nfunction isFunctionMessageChunk(x) {\n    return x._getType() === \"function\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvZnVuY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ08sOEJBQThCLGlEQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyxzREFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBWTtBQUNqQywrQkFBK0IscURBQVc7QUFDMUMsK0JBQStCLHFEQUFXO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxtZXNzYWdlc1xcZnVuY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZnVuY3Rpb24gbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiRnVuY3Rpb25NZXNzYWdlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgbmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGNvbnRlbnQ6IGZpZWxkcywgbmFtZTogbmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgZnVuY3Rpb24gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciBmdW5jdGlvbiBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkZ1bmN0aW9uTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiBtZXJnZUNvbnRlbnQodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBfbWVyZ2VEaWN0cyh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogX21lcmdlRGljdHModGhpcy5yZXNwb25zZV9tZXRhZGF0YSwgY2h1bmsucmVzcG9uc2VfbWV0YWRhdGEpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lID8/IFwiXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb25NZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbk1lc3NhZ2VDaHVuayh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJmdW5jdGlvblwiO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/function.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/human.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/human.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HumanMessage: () => (/* binding */ HumanMessage),\n/* harmony export */   HumanMessageChunk: () => (/* binding */ HumanMessageChunk),\n/* harmony export */   isHumanMessage: () => (/* binding */ isHumanMessage),\n/* harmony export */   isHumanMessageChunk: () => (/* binding */ isHumanMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a human message in a conversation.\n */\nclass HumanMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"HumanMessage\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n}\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nclass HumanMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"HumanMessageChunk\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n    concat(chunk) {\n        return new HumanMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nfunction isHumanMessage(x) {\n    return x.getType() === \"human\";\n}\nfunction isHumanMessageChunk(x) {\n    return x.getType() === \"human\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvaHVtYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLGlEQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLHNEQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBWTtBQUNqQywrQkFBK0IscURBQVc7QUFDMUMsK0JBQStCLHFEQUFXO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXGh1bWFuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VNZXNzYWdlLCBCYXNlTWVzc2FnZUNodW5rLCBtZXJnZUNvbnRlbnQsIF9tZXJnZURpY3RzLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbi8qKlxuICogUmVwcmVzZW50cyBhIGh1bWFuIG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBIdW1hbk1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkh1bWFuTWVzc2FnZVwiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiaHVtYW5cIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBrd2FyZ3MpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBrd2FyZ3MpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgaHVtYW4gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBodW1hbiBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEh1bWFuTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkh1bWFuTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJodW1hblwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGt3YXJncyk7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSHVtYW5NZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5nZXRUeXBlKCkgPT09IFwiaHVtYW5cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0h1bWFuTWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5nZXRUeXBlKCkgPT09IFwiaHVtYW5cIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/human.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIMessage: () => (/* reexport safe */ _ai_js__WEBPACK_IMPORTED_MODULE_0__.AIMessage),\n/* harmony export */   AIMessageChunk: () => (/* reexport safe */ _ai_js__WEBPACK_IMPORTED_MODULE_0__.AIMessageChunk),\n/* harmony export */   BaseMessage: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessage),\n/* harmony export */   BaseMessageChunk: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessageChunk),\n/* harmony export */   ChatMessage: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_2__.ChatMessage),\n/* harmony export */   ChatMessageChunk: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_2__.ChatMessageChunk),\n/* harmony export */   FunctionMessage: () => (/* reexport safe */ _function_js__WEBPACK_IMPORTED_MODULE_3__.FunctionMessage),\n/* harmony export */   FunctionMessageChunk: () => (/* reexport safe */ _function_js__WEBPACK_IMPORTED_MODULE_3__.FunctionMessageChunk),\n/* harmony export */   HumanMessage: () => (/* reexport safe */ _human_js__WEBPACK_IMPORTED_MODULE_4__.HumanMessage),\n/* harmony export */   HumanMessageChunk: () => (/* reexport safe */ _human_js__WEBPACK_IMPORTED_MODULE_4__.HumanMessageChunk),\n/* harmony export */   RemoveMessage: () => (/* reexport safe */ _modifier_js__WEBPACK_IMPORTED_MODULE_8__.RemoveMessage),\n/* harmony export */   SystemMessage: () => (/* reexport safe */ _system_js__WEBPACK_IMPORTED_MODULE_5__.SystemMessage),\n/* harmony export */   SystemMessageChunk: () => (/* reexport safe */ _system_js__WEBPACK_IMPORTED_MODULE_5__.SystemMessageChunk),\n/* harmony export */   ToolMessage: () => (/* reexport safe */ _tool_js__WEBPACK_IMPORTED_MODULE_10__.ToolMessage),\n/* harmony export */   ToolMessageChunk: () => (/* reexport safe */ _tool_js__WEBPACK_IMPORTED_MODULE_10__.ToolMessageChunk),\n/* harmony export */   _isMessageFieldWithRole: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__._isMessageFieldWithRole),\n/* harmony export */   _mergeDicts: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__._mergeDicts),\n/* harmony export */   _mergeLists: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__._mergeLists),\n/* harmony export */   _mergeObj: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__._mergeObj),\n/* harmony export */   _mergeStatus: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__._mergeStatus),\n/* harmony export */   coerceMessageLikeToMessage: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.coerceMessageLikeToMessage),\n/* harmony export */   convertToChunk: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.convertToChunk),\n/* harmony export */   convertToOpenAIImageBlock: () => (/* reexport safe */ _content_blocks_js__WEBPACK_IMPORTED_MODULE_9__.convertToOpenAIImageBlock),\n/* harmony export */   convertToProviderContentBlock: () => (/* reexport safe */ _content_blocks_js__WEBPACK_IMPORTED_MODULE_9__.convertToProviderContentBlock),\n/* harmony export */   defaultTextSplitter: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_7__.defaultTextSplitter),\n/* harmony export */   filterMessages: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_7__.filterMessages),\n/* harmony export */   getBufferString: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.getBufferString),\n/* harmony export */   isAIMessage: () => (/* reexport safe */ _ai_js__WEBPACK_IMPORTED_MODULE_0__.isAIMessage),\n/* harmony export */   isAIMessageChunk: () => (/* reexport safe */ _ai_js__WEBPACK_IMPORTED_MODULE_0__.isAIMessageChunk),\n/* harmony export */   isBase64ContentBlock: () => (/* reexport safe */ _content_blocks_js__WEBPACK_IMPORTED_MODULE_9__.isBase64ContentBlock),\n/* harmony export */   isBaseMessage: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage),\n/* harmony export */   isBaseMessageChunk: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.isBaseMessageChunk),\n/* harmony export */   isChatMessage: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_2__.isChatMessage),\n/* harmony export */   isChatMessageChunk: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_2__.isChatMessageChunk),\n/* harmony export */   isDataContentBlock: () => (/* reexport safe */ _content_blocks_js__WEBPACK_IMPORTED_MODULE_9__.isDataContentBlock),\n/* harmony export */   isFunctionMessage: () => (/* reexport safe */ _function_js__WEBPACK_IMPORTED_MODULE_3__.isFunctionMessage),\n/* harmony export */   isFunctionMessageChunk: () => (/* reexport safe */ _function_js__WEBPACK_IMPORTED_MODULE_3__.isFunctionMessageChunk),\n/* harmony export */   isHumanMessage: () => (/* reexport safe */ _human_js__WEBPACK_IMPORTED_MODULE_4__.isHumanMessage),\n/* harmony export */   isHumanMessageChunk: () => (/* reexport safe */ _human_js__WEBPACK_IMPORTED_MODULE_4__.isHumanMessageChunk),\n/* harmony export */   isIDContentBlock: () => (/* reexport safe */ _content_blocks_js__WEBPACK_IMPORTED_MODULE_9__.isIDContentBlock),\n/* harmony export */   isOpenAIToolCallArray: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.isOpenAIToolCallArray),\n/* harmony export */   isPlainTextContentBlock: () => (/* reexport safe */ _content_blocks_js__WEBPACK_IMPORTED_MODULE_9__.isPlainTextContentBlock),\n/* harmony export */   isSystemMessage: () => (/* reexport safe */ _system_js__WEBPACK_IMPORTED_MODULE_5__.isSystemMessage),\n/* harmony export */   isSystemMessageChunk: () => (/* reexport safe */ _system_js__WEBPACK_IMPORTED_MODULE_5__.isSystemMessageChunk),\n/* harmony export */   isToolMessage: () => (/* reexport safe */ _tool_js__WEBPACK_IMPORTED_MODULE_10__.isToolMessage),\n/* harmony export */   isToolMessageChunk: () => (/* reexport safe */ _tool_js__WEBPACK_IMPORTED_MODULE_10__.isToolMessageChunk),\n/* harmony export */   isURLContentBlock: () => (/* reexport safe */ _content_blocks_js__WEBPACK_IMPORTED_MODULE_9__.isURLContentBlock),\n/* harmony export */   mapChatMessagesToStoredMessages: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapChatMessagesToStoredMessages),\n/* harmony export */   mapStoredMessageToChatMessage: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapStoredMessageToChatMessage),\n/* harmony export */   mapStoredMessagesToChatMessages: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapStoredMessagesToChatMessages),\n/* harmony export */   mergeContent: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.mergeContent),\n/* harmony export */   mergeMessageRuns: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_7__.mergeMessageRuns),\n/* harmony export */   parseBase64DataUrl: () => (/* reexport safe */ _content_blocks_js__WEBPACK_IMPORTED_MODULE_9__.parseBase64DataUrl),\n/* harmony export */   parseMimeType: () => (/* reexport safe */ _content_blocks_js__WEBPACK_IMPORTED_MODULE_9__.parseMimeType),\n/* harmony export */   trimMessages: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_7__.trimMessages)\n/* harmony export */ });\n/* harmony import */ var _ai_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ai.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chat.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./function.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.js\");\n/* harmony import */ var _human_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./human.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./system.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.js\");\n/* harmony import */ var _transformers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transformers.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/transformers.js\");\n/* harmony import */ var _modifier_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifier.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.js\");\n/* harmony import */ var _content_blocks_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./content_blocks.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tool.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.js\");\n\n\n\n\n\n\n\n\n\n\n// TODO: Use a star export when we deprecate the\n// existing \"ToolCall\" type in \"base.js\".\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdCO0FBQ0U7QUFDQTtBQUNJO0FBQ0g7QUFDQztBQUNEO0FBQ087QUFDSjtBQUNNO0FBQ3BDO0FBQ0E7QUFDOEYiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2FpLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jaGF0LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9mdW5jdGlvbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaHVtYW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N5c3RlbS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdXRpbHMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RyYW5zZm9ybWVycy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vbW9kaWZpZXIuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbnRlbnRfYmxvY2tzLmpzXCI7XG4vLyBUT0RPOiBVc2UgYSBzdGFyIGV4cG9ydCB3aGVuIHdlIGRlcHJlY2F0ZSB0aGVcbi8vIGV4aXN0aW5nIFwiVG9vbENhbGxcIiB0eXBlIGluIFwiYmFzZS5qc1wiLlxuZXhwb3J0IHsgVG9vbE1lc3NhZ2UsIFRvb2xNZXNzYWdlQ2h1bmssIGlzVG9vbE1lc3NhZ2UsIGlzVG9vbE1lc3NhZ2VDaHVuaywgfSBmcm9tIFwiLi90b29sLmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/modifier.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/modifier.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RemoveMessage: () => (/* binding */ RemoveMessage)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Message responsible for deleting other messages.\n */\nclass RemoveMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    constructor(fields) {\n        super({\n            ...fields,\n            content: \"\",\n        });\n        /**\n         * The ID of the message to remove.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.id = fields.id;\n    }\n    _getType() {\n        return \"remove\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            id: this.id,\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvbW9kaWZpZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLGlEQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG1lc3NhZ2VzXFxtb2RpZmllci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlTWVzc2FnZSB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbi8qKlxuICogTWVzc2FnZSByZXNwb25zaWJsZSBmb3IgZGVsZXRpbmcgb3RoZXIgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZW1vdmVNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgbWVzc2FnZSB0byByZW1vdmUuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlkID0gZmllbGRzLmlkO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwicmVtb3ZlXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/modifier.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/system.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/system.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemMessage: () => (/* binding */ SystemMessage),\n/* harmony export */   SystemMessageChunk: () => (/* binding */ SystemMessageChunk),\n/* harmony export */   isSystemMessage: () => (/* binding */ isSystemMessage),\n/* harmony export */   isSystemMessageChunk: () => (/* binding */ isSystemMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a system message in a conversation.\n */\nclass SystemMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"SystemMessage\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n}\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nclass SystemMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"SystemMessageChunk\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n    concat(chunk) {\n        return new SystemMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nfunction isSystemMessage(x) {\n    return x._getType() === \"system\";\n}\nfunction isSystemMessageChunk(x) {\n    return x._getType() === \"system\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvc3lzdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyxzREFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQVk7QUFDakMsK0JBQStCLHFEQUFXO0FBQzFDLCtCQUErQixxREFBVztBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG1lc3NhZ2VzXFxzeXN0ZW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3lzdGVtIG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTeXN0ZW1NZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJTeXN0ZW1NZXNzYWdlXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBrd2FyZ3MpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBrd2FyZ3MpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgc3lzdGVtIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgc3lzdGVtIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgU3lzdGVtTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN5c3RlbU1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywga3dhcmdzKTtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3lzdGVtTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU3lzdGVtTWVzc2FnZSh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N5c3RlbU1lc3NhZ2VDaHVuayh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/system.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/tool.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/tool.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToolMessage: () => (/* binding */ ToolMessage),\n/* harmony export */   ToolMessageChunk: () => (/* binding */ ToolMessageChunk),\n/* harmony export */   defaultToolCallParser: () => (/* binding */ defaultToolCallParser),\n/* harmony export */   isDirectToolOutput: () => (/* binding */ isDirectToolOutput),\n/* harmony export */   isToolMessage: () => (/* binding */ isToolMessage),\n/* harmony export */   isToolMessageChunk: () => (/* binding */ isToolMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n\nfunction isDirectToolOutput(x) {\n    return (x != null &&\n        typeof x === \"object\" &&\n        \"lc_direct_tool_output\" in x &&\n        x.lc_direct_tool_output === true);\n}\n/**\n * Represents a tool message in a conversation.\n */\nclass ToolMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"ToolMessage\";\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { tool_call_id: \"tool_call_id\" };\n    }\n    constructor(fields, tool_call_id, name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name, tool_call_id: tool_call_id };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_direct_tool_output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * Status of the tool invocation.\n         * @version 0.2.19\n         */\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Artifact of the Tool execution which is not meant to be sent to the model.\n         *\n         * Should only be specified if it is different from the message content, e.g. if only\n         * a subset of the full tool output is being passed as message content but the full\n         * output is needed in other parts of the code.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"artifact\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n        this.artifact = fields.artifact;\n        this.status = fields.status;\n        this.metadata = fields.metadata;\n    }\n    _getType() {\n        return \"tool\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"tool\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_call_id: this.tool_call_id,\n            artifact: this.artifact,\n        };\n    }\n}\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nclass ToolMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Status of the tool invocation.\n         * @version 0.2.19\n         */\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Artifact of the Tool execution which is not meant to be sent to the model.\n         *\n         * Should only be specified if it is different from the message content, e.g. if only\n         * a subset of the full tool output is being passed as message content but the full\n         * output is needed in other parts of the code.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"artifact\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n        this.artifact = fields.artifact;\n        this.status = fields.status;\n    }\n    static lc_name() {\n        return \"ToolMessageChunk\";\n    }\n    _getType() {\n        return \"tool\";\n    }\n    concat(chunk) {\n        return new ToolMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            artifact: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeObj)(this.artifact, chunk.artifact),\n            tool_call_id: this.tool_call_id,\n            id: this.id ?? chunk.id,\n            status: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeStatus)(this.status, chunk.status),\n        });\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_call_id: this.tool_call_id,\n            artifact: this.artifact,\n        };\n    }\n}\nfunction defaultToolCallParser(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCalls) {\n    const toolCalls = [];\n    const invalidToolCalls = [];\n    for (const toolCall of rawToolCalls) {\n        if (!toolCall.function) {\n            continue;\n        }\n        else {\n            const functionName = toolCall.function.name;\n            try {\n                const functionArgs = JSON.parse(toolCall.function.arguments);\n                const parsed = {\n                    name: functionName || \"\",\n                    args: functionArgs || {},\n                    id: toolCall.id,\n                };\n                toolCalls.push(parsed);\n            }\n            catch (error) {\n                invalidToolCalls.push({\n                    name: functionName,\n                    args: toolCall.function.arguments,\n                    id: toolCall.id,\n                    error: \"Malformed args.\",\n                });\n            }\n        }\n    }\n    return [toolCalls, invalidToolCalls];\n}\nfunction isToolMessage(x) {\n    return x._getType() === \"tool\";\n}\nfunction isToolMessageChunk(x) {\n    return x._getType() === \"tool\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdG9vbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStHO0FBQ3hHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQixpREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQixzREFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBWTtBQUNqQywrQkFBK0IscURBQVc7QUFDMUMsK0JBQStCLHFEQUFXO0FBQzFDLHNCQUFzQixtREFBUztBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFZO0FBQ2hDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxtZXNzYWdlc1xcdG9vbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlTWVzc2FnZSwgQmFzZU1lc3NhZ2VDaHVuaywgbWVyZ2VDb250ZW50LCBfbWVyZ2VEaWN0cywgX21lcmdlT2JqLCBfbWVyZ2VTdGF0dXMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGlyZWN0VG9vbE91dHB1dCh4KSB7XG4gICAgcmV0dXJuICh4ICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgXCJsY19kaXJlY3RfdG9vbF9vdXRwdXRcIiBpbiB4ICYmXG4gICAgICAgIHgubGNfZGlyZWN0X3Rvb2xfb3V0cHV0ID09PSB0cnVlKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHRvb2wgbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFRvb2xNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJUb29sTWVzc2FnZVwiO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHsgdG9vbF9jYWxsX2lkOiBcInRvb2xfY2FsbF9pZFwiIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgdG9vbF9jYWxsX2lkLCBuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgY29udGVudDogZmllbGRzLCBuYW1lLCB0b29sX2NhbGxfaWQ6IHRvb2xfY2FsbF9pZCB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2RpcmVjdF90b29sX291dHB1dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXR1cyBvZiB0aGUgdG9vbCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAdmVyc2lvbiAwLjIuMTlcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFydGlmYWN0IG9mIHRoZSBUb29sIGV4ZWN1dGlvbiB3aGljaCBpcyBub3QgbWVhbnQgdG8gYmUgc2VudCB0byB0aGUgbW9kZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNob3VsZCBvbmx5IGJlIHNwZWNpZmllZCBpZiBpdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbWVzc2FnZSBjb250ZW50LCBlLmcuIGlmIG9ubHlcbiAgICAgICAgICogYSBzdWJzZXQgb2YgdGhlIGZ1bGwgdG9vbCBvdXRwdXQgaXMgYmVpbmcgcGFzc2VkIGFzIG1lc3NhZ2UgY29udGVudCBidXQgdGhlIGZ1bGxcbiAgICAgICAgICogb3V0cHV0IGlzIG5lZWRlZCBpbiBvdGhlciBwYXJ0cyBvZiB0aGUgY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFydGlmYWN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9vbF9jYWxsX2lkID0gZmllbGRzLnRvb2xfY2FsbF9pZDtcbiAgICAgICAgdGhpcy5hcnRpZmFjdCA9IGZpZWxkcy5hcnRpZmFjdDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBmaWVsZHMuc3RhdHVzO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gZmllbGRzLm1ldGFkYXRhO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwidG9vbFwiO1xuICAgIH1cbiAgICBzdGF0aWMgaXNJbnN0YW5jZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwidG9vbFwiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRoaXMudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgYXJ0aWZhY3Q6IHRoaXMuYXJ0aWZhY3QsXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSB0b29sIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWRcbiAqIHdpdGggb3RoZXIgdG9vbCBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRvb2xNZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbF9jYWxsX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGF0dXMgb2YgdGhlIHRvb2wgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHZlcnNpb24gMC4yLjE5XG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0dXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFydGlmYWN0IG9mIHRoZSBUb29sIGV4ZWN1dGlvbiB3aGljaCBpcyBub3QgbWVhbnQgdG8gYmUgc2VudCB0byB0aGUgbW9kZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNob3VsZCBvbmx5IGJlIHNwZWNpZmllZCBpZiBpdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbWVzc2FnZSBjb250ZW50LCBlLmcuIGlmIG9ubHlcbiAgICAgICAgICogYSBzdWJzZXQgb2YgdGhlIGZ1bGwgdG9vbCBvdXRwdXQgaXMgYmVpbmcgcGFzc2VkIGFzIG1lc3NhZ2UgY29udGVudCBidXQgdGhlIGZ1bGxcbiAgICAgICAgICogb3V0cHV0IGlzIG5lZWRlZCBpbiBvdGhlciBwYXJ0cyBvZiB0aGUgY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFydGlmYWN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9vbF9jYWxsX2lkID0gZmllbGRzLnRvb2xfY2FsbF9pZDtcbiAgICAgICAgdGhpcy5hcnRpZmFjdCA9IGZpZWxkcy5hcnRpZmFjdDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBmaWVsZHMuc3RhdHVzO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiVG9vbE1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwidG9vbFwiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb29sTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBhcnRpZmFjdDogX21lcmdlT2JqKHRoaXMuYXJ0aWZhY3QsIGNodW5rLmFydGlmYWN0KSxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdGhpcy50b29sX2NhbGxfaWQsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgICAgIHN0YXR1czogX21lcmdlU3RhdHVzKHRoaXMuc3RhdHVzLCBjaHVuay5zdGF0dXMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IF9wcmludGFibGVGaWVsZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5fcHJpbnRhYmxlRmllbGRzLFxuICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0aGlzLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgIGFydGlmYWN0OiB0aGlzLmFydGlmYWN0LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0VG9vbENhbGxQYXJzZXIoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucmF3VG9vbENhbGxzKSB7XG4gICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgY29uc3QgaW52YWxpZFRvb2xDYWxscyA9IFtdO1xuICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgcmF3VG9vbENhbGxzKSB7XG4gICAgICAgIGlmICghdG9vbENhbGwuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gdG9vbENhbGwuZnVuY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25BcmdzID0gSlNPTi5wYXJzZSh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGZ1bmN0aW9uQXJncyB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLnB1c2gocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGludmFsaWRUb29sQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBcIk1hbGZvcm1lZCBhcmdzLlwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbdG9vbENhbGxzLCBpbnZhbGlkVG9vbENhbGxzXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1Rvb2xNZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcInRvb2xcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1Rvb2xNZXNzYWdlQ2h1bmsoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwidG9vbFwiO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/tool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/transformers.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/transformers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultTextSplitter: () => (/* binding */ defaultTextSplitter),\n/* harmony export */   filterMessages: () => (/* binding */ filterMessages),\n/* harmony export */   mergeMessageRuns: () => (/* binding */ mergeMessageRuns),\n/* harmony export */   trimMessages: () => (/* binding */ trimMessages)\n/* harmony export */ });\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _ai_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ai.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chat.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./function.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.js\");\n/* harmony import */ var _human_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./human.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.js\");\n/* harmony import */ var _modifier_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifier.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./system.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tool.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.js\");\n\n\n\n\n\n\n\n\n\n\nconst _isMessageType = (msg, types) => {\n    const typesAsStrings = [\n        ...new Set(types?.map((t) => {\n            if (typeof t === \"string\") {\n                return t;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const instantiatedMsgClass = new t({});\n            if (!(\"getType\" in instantiatedMsgClass) ||\n                typeof instantiatedMsgClass.getType !== \"function\") {\n                throw new Error(\"Invalid type provided.\");\n            }\n            return instantiatedMsgClass.getType();\n        })),\n    ];\n    const msgType = msg.getType();\n    return typesAsStrings.some((t) => t === msgType);\n};\nfunction filterMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        return _filterMessages(messagesOrOptions, options);\n    }\n    return _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableLambda.from((input) => {\n        return _filterMessages(input, messagesOrOptions);\n    });\n}\nfunction _filterMessages(messages, options = {}) {\n    const { includeNames, excludeNames, includeTypes, excludeTypes, includeIds, excludeIds, } = options;\n    const filtered = [];\n    for (const msg of messages) {\n        if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n            continue;\n        }\n        else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n            continue;\n        }\n        else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n            continue;\n        }\n        // default to inclusion when no inclusion criteria given.\n        if (!(includeTypes || includeIds || includeNames)) {\n            filtered.push(msg);\n        }\n        else if (includeNames &&\n            msg.name &&\n            includeNames.some((iName) => iName === msg.name)) {\n            filtered.push(msg);\n        }\n        else if (includeTypes && _isMessageType(msg, includeTypes)) {\n            filtered.push(msg);\n        }\n        else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n            filtered.push(msg);\n        }\n    }\n    return filtered;\n}\nfunction mergeMessageRuns(messages) {\n    if (Array.isArray(messages)) {\n        return _mergeMessageRuns(messages);\n    }\n    return _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableLambda.from(_mergeMessageRuns);\n}\nfunction _mergeMessageRuns(messages) {\n    if (!messages.length) {\n        return [];\n    }\n    const merged = [];\n    for (const msg of messages) {\n        const curr = msg;\n        const last = merged.pop();\n        if (!last) {\n            merged.push(curr);\n        }\n        else if (curr.getType() === \"tool\" ||\n            !(curr.getType() === last.getType())) {\n            merged.push(last, curr);\n        }\n        else {\n            const lastChunk = (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.convertToChunk)(last);\n            const currChunk = (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.convertToChunk)(curr);\n            const mergedChunks = lastChunk.concat(currChunk);\n            if (typeof lastChunk.content === \"string\" &&\n                typeof currChunk.content === \"string\") {\n                mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n            }\n            merged.push(_chunkToMsg(mergedChunks));\n        }\n    }\n    return merged;\n}\nfunction trimMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        const messages = messagesOrOptions;\n        if (!options) {\n            throw new Error(\"Options parameter is required when providing messages.\");\n        }\n        return _trimMessagesHelper(messages, options);\n    }\n    else {\n        const trimmerOptions = messagesOrOptions;\n        return _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableLambda.from((input) => _trimMessagesHelper(input, trimmerOptions)).withConfig({\n            runName: \"trim_messages\",\n        });\n    }\n}\nasync function _trimMessagesHelper(messages, options) {\n    const { maxTokens, tokenCounter, strategy = \"last\", allowPartial = false, endOn, startOn, includeSystem = false, textSplitter, } = options;\n    if (startOn && strategy === \"first\") {\n        throw new Error(\"`startOn` should only be specified if `strategy` is 'last'.\");\n    }\n    if (includeSystem && strategy === \"first\") {\n        throw new Error(\"`includeSystem` should only be specified if `strategy` is 'last'.\");\n    }\n    let listTokenCounter;\n    if (\"getNumTokens\" in tokenCounter) {\n        listTokenCounter = async (msgs) => {\n            const tokenCounts = await Promise.all(msgs.map((msg) => tokenCounter.getNumTokens(msg.content)));\n            return tokenCounts.reduce((sum, count) => sum + count, 0);\n        };\n    }\n    else {\n        listTokenCounter = async (msgs) => tokenCounter(msgs);\n    }\n    let textSplitterFunc = defaultTextSplitter;\n    if (textSplitter) {\n        if (\"splitText\" in textSplitter) {\n            textSplitterFunc = textSplitter.splitText;\n        }\n        else {\n            textSplitterFunc = async (text) => textSplitter(text);\n        }\n    }\n    if (strategy === \"first\") {\n        return _firstMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            partialStrategy: allowPartial ? \"first\" : undefined,\n            endOn,\n        });\n    }\n    else if (strategy === \"last\") {\n        return _lastMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            allowPartial,\n            includeSystem,\n            startOn,\n            endOn,\n        });\n    }\n    else {\n        throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);\n    }\n}\nasync function _firstMaxTokens(messages, options) {\n    const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } = options;\n    let messagesCopy = [...messages];\n    let idx = 0;\n    for (let i = 0; i < messagesCopy.length; i += 1) {\n        const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n        if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n            idx = messagesCopy.length - i;\n            break;\n        }\n    }\n    if (idx < messagesCopy.length && partialStrategy) {\n        let includedPartial = false;\n        if (Array.isArray(messagesCopy[idx].content)) {\n            const excluded = messagesCopy[idx];\n            if (typeof excluded.content === \"string\") {\n                throw new Error(\"Expected content to be an array.\");\n            }\n            const numBlock = excluded.content.length;\n            const reversedContent = partialStrategy === \"last\"\n                ? [...excluded.content].reverse()\n                : excluded.content;\n            for (let i = 1; i <= numBlock; i += 1) {\n                const partialContent = partialStrategy === \"first\"\n                    ? reversedContent.slice(0, i)\n                    : reversedContent.slice(-i);\n                const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n                const updatedMessage = _switchTypeToMessage(excluded.getType(), {\n                    ...fields,\n                    content: partialContent,\n                });\n                const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n                if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n                    messagesCopy = slicedMessages;\n                    idx += 1;\n                    includedPartial = true;\n                }\n                else {\n                    break;\n                }\n            }\n            if (includedPartial && partialStrategy === \"last\") {\n                excluded.content = [...reversedContent].reverse();\n            }\n        }\n        if (!includedPartial) {\n            const excluded = messagesCopy[idx];\n            let text;\n            if (Array.isArray(excluded.content) &&\n                excluded.content.some((block) => typeof block === \"string\" || block.type === \"text\")) {\n                const textBlock = excluded.content.find((block) => block.type === \"text\" && block.text);\n                text = textBlock?.text;\n            }\n            else if (typeof excluded.content === \"string\") {\n                text = excluded.content;\n            }\n            if (text) {\n                const splitTexts = await textSplitter(text);\n                const numSplits = splitTexts.length;\n                if (partialStrategy === \"last\") {\n                    splitTexts.reverse();\n                }\n                for (let _ = 0; _ < numSplits - 1; _ += 1) {\n                    splitTexts.pop();\n                    excluded.content = splitTexts.join(\"\");\n                    if ((await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n                        maxTokens) {\n                        if (partialStrategy === \"last\") {\n                            excluded.content = [...splitTexts].reverse().join(\"\");\n                        }\n                        messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n                        idx += 1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n            idx -= 1;\n        }\n    }\n    return messagesCopy.slice(0, idx);\n}\nasync function _lastMaxTokens(messages, options) {\n    const { allowPartial = false, includeSystem = false, endOn, startOn, ...rest } = options;\n    // Create a copy of messages to avoid mutation\n    let messagesCopy = messages.map((message) => {\n        const fields = Object.fromEntries(Object.entries(message).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n        return _switchTypeToMessage(message.getType(), fields, (0,_base_js__WEBPACK_IMPORTED_MODULE_2__.isBaseMessageChunk)(message));\n    });\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (messagesCopy.length > 0 &&\n            !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)) {\n            messagesCopy = messagesCopy.slice(0, -1);\n        }\n    }\n    const swappedSystem = includeSystem && messagesCopy[0]?.getType() === \"system\";\n    let reversed_ = swappedSystem\n        ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse())\n        : messagesCopy.reverse();\n    reversed_ = await _firstMaxTokens(reversed_, {\n        ...rest,\n        partialStrategy: allowPartial ? \"last\" : undefined,\n        endOn: startOn,\n    });\n    if (swappedSystem) {\n        return [reversed_[0], ...reversed_.slice(1).reverse()];\n    }\n    else {\n        return reversed_.reverse();\n    }\n}\nconst _MSG_CHUNK_MAP = {\n    human: {\n        message: _human_js__WEBPACK_IMPORTED_MODULE_5__.HumanMessage,\n        messageChunk: _human_js__WEBPACK_IMPORTED_MODULE_5__.HumanMessageChunk,\n    },\n    ai: {\n        message: _ai_js__WEBPACK_IMPORTED_MODULE_1__.AIMessage,\n        messageChunk: _ai_js__WEBPACK_IMPORTED_MODULE_1__.AIMessageChunk,\n    },\n    system: {\n        message: _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessage,\n        messageChunk: _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessageChunk,\n    },\n    developer: {\n        message: _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessage,\n        messageChunk: _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessageChunk,\n    },\n    tool: {\n        message: _tool_js__WEBPACK_IMPORTED_MODULE_8__.ToolMessage,\n        messageChunk: _tool_js__WEBPACK_IMPORTED_MODULE_8__.ToolMessageChunk,\n    },\n    function: {\n        message: _function_js__WEBPACK_IMPORTED_MODULE_4__.FunctionMessage,\n        messageChunk: _function_js__WEBPACK_IMPORTED_MODULE_4__.FunctionMessageChunk,\n    },\n    generic: {\n        message: _chat_js__WEBPACK_IMPORTED_MODULE_3__.ChatMessage,\n        messageChunk: _chat_js__WEBPACK_IMPORTED_MODULE_3__.ChatMessageChunk,\n    },\n    remove: {\n        message: _modifier_js__WEBPACK_IMPORTED_MODULE_6__.RemoveMessage,\n        messageChunk: _modifier_js__WEBPACK_IMPORTED_MODULE_6__.RemoveMessage, // RemoveMessage does not have a chunk class.\n    },\n};\nfunction _switchTypeToMessage(messageType, fields, returnChunk) {\n    let chunk;\n    let msg;\n    switch (messageType) {\n        case \"human\":\n            if (returnChunk) {\n                chunk = new _human_js__WEBPACK_IMPORTED_MODULE_5__.HumanMessageChunk(fields);\n            }\n            else {\n                msg = new _human_js__WEBPACK_IMPORTED_MODULE_5__.HumanMessage(fields);\n            }\n            break;\n        case \"ai\":\n            if (returnChunk) {\n                let aiChunkFields = {\n                    ...fields,\n                };\n                if (\"tool_calls\" in aiChunkFields) {\n                    aiChunkFields = {\n                        ...aiChunkFields,\n                        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                            ...tc,\n                            type: \"tool_call_chunk\",\n                            index: undefined,\n                            args: JSON.stringify(tc.args),\n                        })),\n                    };\n                }\n                chunk = new _ai_js__WEBPACK_IMPORTED_MODULE_1__.AIMessageChunk(aiChunkFields);\n            }\n            else {\n                msg = new _ai_js__WEBPACK_IMPORTED_MODULE_1__.AIMessage(fields);\n            }\n            break;\n        case \"system\":\n            if (returnChunk) {\n                chunk = new _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessageChunk(fields);\n            }\n            else {\n                msg = new _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessage(fields);\n            }\n            break;\n        case \"developer\":\n            if (returnChunk) {\n                chunk = new _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessageChunk({\n                    ...fields,\n                    additional_kwargs: {\n                        ...fields.additional_kwargs,\n                        __openai_role__: \"developer\",\n                    },\n                });\n            }\n            else {\n                msg = new _system_js__WEBPACK_IMPORTED_MODULE_7__.SystemMessage({\n                    ...fields,\n                    additional_kwargs: {\n                        ...fields.additional_kwargs,\n                        __openai_role__: \"developer\",\n                    },\n                });\n            }\n            break;\n        case \"tool\":\n            if (\"tool_call_id\" in fields) {\n                if (returnChunk) {\n                    chunk = new _tool_js__WEBPACK_IMPORTED_MODULE_8__.ToolMessageChunk(fields);\n                }\n                else {\n                    msg = new _tool_js__WEBPACK_IMPORTED_MODULE_8__.ToolMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\");\n            }\n            break;\n        case \"function\":\n            if (returnChunk) {\n                chunk = new _function_js__WEBPACK_IMPORTED_MODULE_4__.FunctionMessageChunk(fields);\n            }\n            else {\n                if (!fields.name) {\n                    throw new Error(\"FunctionMessage must have a 'name' field\");\n                }\n                msg = new _function_js__WEBPACK_IMPORTED_MODULE_4__.FunctionMessage(fields);\n            }\n            break;\n        case \"generic\":\n            if (\"role\" in fields) {\n                if (returnChunk) {\n                    chunk = new _chat_js__WEBPACK_IMPORTED_MODULE_3__.ChatMessageChunk(fields);\n                }\n                else {\n                    msg = new _chat_js__WEBPACK_IMPORTED_MODULE_3__.ChatMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\");\n            }\n            break;\n        default:\n            throw new Error(`Unrecognized message type ${messageType}`);\n    }\n    if (returnChunk && chunk) {\n        return chunk;\n    }\n    if (msg) {\n        return msg;\n    }\n    throw new Error(`Unrecognized message type ${messageType}`);\n}\nfunction _chunkToMsg(chunk) {\n    const chunkType = chunk.getType();\n    let msg;\n    const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")));\n    if (chunkType in _MSG_CHUNK_MAP) {\n        msg = _switchTypeToMessage(chunkType, fields);\n    }\n    if (!msg) {\n        throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);\n    }\n    return msg;\n}\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nfunction defaultTextSplitter(text) {\n    const splits = text.split(\"\\n\");\n    return Promise.resolve([\n        ...splits.slice(0, -1).map((s) => `${s}\\n`),\n        splits[splits.length - 1],\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdHJhbnNmb3JtZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQ0Y7QUFDSjtBQUNXO0FBQ1k7QUFDVjtBQUNmO0FBQ2tCO0FBQ0w7QUFDZjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUFjO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDO0FBQy9DLFlBQVksa0ZBQWtGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5REFBYztBQUM1Qyw4QkFBOEIseURBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQixJQUFJLGtCQUFrQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQWM7QUFDN0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5SEFBeUg7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBZ0U7QUFDNUU7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsNERBQWtCO0FBQ2pGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFZO0FBQzdCLHNCQUFzQix3REFBaUI7QUFDdkMsS0FBSztBQUNMO0FBQ0EsaUJBQWlCLDZDQUFTO0FBQzFCLHNCQUFzQixrREFBYztBQUNwQyxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIscURBQWE7QUFDOUIsc0JBQXNCLDBEQUFrQjtBQUN4QyxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIscURBQWE7QUFDOUIsc0JBQXNCLDBEQUFrQjtBQUN4QyxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIsaURBQVc7QUFDNUIsc0JBQXNCLHNEQUFnQjtBQUN0QyxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIseURBQWU7QUFDaEMsc0JBQXNCLDhEQUFvQjtBQUMxQyxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIsaURBQVc7QUFDNUIsc0JBQXNCLHNEQUFnQjtBQUN0QyxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIsdURBQWE7QUFDOUIsc0JBQXNCLHVEQUFhO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3REFBaUI7QUFDN0M7QUFDQTtBQUNBLDBCQUEwQixtREFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDRCQUE0QixrREFBYztBQUMxQztBQUNBO0FBQ0EsMEJBQTBCLDZDQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFrQjtBQUM5QztBQUNBO0FBQ0EsMEJBQTBCLHFEQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBCQUEwQixxREFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBZ0I7QUFDaEQ7QUFDQTtBQUNBLDhCQUE4QixpREFBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhEQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlEQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0RBQWdCO0FBQ2hEO0FBQ0E7QUFDQSw4QkFBOEIsaURBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVLDBCQUEwQiw0QkFBNEI7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRTtBQUMvQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXHRyYW5zZm9ybWVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSdW5uYWJsZUxhbWJkYSB9IGZyb20gXCIuLi9ydW5uYWJsZXMvYmFzZS5qc1wiO1xuaW1wb3J0IHsgQUlNZXNzYWdlLCBBSU1lc3NhZ2VDaHVuayB9IGZyb20gXCIuL2FpLmpzXCI7XG5pbXBvcnQgeyBpc0Jhc2VNZXNzYWdlQ2h1bmssIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgQ2hhdE1lc3NhZ2UsIENoYXRNZXNzYWdlQ2h1bmssIH0gZnJvbSBcIi4vY2hhdC5qc1wiO1xuaW1wb3J0IHsgRnVuY3Rpb25NZXNzYWdlLCBGdW5jdGlvbk1lc3NhZ2VDaHVuaywgfSBmcm9tIFwiLi9mdW5jdGlvbi5qc1wiO1xuaW1wb3J0IHsgSHVtYW5NZXNzYWdlLCBIdW1hbk1lc3NhZ2VDaHVuayB9IGZyb20gXCIuL2h1bWFuLmpzXCI7XG5pbXBvcnQgeyBSZW1vdmVNZXNzYWdlIH0gZnJvbSBcIi4vbW9kaWZpZXIuanNcIjtcbmltcG9ydCB7IFN5c3RlbU1lc3NhZ2UsIFN5c3RlbU1lc3NhZ2VDaHVuayB9IGZyb20gXCIuL3N5c3RlbS5qc1wiO1xuaW1wb3J0IHsgVG9vbE1lc3NhZ2UsIFRvb2xNZXNzYWdlQ2h1bmssIH0gZnJvbSBcIi4vdG9vbC5qc1wiO1xuaW1wb3J0IHsgY29udmVydFRvQ2h1bmsgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuY29uc3QgX2lzTWVzc2FnZVR5cGUgPSAobXNnLCB0eXBlcykgPT4ge1xuICAgIGNvbnN0IHR5cGVzQXNTdHJpbmdzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KHR5cGVzPy5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbnRpYXRlZE1zZ0NsYXNzID0gbmV3IHQoe30pO1xuICAgICAgICAgICAgaWYgKCEoXCJnZXRUeXBlXCIgaW4gaW5zdGFudGlhdGVkTXNnQ2xhc3MpIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluc3RhbnRpYXRlZE1zZ0NsYXNzLmdldFR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZSBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVkTXNnQ2xhc3MuZ2V0VHlwZSgpO1xuICAgICAgICB9KSksXG4gICAgXTtcbiAgICBjb25zdCBtc2dUeXBlID0gbXNnLmdldFR5cGUoKTtcbiAgICByZXR1cm4gdHlwZXNBc1N0cmluZ3Muc29tZSgodCkgPT4gdCA9PT0gbXNnVHlwZSk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlck1lc3NhZ2VzKG1lc3NhZ2VzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXNPck9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyTWVzc2FnZXMobWVzc2FnZXNPck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gUnVubmFibGVMYW1iZGEuZnJvbSgoaW5wdXQpID0+IHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJNZXNzYWdlcyhpbnB1dCwgbWVzc2FnZXNPck9wdGlvbnMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gX2ZpbHRlck1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGluY2x1ZGVOYW1lcywgZXhjbHVkZU5hbWVzLCBpbmNsdWRlVHlwZXMsIGV4Y2x1ZGVUeXBlcywgaW5jbHVkZUlkcywgZXhjbHVkZUlkcywgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG1zZyBvZiBtZXNzYWdlcykge1xuICAgICAgICBpZiAoZXhjbHVkZU5hbWVzICYmIG1zZy5uYW1lICYmIGV4Y2x1ZGVOYW1lcy5pbmNsdWRlcyhtc2cubmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4Y2x1ZGVUeXBlcyAmJiBfaXNNZXNzYWdlVHlwZShtc2csIGV4Y2x1ZGVUeXBlcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4Y2x1ZGVJZHMgJiYgbXNnLmlkICYmIGV4Y2x1ZGVJZHMuaW5jbHVkZXMobXNnLmlkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmYXVsdCB0byBpbmNsdXNpb24gd2hlbiBubyBpbmNsdXNpb24gY3JpdGVyaWEgZ2l2ZW4uXG4gICAgICAgIGlmICghKGluY2x1ZGVUeXBlcyB8fCBpbmNsdWRlSWRzIHx8IGluY2x1ZGVOYW1lcykpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2gobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNsdWRlTmFtZXMgJiZcbiAgICAgICAgICAgIG1zZy5uYW1lICYmXG4gICAgICAgICAgICBpbmNsdWRlTmFtZXMuc29tZSgoaU5hbWUpID0+IGlOYW1lID09PSBtc2cubmFtZSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2gobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNsdWRlVHlwZXMgJiYgX2lzTWVzc2FnZVR5cGUobXNnLCBpbmNsdWRlVHlwZXMpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5jbHVkZUlkcyAmJiBtc2cuaWQgJiYgaW5jbHVkZUlkcy5zb21lKChpZCkgPT4gaWQgPT09IG1zZy5pZCkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2gobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VNZXNzYWdlUnVucyhtZXNzYWdlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2VzKSkge1xuICAgICAgICByZXR1cm4gX21lcmdlTWVzc2FnZVJ1bnMobWVzc2FnZXMpO1xuICAgIH1cbiAgICByZXR1cm4gUnVubmFibGVMYW1iZGEuZnJvbShfbWVyZ2VNZXNzYWdlUnVucyk7XG59XG5mdW5jdGlvbiBfbWVyZ2VNZXNzYWdlUnVucyhtZXNzYWdlcykge1xuICAgIGlmICghbWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkID0gW107XG4gICAgZm9yIChjb25zdCBtc2cgb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgY29uc3QgY3VyciA9IG1zZztcbiAgICAgICAgY29uc3QgbGFzdCA9IG1lcmdlZC5wb3AoKTtcbiAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChjdXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyLmdldFR5cGUoKSA9PT0gXCJ0b29sXCIgfHxcbiAgICAgICAgICAgICEoY3Vyci5nZXRUeXBlKCkgPT09IGxhc3QuZ2V0VHlwZSgpKSkge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2gobGFzdCwgY3Vycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q2h1bmsgPSBjb252ZXJ0VG9DaHVuayhsYXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJDaHVuayA9IGNvbnZlcnRUb0NodW5rKGN1cnIpO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkQ2h1bmtzID0gbGFzdENodW5rLmNvbmNhdChjdXJyQ2h1bmspO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0Q2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyQ2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG1lcmdlZENodW5rcy5jb250ZW50ID0gYCR7bGFzdENodW5rLmNvbnRlbnR9XFxuJHtjdXJyQ2h1bmsuY29udGVudH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2VkLnB1c2goX2NodW5rVG9Nc2cobWVyZ2VkQ2h1bmtzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmltTWVzc2FnZXMobWVzc2FnZXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlc09yT3B0aW9ucykpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yT3B0aW9ucztcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIHByb3ZpZGluZyBtZXNzYWdlcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90cmltTWVzc2FnZXNIZWxwZXIobWVzc2FnZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdHJpbW1lck9wdGlvbnMgPSBtZXNzYWdlc09yT3B0aW9ucztcbiAgICAgICAgcmV0dXJuIFJ1bm5hYmxlTGFtYmRhLmZyb20oKGlucHV0KSA9PiBfdHJpbU1lc3NhZ2VzSGVscGVyKGlucHV0LCB0cmltbWVyT3B0aW9ucykpLndpdGhDb25maWcoe1xuICAgICAgICAgICAgcnVuTmFtZTogXCJ0cmltX21lc3NhZ2VzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIF90cmltTWVzc2FnZXNIZWxwZXIobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG1heFRva2VucywgdG9rZW5Db3VudGVyLCBzdHJhdGVneSA9IFwibGFzdFwiLCBhbGxvd1BhcnRpYWwgPSBmYWxzZSwgZW5kT24sIHN0YXJ0T24sIGluY2x1ZGVTeXN0ZW0gPSBmYWxzZSwgdGV4dFNwbGl0dGVyLCB9ID0gb3B0aW9ucztcbiAgICBpZiAoc3RhcnRPbiAmJiBzdHJhdGVneSA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBzdGFydE9uYCBzaG91bGQgb25seSBiZSBzcGVjaWZpZWQgaWYgYHN0cmF0ZWd5YCBpcyAnbGFzdCcuXCIpO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZVN5c3RlbSAmJiBzdHJhdGVneSA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBpbmNsdWRlU3lzdGVtYCBzaG91bGQgb25seSBiZSBzcGVjaWZpZWQgaWYgYHN0cmF0ZWd5YCBpcyAnbGFzdCcuXCIpO1xuICAgIH1cbiAgICBsZXQgbGlzdFRva2VuQ291bnRlcjtcbiAgICBpZiAoXCJnZXROdW1Ub2tlbnNcIiBpbiB0b2tlbkNvdW50ZXIpIHtcbiAgICAgICAgbGlzdFRva2VuQ291bnRlciA9IGFzeW5jIChtc2dzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvdW50cyA9IGF3YWl0IFByb21pc2UuYWxsKG1zZ3MubWFwKChtc2cpID0+IHRva2VuQ291bnRlci5nZXROdW1Ub2tlbnMobXNnLmNvbnRlbnQpKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5Db3VudHMucmVkdWNlKChzdW0sIGNvdW50KSA9PiBzdW0gKyBjb3VudCwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsaXN0VG9rZW5Db3VudGVyID0gYXN5bmMgKG1zZ3MpID0+IHRva2VuQ291bnRlcihtc2dzKTtcbiAgICB9XG4gICAgbGV0IHRleHRTcGxpdHRlckZ1bmMgPSBkZWZhdWx0VGV4dFNwbGl0dGVyO1xuICAgIGlmICh0ZXh0U3BsaXR0ZXIpIHtcbiAgICAgICAgaWYgKFwic3BsaXRUZXh0XCIgaW4gdGV4dFNwbGl0dGVyKSB7XG4gICAgICAgICAgICB0ZXh0U3BsaXR0ZXJGdW5jID0gdGV4dFNwbGl0dGVyLnNwbGl0VGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHRTcGxpdHRlckZ1bmMgPSBhc3luYyAodGV4dCkgPT4gdGV4dFNwbGl0dGVyKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJhdGVneSA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgIHJldHVybiBfZmlyc3RNYXhUb2tlbnMobWVzc2FnZXMsIHtcbiAgICAgICAgICAgIG1heFRva2VucyxcbiAgICAgICAgICAgIHRva2VuQ291bnRlcjogbGlzdFRva2VuQ291bnRlcixcbiAgICAgICAgICAgIHRleHRTcGxpdHRlcjogdGV4dFNwbGl0dGVyRnVuYyxcbiAgICAgICAgICAgIHBhcnRpYWxTdHJhdGVneTogYWxsb3dQYXJ0aWFsID8gXCJmaXJzdFwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kT24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHJhdGVneSA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgcmV0dXJuIF9sYXN0TWF4VG9rZW5zKG1lc3NhZ2VzLCB7XG4gICAgICAgICAgICBtYXhUb2tlbnMsXG4gICAgICAgICAgICB0b2tlbkNvdW50ZXI6IGxpc3RUb2tlbkNvdW50ZXIsXG4gICAgICAgICAgICB0ZXh0U3BsaXR0ZXI6IHRleHRTcGxpdHRlckZ1bmMsXG4gICAgICAgICAgICBhbGxvd1BhcnRpYWwsXG4gICAgICAgICAgICBpbmNsdWRlU3lzdGVtLFxuICAgICAgICAgICAgc3RhcnRPbixcbiAgICAgICAgICAgIGVuZE9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIHN0cmF0ZWd5OiAnJHtzdHJhdGVneX0nLiBNdXN0IGJlIG9uZSBvZiAnZmlyc3QnIG9yICdsYXN0Jy5gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBfZmlyc3RNYXhUb2tlbnMobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG1heFRva2VucywgdG9rZW5Db3VudGVyLCB0ZXh0U3BsaXR0ZXIsIHBhcnRpYWxTdHJhdGVneSwgZW5kT24gfSA9IG9wdGlvbnM7XG4gICAgbGV0IG1lc3NhZ2VzQ29weSA9IFsuLi5tZXNzYWdlc107XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlc0NvcHkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nTWVzc2FnZXMgPSBpID4gMCA/IG1lc3NhZ2VzQ29weS5zbGljZSgwLCAtaSkgOiBtZXNzYWdlc0NvcHk7XG4gICAgICAgIGlmICgoYXdhaXQgdG9rZW5Db3VudGVyKHJlbWFpbmluZ01lc3NhZ2VzKSkgPD0gbWF4VG9rZW5zKSB7XG4gICAgICAgICAgICBpZHggPSBtZXNzYWdlc0NvcHkubGVuZ3RoIC0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpZHggPCBtZXNzYWdlc0NvcHkubGVuZ3RoICYmIHBhcnRpYWxTdHJhdGVneSkge1xuICAgICAgICBsZXQgaW5jbHVkZWRQYXJ0aWFsID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2VzQ29weVtpZHhdLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IG1lc3NhZ2VzQ29weVtpZHhdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleGNsdWRlZC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgY29udGVudCB0byBiZSBhbiBhcnJheS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBudW1CbG9jayA9IGV4Y2x1ZGVkLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZWRDb250ZW50ID0gcGFydGlhbFN0cmF0ZWd5ID09PSBcImxhc3RcIlxuICAgICAgICAgICAgICAgID8gWy4uLmV4Y2x1ZGVkLmNvbnRlbnRdLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIDogZXhjbHVkZWQuY29udGVudDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG51bUJsb2NrOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsQ29udGVudCA9IHBhcnRpYWxTdHJhdGVneSA9PT0gXCJmaXJzdFwiXG4gICAgICAgICAgICAgICAgICAgID8gcmV2ZXJzZWRDb250ZW50LnNsaWNlKDAsIGkpXG4gICAgICAgICAgICAgICAgICAgIDogcmV2ZXJzZWRDb250ZW50LnNsaWNlKC1pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZXhjbHVkZWQpLmZpbHRlcigoW2tdKSA9PiBrICE9PSBcInR5cGVcIiAmJiAhay5zdGFydHNXaXRoKFwibGNfXCIpKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE1lc3NhZ2UgPSBfc3dpdGNoVHlwZVRvTWVzc2FnZShleGNsdWRlZC5nZXRUeXBlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBwYXJ0aWFsQ29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbGljZWRNZXNzYWdlcyA9IFsuLi5tZXNzYWdlc0NvcHkuc2xpY2UoMCwgaWR4KSwgdXBkYXRlZE1lc3NhZ2VdO1xuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgdG9rZW5Db3VudGVyKHNsaWNlZE1lc3NhZ2VzKSkgPD0gbWF4VG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzQ29weSA9IHNsaWNlZE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRQYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNsdWRlZFBhcnRpYWwgJiYgcGFydGlhbFN0cmF0ZWd5ID09PSBcImxhc3RcIikge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVkLmNvbnRlbnQgPSBbLi4ucmV2ZXJzZWRDb250ZW50XS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmNsdWRlZFBhcnRpYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gbWVzc2FnZXNDb3B5W2lkeF07XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4Y2x1ZGVkLmNvbnRlbnQpICYmXG4gICAgICAgICAgICAgICAgZXhjbHVkZWQuY29udGVudC5zb21lKChibG9jaykgPT4gdHlwZW9mIGJsb2NrID09PSBcInN0cmluZ1wiIHx8IGJsb2NrLnR5cGUgPT09IFwidGV4dFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRCbG9jayA9IGV4Y2x1ZGVkLmNvbnRlbnQuZmluZCgoYmxvY2spID0+IGJsb2NrLnR5cGUgPT09IFwidGV4dFwiICYmIGJsb2NrLnRleHQpO1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0QmxvY2s/LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXhjbHVkZWQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRleHQgPSBleGNsdWRlZC5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxpdFRleHRzID0gYXdhaXQgdGV4dFNwbGl0dGVyKHRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bVNwbGl0cyA9IHNwbGl0VGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsU3RyYXRlZ3kgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0VGV4dHMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBfID0gMDsgXyA8IG51bVNwbGl0cyAtIDE7IF8gKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFRleHRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBleGNsdWRlZC5jb250ZW50ID0gc3BsaXRUZXh0cy5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGF3YWl0IHRva2VuQ291bnRlcihbLi4ubWVzc2FnZXNDb3B5LnNsaWNlKDAsIGlkeCksIGV4Y2x1ZGVkXSkpIDw9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsU3RyYXRlZ3kgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZWQuY29udGVudCA9IFsuLi5zcGxpdFRleHRzXS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzQ29weSA9IFsuLi5tZXNzYWdlc0NvcHkuc2xpY2UoMCwgaWR4KSwgZXhjbHVkZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kT24pIHtcbiAgICAgICAgY29uc3QgZW5kT25BcnIgPSBBcnJheS5pc0FycmF5KGVuZE9uKSA/IGVuZE9uIDogW2VuZE9uXTtcbiAgICAgICAgd2hpbGUgKGlkeCA+IDAgJiYgIV9pc01lc3NhZ2VUeXBlKG1lc3NhZ2VzQ29weVtpZHggLSAxXSwgZW5kT25BcnIpKSB7XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXNDb3B5LnNsaWNlKDAsIGlkeCk7XG59XG5hc3luYyBmdW5jdGlvbiBfbGFzdE1heFRva2VucyhtZXNzYWdlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYWxsb3dQYXJ0aWFsID0gZmFsc2UsIGluY2x1ZGVTeXN0ZW0gPSBmYWxzZSwgZW5kT24sIHN0YXJ0T24sIC4uLnJlc3QgfSA9IG9wdGlvbnM7XG4gICAgLy8gQ3JlYXRlIGEgY29weSBvZiBtZXNzYWdlcyB0byBhdm9pZCBtdXRhdGlvblxuICAgIGxldCBtZXNzYWdlc0NvcHkgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UpLmZpbHRlcigoW2tdKSA9PiBrICE9PSBcInR5cGVcIiAmJiAhay5zdGFydHNXaXRoKFwibGNfXCIpKSk7XG4gICAgICAgIHJldHVybiBfc3dpdGNoVHlwZVRvTWVzc2FnZShtZXNzYWdlLmdldFR5cGUoKSwgZmllbGRzLCBpc0Jhc2VNZXNzYWdlQ2h1bmsobWVzc2FnZSkpO1xuICAgIH0pO1xuICAgIGlmIChlbmRPbikge1xuICAgICAgICBjb25zdCBlbmRPbkFyciA9IEFycmF5LmlzQXJyYXkoZW5kT24pID8gZW5kT24gOiBbZW5kT25dO1xuICAgICAgICB3aGlsZSAobWVzc2FnZXNDb3B5Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICFfaXNNZXNzYWdlVHlwZShtZXNzYWdlc0NvcHlbbWVzc2FnZXNDb3B5Lmxlbmd0aCAtIDFdLCBlbmRPbkFycikpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzQ29weSA9IG1lc3NhZ2VzQ29weS5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3dhcHBlZFN5c3RlbSA9IGluY2x1ZGVTeXN0ZW0gJiYgbWVzc2FnZXNDb3B5WzBdPy5nZXRUeXBlKCkgPT09IFwic3lzdGVtXCI7XG4gICAgbGV0IHJldmVyc2VkXyA9IHN3YXBwZWRTeXN0ZW1cbiAgICAgICAgPyBtZXNzYWdlc0NvcHkuc2xpY2UoMCwgMSkuY29uY2F0KG1lc3NhZ2VzQ29weS5zbGljZSgxKS5yZXZlcnNlKCkpXG4gICAgICAgIDogbWVzc2FnZXNDb3B5LnJldmVyc2UoKTtcbiAgICByZXZlcnNlZF8gPSBhd2FpdCBfZmlyc3RNYXhUb2tlbnMocmV2ZXJzZWRfLCB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIHBhcnRpYWxTdHJhdGVneTogYWxsb3dQYXJ0aWFsID8gXCJsYXN0XCIgOiB1bmRlZmluZWQsXG4gICAgICAgIGVuZE9uOiBzdGFydE9uLFxuICAgIH0pO1xuICAgIGlmIChzd2FwcGVkU3lzdGVtKSB7XG4gICAgICAgIHJldHVybiBbcmV2ZXJzZWRfWzBdLCAuLi5yZXZlcnNlZF8uc2xpY2UoMSkucmV2ZXJzZSgpXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXZlcnNlZF8ucmV2ZXJzZSgpO1xuICAgIH1cbn1cbmNvbnN0IF9NU0dfQ0hVTktfTUFQID0ge1xuICAgIGh1bWFuOiB7XG4gICAgICAgIG1lc3NhZ2U6IEh1bWFuTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiBIdW1hbk1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIGFpOiB7XG4gICAgICAgIG1lc3NhZ2U6IEFJTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiBBSU1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIHN5c3RlbToge1xuICAgICAgICBtZXNzYWdlOiBTeXN0ZW1NZXNzYWdlLFxuICAgICAgICBtZXNzYWdlQ2h1bms6IFN5c3RlbU1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIGRldmVsb3Blcjoge1xuICAgICAgICBtZXNzYWdlOiBTeXN0ZW1NZXNzYWdlLFxuICAgICAgICBtZXNzYWdlQ2h1bms6IFN5c3RlbU1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIHRvb2w6IHtcbiAgICAgICAgbWVzc2FnZTogVG9vbE1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VDaHVuazogVG9vbE1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgIG1lc3NhZ2U6IEZ1bmN0aW9uTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiBGdW5jdGlvbk1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIGdlbmVyaWM6IHtcbiAgICAgICAgbWVzc2FnZTogQ2hhdE1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VDaHVuazogQ2hhdE1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIHJlbW92ZToge1xuICAgICAgICBtZXNzYWdlOiBSZW1vdmVNZXNzYWdlLFxuICAgICAgICBtZXNzYWdlQ2h1bms6IFJlbW92ZU1lc3NhZ2UsIC8vIFJlbW92ZU1lc3NhZ2UgZG9lcyBub3QgaGF2ZSBhIGNodW5rIGNsYXNzLlxuICAgIH0sXG59O1xuZnVuY3Rpb24gX3N3aXRjaFR5cGVUb01lc3NhZ2UobWVzc2FnZVR5cGUsIGZpZWxkcywgcmV0dXJuQ2h1bmspIHtcbiAgICBsZXQgY2h1bms7XG4gICAgbGV0IG1zZztcbiAgICBzd2l0Y2ggKG1lc3NhZ2VUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJodW1hblwiOlxuICAgICAgICAgICAgaWYgKHJldHVybkNodW5rKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgSHVtYW5NZXNzYWdlQ2h1bmsoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZyA9IG5ldyBIdW1hbk1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWlcIjpcbiAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgIGxldCBhaUNodW5rRmllbGRzID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0b29sX2NhbGxzXCIgaW4gYWlDaHVua0ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBhaUNodW5rRmllbGRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYWlDaHVua0ZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IGFpQ2h1bmtGaWVsZHMudG9vbF9jYWxscz8ubWFwKCh0YykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50YyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbF9jaHVua1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogSlNPTi5zdHJpbmdpZnkodGMuYXJncyksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IEFJTWVzc2FnZUNodW5rKGFpQ2h1bmtGaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXNnID0gbmV3IEFJTWVzc2FnZShmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzeXN0ZW1cIjpcbiAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IFN5c3RlbU1lc3NhZ2VDaHVuayhmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXNnID0gbmV3IFN5c3RlbU1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGV2ZWxvcGVyXCI6XG4gICAgICAgICAgICBpZiAocmV0dXJuQ2h1bmspIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBTeXN0ZW1NZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHMuYWRkaXRpb25hbF9rd2FyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX29wZW5haV9yb2xlX186IFwiZGV2ZWxvcGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBuZXcgU3lzdGVtTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fb3BlbmFpX3JvbGVfXzogXCJkZXZlbG9wZXJcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgICAgICAgaWYgKFwidG9vbF9jYWxsX2lkXCIgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybkNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IFRvb2xNZXNzYWdlQ2h1bmsoZmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IG5ldyBUb29sTWVzc2FnZShmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBUb29sTWVzc2FnZSB0byBUb29sTWVzc2FnZUNodW5rIGlmICd0b29sX2NhbGxfaWQnIGZpZWxkIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IEZ1bmN0aW9uTWVzc2FnZUNodW5rKGZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uTWVzc2FnZSBtdXN0IGhhdmUgYSAnbmFtZScgZmllbGRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1zZyA9IG5ldyBGdW5jdGlvbk1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ2VuZXJpY1wiOlxuICAgICAgICAgICAgaWYgKFwicm9sZVwiIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBDaGF0TWVzc2FnZUNodW5rKGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSBuZXcgQ2hhdE1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgQ2hhdE1lc3NhZ2UgdG8gQ2hhdE1lc3NhZ2VDaHVuayBpZiAncm9sZScgZmllbGQgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtZXNzYWdlIHR5cGUgJHttZXNzYWdlVHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKHJldHVybkNodW5rICYmIGNodW5rKSB7XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgaWYgKG1zZykge1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtZXNzYWdlIHR5cGUgJHttZXNzYWdlVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIF9jaHVua1RvTXNnKGNodW5rKSB7XG4gICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsuZ2V0VHlwZSgpO1xuICAgIGxldCBtc2c7XG4gICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNodW5rKS5maWx0ZXIoKFtrXSkgPT4gIVtcInR5cGVcIiwgXCJ0b29sX2NhbGxfY2h1bmtzXCJdLmluY2x1ZGVzKGspICYmICFrLnN0YXJ0c1dpdGgoXCJsY19cIikpKTtcbiAgICBpZiAoY2h1bmtUeXBlIGluIF9NU0dfQ0hVTktfTUFQKSB7XG4gICAgICAgIG1zZyA9IF9zd2l0Y2hUeXBlVG9NZXNzYWdlKGNodW5rVHlwZSwgZmllbGRzKTtcbiAgICB9XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbWVzc2FnZSBjaHVuayBjbGFzcyAke2NodW5rVHlwZX0uIFN1cHBvcnRlZCBjbGFzc2VzIGFyZSAke09iamVjdC5rZXlzKF9NU0dfQ0hVTktfTUFQKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1zZztcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgdGV4dCBzcGxpdHRlciBmdW5jdGlvbiB0aGF0IHNwbGl0cyB0ZXh0IGJ5IG5ld2xpbmVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBzdHJpbmdzIHNwbGl0IGJ5IG5ld2xpbmVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFRleHRTcGxpdHRlcih0ZXh0KSB7XG4gICAgY29uc3Qgc3BsaXRzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtcbiAgICAgICAgLi4uc3BsaXRzLnNsaWNlKDAsIC0xKS5tYXAoKHMpID0+IGAke3N9XFxuYCksXG4gICAgICAgIHNwbGl0c1tzcGxpdHMubGVuZ3RoIC0gMV0sXG4gICAgXSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/transformers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coerceMessageLikeToMessage: () => (/* binding */ coerceMessageLikeToMessage),\n/* harmony export */   convertToChunk: () => (/* binding */ convertToChunk),\n/* harmony export */   getBufferString: () => (/* binding */ getBufferString),\n/* harmony export */   mapChatMessagesToStoredMessages: () => (/* binding */ mapChatMessagesToStoredMessages),\n/* harmony export */   mapStoredMessageToChatMessage: () => (/* binding */ mapStoredMessageToChatMessage),\n/* harmony export */   mapStoredMessagesToChatMessages: () => (/* binding */ mapStoredMessagesToChatMessages)\n/* harmony export */ });\n/* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/errors/index.js\");\n/* harmony import */ var _tools_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.js\");\n/* harmony import */ var _ai_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ai.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chat.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.js\");\n/* harmony import */ var _human_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./human.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.js\");\n/* harmony import */ var _modifier_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifier.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./system.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tool.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.js\");\n\n\n\n\n\n\n\n\n\n\nfunction _coerceToolCall(toolCall) {\n    if ((0,_tools_utils_js__WEBPACK_IMPORTED_MODULE_1__._isToolCall)(toolCall)) {\n        return toolCall;\n    }\n    else if (typeof toolCall.id === \"string\" &&\n        toolCall.type === \"function\" &&\n        typeof toolCall.function === \"object\" &&\n        toolCall.function !== null &&\n        \"arguments\" in toolCall.function &&\n        typeof toolCall.function.arguments === \"string\" &&\n        \"name\" in toolCall.function &&\n        typeof toolCall.function.name === \"string\") {\n        // Handle OpenAI tool call format\n        return {\n            id: toolCall.id,\n            args: JSON.parse(toolCall.function.arguments),\n            name: toolCall.function.name,\n            type: \"tool_call\",\n        };\n    }\n    else {\n        // TODO: Throw an error?\n        return toolCall;\n    }\n}\nfunction isSerializedConstructor(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        x.lc === 1 &&\n        Array.isArray(x.id) &&\n        x.kwargs != null &&\n        typeof x.kwargs === \"object\");\n}\nfunction _constructMessageFromParams(params) {\n    let type;\n    let rest;\n    // Support serialized messages\n    if (isSerializedConstructor(params)) {\n        const className = params.id.at(-1);\n        if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n            type = \"user\";\n        }\n        else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n            type = \"assistant\";\n        }\n        else if (className === \"SystemMessage\" ||\n            className === \"SystemMessageChunk\") {\n            type = \"system\";\n        }\n        else if (className === \"FunctionMessage\" ||\n            className === \"FunctionMessageChunk\") {\n            type = \"function\";\n        }\n        else if (className === \"ToolMessage\" ||\n            className === \"ToolMessageChunk\") {\n            type = \"tool\";\n        }\n        else {\n            type = \"unknown\";\n        }\n        rest = params.kwargs;\n    }\n    else {\n        const { type: extractedType, ...otherParams } = params;\n        type = extractedType;\n        rest = otherParams;\n    }\n    if (type === \"human\" || type === \"user\") {\n        return new _human_js__WEBPACK_IMPORTED_MODULE_6__.HumanMessage(rest);\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        const { tool_calls: rawToolCalls, ...other } = rest;\n        if (!Array.isArray(rawToolCalls)) {\n            return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessage(rest);\n        }\n        const tool_calls = rawToolCalls.map(_coerceToolCall);\n        return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessage({ ...other, tool_calls });\n    }\n    else if (type === \"system\") {\n        return new _system_js__WEBPACK_IMPORTED_MODULE_8__.SystemMessage(rest);\n    }\n    else if (type === \"developer\") {\n        return new _system_js__WEBPACK_IMPORTED_MODULE_8__.SystemMessage({\n            ...rest,\n            additional_kwargs: {\n                ...rest.additional_kwargs,\n                __openai_role__: \"developer\",\n            },\n        });\n    }\n    else if (type === \"tool\" && \"tool_call_id\" in rest) {\n        return new _tool_js__WEBPACK_IMPORTED_MODULE_9__.ToolMessage({\n            ...rest,\n            content: rest.content,\n            tool_call_id: rest.tool_call_id,\n            name: rest.name,\n        });\n    }\n    else if (type === \"remove\" && \"id\" in rest && typeof rest.id === \"string\") {\n        return new _modifier_js__WEBPACK_IMPORTED_MODULE_7__.RemoveMessage({ ...rest, id: rest.id });\n    }\n    else {\n        const error = (0,_errors_index_js__WEBPACK_IMPORTED_MODULE_0__.addLangChainErrorFields)(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(params, null, 2)}`), \"MESSAGE_COERCION_FAILURE\");\n        throw error;\n    }\n}\nfunction coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new _human_js__WEBPACK_IMPORTED_MODULE_6__.HumanMessage(messageLike);\n    }\n    else if ((0,_base_js__WEBPACK_IMPORTED_MODULE_3__.isBaseMessage)(messageLike)) {\n        return messageLike;\n    }\n    if (Array.isArray(messageLike)) {\n        const [type, content] = messageLike;\n        return _constructMessageFromParams({ type, content });\n    }\n    else if ((0,_base_js__WEBPACK_IMPORTED_MODULE_3__._isMessageFieldWithRole)(messageLike)) {\n        const { role: type, ...rest } = messageLike;\n        return _constructMessageFromParams({ ...rest, type });\n    }\n    else {\n        return _constructMessageFromParams(messageLike);\n    }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nfunction getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        const readableContent = typeof m.content === \"string\"\n            ? m.content\n            : JSON.stringify(m.content, null, 2);\n        string_messages.push(`${role}: ${nameStr}${readableContent}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nfunction mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new _human_js__WEBPACK_IMPORTED_MODULE_6__.HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessage(storedMessage.data);\n        case \"system\":\n            return new _system_js__WEBPACK_IMPORTED_MODULE_8__.SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new _function_js__WEBPACK_IMPORTED_MODULE_5__.FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new _tool_js__WEBPACK_IMPORTED_MODULE_9__.ToolMessage(storedMessage.data);\n        case \"generic\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new _chat_js__WEBPACK_IMPORTED_MODULE_4__.ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nfunction mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nfunction mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\nfunction convertToChunk(message) {\n    const type = message._getType();\n    if (type === \"human\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _human_js__WEBPACK_IMPORTED_MODULE_6__.HumanMessageChunk({ ...message });\n    }\n    else if (type === \"ai\") {\n        let aiChunkFields = {\n            ...message,\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n            aiChunkFields = {\n                ...aiChunkFields,\n                tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                    ...tc,\n                    type: \"tool_call_chunk\",\n                    index: undefined,\n                    args: JSON.stringify(tc.args),\n                })),\n            };\n        }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessageChunk({ ...aiChunkFields });\n    }\n    else if (type === \"system\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _system_js__WEBPACK_IMPORTED_MODULE_8__.SystemMessageChunk({ ...message });\n    }\n    else if (type === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _function_js__WEBPACK_IMPORTED_MODULE_5__.FunctionMessageChunk({ ...message });\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    }\n    else if (_chat_js__WEBPACK_IMPORTED_MODULE_4__.ChatMessage.isInstance(message)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _chat_js__WEBPACK_IMPORTED_MODULE_4__.ChatMessageChunk({ ...message });\n    }\n    else {\n        throw new Error(\"Unknown message type.\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RDtBQUNiO0FBQ0k7QUFDZ0I7QUFDVDtBQUNZO0FBQ1Y7QUFDZjtBQUNrQjtBQUN2QjtBQUN6QztBQUNBLFFBQVEsNERBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFZO0FBQy9CO0FBQ0E7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0EsdUJBQXVCLDZDQUFTO0FBQ2hDO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQVMsR0FBRyxzQkFBc0I7QUFDckQ7QUFDQTtBQUNBLG1CQUFtQixxREFBYTtBQUNoQztBQUNBO0FBQ0EsbUJBQW1CLHFEQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsdURBQWEsR0FBRyxzQkFBc0I7QUFDekQ7QUFDQTtBQUNBLHNCQUFzQix5RUFBdUIsb0pBQW9KLGdDQUFnQztBQUNqTztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsbUJBQW1CLG1EQUFZO0FBQy9CO0FBQ0EsYUFBYSx1REFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0EsYUFBYSxpRUFBdUI7QUFDcEMsZ0JBQWdCLHNCQUFzQjtBQUN0Qyw2Q0FBNkMsZUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUU7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSyxJQUFJLFFBQVEsRUFBRSxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFZO0FBQ25DO0FBQ0EsdUJBQXVCLDZDQUFTO0FBQ2hDO0FBQ0EsdUJBQXVCLHFEQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFXO0FBQ2xDO0FBQ0E7QUFDQSxvREFBb0QsbUJBQW1CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQWlCLEdBQUcsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQWMsR0FBRyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFrQixHQUFHLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUFvQixHQUFHLFlBQVk7QUFDdEQ7QUFDQTtBQUNBLGFBQWEsaURBQVc7QUFDeEI7QUFDQSxtQkFBbUIsc0RBQWdCLEdBQUcsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG1lc3NhZ2VzXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGRMYW5nQ2hhaW5FcnJvckZpZWxkcyB9IGZyb20gXCIuLi9lcnJvcnMvaW5kZXguanNcIjtcbmltcG9ydCB7IF9pc1Rvb2xDYWxsIH0gZnJvbSBcIi4uL3Rvb2xzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBBSU1lc3NhZ2UsIEFJTWVzc2FnZUNodW5rIH0gZnJvbSBcIi4vYWkuanNcIjtcbmltcG9ydCB7IGlzQmFzZU1lc3NhZ2UsIF9pc01lc3NhZ2VGaWVsZFdpdGhSb2xlLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IENoYXRNZXNzYWdlLCBDaGF0TWVzc2FnZUNodW5rLCB9IGZyb20gXCIuL2NoYXQuanNcIjtcbmltcG9ydCB7IEZ1bmN0aW9uTWVzc2FnZSwgRnVuY3Rpb25NZXNzYWdlQ2h1bmssIH0gZnJvbSBcIi4vZnVuY3Rpb24uanNcIjtcbmltcG9ydCB7IEh1bWFuTWVzc2FnZSwgSHVtYW5NZXNzYWdlQ2h1bmsgfSBmcm9tIFwiLi9odW1hbi5qc1wiO1xuaW1wb3J0IHsgUmVtb3ZlTWVzc2FnZSB9IGZyb20gXCIuL21vZGlmaWVyLmpzXCI7XG5pbXBvcnQgeyBTeXN0ZW1NZXNzYWdlLCBTeXN0ZW1NZXNzYWdlQ2h1bmsgfSBmcm9tIFwiLi9zeXN0ZW0uanNcIjtcbmltcG9ydCB7IFRvb2xNZXNzYWdlLCB9IGZyb20gXCIuL3Rvb2wuanNcIjtcbmZ1bmN0aW9uIF9jb2VyY2VUb29sQ2FsbCh0b29sQ2FsbCkge1xuICAgIGlmIChfaXNUb29sQ2FsbCh0b29sQ2FsbCkpIHtcbiAgICAgICAgcmV0dXJuIHRvb2xDYWxsO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdG9vbENhbGwuaWQgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgdG9vbENhbGwudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbiAhPT0gbnVsbCAmJlxuICAgICAgICBcImFyZ3VtZW50c1wiIGluIHRvb2xDYWxsLmZ1bmN0aW9uICYmXG4gICAgICAgIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgXCJuYW1lXCIgaW4gdG9vbENhbGwuZnVuY3Rpb24gJiZcbiAgICAgICAgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gSGFuZGxlIE9wZW5BSSB0b29sIGNhbGwgZm9ybWF0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICBhcmdzOiBKU09OLnBhcnNlKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgICAgICBuYW1lOiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IFRocm93IGFuIGVycm9yP1xuICAgICAgICByZXR1cm4gdG9vbENhbGw7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTZXJpYWxpemVkQ29uc3RydWN0b3IoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgeCAhPSBudWxsICYmXG4gICAgICAgIHgubGMgPT09IDEgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh4LmlkKSAmJlxuICAgICAgICB4Lmt3YXJncyAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB4Lmt3YXJncyA9PT0gXCJvYmplY3RcIik7XG59XG5mdW5jdGlvbiBfY29uc3RydWN0TWVzc2FnZUZyb21QYXJhbXMocGFyYW1zKSB7XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IHJlc3Q7XG4gICAgLy8gU3VwcG9ydCBzZXJpYWxpemVkIG1lc3NhZ2VzXG4gICAgaWYgKGlzU2VyaWFsaXplZENvbnN0cnVjdG9yKHBhcmFtcykpIHtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gcGFyYW1zLmlkLmF0KC0xKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gXCJIdW1hbk1lc3NhZ2VcIiB8fCBjbGFzc05hbWUgPT09IFwiSHVtYW5NZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgdHlwZSA9IFwidXNlclwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gXCJBSU1lc3NhZ2VcIiB8fCBjbGFzc05hbWUgPT09IFwiQUlNZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgdHlwZSA9IFwiYXNzaXN0YW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhc3NOYW1lID09PSBcIlN5c3RlbU1lc3NhZ2VcIiB8fFxuICAgICAgICAgICAgY2xhc3NOYW1lID09PSBcIlN5c3RlbU1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJzeXN0ZW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc05hbWUgPT09IFwiRnVuY3Rpb25NZXNzYWdlXCIgfHxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9PT0gXCJGdW5jdGlvbk1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gXCJUb29sTWVzc2FnZVwiIHx8XG4gICAgICAgICAgICBjbGFzc05hbWUgPT09IFwiVG9vbE1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJ0b29sXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gXCJ1bmtub3duXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdCA9IHBhcmFtcy5rd2FyZ3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB7IHR5cGU6IGV4dHJhY3RlZFR5cGUsIC4uLm90aGVyUGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgICAgIHR5cGUgPSBleHRyYWN0ZWRUeXBlO1xuICAgICAgICByZXN0ID0gb3RoZXJQYXJhbXM7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImh1bWFuXCIgfHwgdHlwZSA9PT0gXCJ1c2VyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdW1hbk1lc3NhZ2UocmVzdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiYWlcIiB8fCB0eXBlID09PSBcImFzc2lzdGFudFwiKSB7XG4gICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsczogcmF3VG9vbENhbGxzLCAuLi5vdGhlciB9ID0gcmVzdDtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJhd1Rvb2xDYWxscykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQUlNZXNzYWdlKHJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xfY2FsbHMgPSByYXdUb29sQ2FsbHMubWFwKF9jb2VyY2VUb29sQ2FsbCk7XG4gICAgICAgIHJldHVybiBuZXcgQUlNZXNzYWdlKHsgLi4ub3RoZXIsIHRvb2xfY2FsbHMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTeXN0ZW1NZXNzYWdlKHJlc3QpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImRldmVsb3BlclwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3lzdGVtTWVzc2FnZSh7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IHtcbiAgICAgICAgICAgICAgICAuLi5yZXN0LmFkZGl0aW9uYWxfa3dhcmdzLFxuICAgICAgICAgICAgICAgIF9fb3BlbmFpX3JvbGVfXzogXCJkZXZlbG9wZXJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcInRvb2xcIiAmJiBcInRvb2xfY2FsbF9pZFwiIGluIHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb29sTWVzc2FnZSh7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgY29udGVudDogcmVzdC5jb250ZW50LFxuICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiByZXN0LnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgIG5hbWU6IHJlc3QubmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwicmVtb3ZlXCIgJiYgXCJpZFwiIGluIHJlc3QgJiYgdHlwZW9mIHJlc3QuaWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNZXNzYWdlKHsgLi4ucmVzdCwgaWQ6IHJlc3QuaWQgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvciA9IGFkZExhbmdDaGFpbkVycm9yRmllbGRzKG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvZXJjZSBtZXNzYWdlIGZyb20gYXJyYXk6IG9ubHkgaHVtYW4sIEFJLCBzeXN0ZW0sIGRldmVsb3Blciwgb3IgdG9vbCBtZXNzYWdlIGNvZXJjaW9uIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXFxuXFxuUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkocGFyYW1zLCBudWxsLCAyKX1gKSwgXCJNRVNTQUdFX0NPRVJDSU9OX0ZBSUxVUkVcIik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZShtZXNzYWdlTGlrZSkge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZUxpa2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdW1hbk1lc3NhZ2UobWVzc2FnZUxpa2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jhc2VNZXNzYWdlKG1lc3NhZ2VMaWtlKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZUxpa2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2VMaWtlKSkge1xuICAgICAgICBjb25zdCBbdHlwZSwgY29udGVudF0gPSBtZXNzYWdlTGlrZTtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3RNZXNzYWdlRnJvbVBhcmFtcyh7IHR5cGUsIGNvbnRlbnQgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc01lc3NhZ2VGaWVsZFdpdGhSb2xlKG1lc3NhZ2VMaWtlKSkge1xuICAgICAgICBjb25zdCB7IHJvbGU6IHR5cGUsIC4uLnJlc3QgfSA9IG1lc3NhZ2VMaWtlO1xuICAgICAgICByZXR1cm4gX2NvbnN0cnVjdE1lc3NhZ2VGcm9tUGFyYW1zKHsgLi4ucmVzdCwgdHlwZSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0TWVzc2FnZUZyb21QYXJhbXMobWVzc2FnZUxpa2UpO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IG1lbW9yeSBjbGFzc2VzIHRvIGdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvblxuICogb2YgdGhlIGNoYXQgbWVzc2FnZSBoaXN0b3J5LCBiYXNlZCBvbiB0aGUgbWVzc2FnZSBjb250ZW50IGFuZCByb2xlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnVmZmVyU3RyaW5nKG1lc3NhZ2VzLCBodW1hblByZWZpeCA9IFwiSHVtYW5cIiwgYWlQcmVmaXggPSBcIkFJXCIpIHtcbiAgICBjb25zdCBzdHJpbmdfbWVzc2FnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG0gb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgbGV0IHJvbGU7XG4gICAgICAgIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiaHVtYW5cIikge1xuICAgICAgICAgICAgcm9sZSA9IGh1bWFuUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJhaVwiKSB7XG4gICAgICAgICAgICByb2xlID0gYWlQcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgICAgICByb2xlID0gXCJTeXN0ZW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcm9sZSA9IFwiRnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwidG9vbFwiKSB7XG4gICAgICAgICAgICByb2xlID0gXCJUb29sXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgcm9sZSA9IG0ucm9sZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVuc3VwcG9ydGVkIG1lc3NhZ2UgdHlwZTogJHttLl9nZXRUeXBlKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZVN0ciA9IG0ubmFtZSA/IGAke20ubmFtZX0sIGAgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRlbnQgPSB0eXBlb2YgbS5jb250ZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IG0uY29udGVudFxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShtLmNvbnRlbnQsIG51bGwsIDIpO1xuICAgICAgICBzdHJpbmdfbWVzc2FnZXMucHVzaChgJHtyb2xlfTogJHtuYW1lU3RyfSR7cmVhZGFibGVDb250ZW50fWApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nX21lc3NhZ2VzLmpvaW4oXCJcXG5cIik7XG59XG4vKipcbiAqIE1hcHMgbWVzc2FnZXMgZnJvbSBhbiBvbGRlciBmb3JtYXQgKFYxKSB0byB0aGUgY3VycmVudCBgU3RvcmVkTWVzc2FnZWBcbiAqIGZvcm1hdC4gSWYgdGhlIG1lc3NhZ2UgaXMgYWxyZWFkeSBpbiB0aGUgYFN0b3JlZE1lc3NhZ2VgIGZvcm1hdCwgaXQgaXNcbiAqIHJldHVybmVkIGFzIGlzLiBPdGhlcndpc2UsIGl0IHRyYW5zZm9ybXMgdGhlIFYxIG1lc3NhZ2UgaW50byBhXG4gKiBgU3RvcmVkTWVzc2FnZWAuIFRoaXMgZnVuY3Rpb24gaXMgaW1wb3J0YW50IGZvciBtYWludGFpbmluZ1xuICogY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIG1lc3NhZ2UgZm9ybWF0cy5cbiAqL1xuZnVuY3Rpb24gbWFwVjFNZXNzYWdlVG9TdG9yZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBtYXBwZXIgd2hlbiB3ZSBkZXByZWNhdGUgdGhlIG9sZCBtZXNzYWdlIGZvcm1hdC5cbiAgICBpZiAobWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB2MU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdjFNZXNzYWdlLnR5cGUsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdjFNZXNzYWdlLnRleHQsXG4gICAgICAgICAgICAgICAgcm9sZTogdjFNZXNzYWdlLnJvbGUsXG4gICAgICAgICAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHN0b3JlZE1lc3NhZ2UgPSBtYXBWMU1lc3NhZ2VUb1N0b3JlZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgc3dpdGNoIChzdG9yZWRNZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImh1bWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwiYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQUlNZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJzeXN0ZW1cIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3lzdGVtTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGlmIChzdG9yZWRNZXNzYWdlLmRhdGEubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSBtdXN0IGJlIGRlZmluZWQgZm9yIGZ1bmN0aW9uIG1lc3NhZ2VzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcInRvb2xcIjpcbiAgICAgICAgICAgIGlmIChzdG9yZWRNZXNzYWdlLmRhdGEudG9vbF9jYWxsX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb29sIGNhbGwgSUQgbXVzdCBiZSBkZWZpbmVkIGZvciB0b29sIG1lc3NhZ2VzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUb29sTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwiZ2VuZXJpY1wiOiB7XG4gICAgICAgICAgICBpZiAoc3RvcmVkTWVzc2FnZS5kYXRhLnJvbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvbGUgbXVzdCBiZSBkZWZpbmVkIGZvciBjaGF0IG1lc3NhZ2VzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmV4cGVjdGVkIHR5cGU6ICR7c3RvcmVkTWVzc2FnZS50eXBlfWApO1xuICAgIH1cbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBgU3RvcmVkTWVzc2FnZWAgaW5zdGFuY2VzIGludG8gYW4gYXJyYXkgb2ZcbiAqIGBCYXNlTWVzc2FnZWAgaW5zdGFuY2VzLiBJdCB1c2VzIHRoZSBgbWFwVjFNZXNzYWdlVG9TdG9yZWRNZXNzYWdlYFxuICogZnVuY3Rpb24gdG8gZW5zdXJlIGFsbCBtZXNzYWdlcyBhcmUgaW4gdGhlIGBTdG9yZWRNZXNzYWdlYCBmb3JtYXQsIHRoZW5cbiAqIGNyZWF0ZXMgbmV3IGluc3RhbmNlcyBvZiB0aGUgYXBwcm9wcmlhdGUgYEJhc2VNZXNzYWdlYCBzdWJjbGFzcyBiYXNlZFxuICogb24gdGhlIHR5cGUgb2YgZWFjaCBtZXNzYWdlLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJlcGFyZSBzdG9yZWRcbiAqIG1lc3NhZ2VzIGZvciB1c2UgaW4gYSBjaGF0IGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBTdG9yZWRNZXNzYWdlc1RvQ2hhdE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VzLm1hcChtYXBTdG9yZWRNZXNzYWdlVG9DaGF0TWVzc2FnZSk7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2YgYEJhc2VNZXNzYWdlYCBpbnN0YW5jZXMgaW50byBhbiBhcnJheSBvZlxuICogYFN0b3JlZE1lc3NhZ2VgIGluc3RhbmNlcy4gSXQgZG9lcyB0aGlzIGJ5IGNhbGxpbmcgdGhlIGB0b0RpY3RgIG1ldGhvZFxuICogb24gZWFjaCBgQmFzZU1lc3NhZ2VgLCB3aGljaCByZXR1cm5zIGEgYFN0b3JlZE1lc3NhZ2VgLiBUaGlzIGZ1bmN0aW9uXG4gKiBpcyB1c2VkIHRvIHByZXBhcmUgY2hhdCBtZXNzYWdlcyBmb3Igc3RvcmFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcENoYXRNZXNzYWdlc1RvU3RvcmVkTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiBtZXNzYWdlLnRvRGljdCgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9DaHVuayhtZXNzYWdlKSB7XG4gICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuX2dldFR5cGUoKTtcbiAgICBpZiAodHlwZSA9PT0gXCJodW1hblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBIdW1hbk1lc3NhZ2VDaHVuayh7IC4uLm1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiYWlcIikge1xuICAgICAgICBsZXQgYWlDaHVua0ZpZWxkcyA9IHtcbiAgICAgICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChcInRvb2xfY2FsbHNcIiBpbiBhaUNodW5rRmllbGRzKSB7XG4gICAgICAgICAgICBhaUNodW5rRmllbGRzID0ge1xuICAgICAgICAgICAgICAgIC4uLmFpQ2h1bmtGaWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogYWlDaHVua0ZpZWxkcy50b29sX2NhbGxzPy5tYXAoKHRjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAuLi50YyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxfY2h1bmtcIixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogSlNPTi5zdHJpbmdpZnkodGMuYXJncyksXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgQUlNZXNzYWdlQ2h1bmsoeyAuLi5haUNodW5rRmllbGRzIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBTeXN0ZW1NZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uTWVzc2FnZUNodW5rKHsgLi4ubWVzc2FnZSB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIH1cbiAgICBlbHNlIGlmIChDaGF0TWVzc2FnZS5pc0luc3RhbmNlKG1lc3NhZ2UpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZUNodW5rKHsgLi4ubWVzc2FnZSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbWVzc2FnZSB0eXBlLlwiKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.js":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/base.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseLLMOutputParser: () => (/* binding */ BaseLLMOutputParser),\n/* harmony export */   BaseOutputParser: () => (/* binding */ BaseOutputParser),\n/* harmony export */   OutputParserException: () => (/* binding */ OutputParserException)\n/* harmony export */ });\n/* harmony import */ var _runnables_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/index.js\");\n/* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/errors/index.js\");\n\n\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nclass BaseLLMOutputParser extends _runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    /**\n     * Parses the result of an LLM call with a given prompt. By default, it\n     * simply calls `parseResult`.\n     * @param generations The generations from an LLM call.\n     * @param _prompt The prompt used in the LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parseResultWithPrompt(generations, _prompt, callbacks) {\n        return this.parseResult(generations, callbacks);\n    }\n    _baseMessageToString(message) {\n        return typeof message.content === \"string\"\n            ? message.content\n            : this._baseMessageContentToString(message.content);\n    }\n    _baseMessageContentToString(content) {\n        return JSON.stringify(content);\n    }\n    /**\n     * Calls the parser with a given input and optional configuration options.\n     * If the input is a string, it creates a generation with the input as\n     * text and calls `parseResult`. If the input is a `BaseMessage`, it\n     * creates a generation with the input as a message and the content of the\n     * input as text, and then calls `parseResult`.\n     * @param input The input to the parser, which can be a string or a `BaseMessage`.\n     * @param options Optional configuration options.\n     * @returns A promise of the parsed output.\n     */\n    async invoke(input, options) {\n        if (typeof input === \"string\") {\n            return this._callWithConfig(async (input, options) => this.parseResult([{ text: input }], options?.callbacks), input, { ...options, runType: \"parser\" });\n        }\n        else {\n            return this._callWithConfig(async (input, options) => this.parseResult([\n                {\n                    message: input,\n                    text: this._baseMessageToString(input),\n                },\n            ], options?.callbacks), input, { ...options, runType: \"parser\" });\n        }\n    }\n}\n/**\n * Class to parse the output of an LLM call.\n */\nclass BaseOutputParser extends BaseLLMOutputParser {\n    parseResult(generations, callbacks) {\n        return this.parse(generations[0].text, callbacks);\n    }\n    async parseWithPrompt(text, _prompt, callbacks) {\n        return this.parse(text, callbacks);\n    }\n    /**\n     * Return the string type key uniquely identifying this class of parser\n     */\n    _type() {\n        throw new Error(\"_type not implemented\");\n    }\n}\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nclass OutputParserException extends Error {\n    constructor(message, llmOutput, observation, sendToLLM = false) {\n        super(message);\n        Object.defineProperty(this, \"llmOutput\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sendToLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.llmOutput = llmOutput;\n        this.observation = observation;\n        this.sendToLLM = sendToLLM;\n        if (sendToLLM) {\n            if (observation === undefined || llmOutput === undefined) {\n                throw new Error(\"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\");\n            }\n        }\n        (0,_errors_index_js__WEBPACK_IMPORTED_MODULE_1__.addLangChainErrorFields)(this, \"OUTPUT_PARSING_FAILURE\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MseURBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYSxpQ0FBaUMsK0JBQStCO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2Q0FBNkMsK0JBQStCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5RUFBdUI7QUFDL0I7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxvdXRwdXRfcGFyc2Vyc1xcYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSdW5uYWJsZSB9IGZyb20gXCIuLi9ydW5uYWJsZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IGFkZExhbmdDaGFpbkVycm9yRmllbGRzIH0gZnJvbSBcIi4uL2Vycm9ycy9pbmRleC5qc1wiO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwYXJzaW5nIHRoZSBvdXRwdXQgb2YgYSBMYXJnZSBMYW5ndWFnZSBNb2RlbFxuICogKExMTSkgY2FsbC4gSXQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgcGFyc2luZyB0aGUgcmVzdWx0IG9mIGFuIExMTSBjYWxsXG4gKiBhbmQgaW52b2tpbmcgdGhlIHBhcnNlciB3aXRoIGEgZ2l2ZW4gaW5wdXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTExNT3V0cHV0UGFyc2VyIGV4dGVuZHMgUnVubmFibGUge1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgcmVzdWx0IG9mIGFuIExMTSBjYWxsIHdpdGggYSBnaXZlbiBwcm9tcHQuIEJ5IGRlZmF1bHQsIGl0XG4gICAgICogc2ltcGx5IGNhbGxzIGBwYXJzZVJlc3VsdGAuXG4gICAgICogQHBhcmFtIGdlbmVyYXRpb25zIFRoZSBnZW5lcmF0aW9ucyBmcm9tIGFuIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBfcHJvbXB0IFRoZSBwcm9tcHQgdXNlZCBpbiB0aGUgTExNIGNhbGwuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBPcHRpb25hbCBjYWxsYmFja3MuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIHBhcnNlUmVzdWx0V2l0aFByb21wdChnZW5lcmF0aW9ucywgX3Byb21wdCwgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVzdWx0KGdlbmVyYXRpb25zLCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICBfYmFzZU1lc3NhZ2VUb1N0cmluZyhtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IG1lc3NhZ2UuY29udGVudFxuICAgICAgICAgICAgOiB0aGlzLl9iYXNlTWVzc2FnZUNvbnRlbnRUb1N0cmluZyhtZXNzYWdlLmNvbnRlbnQpO1xuICAgIH1cbiAgICBfYmFzZU1lc3NhZ2VDb250ZW50VG9TdHJpbmcoY29udGVudCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBwYXJzZXIgd2l0aCBhIGdpdmVuIGlucHV0IGFuZCBvcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogSWYgdGhlIGlucHV0IGlzIGEgc3RyaW5nLCBpdCBjcmVhdGVzIGEgZ2VuZXJhdGlvbiB3aXRoIHRoZSBpbnB1dCBhc1xuICAgICAqIHRleHQgYW5kIGNhbGxzIGBwYXJzZVJlc3VsdGAuIElmIHRoZSBpbnB1dCBpcyBhIGBCYXNlTWVzc2FnZWAsIGl0XG4gICAgICogY3JlYXRlcyBhIGdlbmVyYXRpb24gd2l0aCB0aGUgaW5wdXQgYXMgYSBtZXNzYWdlIGFuZCB0aGUgY29udGVudCBvZiB0aGVcbiAgICAgKiBpbnB1dCBhcyB0ZXh0LCBhbmQgdGhlbiBjYWxscyBgcGFyc2VSZXN1bHRgLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gdGhlIHBhcnNlciwgd2hpY2ggY2FuIGJlIGEgc3RyaW5nIG9yIGEgYEJhc2VNZXNzYWdlYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcoYXN5bmMgKGlucHV0LCBvcHRpb25zKSA9PiB0aGlzLnBhcnNlUmVzdWx0KFt7IHRleHQ6IGlucHV0IH1dLCBvcHRpb25zPy5jYWxsYmFja3MpLCBpbnB1dCwgeyAuLi5vcHRpb25zLCBydW5UeXBlOiBcInBhcnNlclwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKGFzeW5jIChpbnB1dCwgb3B0aW9ucykgPT4gdGhpcy5wYXJzZVJlc3VsdChbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fYmFzZU1lc3NhZ2VUb1N0cmluZyhpbnB1dCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sIG9wdGlvbnM/LmNhbGxiYWNrcyksIGlucHV0LCB7IC4uLm9wdGlvbnMsIHJ1blR5cGU6IFwicGFyc2VyXCIgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENsYXNzIHRvIHBhcnNlIHRoZSBvdXRwdXQgb2YgYW4gTExNIGNhbGwuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlT3V0cHV0UGFyc2VyIGV4dGVuZHMgQmFzZUxMTU91dHB1dFBhcnNlciB7XG4gICAgcGFyc2VSZXN1bHQoZ2VuZXJhdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShnZW5lcmF0aW9uc1swXS50ZXh0LCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZVdpdGhQcm9tcHQodGV4dCwgX3Byb21wdCwgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKHRleHQsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3RyaW5nIHR5cGUga2V5IHVuaXF1ZWx5IGlkZW50aWZ5aW5nIHRoaXMgY2xhc3Mgb2YgcGFyc2VyXG4gICAgICovXG4gICAgX3R5cGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIl90eXBlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59XG4vKipcbiAqIEV4Y2VwdGlvbiB0aGF0IG91dHB1dCBwYXJzZXJzIHNob3VsZCByYWlzZSB0byBzaWduaWZ5IGEgcGFyc2luZyBlcnJvci5cbiAqXG4gKiBUaGlzIGV4aXN0cyB0byBkaWZmZXJlbnRpYXRlIHBhcnNpbmcgZXJyb3JzIGZyb20gb3RoZXIgY29kZSBvciBleGVjdXRpb24gZXJyb3JzXG4gKiB0aGF0IGFsc28gbWF5IGFyaXNlIGluc2lkZSB0aGUgb3V0cHV0IHBhcnNlci4gT3V0cHV0UGFyc2VyRXhjZXB0aW9ucyB3aWxsIGJlXG4gKiBhdmFpbGFibGUgdG8gY2F0Y2ggYW5kIGhhbmRsZSBpbiB3YXlzIHRvIGZpeCB0aGUgcGFyc2luZyBlcnJvciwgd2hpbGUgb3RoZXJcbiAqIGVycm9ycyB3aWxsIGJlIHJhaXNlZC5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciB0aGF0J3MgYmVpbmcgcmUtcmFpc2VkIG9yIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0gbGxtT3V0cHV0IC0gU3RyaW5nIG1vZGVsIG91dHB1dCB3aGljaCBpcyBlcnJvci1pbmcuXG4gKiBAcGFyYW0gb2JzZXJ2YXRpb24gLSBTdHJpbmcgZXhwbGFuYXRpb24gb2YgZXJyb3Igd2hpY2ggY2FuIGJlIHBhc3NlZCB0byBhXG4gKiAgICAgbW9kZWwgdG8gdHJ5IGFuZCByZW1lZGlhdGUgdGhlIGlzc3VlLlxuICogQHBhcmFtIHNlbmRUb0xMTSAtIFdoZXRoZXIgdG8gc2VuZCB0aGUgb2JzZXJ2YXRpb24gYW5kIGxsbV9vdXRwdXQgYmFjayB0byBhbiBBZ2VudFxuICogICAgIGFmdGVyIGFuIE91dHB1dFBhcnNlckV4Y2VwdGlvbiBoYXMgYmVlbiByYWlzZWQuIFRoaXMgZ2l2ZXMgdGhlIHVuZGVybHlpbmdcbiAqICAgICBtb2RlbCBkcml2aW5nIHRoZSBhZ2VudCB0aGUgY29udGV4dCB0aGF0IHRoZSBwcmV2aW91cyBvdXRwdXQgd2FzIGltcHJvcGVybHlcbiAqICAgICBzdHJ1Y3R1cmVkLCBpbiB0aGUgaG9wZXMgdGhhdCBpdCB3aWxsIHVwZGF0ZSB0aGUgb3V0cHV0IHRvIHRoZSBjb3JyZWN0XG4gKiAgICAgZm9ybWF0LlxuICovXG5leHBvcnQgY2xhc3MgT3V0cHV0UGFyc2VyRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGxsbU91dHB1dCwgb2JzZXJ2YXRpb24sIHNlbmRUb0xMTSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsbG1PdXRwdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JzZXJ2YXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VuZFRvTExNXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGxtT3V0cHV0ID0gbGxtT3V0cHV0O1xuICAgICAgICB0aGlzLm9ic2VydmF0aW9uID0gb2JzZXJ2YXRpb247XG4gICAgICAgIHRoaXMuc2VuZFRvTExNID0gc2VuZFRvTExNO1xuICAgICAgICBpZiAoc2VuZFRvTExNKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24gPT09IHVuZGVmaW5lZCB8fCBsbG1PdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50cyAnb2JzZXJ2YXRpb24nICYgJ2xsbU91dHB1dCcgYXJlIHJlcXVpcmVkIGlmICdzZW5kVG9MbG0nIGlzIHRydWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkTGFuZ0NoYWluRXJyb3JGaWVsZHModGhpcywgXCJPVVRQVVRfUEFSU0lOR19GQUlMVVJFXCIpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/bytes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/bytes.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesOutputParser: () => (/* binding */ BytesOutputParser)\n/* harmony export */ });\n/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.js\");\n\n/**\n * OutputParser that parses LLMResult into the top likely string and\n * encodes it into bytes.\n */\nclass BytesOutputParser extends _transform_js__WEBPACK_IMPORTED_MODULE_0__.BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"bytes\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"textEncoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new TextEncoder()\n        });\n    }\n    static lc_name() {\n        return \"BytesOutputParser\";\n    }\n    parse(text) {\n        return Promise.resolve(this.textEncoder.encode(text));\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvYnl0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0Msb0VBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG91dHB1dF9wYXJzZXJzXFxieXRlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIH0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG4vKipcbiAqIE91dHB1dFBhcnNlciB0aGF0IHBhcnNlcyBMTE1SZXN1bHQgaW50byB0aGUgdG9wIGxpa2VseSBzdHJpbmcgYW5kXG4gKiBlbmNvZGVzIGl0IGludG8gYnl0ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc091dHB1dFBhcnNlciBleHRlbmRzIEJhc2VUcmFuc2Zvcm1PdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwib3V0cHV0X3BhcnNlcnNcIiwgXCJieXRlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXh0RW5jb2RlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRleHRFbmNvZGVyKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJCeXRlc091dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodGV4dCkpO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/bytes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsymmetricStructuredOutputParser: () => (/* reexport safe */ _structured_js__WEBPACK_IMPORTED_MODULE_4__.AsymmetricStructuredOutputParser),\n/* harmony export */   BaseCumulativeTransformOutputParser: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_5__.BaseCumulativeTransformOutputParser),\n/* harmony export */   BaseLLMOutputParser: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseLLMOutputParser),\n/* harmony export */   BaseOutputParser: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseOutputParser),\n/* harmony export */   BaseTransformOutputParser: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_5__.BaseTransformOutputParser),\n/* harmony export */   BytesOutputParser: () => (/* reexport safe */ _bytes_js__WEBPACK_IMPORTED_MODULE_1__.BytesOutputParser),\n/* harmony export */   CommaSeparatedListOutputParser: () => (/* reexport safe */ _list_js__WEBPACK_IMPORTED_MODULE_2__.CommaSeparatedListOutputParser),\n/* harmony export */   CustomListOutputParser: () => (/* reexport safe */ _list_js__WEBPACK_IMPORTED_MODULE_2__.CustomListOutputParser),\n/* harmony export */   JsonMarkdownStructuredOutputParser: () => (/* reexport safe */ _structured_js__WEBPACK_IMPORTED_MODULE_4__.JsonMarkdownStructuredOutputParser),\n/* harmony export */   JsonOutputParser: () => (/* reexport safe */ _json_js__WEBPACK_IMPORTED_MODULE_6__.JsonOutputParser),\n/* harmony export */   ListOutputParser: () => (/* reexport safe */ _list_js__WEBPACK_IMPORTED_MODULE_2__.ListOutputParser),\n/* harmony export */   MarkdownListOutputParser: () => (/* reexport safe */ _list_js__WEBPACK_IMPORTED_MODULE_2__.MarkdownListOutputParser),\n/* harmony export */   NumberedListOutputParser: () => (/* reexport safe */ _list_js__WEBPACK_IMPORTED_MODULE_2__.NumberedListOutputParser),\n/* harmony export */   OutputParserException: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.OutputParserException),\n/* harmony export */   StringOutputParser: () => (/* reexport safe */ _string_js__WEBPACK_IMPORTED_MODULE_3__.StringOutputParser),\n/* harmony export */   StructuredOutputParser: () => (/* reexport safe */ _structured_js__WEBPACK_IMPORTED_MODULE_4__.StructuredOutputParser),\n/* harmony export */   XMLOutputParser: () => (/* reexport safe */ _xml_js__WEBPACK_IMPORTED_MODULE_7__.XMLOutputParser),\n/* harmony export */   XML_FORMAT_INSTRUCTIONS: () => (/* reexport safe */ _xml_js__WEBPACK_IMPORTED_MODULE_7__.XML_FORMAT_INSTRUCTIONS),\n/* harmony export */   parseJsonMarkdown: () => (/* reexport safe */ _json_js__WEBPACK_IMPORTED_MODULE_6__.parseJsonMarkdown),\n/* harmony export */   parsePartialJson: () => (/* reexport safe */ _json_js__WEBPACK_IMPORTED_MODULE_6__.parsePartialJson),\n/* harmony export */   parseXMLMarkdown: () => (/* reexport safe */ _xml_js__WEBPACK_IMPORTED_MODULE_7__.parseXMLMarkdown)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytes.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/bytes.js\");\n/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./list.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/list.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/string.js\");\n/* harmony import */ var _structured_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./structured.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/structured.js\");\n/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transform.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.js\");\n/* harmony import */ var _json_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./json.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.js\");\n/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./xml.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/xml.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDQztBQUNEO0FBQ0U7QUFDSTtBQUNEO0FBQ0w7QUFDRCIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxvdXRwdXRfcGFyc2Vyc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vYmFzZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vYnl0ZXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpc3QuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N0cmluZy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3RydWN0dXJlZC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9qc29uLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi94bWwuanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.js":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/json.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonOutputParser: () => (/* binding */ JsonOutputParser),\n/* harmony export */   parseJsonMarkdown: () => (/* reexport safe */ _utils_json_js__WEBPACK_IMPORTED_MODULE_2__.parseJsonMarkdown),\n/* harmony export */   parsePartialJson: () => (/* reexport safe */ _utils_json_js__WEBPACK_IMPORTED_MODULE_2__.parsePartialJson)\n/* harmony export */ });\n/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.js\");\n/* harmony import */ var _utils_json_patch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/json_patch.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.js\");\n/* harmony import */ var _utils_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/json.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json.js\");\n\n\n\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nclass JsonOutputParser extends _transform_js__WEBPACK_IMPORTED_MODULE_0__.BaseCumulativeTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"JsonOutputParser\";\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        if (this.diff) {\n            return super._concatOutputChunks(first, second);\n        }\n        return second;\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return (0,_utils_json_patch_js__WEBPACK_IMPORTED_MODULE_1__.compare)(prev, next);\n    }\n    // This should actually return Partial<T>, but there's no way\n    // to specify emitted chunks as instances separate from the main output type.\n    async parsePartialResult(generations) {\n        return (0,_utils_json_js__WEBPACK_IMPORTED_MODULE_2__.parseJsonMarkdown)(generations[0].text);\n    }\n    async parse(text) {\n        return (0,_utils_json_js__WEBPACK_IMPORTED_MODULE_2__.parseJsonMarkdown)(text, JSON.parse);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUU7QUFDcEI7QUFDc0I7QUFDdkU7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDhFQUFtQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBLGVBQWUsNkRBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFpQjtBQUNoQztBQUNBO0FBQ0EsZUFBZSxpRUFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQyIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxvdXRwdXRfcGFyc2Vyc1xcanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ3VtdWxhdGl2ZVRyYW5zZm9ybU91dHB1dFBhcnNlciB9IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuaW1wb3J0IHsgY29tcGFyZSB9IGZyb20gXCIuLi91dGlscy9qc29uX3BhdGNoLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUpzb25NYXJrZG93biwgcGFyc2VQYXJ0aWFsSnNvbiB9IGZyb20gXCIuLi91dGlscy9qc29uLmpzXCI7XG4vKipcbiAqIENsYXNzIGZvciBwYXJzaW5nIHRoZSBvdXRwdXQgb2YgYW4gTExNIGludG8gYSBKU09OIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25PdXRwdXRQYXJzZXIgZXh0ZW5kcyBCYXNlQ3VtdWxhdGl2ZVRyYW5zZm9ybU91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJvdXRwdXRfcGFyc2Vyc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSnNvbk91dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NvbmNhdE91dHB1dENodW5rcyhmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIGlmICh0aGlzLmRpZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5fY29uY2F0T3V0cHV0Q2h1bmtzKGZpcnN0LCBzZWNvbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWNvbmQ7XG4gICAgfVxuICAgIF9kaWZmKHByZXYsIG5leHQpIHtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgcmV0dXJuIFt7IG9wOiBcInJlcGxhY2VcIiwgcGF0aDogXCJcIiwgdmFsdWU6IG5leHQgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBhcmUocHJldiwgbmV4dCk7XG4gICAgfVxuICAgIC8vIFRoaXMgc2hvdWxkIGFjdHVhbGx5IHJldHVybiBQYXJ0aWFsPFQ+LCBidXQgdGhlcmUncyBubyB3YXlcbiAgICAvLyB0byBzcGVjaWZ5IGVtaXR0ZWQgY2h1bmtzIGFzIGluc3RhbmNlcyBzZXBhcmF0ZSBmcm9tIHRoZSBtYWluIG91dHB1dCB0eXBlLlxuICAgIGFzeW5jIHBhcnNlUGFydGlhbFJlc3VsdChnZW5lcmF0aW9ucykge1xuICAgICAgICByZXR1cm4gcGFyc2VKc29uTWFya2Rvd24oZ2VuZXJhdGlvbnNbMF0udGV4dCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSnNvbk1hcmtkb3duKHRleHQsIEpTT04ucGFyc2UpO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn1cbmV4cG9ydCB7IHBhcnNlUGFydGlhbEpzb24sIHBhcnNlSnNvbk1hcmtkb3duIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/list.js":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/list.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommaSeparatedListOutputParser: () => (/* binding */ CommaSeparatedListOutputParser),\n/* harmony export */   CustomListOutputParser: () => (/* binding */ CustomListOutputParser),\n/* harmony export */   ListOutputParser: () => (/* binding */ ListOutputParser),\n/* harmony export */   MarkdownListOutputParser: () => (/* binding */ MarkdownListOutputParser),\n/* harmony export */   NumberedListOutputParser: () => (/* binding */ NumberedListOutputParser)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.js\");\n/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.js\");\n\n\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nclass ListOutputParser extends _transform_js__WEBPACK_IMPORTED_MODULE_1__.BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async *_transform(inputGenerator) {\n        let buffer = \"\";\n        for await (const input of inputGenerator) {\n            if (typeof input === \"string\") {\n                // add current chunk to buffer\n                buffer += input;\n            }\n            else {\n                // extract message content and add to buffer\n                buffer += input.content;\n            }\n            // get parts in buffer\n            if (!this.re) {\n                const parts = await this.parse(buffer);\n                if (parts.length > 1) {\n                    // if there are multiple parts, yield all but the last one\n                    for (const part of parts.slice(0, -1)) {\n                        yield [part];\n                    }\n                    // keep the last part in the buffer\n                    buffer = parts[parts.length - 1];\n                }\n            }\n            else {\n                // if there is a regex, get all matches\n                const matches = [...buffer.matchAll(this.re)];\n                if (matches.length > 1) {\n                    let doneIdx = 0;\n                    // if there are multiple matches, yield all but the last one\n                    for (const match of matches.slice(0, -1)) {\n                        yield [match[1]];\n                        doneIdx += (match.index ?? 0) + match[0].length;\n                    }\n                    // keep the last match in the buffer\n                    buffer = buffer.slice(doneIdx);\n                }\n            }\n        }\n        // yield the last part\n        for (const part of await this.parse(buffer)) {\n            yield [part];\n        }\n    }\n}\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nclass CommaSeparatedListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"CommaSeparatedListOutputParser\";\n    }\n    /**\n     * Parses the given text into an array of strings, using a comma as the\n     * separator. If the parsing fails, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each comma.\n     */\n    async parse(text) {\n        try {\n            return text\n                .trim()\n                .split(\",\")\n                .map((s) => s.trim());\n        }\n        catch (e) {\n            throw new _base_js__WEBPACK_IMPORTED_MODULE_0__.OutputParserException(`Could not parse output: ${text}`, text);\n        }\n    }\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CommaSeparatedListOutputParser.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions() {\n        return `Your response should be a list of comma separated values, eg: \\`foo, bar, baz\\``;\n    }\n}\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nclass CustomListOutputParser extends ListOutputParser {\n    constructor({ length, separator }) {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"length\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"separator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.length = length;\n        this.separator = separator || \",\";\n    }\n    /**\n     * Parses the given text into an array of strings, using the specified\n     * separator. If the parsing fails or the number of items in the list\n     * doesn't match the expected length, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n     */\n    async parse(text) {\n        try {\n            const items = text\n                .trim()\n                .split(this.separator)\n                .map((s) => s.trim());\n            if (this.length !== undefined && items.length !== this.length) {\n                throw new _base_js__WEBPACK_IMPORTED_MODULE_0__.OutputParserException(`Incorrect number of items. Expected ${this.length}, got ${items.length}.`);\n            }\n            return items;\n        }\n        catch (e) {\n            if (Object.getPrototypeOf(e) === _base_js__WEBPACK_IMPORTED_MODULE_0__.OutputParserException.prototype) {\n                throw e;\n            }\n            throw new _base_js__WEBPACK_IMPORTED_MODULE_0__.OutputParserException(`Could not parse output: ${text}`);\n        }\n    }\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CustomListOutputParser, including the number of items and the\n     * separator.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions() {\n        return `Your response should be a list of ${this.length === undefined ? \"\" : `${this.length} `}items separated by \"${this.separator}\" (eg: \\`foo${this.separator} bar${this.separator} baz\\`)`;\n    }\n}\nclass NumberedListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: /\\d+\\.\\s([^\\n]+)/g\n        });\n    }\n    static lc_name() {\n        return \"NumberedListOutputParser\";\n    }\n    getFormatInstructions() {\n        return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n    }\n    async parse(text) {\n        return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n    }\n}\nclass MarkdownListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: /^\\s*[-*]\\s([^\\n]+)$/gm\n        });\n    }\n    static lc_name() {\n        return \"NumberedListOutputParser\";\n    }\n    getFormatInstructions() {\n        return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n    }\n    async parse(text) {\n        return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvbGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWtEO0FBQ1M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0Isb0VBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBcUIsNEJBQTRCLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBcUIsd0NBQXdDLFlBQVksUUFBUSxhQUFhO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDJEQUFxQjtBQUNsRTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFxQiw0QkFBNEIsS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsb0NBQW9DLGFBQWEsRUFBRSxzQkFBc0IsZUFBZSxjQUFjLGdCQUFnQixLQUFLLGdCQUFnQjtBQUMvTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcb3V0cHV0X3BhcnNlcnNcXGxpc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3V0cHV0UGFyc2VyRXhjZXB0aW9uIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlciB9IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuLyoqXG4gKiBDbGFzcyB0byBwYXJzZSB0aGUgb3V0cHV0IG9mIGFuIExMTSBjYWxsIHRvIGEgbGlzdC5cbiAqIEBhdWdtZW50cyBCYXNlT3V0cHV0UGFyc2VyXG4gKi9cbmV4cG9ydCBjbGFzcyBMaXN0T3V0cHV0UGFyc2VyIGV4dGVuZHMgQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGlucHV0R2VuZXJhdG9yKSB7XG4gICAgICAgIGxldCBidWZmZXIgPSBcIlwiO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGlucHV0IG9mIGlucHV0R2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGN1cnJlbnQgY2h1bmsgdG8gYnVmZmVyXG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXh0cmFjdCBtZXNzYWdlIGNvbnRlbnQgYW5kIGFkZCB0byBidWZmZXJcbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gaW5wdXQuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdldCBwYXJ0cyBpbiBidWZmZXJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gYXdhaXQgdGhpcy5wYXJzZShidWZmZXIpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBwYXJ0cywgeWllbGQgYWxsIGJ1dCB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzLnNsaWNlKDAsIC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW3BhcnRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlIGxhc3QgcGFydCBpbiB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgcmVnZXgsIGdldCBhbGwgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbLi4uYnVmZmVyLm1hdGNoQWxsKHRoaXMucmUpXTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkb25lSWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1hdGNoZXMsIHlpZWxkIGFsbCBidXQgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcy5zbGljZSgwLCAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFttYXRjaFsxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lSWR4ICs9IChtYXRjaC5pbmRleCA/PyAwKSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIHRoZSBsYXN0IG1hdGNoIGluIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGRvbmVJZHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB5aWVsZCB0aGUgbGFzdCBwYXJ0XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBhd2FpdCB0aGlzLnBhcnNlKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHlpZWxkIFtwYXJ0XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgdG8gcGFyc2UgdGhlIG91dHB1dCBvZiBhbiBMTE0gY2FsbCBhcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0LlxuICogQGF1Z21lbnRzIExpc3RPdXRwdXRQYXJzZXJcbiAqL1xuZXhwb3J0IGNsYXNzIENvbW1hU2VwYXJhdGVkTGlzdE91dHB1dFBhcnNlciBleHRlbmRzIExpc3RPdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwib3V0cHV0X3BhcnNlcnNcIiwgXCJsaXN0XCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJDb21tYVNlcGFyYXRlZExpc3RPdXRwdXRQYXJzZXJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncywgdXNpbmcgYSBjb21tYSBhcyB0aGVcbiAgICAgKiBzZXBhcmF0b3IuIElmIHRoZSBwYXJzaW5nIGZhaWxzLCB0aHJvd3MgYW4gT3V0cHV0UGFyc2VyRXhjZXB0aW9uLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIHBhcnNlLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0cmluZ3Mgb2J0YWluZWQgYnkgc3BsaXR0aW5nIHRoZSBpbnB1dCB0ZXh0IGF0IGVhY2ggY29tbWEuXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2UodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRcbiAgICAgICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgICAgICAgIC5tYXAoKHMpID0+IHMudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE91dHB1dFBhcnNlckV4Y2VwdGlvbihgQ291bGQgbm90IHBhcnNlIG91dHB1dDogJHt0ZXh0fWAsIHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGluc3RydWN0aW9ucyBvbiB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIHRoZSByZXNwb25zZSBmb3IgdGhlXG4gICAgICogQ29tbWFTZXBhcmF0ZWRMaXN0T3V0cHV0UGFyc2VyLlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgaW5zdHJ1Y3Rpb25zIG9uIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIGBZb3VyIHJlc3BvbnNlIHNob3VsZCBiZSBhIGxpc3Qgb2YgY29tbWEgc2VwYXJhdGVkIHZhbHVlcywgZWc6IFxcYGZvbywgYmFyLCBiYXpcXGBgO1xuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgdG8gcGFyc2UgdGhlIG91dHB1dCBvZiBhbiBMTE0gY2FsbCB0byBhIGxpc3Qgd2l0aCBhIHNwZWNpZmljIGxlbmd0aCBhbmQgc2VwYXJhdG9yLlxuICogQGF1Z21lbnRzIExpc3RPdXRwdXRQYXJzZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEN1c3RvbUxpc3RPdXRwdXRQYXJzZXIgZXh0ZW5kcyBMaXN0T3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGxlbmd0aCwgc2VwYXJhdG9yIH0pIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm91dHB1dF9wYXJzZXJzXCIsIFwibGlzdFwiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcGFyYXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgXCIsXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gdGV4dCBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MsIHVzaW5nIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBzZXBhcmF0b3IuIElmIHRoZSBwYXJzaW5nIGZhaWxzIG9yIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgICAgKiBkb2Vzbid0IG1hdGNoIHRoZSBleHBlY3RlZCBsZW5ndGgsIHRocm93cyBhbiBPdXRwdXRQYXJzZXJFeGNlcHRpb24uXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncyBvYnRhaW5lZCBieSBzcGxpdHRpbmcgdGhlIGlucHV0IHRleHQgYXQgZWFjaCBvY2N1cnJlbmNlIG9mIHRoZSBzcGVjaWZpZWQgc2VwYXJhdG9yLlxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdGV4dFxuICAgICAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgICAgICAuc3BsaXQodGhpcy5zZXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgLm1hcCgocykgPT4gcy50cmltKCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgaXRlbXMubGVuZ3RoICE9PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPdXRwdXRQYXJzZXJFeGNlcHRpb24oYEluY29ycmVjdCBudW1iZXIgb2YgaXRlbXMuIEV4cGVjdGVkICR7dGhpcy5sZW5ndGh9LCBnb3QgJHtpdGVtcy5sZW5ndGh9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpID09PSBPdXRwdXRQYXJzZXJFeGNlcHRpb24ucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBPdXRwdXRQYXJzZXJFeGNlcHRpb24oYENvdWxkIG5vdCBwYXJzZSBvdXRwdXQ6ICR7dGV4dH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBpbnN0cnVjdGlvbnMgb24gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgcmVzcG9uc2UgZm9yIHRoZVxuICAgICAqIEN1c3RvbUxpc3RPdXRwdXRQYXJzZXIsIGluY2x1ZGluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGFuZCB0aGVcbiAgICAgKiBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyBpbnN0cnVjdGlvbnMgb24gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gYFlvdXIgcmVzcG9uc2Ugc2hvdWxkIGJlIGEgbGlzdCBvZiAke3RoaXMubGVuZ3RoID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCR7dGhpcy5sZW5ndGh9IGB9aXRlbXMgc2VwYXJhdGVkIGJ5IFwiJHt0aGlzLnNlcGFyYXRvcn1cIiAoZWc6IFxcYGZvbyR7dGhpcy5zZXBhcmF0b3J9IGJhciR7dGhpcy5zZXBhcmF0b3J9IGJhelxcYClgO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOdW1iZXJlZExpc3RPdXRwdXRQYXJzZXIgZXh0ZW5kcyBMaXN0T3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm91dHB1dF9wYXJzZXJzXCIsIFwibGlzdFwiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogL1xcZCtcXC5cXHMoW15cXG5dKykvZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIk51bWJlcmVkTGlzdE91dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBgWW91ciByZXNwb25zZSBzaG91bGQgYmUgYSBudW1iZXJlZCBsaXN0IHdpdGggZWFjaCBpdGVtIG9uIGEgbmV3IGxpbmUuIEZvciBleGFtcGxlOiBcXG5cXG4xLiBmb29cXG5cXG4yLiBiYXJcXG5cXG4zLiBiYXpgO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBbLi4uKHRleHQubWF0Y2hBbGwodGhpcy5yZSkgPz8gW10pXS5tYXAoKG0pID0+IG1bMV0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNYXJrZG93bkxpc3RPdXRwdXRQYXJzZXIgZXh0ZW5kcyBMaXN0T3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm91dHB1dF9wYXJzZXJzXCIsIFwibGlzdFwiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogL15cXHMqWy0qXVxccyhbXlxcbl0rKSQvZ21cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJOdW1iZXJlZExpc3RPdXRwdXRQYXJzZXJcIjtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gYFlvdXIgcmVzcG9uc2Ugc2hvdWxkIGJlIGEgbnVtYmVyZWQgbGlzdCB3aXRoIGVhY2ggaXRlbSBvbiBhIG5ldyBsaW5lLiBGb3IgZXhhbXBsZTogXFxuXFxuMS4gZm9vXFxuXFxuMi4gYmFyXFxuXFxuMy4gYmF6YDtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UodGV4dCkge1xuICAgICAgICByZXR1cm4gWy4uLih0ZXh0Lm1hdGNoQWxsKHRoaXMucmUpID8/IFtdKV0ubWFwKChtKSA9PiBtWzFdKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/list.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/string.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/string.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringOutputParser: () => (/* binding */ StringOutputParser)\n/* harmony export */ });\n/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.js\");\n\n/**\n * OutputParser that parses LLMResult into the top likely string.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n *\n * const chain = RunnableSequence.from([\n *   promptTemplate,\n *   new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   new StringOutputParser(),\n * ]);\n *\n * const result = await chain.invoke({ topic: \"bears\" });\n * console.log(\"What do you call a bear with no teeth? A gummy bear!\");\n * ```\n */\nclass StringOutputParser extends _transform_js__WEBPACK_IMPORTED_MODULE_0__.BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"string\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"StrOutputParser\";\n    }\n    /**\n     * Parses a string output from an LLM call. This method is meant to be\n     * implemented by subclasses to define how a string output from an LLM\n     * should be parsed.\n     * @param text The string output from an LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parse(text) {\n        return Promise.resolve(text);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n    _textContentToString(content) {\n        return content.text;\n    }\n    _imageUrlContentToString(_content) {\n        throw new Error(`Cannot coerce a multimodal \"image_url\" message part into a string.`);\n    }\n    _messageContentComplexToString(content) {\n        switch (content.type) {\n            case \"text\":\n            case \"text_delta\":\n                if (\"text\" in content) {\n                    // Type guard for MessageContentText\n                    return this._textContentToString(content);\n                }\n                break;\n            case \"image_url\":\n                if (\"image_url\" in content) {\n                    // Type guard for MessageContentImageUrl\n                    return this._imageUrlContentToString(content);\n                }\n                break;\n            default:\n                throw new Error(`Cannot coerce \"${content.type}\" message part into a string.`);\n        }\n        throw new Error(`Invalid content type: ${content.type}`);\n    }\n    _baseMessageContentToString(content) {\n        return content.reduce((acc, item) => acc + this._messageContentComplexToString(item), \"\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvc3RyaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsb0VBQXlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcb3V0cHV0X3BhcnNlcnNcXHN0cmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIH0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG4vKipcbiAqIE91dHB1dFBhcnNlciB0aGF0IHBhcnNlcyBMTE1SZXN1bHQgaW50byB0aGUgdG9wIGxpa2VseSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcHJvbXB0VGVtcGxhdGUgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXG4gKiAgIFwiVGVsbCBtZSBhIGpva2UgYWJvdXQge3RvcGljfVwiLFxuICogKTtcbiAqXG4gKiBjb25zdCBjaGFpbiA9IFJ1bm5hYmxlU2VxdWVuY2UuZnJvbShbXG4gKiAgIHByb21wdFRlbXBsYXRlLFxuICogICBuZXcgQ2hhdE9wZW5BSSh7IG1vZGVsOiBcImdwdC00by1taW5pXCIgfSksXG4gKiAgIG5ldyBTdHJpbmdPdXRwdXRQYXJzZXIoKSxcbiAqIF0pO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmludm9rZSh7IHRvcGljOiBcImJlYXJzXCIgfSk7XG4gKiBjb25zb2xlLmxvZyhcIldoYXQgZG8geW91IGNhbGwgYSBiZWFyIHdpdGggbm8gdGVldGg/IEEgZ3VtbXkgYmVhciFcIik7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ091dHB1dFBhcnNlciBleHRlbmRzIEJhc2VUcmFuc2Zvcm1PdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwib3V0cHV0X3BhcnNlcnNcIiwgXCJzdHJpbmdcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN0ck91dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzdHJpbmcgb3V0cHV0IGZyb20gYW4gTExNIGNhbGwuIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlXG4gICAgICogaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyB0byBkZWZpbmUgaG93IGEgc3RyaW5nIG91dHB1dCBmcm9tIGFuIExMTVxuICAgICAqIHNob3VsZCBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHN0cmluZyBvdXRwdXQgZnJvbSBhbiBMTE0gY2FsbC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIE9wdGlvbmFsIGNhbGxiYWNrcy5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2Ugb2YgdGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgcGFyc2UodGV4dCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRleHQpO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBfdGV4dENvbnRlbnRUb1N0cmluZyhjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50LnRleHQ7XG4gICAgfVxuICAgIF9pbWFnZVVybENvbnRlbnRUb1N0cmluZyhfY29udGVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb2VyY2UgYSBtdWx0aW1vZGFsIFwiaW1hZ2VfdXJsXCIgbWVzc2FnZSBwYXJ0IGludG8gYSBzdHJpbmcuYCk7XG4gICAgfVxuICAgIF9tZXNzYWdlQ29udGVudENvbXBsZXhUb1N0cmluZyhjb250ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoY29udGVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgY2FzZSBcInRleHRfZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJ0ZXh0XCIgaW4gY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUeXBlIGd1YXJkIGZvciBNZXNzYWdlQ29udGVudFRleHRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRDb250ZW50VG9TdHJpbmcoY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImltYWdlX3VybFwiOlxuICAgICAgICAgICAgICAgIGlmIChcImltYWdlX3VybFwiIGluIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHlwZSBndWFyZCBmb3IgTWVzc2FnZUNvbnRlbnRJbWFnZVVybFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VVcmxDb250ZW50VG9TdHJpbmcoY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb2VyY2UgXCIke2NvbnRlbnQudHlwZX1cIiBtZXNzYWdlIHBhcnQgaW50byBhIHN0cmluZy5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29udGVudCB0eXBlOiAke2NvbnRlbnQudHlwZX1gKTtcbiAgICB9XG4gICAgX2Jhc2VNZXNzYWdlQ29udGVudFRvU3RyaW5nKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVkdWNlKChhY2MsIGl0ZW0pID0+IGFjYyArIHRoaXMuX21lc3NhZ2VDb250ZW50Q29tcGxleFRvU3RyaW5nKGl0ZW0pLCBcIlwiKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/string.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/structured.js":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/structured.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsymmetricStructuredOutputParser: () => (/* binding */ AsymmetricStructuredOutputParser),\n/* harmony export */   JsonMarkdownStructuredOutputParser: () => (/* binding */ JsonMarkdownStructuredOutputParser),\n/* harmony export */   StructuredOutputParser: () => (/* binding */ StructuredOutputParser)\n/* harmony export */ });\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.js\");\n/* harmony import */ var _utils_types_zod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/types/zod.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.js\");\n/* harmony import */ var _utils_json_schema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/json_schema.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.js\");\n\n\n\n\nclass StructuredOutputParser extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseOutputParser {\n    static lc_name() {\n        return \"StructuredOutputParser\";\n    }\n    toJSON() {\n        return this.toJSONNotImplemented();\n    }\n    constructor(schema) {\n        super(schema);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: schema\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"structured\"]\n        });\n    }\n    /**\n     * Creates a new StructuredOutputParser from a Zod schema.\n     * @param schema The Zod schema which the output should match\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromZodSchema(schema) {\n        return new this(schema);\n    }\n    /**\n     * Creates a new StructuredOutputParser from a set of names and\n     * descriptions.\n     * @param schemas An object where each key is a name and each value is a description\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromNamesAndDescriptions(schemas) {\n        const zodSchema = zod_v3__WEBPACK_IMPORTED_MODULE_3__.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, zod_v3__WEBPACK_IMPORTED_MODULE_3__.string().describe(description)])));\n        return new this(zodSchema);\n    }\n    /**\n     * Returns a markdown code snippet with a JSON object formatted according\n     * to the schema.\n     * @param options Optional. The options for formatting the instructions\n     * @returns A markdown code snippet with a JSON object formatted according to the schema.\n     */\n    getFormatInstructions() {\n        return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify((0,_utils_json_schema_js__WEBPACK_IMPORTED_MODULE_2__.toJsonSchema)(this.schema))}\n\\`\\`\\`\n`;\n    }\n    /**\n     * Parses the given text according to the schema.\n     * @param text The text to parse\n     * @returns The parsed output.\n     */\n    async parse(text) {\n        try {\n            const trimmedText = text.trim();\n            const json = \n            // first case: if back ticks appear at the start of the text\n            trimmedText.match(/^```(?:json)?\\s*([\\s\\S]*?)```/)?.[1] ||\n                // second case: if back ticks with `json` appear anywhere in the text\n                trimmedText.match(/```json\\s*([\\s\\S]*?)```/)?.[1] ||\n                // otherwise, return the trimmed text\n                trimmedText;\n            const escapedJson = json\n                .replace(/\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/g, (_match, capturedGroup) => {\n                const escapedInsideQuotes = capturedGroup.replace(/\\n/g, \"\\\\n\");\n                return `\"${escapedInsideQuotes}\"`;\n            })\n                .replace(/\\n/g, \"\");\n            return await (0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_1__.interopParseAsync)(this.schema, JSON.parse(escapedJson));\n        }\n        catch (e) {\n            throw new _base_js__WEBPACK_IMPORTED_MODULE_0__.OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n        }\n    }\n}\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nclass JsonMarkdownStructuredOutputParser extends StructuredOutputParser {\n    static lc_name() {\n        return \"JsonMarkdownStructuredOutputParser\";\n    }\n    getFormatInstructions(options) {\n        const interpolationDepth = options?.interpolationDepth ?? 1;\n        if (interpolationDepth < 1) {\n            throw new Error(\"f string interpolation depth must be at least 1\");\n        }\n        return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction((0,_utils_json_schema_js__WEBPACK_IMPORTED_MODULE_2__.toJsonSchema)(this.schema))\n            .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n            .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n    }\n    _schemaToInstruction(schemaInput, indent = 2) {\n        const schema = schemaInput;\n        if (\"type\" in schema) {\n            let nullable = false;\n            let type;\n            if (Array.isArray(schema.type)) {\n                const nullIdx = schema.type.findIndex((type) => type === \"null\");\n                if (nullIdx !== -1) {\n                    nullable = true;\n                    schema.type.splice(nullIdx, 1);\n                }\n                type = schema.type.join(\" | \");\n            }\n            else {\n                type = schema.type;\n            }\n            if (schema.type === \"object\" && schema.properties) {\n                const description = schema.description\n                    ? ` // ${schema.description}`\n                    : \"\";\n                const properties = Object.entries(schema.properties)\n                    .map(([key, value]) => {\n                    const isOptional = schema.required?.includes(key)\n                        ? \"\"\n                        : \" (optional)\";\n                    return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;\n                })\n                    .join(\"\\n\");\n                return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n            }\n            if (schema.type === \"array\" && schema.items) {\n                const description = schema.description\n                    ? ` // ${schema.description}`\n                    : \"\";\n                return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}\\n${\" \".repeat(indent - 2)}] ${description}`;\n            }\n            const isNullable = nullable ? \" (nullable)\" : \"\";\n            const description = schema.description ? ` // ${schema.description}` : \"\";\n            return `${type}${description}${isNullable}`;\n        }\n        if (\"anyOf\" in schema) {\n            return schema.anyOf\n                .map((s) => this._schemaToInstruction(s, indent))\n                .join(`\\n${\" \".repeat(indent - 2)}`);\n        }\n        throw new Error(\"unsupported schema type\");\n    }\n    static fromZodSchema(schema) {\n        return new this(schema);\n    }\n    static fromNamesAndDescriptions(schemas) {\n        const zodSchema = zod_v3__WEBPACK_IMPORTED_MODULE_3__.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, zod_v3__WEBPACK_IMPORTED_MODULE_3__.string().describe(description)])));\n        return new this(zodSchema);\n    }\n}\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nclass AsymmetricStructuredOutputParser extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseOutputParser {\n    constructor({ inputSchema }) {\n        super(...arguments);\n        Object.defineProperty(this, \"structuredInputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);\n    }\n    async parse(text) {\n        let parsedInput;\n        try {\n            parsedInput = await this.structuredInputParser.parse(text);\n        }\n        catch (e) {\n            throw new _base_js__WEBPACK_IMPORTED_MODULE_0__.OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n        }\n        return this.outputProcessor(parsedInput);\n    }\n    getFormatInstructions() {\n        return this.structuredInputParser.getFormatInstructions();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvc3RydWN0dXJlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTJCO0FBQzBDO0FBQ1Y7QUFDSDtBQUNqRCxxQ0FBcUMsc0RBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQVEsZ0ZBQWdGLDBDQUFRO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtEQUFrRCxnQkFBZ0IsU0FBUyxtRUFBbUUsc0JBQXNCO0FBQ3BLO0FBQ0EsbUJBQW1CLHdCQUF3Qix5RUFBeUUsZ0JBQWdCLDBCQUEwQjs7QUFFOUo7O0FBRUE7QUFDQTtBQUNBLEVBQUUsZUFBZSxtRUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DLGFBQWE7QUFDYjtBQUNBLHlCQUF5QixzRUFBaUI7QUFDMUM7QUFDQTtBQUNBLHNCQUFzQiwyREFBcUIsNEJBQTRCLEtBQUssWUFBWSxFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLDBCQUEwQixtRUFBWTtBQUMvSSwwQkFBMEIsS0FBSztBQUMvQiwwQkFBMEIsS0FBSyw4QkFBOEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUIsR0FBRyxJQUFJLEtBQUssNkNBQTZDLEVBQUUsV0FBVztBQUN2SCxpQkFBaUI7QUFDakI7QUFDQSx5QkFBeUIsSUFBSSxXQUFXLElBQUksd0JBQXdCLEVBQUUsWUFBWTtBQUNsRjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0Esa0NBQWtDLG1CQUFtQixFQUFFLG9EQUFvRCxJQUFJLHVCQUF1QixJQUFJLFlBQVk7QUFDdEo7QUFDQTtBQUNBLDREQUE0RCxtQkFBbUI7QUFDL0Usc0JBQXNCLEtBQUssRUFBRSxZQUFZLEVBQUUsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQVEsZ0ZBQWdGLDBDQUFRO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0NBQStDLHNEQUFnQjtBQUN0RSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBcUIsNEJBQTRCLEtBQUssWUFBWSxFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG91dHB1dF9wYXJzZXJzXFxzdHJ1Y3R1cmVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHogfSBmcm9tIFwiem9kL3YzXCI7XG5pbXBvcnQgeyBCYXNlT3V0cHV0UGFyc2VyLCBPdXRwdXRQYXJzZXJFeGNlcHRpb24sIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgaW50ZXJvcFBhcnNlQXN5bmMsIH0gZnJvbSBcIi4uL3V0aWxzL3R5cGVzL3pvZC5qc1wiO1xuaW1wb3J0IHsgdG9Kc29uU2NoZW1hLCB9IGZyb20gXCIuLi91dGlscy9qc29uX3NjaGVtYS5qc1wiO1xuZXhwb3J0IGNsYXNzIFN0cnVjdHVyZWRPdXRwdXRQYXJzZXIgZXh0ZW5kcyBCYXNlT3V0cHV0UGFyc2VyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3RydWN0dXJlZE91dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihzY2hlbWEpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2hlbWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHNjaGVtYVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJvdXRwdXRfcGFyc2Vyc1wiLCBcInN0cnVjdHVyZWRcIl1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RydWN0dXJlZE91dHB1dFBhcnNlciBmcm9tIGEgWm9kIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0gc2NoZW1hIFRoZSBab2Qgc2NoZW1hIHdoaWNoIHRoZSBvdXRwdXQgc2hvdWxkIG1hdGNoXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgU3RydWN0dXJlZE91dHB1dFBhcnNlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVpvZFNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RydWN0dXJlZE91dHB1dFBhcnNlciBmcm9tIGEgc2V0IG9mIG5hbWVzIGFuZFxuICAgICAqIGRlc2NyaXB0aW9ucy5cbiAgICAgKiBAcGFyYW0gc2NoZW1hcyBBbiBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYSBuYW1lIGFuZCBlYWNoIHZhbHVlIGlzIGEgZGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTmFtZXNBbmREZXNjcmlwdGlvbnMoc2NoZW1hcykge1xuICAgICAgICBjb25zdCB6b2RTY2hlbWEgPSB6Lm9iamVjdChPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoc2NoZW1hcykubWFwKChbbmFtZSwgZGVzY3JpcHRpb25dKSA9PiBbbmFtZSwgei5zdHJpbmcoKS5kZXNjcmliZShkZXNjcmlwdGlvbildKSkpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoem9kU2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcmtkb3duIGNvZGUgc25pcHBldCB3aXRoIGEgSlNPTiBvYmplY3QgZm9ybWF0dGVkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzY2hlbWEuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwuIFRoZSBvcHRpb25zIGZvciBmb3JtYXR0aW5nIHRoZSBpbnN0cnVjdGlvbnNcbiAgICAgKiBAcmV0dXJucyBBIG1hcmtkb3duIGNvZGUgc25pcHBldCB3aXRoIGEgSlNPTiBvYmplY3QgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc2NoZW1hLlxuICAgICAqL1xuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIGBZb3UgbXVzdCBmb3JtYXQgeW91ciBvdXRwdXQgYXMgYSBKU09OIHZhbHVlIHRoYXQgYWRoZXJlcyB0byBhIGdpdmVuIFwiSlNPTiBTY2hlbWFcIiBpbnN0YW5jZS5cblxuXCJKU09OIFNjaGVtYVwiIGlzIGEgZGVjbGFyYXRpdmUgbGFuZ3VhZ2UgdGhhdCBhbGxvd3MgeW91IHRvIGFubm90YXRlIGFuZCB2YWxpZGF0ZSBKU09OIGRvY3VtZW50cy5cblxuRm9yIGV4YW1wbGUsIHRoZSBleGFtcGxlIFwiSlNPTiBTY2hlbWFcIiBpbnN0YW5jZSB7e1wicHJvcGVydGllc1wiOiB7e1wiZm9vXCI6IHt7XCJkZXNjcmlwdGlvblwiOiBcImEgbGlzdCBvZiB0ZXN0IHdvcmRzXCIsIFwidHlwZVwiOiBcImFycmF5XCIsIFwiaXRlbXNcIjoge3tcInR5cGVcIjogXCJzdHJpbmdcIn19fX19fSwgXCJyZXF1aXJlZFwiOiBbXCJmb29cIl19fVxud291bGQgbWF0Y2ggYW4gb2JqZWN0IHdpdGggb25lIHJlcXVpcmVkIHByb3BlcnR5LCBcImZvb1wiLiBUaGUgXCJ0eXBlXCIgcHJvcGVydHkgc3BlY2lmaWVzIFwiZm9vXCIgbXVzdCBiZSBhbiBcImFycmF5XCIsIGFuZCB0aGUgXCJkZXNjcmlwdGlvblwiIHByb3BlcnR5IHNlbWFudGljYWxseSBkZXNjcmliZXMgaXQgYXMgXCJhIGxpc3Qgb2YgdGVzdCB3b3Jkc1wiLiBUaGUgaXRlbXMgd2l0aGluIFwiZm9vXCIgbXVzdCBiZSBzdHJpbmdzLlxuVGh1cywgdGhlIG9iamVjdCB7e1wiZm9vXCI6IFtcImJhclwiLCBcImJhelwiXX19IGlzIGEgd2VsbC1mb3JtYXR0ZWQgaW5zdGFuY2Ugb2YgdGhpcyBleGFtcGxlIFwiSlNPTiBTY2hlbWFcIi4gVGhlIG9iamVjdCB7e1wicHJvcGVydGllc1wiOiB7e1wiZm9vXCI6IFtcImJhclwiLCBcImJhelwiXX19fX0gaXMgbm90IHdlbGwtZm9ybWF0dGVkLlxuXG5Zb3VyIG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhbmQgdHlwZS1jaGVja2VkIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgc2NoZW1hIGluc3RhbmNlLCBzbyBtYWtlIHN1cmUgYWxsIGZpZWxkcyBpbiB5b3VyIG91dHB1dCBtYXRjaCB0aGUgc2NoZW1hIGV4YWN0bHkgYW5kIHRoZXJlIGFyZSBubyB0cmFpbGluZyBjb21tYXMhXG5cbkhlcmUgaXMgdGhlIEpTT04gU2NoZW1hIGluc3RhbmNlIHlvdXIgb3V0cHV0IG11c3QgYWRoZXJlIHRvLiBJbmNsdWRlIHRoZSBlbmNsb3NpbmcgbWFya2Rvd24gY29kZWJsb2NrOlxuXFxgXFxgXFxganNvblxuJHtKU09OLnN0cmluZ2lmeSh0b0pzb25TY2hlbWEodGhpcy5zY2hlbWEpKX1cblxcYFxcYFxcYFxuYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFjY29yZGluZyB0byB0aGUgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIHBhcnNlXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2UodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBcbiAgICAgICAgICAgIC8vIGZpcnN0IGNhc2U6IGlmIGJhY2sgdGlja3MgYXBwZWFyIGF0IHRoZSBzdGFydCBvZiB0aGUgdGV4dFxuICAgICAgICAgICAgdHJpbW1lZFRleHQubWF0Y2goL15gYGAoPzpqc29uKT9cXHMqKFtcXHNcXFNdKj8pYGBgLyk/LlsxXSB8fFxuICAgICAgICAgICAgICAgIC8vIHNlY29uZCBjYXNlOiBpZiBiYWNrIHRpY2tzIHdpdGggYGpzb25gIGFwcGVhciBhbnl3aGVyZSBpbiB0aGUgdGV4dFxuICAgICAgICAgICAgICAgIHRyaW1tZWRUZXh0Lm1hdGNoKC9gYGBqc29uXFxzKihbXFxzXFxTXSo/KWBgYC8pPy5bMV0gfHxcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgdHJpbW1lZCB0ZXh0XG4gICAgICAgICAgICAgICAgdHJpbW1lZFRleHQ7XG4gICAgICAgICAgICBjb25zdCBlc2NhcGVkSnNvbiA9IGpzb25cbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCIoW15cIlxcXFxdKihcXFxcLlteXCJcXFxcXSopKilcIi9nLCAoX21hdGNoLCBjYXB0dXJlZEdyb3VwKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlZEluc2lkZVF1b3RlcyA9IGNhcHR1cmVkR3JvdXAucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcIiR7ZXNjYXBlZEluc2lkZVF1b3Rlc31cImA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgaW50ZXJvcFBhcnNlQXN5bmModGhpcy5zY2hlbWEsIEpTT04ucGFyc2UoZXNjYXBlZEpzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE91dHB1dFBhcnNlckV4Y2VwdGlvbihgRmFpbGVkIHRvIHBhcnNlLiBUZXh0OiBcIiR7dGV4dH1cIi4gRXJyb3I6ICR7ZX1gLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBzcGVjaWZpYyB0eXBlIG9mIGBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyYCB0aGF0IHBhcnNlcyBKU09OIGRhdGFcbiAqIGZvcm1hdHRlZCBhcyBhIG1hcmtkb3duIGNvZGUgc25pcHBldC5cbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25NYXJrZG93blN0cnVjdHVyZWRPdXRwdXRQYXJzZXIgZXh0ZW5kcyBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSnNvbk1hcmtkb3duU3RydWN0dXJlZE91dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uRGVwdGggPSBvcHRpb25zPy5pbnRlcnBvbGF0aW9uRGVwdGggPz8gMTtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25EZXB0aCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImYgc3RyaW5nIGludGVycG9sYXRpb24gZGVwdGggbXVzdCBiZSBhdCBsZWFzdCAxXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgUmV0dXJuIGEgbWFya2Rvd24gY29kZSBzbmlwcGV0IHdpdGggYSBKU09OIG9iamVjdCBmb3JtYXR0ZWQgdG8gbG9vayBsaWtlOlxcblxcYFxcYFxcYGpzb25cXG4ke3RoaXMuX3NjaGVtYVRvSW5zdHJ1Y3Rpb24odG9Kc29uU2NoZW1hKHRoaXMuc2NoZW1hKSlcbiAgICAgICAgICAgIC5yZXBsYWNlQWxsKFwie1wiLCBcIntcIi5yZXBlYXQoaW50ZXJwb2xhdGlvbkRlcHRoKSlcbiAgICAgICAgICAgIC5yZXBsYWNlQWxsKFwifVwiLCBcIn1cIi5yZXBlYXQoaW50ZXJwb2xhdGlvbkRlcHRoKSl9XFxuXFxgXFxgXFxgYDtcbiAgICB9XG4gICAgX3NjaGVtYVRvSW5zdHJ1Y3Rpb24oc2NoZW1hSW5wdXQsIGluZGVudCA9IDIpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hSW5wdXQ7XG4gICAgICAgIGlmIChcInR5cGVcIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGxldCBudWxsYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBudWxsSWR4ID0gc2NoZW1hLnR5cGUuZmluZEluZGV4KCh0eXBlKSA9PiB0eXBlID09PSBcIm51bGxcIik7XG4gICAgICAgICAgICAgICAgaWYgKG51bGxJZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bGxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLnR5cGUuc3BsaWNlKG51bGxJZHgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eXBlID0gc2NoZW1hLnR5cGUuam9pbihcIiB8IFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc2NoZW1hLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gYCAvLyAke3NjaGVtYS5kZXNjcmlwdGlvbn1gXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc09wdGlvbmFsID0gc2NoZW1hLnJlcXVpcmVkPy5pbmNsdWRlcyhrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCIgKG9wdGlvbmFsKVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7XCIgXCIucmVwZWF0KGluZGVudCl9XCIke2tleX1cIjogJHt0aGlzLl9zY2hlbWFUb0luc3RydWN0aW9uKHZhbHVlLCBpbmRlbnQgKyAyKX0ke2lzT3B0aW9uYWx9YDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYHtcXG4ke3Byb3BlcnRpZXN9XFxuJHtcIiBcIi5yZXBlYXQoaW5kZW50IC0gMil9fSR7ZGVzY3JpcHRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJhcnJheVwiICYmIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc2NoZW1hLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gYCAvLyAke3NjaGVtYS5kZXNjcmlwdGlvbn1gXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYGFycmF5W1xcbiR7XCIgXCIucmVwZWF0KGluZGVudCl9JHt0aGlzLl9zY2hlbWFUb0luc3RydWN0aW9uKHNjaGVtYS5pdGVtcywgaW5kZW50ICsgMil9XFxuJHtcIiBcIi5yZXBlYXQoaW5kZW50IC0gMil9XSAke2Rlc2NyaXB0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc051bGxhYmxlID0gbnVsbGFibGUgPyBcIiAobnVsbGFibGUpXCIgOiBcIlwiO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzY2hlbWEuZGVzY3JpcHRpb24gPyBgIC8vICR7c2NoZW1hLmRlc2NyaXB0aW9ufWAgOiBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIGAke3R5cGV9JHtkZXNjcmlwdGlvbn0ke2lzTnVsbGFibGV9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJhbnlPZlwiIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5hbnlPZlxuICAgICAgICAgICAgICAgIC5tYXAoKHMpID0+IHRoaXMuX3NjaGVtYVRvSW5zdHJ1Y3Rpb24ocywgaW5kZW50KSlcbiAgICAgICAgICAgICAgICAuam9pbihgXFxuJHtcIiBcIi5yZXBlYXQoaW5kZW50IC0gMil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgc2NoZW1hIHR5cGVcIik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tWm9kU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoc2NoZW1hKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21OYW1lc0FuZERlc2NyaXB0aW9ucyhzY2hlbWFzKSB7XG4gICAgICAgIGNvbnN0IHpvZFNjaGVtYSA9IHoub2JqZWN0KE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzY2hlbWFzKS5tYXAoKFtuYW1lLCBkZXNjcmlwdGlvbl0pID0+IFtuYW1lLCB6LnN0cmluZygpLmRlc2NyaWJlKGRlc2NyaXB0aW9uKV0pKSk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh6b2RTY2hlbWEpO1xuICAgIH1cbn1cbi8qKlxuICogQSB0eXBlIG9mIGBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyYCB0aGF0IGhhbmRsZXMgYXN5bW1ldHJpYyBpbnB1dCBhbmRcbiAqIG91dHB1dCBzY2hlbWFzLlxuICovXG5leHBvcnQgY2xhc3MgQXN5bW1ldHJpY1N0cnVjdHVyZWRPdXRwdXRQYXJzZXIgZXh0ZW5kcyBCYXNlT3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGlucHV0U2NoZW1hIH0pIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RydWN0dXJlZElucHV0UGFyc2VyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlZElucHV0UGFyc2VyID0gbmV3IEpzb25NYXJrZG93blN0cnVjdHVyZWRPdXRwdXRQYXJzZXIoaW5wdXRTY2hlbWEpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIGxldCBwYXJzZWRJbnB1dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gYXdhaXQgdGhpcy5zdHJ1Y3R1cmVkSW5wdXRQYXJzZXIucGFyc2UodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPdXRwdXRQYXJzZXJFeGNlcHRpb24oYEZhaWxlZCB0byBwYXJzZS4gVGV4dDogXCIke3RleHR9XCIuIEVycm9yOiAke2V9YCwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0UHJvY2Vzc29yKHBhcnNlZElucHV0KTtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkSW5wdXRQYXJzZXIuZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/structured.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/transform.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCumulativeTransformOutputParser: () => (/* binding */ BaseCumulativeTransformOutputParser),\n/* harmony export */   BaseTransformOutputParser: () => (/* binding */ BaseTransformOutputParser)\n/* harmony export */ });\n/* harmony import */ var _cfworker_json_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/esm/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.js\");\n/* harmony import */ var _messages_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../messages/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.js\");\n/* harmony import */ var _messages_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../messages/utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.js\");\n/* harmony import */ var _outputs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../outputs.js */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.js\");\n\n\n\n\n\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nclass BaseTransformOutputParser extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseOutputParser {\n    async *_transform(inputGenerator) {\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk === \"string\") {\n                yield this.parseResult([{ text: chunk }]);\n            }\n            else {\n                yield this.parseResult([\n                    {\n                        message: chunk,\n                        text: this._baseMessageToString(chunk),\n                    },\n                ]);\n            }\n        }\n    }\n    /**\n     * Transforms an asynchronous generator of input into an asynchronous\n     * generator of parsed output.\n     * @param inputGenerator An asynchronous generator of input.\n     * @param options A configuration object.\n     * @returns An asynchronous generator of parsed output.\n     */\n    async *transform(inputGenerator, options) {\n        yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n            ...options,\n            runType: \"parser\",\n        });\n    }\n}\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nclass BaseCumulativeTransformOutputParser extends BaseTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"diff\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.diff = fields?.diff ?? this.diff;\n    }\n    async *_transform(inputGenerator) {\n        let prevParsed;\n        let accGen;\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n                throw new Error(\"Cannot handle non-string output.\");\n            }\n            let chunkGen;\n            if ((0,_messages_base_js__WEBPACK_IMPORTED_MODULE_2__.isBaseMessageChunk)(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new _outputs_js__WEBPACK_IMPORTED_MODULE_4__.ChatGenerationChunk({\n                    message: chunk,\n                    text: chunk.content,\n                });\n            }\n            else if ((0,_messages_base_js__WEBPACK_IMPORTED_MODULE_2__.isBaseMessage)(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new _outputs_js__WEBPACK_IMPORTED_MODULE_4__.ChatGenerationChunk({\n                    message: (0,_messages_utils_js__WEBPACK_IMPORTED_MODULE_3__.convertToChunk)(chunk),\n                    text: chunk.content,\n                });\n            }\n            else {\n                chunkGen = new _outputs_js__WEBPACK_IMPORTED_MODULE_4__.GenerationChunk({ text: chunk });\n            }\n            if (accGen === undefined) {\n                accGen = chunkGen;\n            }\n            else {\n                accGen = accGen.concat(chunkGen);\n            }\n            const parsed = await this.parsePartialResult([accGen]);\n            if (parsed !== undefined &&\n                parsed !== null &&\n                !(0,_cfworker_json_schema__WEBPACK_IMPORTED_MODULE_0__.deepCompareStrict)(parsed, prevParsed)) {\n                if (this.diff) {\n                    yield this._diff(prevParsed, parsed);\n                }\n                else {\n                    yield parsed;\n                }\n                prevParsed = parsed;\n            }\n        }\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvdHJhbnNmb3JtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDYjtBQUM0QjtBQUNuQjtBQUNnQjtBQUN0RTtBQUNBO0FBQ0E7QUFDTyx3Q0FBd0Msc0RBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQW1CO0FBQ2xEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxxQkFBcUIsZ0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFtQjtBQUNsRCw2QkFBNkIsa0VBQWM7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtCQUErQix3REFBZSxHQUFHLGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0VBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcb3V0cHV0X3BhcnNlcnNcXHRyYW5zZm9ybS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWVwQ29tcGFyZVN0cmljdCB9IGZyb20gXCJAY2Z3b3JrZXIvanNvbi1zY2hlbWFcIjtcbmltcG9ydCB7IEJhc2VPdXRwdXRQYXJzZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBpc0Jhc2VNZXNzYWdlLCBpc0Jhc2VNZXNzYWdlQ2h1bmssIH0gZnJvbSBcIi4uL21lc3NhZ2VzL2Jhc2UuanNcIjtcbmltcG9ydCB7IGNvbnZlcnRUb0NodW5rIH0gZnJvbSBcIi4uL21lc3NhZ2VzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBHZW5lcmF0aW9uQ2h1bmssIENoYXRHZW5lcmF0aW9uQ2h1bmssIH0gZnJvbSBcIi4uL291dHB1dHMuanNcIjtcbi8qKlxuICogQ2xhc3MgdG8gcGFyc2UgdGhlIG91dHB1dCBvZiBhbiBMTE0gY2FsbCB0aGF0IGFsc28gYWxsb3dzIHN0cmVhbWluZyBpbnB1dHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIGV4dGVuZHMgQmFzZU91dHB1dFBhcnNlciB7XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGFyc2VSZXN1bHQoW3sgdGV4dDogY2h1bmsgfV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wYXJzZVJlc3VsdChbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fYmFzZU1lc3NhZ2VUb1N0cmluZyhjaHVuayksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yIG9mIGlucHV0IGludG8gYW4gYXN5bmNocm9ub3VzXG4gICAgICogZ2VuZXJhdG9yIG9mIHBhcnNlZCBvdXRwdXQuXG4gICAgICogQHBhcmFtIGlucHV0R2VuZXJhdG9yIEFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3Igb2YgaW5wdXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBBbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yIG9mIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgKnRyYW5zZm9ybShpbnB1dEdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICB5aWVsZCogdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhpbnB1dEdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBydW5UeXBlOiBcInBhcnNlclwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEEgYmFzZSBjbGFzcyBmb3Igb3V0cHV0IHBhcnNlcnMgdGhhdCBjYW4gaGFuZGxlIHN0cmVhbWluZyBpbnB1dC4gSXRcbiAqIGV4dGVuZHMgdGhlIGBCYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyYCBjbGFzcyBhbmQgcHJvdmlkZXMgYSBtZXRob2QgZm9yXG4gKiBjb252ZXJ0aW5nIHBhcnNlZCBvdXRwdXRzIGludG8gYSBkaWZmIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIGV4dGVuZHMgQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRpZmZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpZmYgPSBmaWVsZHM/LmRpZmYgPz8gdGhpcy5kaWZmO1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICBsZXQgcHJldlBhcnNlZDtcbiAgICAgICAgbGV0IGFjY0dlbjtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgY2h1bmsuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYW5kbGUgbm9uLXN0cmluZyBvdXRwdXQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNodW5rR2VuO1xuICAgICAgICAgICAgaWYgKGlzQmFzZU1lc3NhZ2VDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhbmRsZSBub24tc3RyaW5nIG1lc3NhZ2Ugb3V0cHV0LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2h1bmtHZW4gPSBuZXcgQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay5jb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCYXNlTWVzc2FnZShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhbmRsZSBub24tc3RyaW5nIG1lc3NhZ2Ugb3V0cHV0LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2h1bmtHZW4gPSBuZXcgQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNvbnZlcnRUb0NodW5rKGNodW5rKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsuY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rR2VuID0gbmV3IEdlbmVyYXRpb25DaHVuayh7IHRleHQ6IGNodW5rIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjY0dlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWNjR2VuID0gY2h1bmtHZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2NHZW4gPSBhY2NHZW4uY29uY2F0KGNodW5rR2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHRoaXMucGFyc2VQYXJ0aWFsUmVzdWx0KFthY2NHZW5dKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICFkZWVwQ29tcGFyZVN0cmljdChwYXJzZWQsIHByZXZQYXJzZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlmZikge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9kaWZmKHByZXZQYXJzZWQsIHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/xml.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/xml.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XMLOutputParser: () => (/* binding */ XMLOutputParser),\n/* harmony export */   XML_FORMAT_INSTRUCTIONS: () => (/* binding */ XML_FORMAT_INSTRUCTIONS),\n/* harmony export */   parseXMLMarkdown: () => (/* binding */ parseXMLMarkdown)\n/* harmony export */ });\n/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.js\");\n/* harmony import */ var _utils_json_patch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/json_patch.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.js\");\n/* harmony import */ var _utils_sax_js_sax_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/sax-js/sax.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/sax-js/sax.js\");\n\n\n\nconst XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\nclass XMLOutputParser extends _transform_js__WEBPACK_IMPORTED_MODULE_0__.BaseCumulativeTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.tags = fields?.tags;\n    }\n    static lc_name() {\n        return \"XMLOutputParser\";\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return (0,_utils_json_patch_js__WEBPACK_IMPORTED_MODULE_1__.compare)(prev, next);\n    }\n    async parsePartialResult(generations) {\n        return parseXMLMarkdown(generations[0].text);\n    }\n    async parse(text) {\n        return parseXMLMarkdown(text);\n    }\n    getFormatInstructions() {\n        const withTags = !!(this.tags && this.tags.length > 0);\n        return withTags\n            ? XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n            : XML_FORMAT_INSTRUCTIONS;\n    }\n}\nconst strip = (text) => text\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s+/, \"\"))\n    .join(\"\\n\")\n    .trim();\nconst parseParsedResult = (input) => {\n    if (Object.keys(input).length === 0) {\n        return {};\n    }\n    const result = {};\n    if (input.children.length > 0) {\n        result[input.name] = input.children.map(parseParsedResult);\n        return result;\n    }\n    else {\n        result[input.name] = input.text ?? undefined;\n        return result;\n    }\n};\nfunction parseXMLMarkdown(s) {\n    const cleanedString = strip(s);\n    const parser = _utils_sax_js_sax_js__WEBPACK_IMPORTED_MODULE_2__.sax.parser(true);\n    let parsedResult = {};\n    const elementStack = [];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.onopentag = (node) => {\n        const element = {\n            name: node.name,\n            attributes: node.attributes,\n            children: [],\n            text: \"\",\n            isSelfClosing: node.isSelfClosing,\n        };\n        if (elementStack.length > 0) {\n            const parentElement = elementStack[elementStack.length - 1];\n            parentElement.children.push(element);\n        }\n        else {\n            parsedResult = element;\n        }\n        if (!node.isSelfClosing) {\n            elementStack.push(element);\n        }\n    };\n    parser.onclosetag = () => {\n        if (elementStack.length > 0) {\n            const lastElement = elementStack.pop();\n            if (elementStack.length === 0 && lastElement) {\n                parsedResult = lastElement;\n            }\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.ontext = (text) => {\n        if (elementStack.length > 0) {\n            const currentElement = elementStack[elementStack.length - 1];\n            currentElement.text += text;\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.onattribute = (attr) => {\n        if (elementStack.length > 0) {\n            const currentElement = elementStack[elementStack.length - 1];\n            currentElement.attributes[attr.name] = attr.value;\n        }\n    };\n    // Try to find XML string within triple backticks.\n    const match = /```(xml)?(.*)```/s.exec(cleanedString);\n    const xmlString = match ? match[2] : cleanedString;\n    parser.write(xmlString).close();\n    // Remove the XML declaration if present\n    if (parsedResult && parsedResult.name === \"?xml\") {\n        parsedResult = parsedResult.children[0];\n    }\n    return parseParsedResult(parsedResult);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMveG1sLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFzRTtBQUNyQjtBQUNKO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTyw4QkFBOEIsOEVBQW1DO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQSxlQUFlLDZEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsbUJBQW1CLHFEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxvdXRwdXRfcGFyc2Vyc1xceG1sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyLCB9IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuaW1wb3J0IHsgY29tcGFyZSB9IGZyb20gXCIuLi91dGlscy9qc29uX3BhdGNoLmpzXCI7XG5pbXBvcnQgeyBzYXggfSBmcm9tIFwiLi4vdXRpbHMvc2F4LWpzL3NheC5qc1wiO1xuZXhwb3J0IGNvbnN0IFhNTF9GT1JNQVRfSU5TVFJVQ1RJT05TID0gYFRoZSBvdXRwdXQgc2hvdWxkIGJlIGZvcm1hdHRlZCBhcyBhIFhNTCBmaWxlLlxuMS4gT3V0cHV0IHNob3VsZCBjb25mb3JtIHRvIHRoZSB0YWdzIGJlbG93LiBcbjIuIElmIHRhZ3MgYXJlIG5vdCBnaXZlbiwgbWFrZSB0aGVtIG9uIHlvdXIgb3duLlxuMy4gUmVtZW1iZXIgdG8gYWx3YXlzIG9wZW4gYW5kIGNsb3NlIGFsbCB0aGUgdGFncy5cblxuQXMgYW4gZXhhbXBsZSwgZm9yIHRoZSB0YWdzIFtcImZvb1wiLCBcImJhclwiLCBcImJhelwiXTpcbjEuIFN0cmluZyBcIjxmb28+XFxuICAgPGJhcj5cXG4gICAgICA8YmF6PjwvYmF6PlxcbiAgIDwvYmFyPlxcbjwvZm9vPlwiIGlzIGEgd2VsbC1mb3JtYXR0ZWQgaW5zdGFuY2Ugb2YgdGhlIHNjaGVtYS4gXG4yLiBTdHJpbmcgXCI8Zm9vPlxcbiAgIDxiYXI+XFxuICAgPC9mb28+XCIgaXMgYSBiYWRseS1mb3JtYXR0ZWQgaW5zdGFuY2UuXG4zLiBTdHJpbmcgXCI8Zm9vPlxcbiAgIDx0YWc+XFxuICAgPC90YWc+XFxuPC9mb28+XCIgaXMgYSBiYWRseS1mb3JtYXR0ZWQgaW5zdGFuY2UuXG5cbkhlcmUgYXJlIHRoZSBvdXRwdXQgdGFnczpcblxcYFxcYFxcYFxue3RhZ3N9XG5cXGBcXGBcXGBgO1xuZXhwb3J0IGNsYXNzIFhNTE91dHB1dFBhcnNlciBleHRlbmRzIEJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwib3V0cHV0X3BhcnNlcnNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50YWdzID0gZmllbGRzPy50YWdzO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiWE1MT3V0cHV0UGFyc2VyXCI7XG4gICAgfVxuICAgIF9kaWZmKHByZXYsIG5leHQpIHtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgcmV0dXJuIFt7IG9wOiBcInJlcGxhY2VcIiwgcGF0aDogXCJcIiwgdmFsdWU6IG5leHQgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBhcmUocHJldiwgbmV4dCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlUGFydGlhbFJlc3VsdChnZW5lcmF0aW9ucykge1xuICAgICAgICByZXR1cm4gcGFyc2VYTUxNYXJrZG93bihnZW5lcmF0aW9uc1swXS50ZXh0KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UodGV4dCkge1xuICAgICAgICByZXR1cm4gcGFyc2VYTUxNYXJrZG93bih0ZXh0KTtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICBjb25zdCB3aXRoVGFncyA9ICEhKHRoaXMudGFncyAmJiB0aGlzLnRhZ3MubGVuZ3RoID4gMCk7XG4gICAgICAgIHJldHVybiB3aXRoVGFnc1xuICAgICAgICAgICAgPyBYTUxfRk9STUFUX0lOU1RSVUNUSU9OUy5yZXBsYWNlKFwie3RhZ3N9XCIsIHRoaXMudGFncz8uam9pbihcIiwgXCIpID8/IFwiXCIpXG4gICAgICAgICAgICA6IFhNTF9GT1JNQVRfSU5TVFJVQ1RJT05TO1xuICAgIH1cbn1cbmNvbnN0IHN0cmlwID0gKHRleHQpID0+IHRleHRcbiAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAubWFwKChsaW5lKSA9PiBsaW5lLnJlcGxhY2UoL15cXHMrLywgXCJcIikpXG4gICAgLmpvaW4oXCJcXG5cIilcbiAgICAudHJpbSgpO1xuY29uc3QgcGFyc2VQYXJzZWRSZXN1bHQgPSAoaW5wdXQpID0+IHtcbiAgICBpZiAoT2JqZWN0LmtleXMoaW5wdXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChpbnB1dC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdFtpbnB1dC5uYW1lXSA9IGlucHV0LmNoaWxkcmVuLm1hcChwYXJzZVBhcnNlZFJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHRbaW5wdXQubmFtZV0gPSBpbnB1dC50ZXh0ID8/IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlWE1MTWFya2Rvd24ocykge1xuICAgIGNvbnN0IGNsZWFuZWRTdHJpbmcgPSBzdHJpcChzKTtcbiAgICBjb25zdCBwYXJzZXIgPSBzYXgucGFyc2VyKHRydWUpO1xuICAgIGxldCBwYXJzZWRSZXN1bHQgPSB7fTtcbiAgICBjb25zdCBlbGVtZW50U3RhY2sgPSBbXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHBhcnNlci5vbm9wZW50YWcgPSAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0ge1xuICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlczogbm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIGlzU2VsZkNsb3Npbmc6IG5vZGUuaXNTZWxmQ2xvc2luZyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVsZW1lbnRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gZWxlbWVudFN0YWNrW2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZFJlc3VsdCA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLmlzU2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBwYXJzZXIub25jbG9zZXRhZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0RWxlbWVudCA9IGVsZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50U3RhY2subGVuZ3RoID09PSAwICYmIGxhc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkUmVzdWx0ID0gbGFzdEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcGFyc2VyLm9udGV4dCA9ICh0ZXh0KSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBlbGVtZW50U3RhY2tbZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQudGV4dCArPSB0ZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHBhcnNlci5vbmF0dHJpYnV0ZSA9IChhdHRyKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBlbGVtZW50U3RhY2tbZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQuYXR0cmlidXRlc1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gVHJ5IHRvIGZpbmQgWE1MIHN0cmluZyB3aXRoaW4gdHJpcGxlIGJhY2t0aWNrcy5cbiAgICBjb25zdCBtYXRjaCA9IC9gYGAoeG1sKT8oLiopYGBgL3MuZXhlYyhjbGVhbmVkU3RyaW5nKTtcbiAgICBjb25zdCB4bWxTdHJpbmcgPSBtYXRjaCA/IG1hdGNoWzJdIDogY2xlYW5lZFN0cmluZztcbiAgICBwYXJzZXIud3JpdGUoeG1sU3RyaW5nKS5jbG9zZSgpO1xuICAgIC8vIFJlbW92ZSB0aGUgWE1MIGRlY2xhcmF0aW9uIGlmIHByZXNlbnRcbiAgICBpZiAocGFyc2VkUmVzdWx0ICYmIHBhcnNlZFJlc3VsdC5uYW1lID09PSBcIj94bWxcIikge1xuICAgICAgICBwYXJzZWRSZXN1bHQgPSBwYXJzZWRSZXN1bHQuY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZVBhcnNlZFJlc3VsdChwYXJzZWRSZXN1bHQpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/xml.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/outputs.js":
/*!******************************************************!*\
  !*** ./node_modules/@langchain/core/dist/outputs.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatGenerationChunk: () => (/* binding */ ChatGenerationChunk),\n/* harmony export */   GenerationChunk: () => (/* binding */ GenerationChunk),\n/* harmony export */   RUN_KEY: () => (/* binding */ RUN_KEY)\n/* harmony export */ });\nconst RUN_KEY = \"__run\";\n/**\n * Chunk of a single generation. Used for streaming.\n */\nclass GenerationChunk {\n    constructor(fields) {\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"generationInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.text = fields.text;\n        this.generationInfo = fields.generationInfo;\n    }\n    concat(chunk) {\n        return new GenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n        });\n    }\n}\nclass ChatGenerationChunk extends GenerationChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"message\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.message = fields.message;\n    }\n    concat(chunk) {\n        return new ChatGenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n            message: this.message.concat(chunk.message),\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxvdXRwdXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBSVU5fS0VZID0gXCJfX3J1blwiO1xuLyoqXG4gKiBDaHVuayBvZiBhIHNpbmdsZSBnZW5lcmF0aW9uLiBVc2VkIGZvciBzdHJlYW1pbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBHZW5lcmF0aW9uQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXh0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlbmVyYXRpb25JbmZvXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGV4dCA9IGZpZWxkcy50ZXh0O1xuICAgICAgICB0aGlzLmdlbmVyYXRpb25JbmZvID0gZmllbGRzLmdlbmVyYXRpb25JbmZvO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0ICsgY2h1bmsudGV4dCxcbiAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgICAgICAuLi5jaHVuay5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDaGF0R2VuZXJhdGlvbkNodW5rIGV4dGVuZHMgR2VuZXJhdGlvbkNodW5rIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBmaWVsZHMubWVzc2FnZTtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQgKyBjaHVuay50ZXh0LFxuICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgIC4uLmNodW5rLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZS5jb25jYXQoY2h1bmsubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/outputs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompt_values.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompt_values.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePromptValue: () => (/* binding */ BasePromptValue),\n/* harmony export */   ChatPromptValue: () => (/* binding */ ChatPromptValue),\n/* harmony export */   ImagePromptValue: () => (/* binding */ ImagePromptValue),\n/* harmony export */   StringPromptValue: () => (/* binding */ StringPromptValue)\n/* harmony export */ });\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./load/serializable.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _messages_human_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./messages/human.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.js\");\n/* harmony import */ var _messages_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./messages/utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.js\");\n\n\n\n/**\n * Base PromptValue class. All prompt values should extend this class.\n */\nclass BasePromptValue extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable {\n}\n/**\n * Represents a prompt value as a string. It extends the BasePromptValue\n * class and overrides the toString and toChatMessages methods.\n */\nclass StringPromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"StringPromptValue\";\n    }\n    constructor(value) {\n        super({ value });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.value = value;\n    }\n    toString() {\n        return this.value;\n    }\n    toChatMessages() {\n        return [new _messages_human_js__WEBPACK_IMPORTED_MODULE_1__.HumanMessage(this.value)];\n    }\n}\n/**\n * Class that represents a chat prompt value. It extends the\n * BasePromptValue and includes an array of BaseMessage instances.\n */\nclass ChatPromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"ChatPromptValue\";\n    }\n    constructor(fields) {\n        if (Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { messages: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"messages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.messages = fields.messages;\n    }\n    toString() {\n        return (0,_messages_utils_js__WEBPACK_IMPORTED_MODULE_2__.getBufferString)(this.messages);\n    }\n    toChatMessages() {\n        return this.messages;\n    }\n}\n/**\n * Class that represents an image prompt value. It extends the\n * BasePromptValue and includes an ImageURL instance.\n */\nclass ImagePromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"ImagePromptValue\";\n    }\n    constructor(fields) {\n        if (!(\"imageUrl\" in fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { imageUrl: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"imageUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @ignore */\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.imageUrl = fields.imageUrl;\n    }\n    toString() {\n        return this.imageUrl.url;\n    }\n    toChatMessages() {\n        return [\n            new _messages_human_js__WEBPACK_IMPORTED_MODULE_1__.HumanMessage({\n                content: [\n                    {\n                        type: \"image_url\",\n                        image_url: {\n                            detail: this.imageUrl.detail,\n                            url: this.imageUrl.url,\n                        },\n                    },\n                ],\n            }),\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0X3ZhbHVlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXNEO0FBQ0g7QUFDRztBQUN0RDtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIsK0RBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxwcm9tcHRfdmFsdWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNlcmlhbGl6YWJsZSB9IGZyb20gXCIuL2xvYWQvc2VyaWFsaXphYmxlLmpzXCI7XG5pbXBvcnQgeyBIdW1hbk1lc3NhZ2UgfSBmcm9tIFwiLi9tZXNzYWdlcy9odW1hbi5qc1wiO1xuaW1wb3J0IHsgZ2V0QnVmZmVyU3RyaW5nIH0gZnJvbSBcIi4vbWVzc2FnZXMvdXRpbHMuanNcIjtcbi8qKlxuICogQmFzZSBQcm9tcHRWYWx1ZSBjbGFzcy4gQWxsIHByb21wdCB2YWx1ZXMgc2hvdWxkIGV4dGVuZCB0aGlzIGNsYXNzLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZVByb21wdFZhbHVlIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHByb21wdCB2YWx1ZSBhcyBhIHN0cmluZy4gSXQgZXh0ZW5kcyB0aGUgQmFzZVByb21wdFZhbHVlXG4gKiBjbGFzcyBhbmQgb3ZlcnJpZGVzIHRoZSB0b1N0cmluZyBhbmQgdG9DaGF0TWVzc2FnZXMgbWV0aG9kcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ1Byb21wdFZhbHVlIGV4dGVuZHMgQmFzZVByb21wdFZhbHVlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3RyaW5nUHJvbXB0VmFsdWVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoeyB2YWx1ZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdF92YWx1ZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvQ2hhdE1lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gW25ldyBIdW1hbk1lc3NhZ2UodGhpcy52YWx1ZSldO1xuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgY2hhdCBwcm9tcHQgdmFsdWUuIEl0IGV4dGVuZHMgdGhlXG4gKiBCYXNlUHJvbXB0VmFsdWUgYW5kIGluY2x1ZGVzIGFuIGFycmF5IG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIENoYXRQcm9tcHRWYWx1ZSBleHRlbmRzIEJhc2VQcm9tcHRWYWx1ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRQcm9tcHRWYWx1ZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7IG1lc3NhZ2VzOiBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicHJvbXB0X3ZhbHVlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gZmllbGRzLm1lc3NhZ2VzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1ZmZlclN0cmluZyh0aGlzLm1lc3NhZ2VzKTtcbiAgICB9XG4gICAgdG9DaGF0TWVzc2FnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzO1xuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGFuIGltYWdlIHByb21wdCB2YWx1ZS4gSXQgZXh0ZW5kcyB0aGVcbiAqIEJhc2VQcm9tcHRWYWx1ZSBhbmQgaW5jbHVkZXMgYW4gSW1hZ2VVUkwgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZVByb21wdFZhbHVlIGV4dGVuZHMgQmFzZVByb21wdFZhbHVlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSW1hZ2VQcm9tcHRWYWx1ZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgaWYgKCEoXCJpbWFnZVVybFwiIGluIGZpZWxkcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBpbWFnZVVybDogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdF92YWx1ZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW1hZ2VVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbWFnZVVybCA9IGZpZWxkcy5pbWFnZVVybDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlVXJsLnVybDtcbiAgICB9XG4gICAgdG9DaGF0TWVzc2FnZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgSHVtYW5NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHRoaXMuaW1hZ2VVcmwuZGV0YWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy5pbWFnZVVybC51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompt_values.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/base.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/base.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePromptTemplate: () => (/* binding */ BasePromptTemplate)\n/* harmony export */ });\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\n/**\n * Base class for prompt templates. Exposes a format method that returns a\n * string prompt given a set of input values.\n */\nclass BasePromptTemplate extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    get lc_attributes() {\n        return {\n            partialVariables: undefined, // python doesn't support this yet\n        };\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompts\", this._getPromptType()]\n        });\n        Object.defineProperty(this, \"inputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"partialVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Metadata to be used for tracing.\n         */\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Tags to be used for tracing. */\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { inputVariables } = input;\n        if (inputVariables.includes(\"stop\")) {\n            throw new Error(\"Cannot have an input variable named 'stop', as it is used internally, please rename.\");\n        }\n        Object.assign(this, input);\n    }\n    /**\n     * Merges partial variables and user variables.\n     * @param userVariables The user variables to merge with the partial variables.\n     * @returns A Promise that resolves to an object containing the merged variables.\n     */\n    async mergePartialAndUserVariables(userVariables) {\n        const partialVariables = this.partialVariables ?? {};\n        const partialValues = {};\n        for (const [key, value] of Object.entries(partialVariables)) {\n            if (typeof value === \"string\") {\n                partialValues[key] = value;\n            }\n            else {\n                partialValues[key] = await value();\n            }\n        }\n        const allKwargs = {\n            ...partialValues,\n            ...userVariables,\n        };\n        return allKwargs;\n    }\n    /**\n     * Invokes the prompt template with the given input and options.\n     * @param input The input to invoke the prompt template with.\n     * @param options Optional configuration for the callback.\n     * @returns A Promise that resolves to the output of the prompt template.\n     */\n    async invoke(input, options) {\n        const metadata = {\n            ...this.metadata,\n            ...options?.metadata,\n        };\n        const tags = [...(this.tags ?? []), ...(options?.tags ?? [])];\n        return this._callWithConfig((input) => this.formatPromptValue(input), input, { ...options, tags, metadata, runType: \"prompt\" });\n    }\n    /**\n     * Return a json-like object representing this prompt template.\n     * @deprecated\n     */\n    serialize() {\n        throw new Error(\"Use .toJSON() instead\");\n    }\n    /**\n     * @deprecated\n     * Load a prompt template from a json-like object describing it.\n     *\n     * @remarks\n     * Deserializing needs to be async because templates (e.g. {@link FewShotPromptTemplate}) can\n     * reference remote resources that we read asynchronously with a web\n     * request.\n     */\n    static async deserialize(data) {\n        switch (data._type) {\n            case \"prompt\": {\n                const { PromptTemplate } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./prompt.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/prompt.js\"));\n                return PromptTemplate.deserialize(data);\n            }\n            case undefined: {\n                const { PromptTemplate } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./prompt.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/prompt.js\"));\n                return PromptTemplate.deserialize({ ...data, _type: \"prompt\" });\n            }\n            case \"few_shot\": {\n                const { FewShotPromptTemplate } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./few_shot.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/few_shot.js\"));\n                return FewShotPromptTemplate.deserialize(data);\n            }\n            default:\n                throw new Error(`Invalid prompt type in config: ${data._type}`);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyx3REFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RiwrQ0FBK0M7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsNEJBQTRCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUIsUUFBUSxzS0FBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQixRQUFRLHNLQUFxQjtBQUN0RSxvREFBb0QsMEJBQTBCO0FBQzlFO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCLFFBQVEsMEtBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxwcm9tcHRzXFxiYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERlZmF1bHQgZ2VuZXJpYyBcImFueVwiIHZhbHVlcyBhcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuLy8gUmVwbGFjZSB3aXRoIFwic3RyaW5nXCIgd2hlbiB3ZSBhcmUgY29tZm9ydGFibGUgd2l0aCBhIGJyZWFraW5nIGNoYW5nZS5cbmltcG9ydCB7IFJ1bm5hYmxlIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9iYXNlLmpzXCI7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHByb21wdCB0ZW1wbGF0ZXMuIEV4cG9zZXMgYSBmb3JtYXQgbWV0aG9kIHRoYXQgcmV0dXJucyBhXG4gKiBzdHJpbmcgcHJvbXB0IGdpdmVuIGEgc2V0IG9mIGlucHV0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VQcm9tcHRUZW1wbGF0ZSBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBnZXQgbGNfYXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcnRpYWxWYXJpYWJsZXM6IHVuZGVmaW5lZCwgLy8gcHl0aG9uIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzIHlldFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBzdXBlcihpbnB1dCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdHNcIiwgdGhpcy5fZ2V0UHJvbXB0VHlwZSgpXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRWYXJpYWJsZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3V0cHV0UGFyc2VyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcnRpYWxWYXJpYWJsZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGFkYXRhIHRvIGJlIHVzZWQgZm9yIHRyYWNpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogVGFncyB0byBiZSB1c2VkIGZvciB0cmFjaW5nLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRWYXJpYWJsZXMgfSA9IGlucHV0O1xuICAgICAgICBpZiAoaW5wdXRWYXJpYWJsZXMuaW5jbHVkZXMoXCJzdG9wXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGF2ZSBhbiBpbnB1dCB2YXJpYWJsZSBuYW1lZCAnc3RvcCcsIGFzIGl0IGlzIHVzZWQgaW50ZXJuYWxseSwgcGxlYXNlIHJlbmFtZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbnB1dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBwYXJ0aWFsIHZhcmlhYmxlcyBhbmQgdXNlciB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHVzZXJWYXJpYWJsZXMgVGhlIHVzZXIgdmFyaWFibGVzIHRvIG1lcmdlIHdpdGggdGhlIHBhcnRpYWwgdmFyaWFibGVzLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtZXJnZWQgdmFyaWFibGVzLlxuICAgICAqL1xuICAgIGFzeW5jIG1lcmdlUGFydGlhbEFuZFVzZXJWYXJpYWJsZXModXNlclZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBwYXJ0aWFsVmFyaWFibGVzID0gdGhpcy5wYXJ0aWFsVmFyaWFibGVzID8/IHt9O1xuICAgICAgICBjb25zdCBwYXJ0aWFsVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnRpYWxWYXJpYWJsZXMpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbFZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsVmFsdWVzW2tleV0gPSBhd2FpdCB2YWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbEt3YXJncyA9IHtcbiAgICAgICAgICAgIC4uLnBhcnRpYWxWYWx1ZXMsXG4gICAgICAgICAgICAuLi51c2VyVmFyaWFibGVzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYWxsS3dhcmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBwcm9tcHQgdGVtcGxhdGUgd2l0aCB0aGUgZ2l2ZW4gaW5wdXQgYW5kIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBpbnZva2UgdGhlIHByb21wdCB0ZW1wbGF0ZSB3aXRoLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBwcm9tcHQgdGVtcGxhdGUuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgLi4udGhpcy5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnM/Lm1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0YWdzID0gWy4uLih0aGlzLnRhZ3MgPz8gW10pLCAuLi4ob3B0aW9ucz8udGFncyA/PyBbXSldO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcoKGlucHV0KSA9PiB0aGlzLmZvcm1hdFByb21wdFZhbHVlKGlucHV0KSwgaW5wdXQsIHsgLi4ub3B0aW9ucywgdGFncywgbWV0YWRhdGEsIHJ1blR5cGU6IFwicHJvbXB0XCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGpzb24tbGlrZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgcHJvbXB0IHRlbXBsYXRlLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2UgLnRvSlNPTigpIGluc3RlYWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogTG9hZCBhIHByb21wdCB0ZW1wbGF0ZSBmcm9tIGEganNvbi1saWtlIG9iamVjdCBkZXNjcmliaW5nIGl0LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBEZXNlcmlhbGl6aW5nIG5lZWRzIHRvIGJlIGFzeW5jIGJlY2F1c2UgdGVtcGxhdGVzIChlLmcuIHtAbGluayBGZXdTaG90UHJvbXB0VGVtcGxhdGV9KSBjYW5cbiAgICAgKiByZWZlcmVuY2UgcmVtb3RlIHJlc291cmNlcyB0aGF0IHdlIHJlYWQgYXN5bmNocm9ub3VzbHkgd2l0aCBhIHdlYlxuICAgICAqIHJlcXVlc3QuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgc3dpdGNoIChkYXRhLl90eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwicHJvbXB0XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IFByb21wdFRlbXBsYXRlIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3Byb21wdC5qc1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbXB0VGVtcGxhdGUuZGVzZXJpYWxpemUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgUHJvbXB0VGVtcGxhdGUgfSA9IGF3YWl0IGltcG9ydChcIi4vcHJvbXB0LmpzXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9tcHRUZW1wbGF0ZS5kZXNlcmlhbGl6ZSh7IC4uLmRhdGEsIF90eXBlOiBcInByb21wdFwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZld19zaG90XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IEZld1Nob3RQcm9tcHRUZW1wbGF0ZSB9ID0gYXdhaXQgaW1wb3J0KFwiLi9mZXdfc2hvdC5qc1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRmV3U2hvdFByb21wdFRlbXBsYXRlLmRlc2VyaWFsaXplKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJvbXB0IHR5cGUgaW4gY29uZmlnOiAke2RhdGEuX3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/chat.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/chat.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIMessagePromptTemplate: () => (/* binding */ AIMessagePromptTemplate),\n/* harmony export */   BaseChatPromptTemplate: () => (/* binding */ BaseChatPromptTemplate),\n/* harmony export */   BaseMessagePromptTemplate: () => (/* binding */ BaseMessagePromptTemplate),\n/* harmony export */   BaseMessageStringPromptTemplate: () => (/* binding */ BaseMessageStringPromptTemplate),\n/* harmony export */   ChatMessagePromptTemplate: () => (/* binding */ ChatMessagePromptTemplate),\n/* harmony export */   ChatPromptTemplate: () => (/* binding */ ChatPromptTemplate),\n/* harmony export */   HumanMessagePromptTemplate: () => (/* binding */ HumanMessagePromptTemplate),\n/* harmony export */   MessagesPlaceholder: () => (/* binding */ MessagesPlaceholder),\n/* harmony export */   SystemMessagePromptTemplate: () => (/* binding */ SystemMessagePromptTemplate)\n/* harmony export */ });\n/* harmony import */ var _messages_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../messages/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.js\");\n/* harmony import */ var _prompt_values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../prompt_values.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.js\");\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/string.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/base.js\");\n/* harmony import */ var _prompt_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./prompt.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/prompt.js\");\n/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./image.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/image.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./template.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/template.js\");\n/* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../errors/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/errors/index.js\");\n/* harmony import */ var _dict_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dict.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/dict.js\");\n// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\n\n\n\n\n\n\n\n\n\n/**\n * Abstract class that serves as a base for creating message prompt\n * templates. It defines how to format messages for different roles in a\n * conversation.\n */\nclass BaseMessagePromptTemplate extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_2__.Runnable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompts\", \"chat\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    /**\n     * Calls the formatMessages method with the provided input and options.\n     * @param input Input for the formatMessages method\n     * @param options Optional BaseCallbackConfig\n     * @returns Formatted output messages\n     */\n    async invoke(input, options) {\n        return this._callWithConfig((input) => this.formatMessages(input), input, { ...options, runType: \"prompt\" });\n    }\n}\n/**\n * Class that represents a placeholder for messages in a chat prompt. It\n * extends the BaseMessagePromptTemplate.\n */\nclass MessagesPlaceholder extends BaseMessagePromptTemplate {\n    static lc_name() {\n        return \"MessagesPlaceholder\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            fields = { variableName: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"variableName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"optional\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.variableName = fields.variableName;\n        this.optional = fields.optional ?? false;\n    }\n    get inputVariables() {\n        return [this.variableName];\n    }\n    async formatMessages(values) {\n        const input = values[this.variableName];\n        if (this.optional && !input) {\n            return [];\n        }\n        else if (!input) {\n            const error = new Error(`Field \"${this.variableName}\" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages as an input value. Received: undefined`);\n            error.name = \"InputFormatError\";\n            throw error;\n        }\n        let formattedMessages;\n        try {\n            if (Array.isArray(input)) {\n                formattedMessages = input.map(_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage);\n            }\n            else {\n                formattedMessages = [(0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage)(input)];\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            const readableInput = typeof input === \"string\" ? input : JSON.stringify(input, null, 2);\n            const error = new Error([\n                `Field \"${this.variableName}\" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages or coerceable values as input.`,\n                `Received value: ${readableInput}`,\n                `Additional message: ${e.message}`,\n            ].join(\"\\n\\n\"));\n            error.name = \"InputFormatError\";\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            error.lc_error_code = e.lc_error_code;\n            throw error;\n        }\n        return formattedMessages;\n    }\n}\n/**\n * Abstract class that serves as a base for creating message string prompt\n * templates. It extends the BaseMessagePromptTemplate.\n */\nclass BaseMessageStringPromptTemplate extends BaseMessagePromptTemplate {\n    constructor(fields) {\n        if (!(\"prompt\" in fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { prompt: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"prompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.prompt = fields.prompt;\n    }\n    get inputVariables() {\n        return this.prompt.inputVariables;\n    }\n    async formatMessages(values) {\n        return [await this.format(values)];\n    }\n}\n/**\n * Abstract class that serves as a base for creating chat prompt\n * templates. It extends the BasePromptTemplate.\n */\nclass BaseChatPromptTemplate extends _base_js__WEBPACK_IMPORTED_MODULE_4__.BasePromptTemplate {\n    constructor(input) {\n        super(input);\n    }\n    async format(values) {\n        return (await this.formatPromptValue(values)).toString();\n    }\n    async formatPromptValue(values) {\n        const resultMessages = await this.formatMessages(values);\n        return new _prompt_values_js__WEBPACK_IMPORTED_MODULE_1__.ChatPromptValue(resultMessages);\n    }\n}\n/**\n * Class that represents a chat message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n */\nclass ChatMessagePromptTemplate extends BaseMessageStringPromptTemplate {\n    static lc_name() {\n        return \"ChatMessagePromptTemplate\";\n    }\n    constructor(fields, role) {\n        if (!(\"prompt\" in fields)) {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { prompt: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    async format(values) {\n        return new _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.ChatMessage(await this.prompt.format(values), this.role);\n    }\n    static fromTemplate(template, role, options) {\n        return new this(_prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(template, {\n            templateFormat: options?.templateFormat,\n        }), role);\n    }\n}\nfunction isTextTemplateParam(param) {\n    if (param === null || typeof param !== \"object\" || Array.isArray(param)) {\n        return false;\n    }\n    return (Object.keys(param).length === 1 &&\n        \"text\" in param &&\n        typeof param.text === \"string\");\n}\nfunction isImageTemplateParam(param) {\n    if (param === null || typeof param !== \"object\" || Array.isArray(param)) {\n        return false;\n    }\n    return (\"image_url\" in param &&\n        (typeof param.image_url === \"string\" ||\n            (typeof param.image_url === \"object\" &&\n                param.image_url !== null &&\n                \"url\" in param.image_url &&\n                typeof param.image_url.url === \"string\")));\n}\nclass _StringImageMessagePromptTemplate extends BaseMessagePromptTemplate {\n    static _messageClass() {\n        throw new Error(\"Can not invoke _messageClass from inside _StringImageMessagePromptTemplate\");\n    }\n    constructor(\n    /** @TODO When we come up with a better way to type prompt templates, fix this */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    fields, additionalOptions) {\n        if (!(\"prompt\" in fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { prompt: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompts\", \"chat\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"inputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"additionalOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"prompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"messageClass\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // ChatMessage contains role field, others don't.\n        // Because of this, we have a separate class property for ChatMessage.\n        Object.defineProperty(this, \"chatMessageClass\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.prompt = fields.prompt;\n        if (Array.isArray(this.prompt)) {\n            let inputVariables = [];\n            this.prompt.forEach((prompt) => {\n                if (\"inputVariables\" in prompt) {\n                    inputVariables = inputVariables.concat(prompt.inputVariables);\n                }\n            });\n            this.inputVariables = inputVariables;\n        }\n        else {\n            this.inputVariables = this.prompt.inputVariables;\n        }\n        this.additionalOptions = additionalOptions ?? this.additionalOptions;\n    }\n    createMessage(content) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const constructor = this.constructor;\n        if (constructor._messageClass()) {\n            const MsgClass = constructor._messageClass();\n            return new MsgClass({ content });\n        }\n        else if (constructor.chatMessageClass) {\n            const MsgClass = constructor.chatMessageClass();\n            // Assuming ChatMessage constructor also takes a content argument\n            return new MsgClass({\n                content,\n                role: this.getRoleFromMessageClass(MsgClass.lc_name()),\n            });\n        }\n        else {\n            throw new Error(\"No message class defined\");\n        }\n    }\n    getRoleFromMessageClass(name) {\n        switch (name) {\n            case \"HumanMessage\":\n                return \"human\";\n            case \"AIMessage\":\n                return \"ai\";\n            case \"SystemMessage\":\n                return \"system\";\n            case \"ChatMessage\":\n                return \"chat\";\n            default:\n                throw new Error(\"Invalid message class name\");\n        }\n    }\n    static fromTemplate(template, additionalOptions) {\n        if (typeof template === \"string\") {\n            return new this(_prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(template, additionalOptions));\n        }\n        const prompt = [];\n        for (const item of template) {\n            // handle string cases\n            if (typeof item === \"string\") {\n                prompt.push(_prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(item, additionalOptions));\n            }\n            else if (item === null) {\n                // pass\n            }\n            else if (isTextTemplateParam(item)) {\n                let text = \"\";\n                if (typeof item.text === \"string\") {\n                    text = item.text ?? \"\";\n                }\n                const options = {\n                    ...additionalOptions,\n                    additionalContentFields: item,\n                };\n                prompt.push(_prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(text, options));\n            }\n            else if (isImageTemplateParam(item)) {\n                let imgTemplate = item.image_url ?? \"\";\n                let imgTemplateObject;\n                let inputVariables = [];\n                if (typeof imgTemplate === \"string\") {\n                    let parsedTemplate;\n                    if (additionalOptions?.templateFormat === \"mustache\") {\n                        parsedTemplate = (0,_template_js__WEBPACK_IMPORTED_MODULE_7__.parseMustache)(imgTemplate);\n                    }\n                    else {\n                        parsedTemplate = (0,_template_js__WEBPACK_IMPORTED_MODULE_7__.parseFString)(imgTemplate);\n                    }\n                    const variables = parsedTemplate.flatMap((item) => item.type === \"variable\" ? [item.name] : []);\n                    if ((variables?.length ?? 0) > 0) {\n                        if (variables.length > 1) {\n                            throw new Error(`Only one format variable allowed per image template.\\nGot: ${variables}\\nFrom: ${imgTemplate}`);\n                        }\n                        inputVariables = [variables[0]];\n                    }\n                    else {\n                        inputVariables = [];\n                    }\n                    imgTemplate = { url: imgTemplate };\n                    imgTemplateObject = new _image_js__WEBPACK_IMPORTED_MODULE_6__.ImagePromptTemplate({\n                        template: imgTemplate,\n                        inputVariables,\n                        templateFormat: additionalOptions?.templateFormat,\n                        additionalContentFields: item,\n                    });\n                }\n                else if (typeof imgTemplate === \"object\") {\n                    if (\"url\" in imgTemplate) {\n                        let parsedTemplate;\n                        if (additionalOptions?.templateFormat === \"mustache\") {\n                            parsedTemplate = (0,_template_js__WEBPACK_IMPORTED_MODULE_7__.parseMustache)(imgTemplate.url);\n                        }\n                        else {\n                            parsedTemplate = (0,_template_js__WEBPACK_IMPORTED_MODULE_7__.parseFString)(imgTemplate.url);\n                        }\n                        inputVariables = parsedTemplate.flatMap((item) => item.type === \"variable\" ? [item.name] : []);\n                    }\n                    else {\n                        inputVariables = [];\n                    }\n                    imgTemplateObject = new _image_js__WEBPACK_IMPORTED_MODULE_6__.ImagePromptTemplate({\n                        template: imgTemplate,\n                        inputVariables,\n                        templateFormat: additionalOptions?.templateFormat,\n                        additionalContentFields: item,\n                    });\n                }\n                else {\n                    throw new Error(\"Invalid image template\");\n                }\n                prompt.push(imgTemplateObject);\n            }\n            else if (typeof item === \"object\") {\n                prompt.push(new _dict_js__WEBPACK_IMPORTED_MODULE_9__.DictPromptTemplate({\n                    template: item,\n                    templateFormat: additionalOptions?.templateFormat,\n                }));\n            }\n        }\n        return new this({ prompt, additionalOptions });\n    }\n    async format(input) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (this.prompt instanceof _string_js__WEBPACK_IMPORTED_MODULE_3__.BaseStringPromptTemplate) {\n            const text = await this.prompt.format(input);\n            return this.createMessage(text);\n        }\n        else {\n            const content = [];\n            for (const prompt of this.prompt) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let inputs = {};\n                if (!(\"inputVariables\" in prompt)) {\n                    throw new Error(`Prompt ${prompt} does not have inputVariables defined.`);\n                }\n                for (const item of prompt.inputVariables) {\n                    if (!inputs) {\n                        inputs = { [item]: input[item] };\n                    }\n                    inputs = { ...inputs, [item]: input[item] };\n                }\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (prompt instanceof _string_js__WEBPACK_IMPORTED_MODULE_3__.BaseStringPromptTemplate) {\n                    const formatted = await prompt.format(inputs);\n                    let additionalContentFields;\n                    if (\"additionalContentFields\" in prompt) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        additionalContentFields = prompt.additionalContentFields;\n                    }\n                    if (formatted !== \"\") {\n                        content.push({\n                            ...additionalContentFields,\n                            type: \"text\",\n                            text: formatted,\n                        });\n                    }\n                    /** @TODO replace this */\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                }\n                else if (prompt instanceof _image_js__WEBPACK_IMPORTED_MODULE_6__.ImagePromptTemplate) {\n                    const formatted = await prompt.format(inputs);\n                    let additionalContentFields;\n                    if (\"additionalContentFields\" in prompt) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        additionalContentFields = prompt.additionalContentFields;\n                    }\n                    content.push({\n                        ...additionalContentFields,\n                        type: \"image_url\",\n                        image_url: formatted,\n                    });\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                }\n                else if (prompt instanceof _dict_js__WEBPACK_IMPORTED_MODULE_9__.DictPromptTemplate) {\n                    const formatted = await prompt.format(inputs);\n                    let additionalContentFields;\n                    if (\"additionalContentFields\" in prompt) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        additionalContentFields = prompt.additionalContentFields;\n                    }\n                    content.push({\n                        ...additionalContentFields,\n                        ...formatted,\n                    });\n                }\n            }\n            return this.createMessage(content);\n        }\n    }\n    async formatMessages(values) {\n        return [await this.format(values)];\n    }\n}\n/**\n * Class that represents a human message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n * @example\n * ```typescript\n * const message = HumanMessagePromptTemplate.fromTemplate(\"{text}\");\n * const formatted = await message.format({ text: \"Hello world!\" });\n *\n * const chatPrompt = ChatPromptTemplate.fromMessages([message]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nclass HumanMessagePromptTemplate extends _StringImageMessagePromptTemplate {\n    static _messageClass() {\n        return _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.HumanMessage;\n    }\n    static lc_name() {\n        return \"HumanMessagePromptTemplate\";\n    }\n}\n/**\n * Class that represents an AI message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n */\nclass AIMessagePromptTemplate extends _StringImageMessagePromptTemplate {\n    static _messageClass() {\n        return _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.AIMessage;\n    }\n    static lc_name() {\n        return \"AIMessagePromptTemplate\";\n    }\n}\n/**\n * Class that represents a system message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n * @example\n * ```typescript\n * const message = SystemMessagePromptTemplate.fromTemplate(\"{text}\");\n * const formatted = await message.format({ text: \"Hello world!\" });\n *\n * const chatPrompt = ChatPromptTemplate.fromMessages([message]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nclass SystemMessagePromptTemplate extends _StringImageMessagePromptTemplate {\n    static _messageClass() {\n        return _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.SystemMessage;\n    }\n    static lc_name() {\n        return \"SystemMessagePromptTemplate\";\n    }\n}\nfunction _isBaseMessagePromptTemplate(baseMessagePromptTemplateLike) {\n    return (typeof baseMessagePromptTemplateLike\n        .formatMessages === \"function\");\n}\nfunction _coerceMessagePromptTemplateLike(messagePromptTemplateLike, extra) {\n    if (_isBaseMessagePromptTemplate(messagePromptTemplateLike) ||\n        (0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isBaseMessage)(messagePromptTemplateLike)) {\n        return messagePromptTemplateLike;\n    }\n    if (Array.isArray(messagePromptTemplateLike) &&\n        messagePromptTemplateLike[0] === \"placeholder\") {\n        const messageContent = messagePromptTemplateLike[1];\n        if (extra?.templateFormat === \"mustache\" &&\n            typeof messageContent === \"string\" &&\n            messageContent.slice(0, 2) === \"{{\" &&\n            messageContent.slice(-2) === \"}}\") {\n            const variableName = messageContent.slice(2, -2);\n            return new MessagesPlaceholder({ variableName, optional: true });\n        }\n        else if (typeof messageContent === \"string\" &&\n            messageContent[0] === \"{\" &&\n            messageContent[messageContent.length - 1] === \"}\") {\n            const variableName = messageContent.slice(1, -1);\n            return new MessagesPlaceholder({ variableName, optional: true });\n        }\n        throw new Error(`Invalid placeholder template for format ${extra?.templateFormat ?? `\"f-string\"`}: \"${messagePromptTemplateLike[1]}\". Expected a variable name surrounded by ${extra?.templateFormat === \"mustache\" ? \"double\" : \"single\"} curly braces.`);\n    }\n    const message = (0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage)(messagePromptTemplateLike);\n    let templateData;\n    if (typeof message.content === \"string\") {\n        templateData = message.content;\n    }\n    else {\n        // Assuming message.content is an array of complex objects, transform it.\n        templateData = message.content.map((item) => {\n            if (\"text\" in item) {\n                return { ...item, text: item.text };\n            }\n            else if (\"image_url\" in item) {\n                return { ...item, image_url: item.image_url };\n            }\n            else {\n                return item;\n            }\n        });\n    }\n    if (message._getType() === \"human\") {\n        return HumanMessagePromptTemplate.fromTemplate(templateData, extra);\n    }\n    else if (message._getType() === \"ai\") {\n        return AIMessagePromptTemplate.fromTemplate(templateData, extra);\n    }\n    else if (message._getType() === \"system\") {\n        return SystemMessagePromptTemplate.fromTemplate(templateData, extra);\n    }\n    else if (_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.ChatMessage.isInstance(message)) {\n        return ChatMessagePromptTemplate.fromTemplate(message.content, message.role, extra);\n    }\n    else {\n        throw new Error(`Could not coerce message prompt template from input. Received message type: \"${message._getType()}\".`);\n    }\n}\nfunction isMessagesPlaceholder(x) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return x.constructor.lc_name() === \"MessagesPlaceholder\";\n}\n/**\n * Class that represents a chat prompt. It extends the\n * BaseChatPromptTemplate and uses an array of BaseMessagePromptTemplate\n * instances to format a series of messages for a conversation.\n * @example\n * ```typescript\n * const message = SystemMessagePromptTemplate.fromTemplate(\"{text}\");\n * const chatPrompt = ChatPromptTemplate.fromMessages([\n *   [\"ai\", \"You are a helpful assistant.\"],\n *   message,\n * ]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nclass ChatPromptTemplate extends BaseChatPromptTemplate {\n    static lc_name() {\n        return \"ChatPromptTemplate\";\n    }\n    get lc_aliases() {\n        return {\n            promptMessages: \"messages\",\n        };\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"promptMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        // If input is mustache and validateTemplate is not defined, set it to false\n        if (input.templateFormat === \"mustache\" &&\n            input.validateTemplate === undefined) {\n            this.validateTemplate = false;\n        }\n        Object.assign(this, input);\n        if (this.validateTemplate) {\n            const inputVariablesMessages = new Set();\n            for (const promptMessage of this.promptMessages) {\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (promptMessage instanceof _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage)\n                    continue;\n                for (const inputVariable of promptMessage.inputVariables) {\n                    inputVariablesMessages.add(inputVariable);\n                }\n            }\n            const totalInputVariables = this.inputVariables;\n            const inputVariablesInstance = new Set(this.partialVariables\n                ? totalInputVariables.concat(Object.keys(this.partialVariables))\n                : totalInputVariables);\n            const difference = new Set([...inputVariablesInstance].filter((x) => !inputVariablesMessages.has(x)));\n            if (difference.size > 0) {\n                throw new Error(`Input variables \\`${[\n                    ...difference,\n                ]}\\` are not used in any of the prompt messages.`);\n            }\n            const otherDifference = new Set([...inputVariablesMessages].filter((x) => !inputVariablesInstance.has(x)));\n            if (otherDifference.size > 0) {\n                throw new Error(`Input variables \\`${[\n                    ...otherDifference,\n                ]}\\` are used in prompt messages but not in the prompt template.`);\n            }\n        }\n    }\n    _getPromptType() {\n        return \"chat\";\n    }\n    async _parseImagePrompts(message, inputValues) {\n        if (typeof message.content === \"string\") {\n            return message;\n        }\n        const formattedMessageContent = await Promise.all(message.content.map(async (item) => {\n            if (item.type !== \"image_url\") {\n                return item;\n            }\n            let imageUrl = \"\";\n            if (typeof item.image_url === \"string\") {\n                imageUrl = item.image_url;\n            }\n            else {\n                imageUrl = item.image_url.url;\n            }\n            const promptTemplatePlaceholder = _prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(imageUrl, {\n                templateFormat: this.templateFormat,\n            });\n            const formattedUrl = await promptTemplatePlaceholder.format(inputValues);\n            if (typeof item.image_url !== \"string\" && \"url\" in item.image_url) {\n                // eslint-disable-next-line no-param-reassign\n                item.image_url.url = formattedUrl;\n            }\n            else {\n                // eslint-disable-next-line no-param-reassign\n                item.image_url = formattedUrl;\n            }\n            return item;\n        }));\n        // eslint-disable-next-line no-param-reassign\n        message.content = formattedMessageContent;\n        return message;\n    }\n    async formatMessages(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        let resultMessages = [];\n        for (const promptMessage of this.promptMessages) {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (promptMessage instanceof _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage) {\n                resultMessages.push(await this._parseImagePrompts(promptMessage, allValues));\n            }\n            else {\n                let inputValues;\n                if (this.templateFormat === \"mustache\") {\n                    inputValues = { ...allValues };\n                }\n                else {\n                    inputValues = promptMessage.inputVariables.reduce((acc, inputVariable) => {\n                        if (!(inputVariable in allValues) &&\n                            !(isMessagesPlaceholder(promptMessage) && promptMessage.optional)) {\n                            const error = (0,_errors_index_js__WEBPACK_IMPORTED_MODULE_8__.addLangChainErrorFields)(new Error(`Missing value for input variable \\`${inputVariable.toString()}\\``), \"INVALID_PROMPT_INPUT\");\n                            throw error;\n                        }\n                        acc[inputVariable] = allValues[inputVariable];\n                        return acc;\n                    }, {});\n                }\n                const message = await promptMessage.formatMessages(inputValues);\n                resultMessages = resultMessages.concat(message);\n            }\n        }\n        return resultMessages;\n    }\n    async partial(values) {\n        // This is implemented in a way it doesn't require making\n        // BaseMessagePromptTemplate aware of .partial()\n        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new ChatPromptTemplate(promptDict);\n    }\n    static fromTemplate(template, options) {\n        const prompt = _prompt_js__WEBPACK_IMPORTED_MODULE_5__.PromptTemplate.fromTemplate(template, options);\n        const humanTemplate = new HumanMessagePromptTemplate({ prompt });\n        return this.fromMessages([humanTemplate]);\n    }\n    /**\n     * Create a chat model-specific prompt from individual chat messages\n     * or message-like tuples.\n     * @param promptMessages Messages to be passed to the chat model\n     * @returns A new ChatPromptTemplate\n     */\n    static fromMessages(promptMessages, extra) {\n        const flattenedMessages = promptMessages.reduce((acc, promptMessage) => acc.concat(\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        promptMessage instanceof ChatPromptTemplate\n            ? promptMessage.promptMessages\n            : [\n                _coerceMessagePromptTemplateLike(promptMessage, extra),\n            ]), []);\n        const flattenedPartialVariables = promptMessages.reduce((acc, promptMessage) => \n        // eslint-disable-next-line no-instanceof/no-instanceof\n        promptMessage instanceof ChatPromptTemplate\n            ? Object.assign(acc, promptMessage.partialVariables)\n            : acc, Object.create(null));\n        const inputVariables = new Set();\n        for (const promptMessage of flattenedMessages) {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (promptMessage instanceof _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage)\n                continue;\n            for (const inputVariable of promptMessage.inputVariables) {\n                if (inputVariable in flattenedPartialVariables) {\n                    continue;\n                }\n                inputVariables.add(inputVariable);\n            }\n        }\n        return new this({\n            ...extra,\n            inputVariables: [...inputVariables],\n            promptMessages: flattenedMessages,\n            partialVariables: flattenedPartialVariables,\n            templateFormat: extra?.templateFormat,\n        });\n    }\n    /** @deprecated Renamed to .fromMessages */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static fromPromptMessages(promptMessages) {\n        return this.fromMessages(promptMessages);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9jaGF0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ29KO0FBQzdGO0FBQ1A7QUFDTztBQUNQO0FBQ0Y7QUFDRztBQUNZO0FBQ0E7QUFDZDtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0NBQXdDLHdEQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiwrQkFBK0I7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwRUFBMEI7QUFDeEU7QUFDQTtBQUNBLHFDQUFxQyw4RUFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QyxtQ0FBbUMsY0FBYztBQUNqRCx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUNBQXFDLHdEQUFrQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBVztBQUM5QjtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFjO0FBQ3RDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzREFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzREFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJEQUFhO0FBQ3REO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsVUFBVSxVQUFVLFlBQVk7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLDRDQUE0QywwREFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyREFBYTtBQUMxRDtBQUNBO0FBQ0EsNkNBQTZDLDBEQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwREFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQWtCO0FBQ2xEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdFQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLHNDQUFzQyxnRUFBd0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwREFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDJDQUEyQyx3REFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSztBQUNsRSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSw0REFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSx5REFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxLQUFLO0FBQ25FLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNPO0FBQ1A7QUFDQSxlQUFlLDZEQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDRDQUE0QztBQUM1QztBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0U7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyw0REFBNEQ7QUFDNUQ7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFO0FBQ0EsbUVBQW1FLHNDQUFzQyxLQUFLLDZCQUE2Qiw0Q0FBNEMsNERBQTREO0FBQ25QO0FBQ0Esb0JBQW9CLDhFQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJEQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxtQkFBbUI7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELEtBQUs7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkRBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHNEQUFjO0FBQzVEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywyREFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUVBQXVCLGlEQUFpRCx5QkFBeUI7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQWM7QUFDckMsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJEQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccHJvbXB0c1xcY2hhdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEZWZhdWx0IGdlbmVyaWMgXCJhbnlcIiB2YWx1ZXMgYXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbi8vIFJlcGxhY2Ugd2l0aCBcInN0cmluZ1wiIHdoZW4gd2UgYXJlIGNvbWZvcnRhYmxlIHdpdGggYSBicmVha2luZyBjaGFuZ2UuXG5pbXBvcnQgeyBBSU1lc3NhZ2UsIEh1bWFuTWVzc2FnZSwgU3lzdGVtTWVzc2FnZSwgQmFzZU1lc3NhZ2UsIENoYXRNZXNzYWdlLCBjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSwgaXNCYXNlTWVzc2FnZSwgfSBmcm9tIFwiLi4vbWVzc2FnZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IENoYXRQcm9tcHRWYWx1ZSwgfSBmcm9tIFwiLi4vcHJvbXB0X3ZhbHVlcy5qc1wiO1xuaW1wb3J0IHsgUnVubmFibGUgfSBmcm9tIFwiLi4vcnVubmFibGVzL2Jhc2UuanNcIjtcbmltcG9ydCB7IEJhc2VTdHJpbmdQcm9tcHRUZW1wbGF0ZSB9IGZyb20gXCIuL3N0cmluZy5qc1wiO1xuaW1wb3J0IHsgQmFzZVByb21wdFRlbXBsYXRlLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IFByb21wdFRlbXBsYXRlLCB9IGZyb20gXCIuL3Byb21wdC5qc1wiO1xuaW1wb3J0IHsgSW1hZ2VQcm9tcHRUZW1wbGF0ZSB9IGZyb20gXCIuL2ltYWdlLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUZTdHJpbmcsIHBhcnNlTXVzdGFjaGUsIH0gZnJvbSBcIi4vdGVtcGxhdGUuanNcIjtcbmltcG9ydCB7IGFkZExhbmdDaGFpbkVycm9yRmllbGRzIH0gZnJvbSBcIi4uL2Vycm9ycy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRGljdFByb21wdFRlbXBsYXRlIH0gZnJvbSBcIi4vZGljdC5qc1wiO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHNlcnZlcyBhcyBhIGJhc2UgZm9yIGNyZWF0aW5nIG1lc3NhZ2UgcHJvbXB0XG4gKiB0ZW1wbGF0ZXMuIEl0IGRlZmluZXMgaG93IHRvIGZvcm1hdCBtZXNzYWdlcyBmb3IgZGlmZmVyZW50IHJvbGVzIGluIGFcbiAqIGNvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VNZXNzYWdlUHJvbXB0VGVtcGxhdGUgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJwcm9tcHRzXCIsIFwiY2hhdFwiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgZm9ybWF0TWVzc2FnZXMgbWV0aG9kIHdpdGggdGhlIHByb3ZpZGVkIGlucHV0IGFuZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBpbnB1dCBJbnB1dCBmb3IgdGhlIGZvcm1hdE1lc3NhZ2VzIG1ldGhvZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIEJhc2VDYWxsYmFja0NvbmZpZ1xuICAgICAqIEByZXR1cm5zIEZvcm1hdHRlZCBvdXRwdXQgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKChpbnB1dCkgPT4gdGhpcy5mb3JtYXRNZXNzYWdlcyhpbnB1dCksIGlucHV0LCB7IC4uLm9wdGlvbnMsIHJ1blR5cGU6IFwicHJvbXB0XCIgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBwbGFjZWhvbGRlciBmb3IgbWVzc2FnZXMgaW4gYSBjaGF0IHByb21wdC4gSXRcbiAqIGV4dGVuZHMgdGhlIEJhc2VNZXNzYWdlUHJvbXB0VGVtcGxhdGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlc1BsYWNlaG9sZGVyIGV4dGVuZHMgQmFzZU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIk1lc3NhZ2VzUGxhY2Vob2xkZXJcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgdmFyaWFibGVOYW1lOiBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YXJpYWJsZU5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3B0aW9uYWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWUgPSBmaWVsZHMudmFyaWFibGVOYW1lO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gZmllbGRzLm9wdGlvbmFsID8/IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgaW5wdXRWYXJpYWJsZXMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy52YXJpYWJsZU5hbWVdO1xuICAgIH1cbiAgICBhc3luYyBmb3JtYXRNZXNzYWdlcyh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB2YWx1ZXNbdGhpcy52YXJpYWJsZU5hbWVdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbCAmJiAhaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBGaWVsZCBcIiR7dGhpcy52YXJpYWJsZU5hbWV9XCIgaW4gcHJvbXB0IHVzZXMgYSBNZXNzYWdlc1BsYWNlaG9sZGVyLCB3aGljaCBleHBlY3RzIGFuIGFycmF5IG9mIEJhc2VNZXNzYWdlcyBhcyBhbiBpbnB1dCB2YWx1ZS4gUmVjZWl2ZWQ6IHVuZGVmaW5lZGApO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiSW5wdXRGb3JtYXRFcnJvclwiO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvcm1hdHRlZE1lc3NhZ2VzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkTWVzc2FnZXMgPSBpbnB1dC5tYXAoY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkTWVzc2FnZXMgPSBbY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UoaW5wdXQpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBpbnB1dCA6IEpTT04uc3RyaW5naWZ5KGlucHV0LCBudWxsLCAyKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFtcbiAgICAgICAgICAgICAgICBgRmllbGQgXCIke3RoaXMudmFyaWFibGVOYW1lfVwiIGluIHByb21wdCB1c2VzIGEgTWVzc2FnZXNQbGFjZWhvbGRlciwgd2hpY2ggZXhwZWN0cyBhbiBhcnJheSBvZiBCYXNlTWVzc2FnZXMgb3IgY29lcmNlYWJsZSB2YWx1ZXMgYXMgaW5wdXQuYCxcbiAgICAgICAgICAgICAgICBgUmVjZWl2ZWQgdmFsdWU6ICR7cmVhZGFibGVJbnB1dH1gLFxuICAgICAgICAgICAgICAgIGBBZGRpdGlvbmFsIG1lc3NhZ2U6ICR7ZS5tZXNzYWdlfWAsXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cXG5cIikpO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiSW5wdXRGb3JtYXRFcnJvclwiO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGVycm9yLmxjX2Vycm9yX2NvZGUgPSBlLmxjX2Vycm9yX2NvZGU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkTWVzc2FnZXM7XG4gICAgfVxufVxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHNlcnZlcyBhcyBhIGJhc2UgZm9yIGNyZWF0aW5nIG1lc3NhZ2Ugc3RyaW5nIHByb21wdFxuICogdGVtcGxhdGVzLiBJdCBleHRlbmRzIHRoZSBCYXNlTWVzc2FnZVByb21wdFRlbXBsYXRlLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZU1lc3NhZ2VTdHJpbmdQcm9tcHRUZW1wbGF0ZSBleHRlbmRzIEJhc2VNZXNzYWdlUHJvbXB0VGVtcGxhdGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBpZiAoIShcInByb21wdFwiIGluIGZpZWxkcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBwcm9tcHQ6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb21wdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb21wdCA9IGZpZWxkcy5wcm9tcHQ7XG4gICAgfVxuICAgIGdldCBpbnB1dFZhcmlhYmxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbXB0LmlucHV0VmFyaWFibGVzO1xuICAgIH1cbiAgICBhc3luYyBmb3JtYXRNZXNzYWdlcyh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIFthd2FpdCB0aGlzLmZvcm1hdCh2YWx1ZXMpXTtcbiAgICB9XG59XG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgc2VydmVzIGFzIGEgYmFzZSBmb3IgY3JlYXRpbmcgY2hhdCBwcm9tcHRcbiAqIHRlbXBsYXRlcy4gSXQgZXh0ZW5kcyB0aGUgQmFzZVByb21wdFRlbXBsYXRlLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUNoYXRQcm9tcHRUZW1wbGF0ZSBleHRlbmRzIEJhc2VQcm9tcHRUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoaW5wdXQpO1xuICAgIH1cbiAgICBhc3luYyBmb3JtYXQodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5mb3JtYXRQcm9tcHRWYWx1ZSh2YWx1ZXMpKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBhc3luYyBmb3JtYXRQcm9tcHRWYWx1ZSh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0TWVzc2FnZXMgPSBhd2FpdCB0aGlzLmZvcm1hdE1lc3NhZ2VzKHZhbHVlcyk7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdFByb21wdFZhbHVlKHJlc3VsdE1lc3NhZ2VzKTtcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGNoYXQgbWVzc2FnZSBwcm9tcHQgdGVtcGxhdGUuIEl0IGV4dGVuZHMgdGhlXG4gKiBCYXNlTWVzc2FnZVN0cmluZ1Byb21wdFRlbXBsYXRlLlxuICovXG5leHBvcnQgY2xhc3MgQ2hhdE1lc3NhZ2VQcm9tcHRUZW1wbGF0ZSBleHRlbmRzIEJhc2VNZXNzYWdlU3RyaW5nUHJvbXB0VGVtcGxhdGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJDaGF0TWVzc2FnZVByb21wdFRlbXBsYXRlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgcm9sZSkge1xuICAgICAgICBpZiAoIShcInByb21wdFwiIGluIGZpZWxkcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBwcm9tcHQ6IGZpZWxkcywgcm9sZTogcm9sZSB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvbGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb2xlID0gZmllbGRzLnJvbGU7XG4gICAgfVxuICAgIGFzeW5jIGZvcm1hdCh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZShhd2FpdCB0aGlzLnByb21wdC5mb3JtYXQodmFsdWVzKSwgdGhpcy5yb2xlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgcm9sZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKHRlbXBsYXRlLCB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUZvcm1hdDogb3B0aW9ucz8udGVtcGxhdGVGb3JtYXQsXG4gICAgICAgIH0pLCByb2xlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1RleHRUZW1wbGF0ZVBhcmFtKHBhcmFtKSB7XG4gICAgaWYgKHBhcmFtID09PSBudWxsIHx8IHR5cGVvZiBwYXJhbSAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KHBhcmFtKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoT2JqZWN0LmtleXMocGFyYW0pLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBcInRleHRcIiBpbiBwYXJhbSAmJlxuICAgICAgICB0eXBlb2YgcGFyYW0udGV4dCA9PT0gXCJzdHJpbmdcIik7XG59XG5mdW5jdGlvbiBpc0ltYWdlVGVtcGxhdGVQYXJhbShwYXJhbSkge1xuICAgIGlmIChwYXJhbSA9PT0gbnVsbCB8fCB0eXBlb2YgcGFyYW0gIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShwYXJhbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKFwiaW1hZ2VfdXJsXCIgaW4gcGFyYW0gJiZcbiAgICAgICAgKHR5cGVvZiBwYXJhbS5pbWFnZV91cmwgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICh0eXBlb2YgcGFyYW0uaW1hZ2VfdXJsID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgcGFyYW0uaW1hZ2VfdXJsICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgXCJ1cmxcIiBpbiBwYXJhbS5pbWFnZV91cmwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcGFyYW0uaW1hZ2VfdXJsLnVybCA9PT0gXCJzdHJpbmdcIikpKTtcbn1cbmNsYXNzIF9TdHJpbmdJbWFnZU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZSBleHRlbmRzIEJhc2VNZXNzYWdlUHJvbXB0VGVtcGxhdGUge1xuICAgIHN0YXRpYyBfbWVzc2FnZUNsYXNzKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGludm9rZSBfbWVzc2FnZUNsYXNzIGZyb20gaW5zaWRlIF9TdHJpbmdJbWFnZU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZVwiKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIEBUT0RPIFdoZW4gd2UgY29tZSB1cCB3aXRoIGEgYmV0dGVyIHdheSB0byB0eXBlIHByb21wdCB0ZW1wbGF0ZXMsIGZpeCB0aGlzICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBmaWVsZHMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIGlmICghKFwicHJvbXB0XCIgaW4gZmllbGRzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7IHByb21wdDogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdHNcIiwgXCJjaGF0XCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0VmFyaWFibGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRkaXRpb25hbE9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9tcHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZUNsYXNzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENoYXRNZXNzYWdlIGNvbnRhaW5zIHJvbGUgZmllbGQsIG90aGVycyBkb24ndC5cbiAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGlzLCB3ZSBoYXZlIGEgc2VwYXJhdGUgY2xhc3MgcHJvcGVydHkgZm9yIENoYXRNZXNzYWdlLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGF0TWVzc2FnZUNsYXNzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvbXB0ID0gZmllbGRzLnByb21wdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9tcHQpKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucHJvbXB0LmZvckVhY2goKHByb21wdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcImlucHV0VmFyaWFibGVzXCIgaW4gcHJvbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFyaWFibGVzID0gaW5wdXRWYXJpYWJsZXMuY29uY2F0KHByb21wdC5pbnB1dFZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0VmFyaWFibGVzID0gaW5wdXRWYXJpYWJsZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0VmFyaWFibGVzID0gdGhpcy5wcm9tcHQuaW5wdXRWYXJpYWJsZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsT3B0aW9ucyA9IGFkZGl0aW9uYWxPcHRpb25zID8/IHRoaXMuYWRkaXRpb25hbE9wdGlvbnM7XG4gICAgfVxuICAgIGNyZWF0ZU1lc3NhZ2UoY29udGVudCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvci5fbWVzc2FnZUNsYXNzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IE1zZ0NsYXNzID0gY29uc3RydWN0b3IuX21lc3NhZ2VDbGFzcygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNc2dDbGFzcyh7IGNvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uc3RydWN0b3IuY2hhdE1lc3NhZ2VDbGFzcykge1xuICAgICAgICAgICAgY29uc3QgTXNnQ2xhc3MgPSBjb25zdHJ1Y3Rvci5jaGF0TWVzc2FnZUNsYXNzKCk7XG4gICAgICAgICAgICAvLyBBc3N1bWluZyBDaGF0TWVzc2FnZSBjb25zdHJ1Y3RvciBhbHNvIHRha2VzIGEgY29udGVudCBhcmd1bWVudFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNc2dDbGFzcyh7XG4gICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICByb2xlOiB0aGlzLmdldFJvbGVGcm9tTWVzc2FnZUNsYXNzKE1zZ0NsYXNzLmxjX25hbWUoKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1lc3NhZ2UgY2xhc3MgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSb2xlRnJvbU1lc3NhZ2VDbGFzcyhuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcIkh1bWFuTWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh1bWFuXCI7XG4gICAgICAgICAgICBjYXNlIFwiQUlNZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYWlcIjtcbiAgICAgICAgICAgIGNhc2UgXCJTeXN0ZW1NZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gICAgICAgICAgICBjYXNlIFwiQ2hhdE1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjaGF0XCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWVzc2FnZSBjbGFzcyBuYW1lXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVGVtcGxhdGUodGVtcGxhdGUsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyhQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUodGVtcGxhdGUsIGFkZGl0aW9uYWxPcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbXB0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gaGFuZGxlIHN0cmluZyBjYXNlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcHJvbXB0LnB1c2goUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKGl0ZW0sIGFkZGl0aW9uYWxPcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFzc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNUZXh0VGVtcGxhdGVQYXJhbShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0udGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gaXRlbS50ZXh0ID8/IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQ29udGVudEZpZWxkczogaXRlbSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHByb21wdC5wdXNoKFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZSh0ZXh0LCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ltYWdlVGVtcGxhdGVQYXJhbShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGxldCBpbWdUZW1wbGF0ZSA9IGl0ZW0uaW1hZ2VfdXJsID8/IFwiXCI7XG4gICAgICAgICAgICAgICAgbGV0IGltZ1RlbXBsYXRlT2JqZWN0O1xuICAgICAgICAgICAgICAgIGxldCBpbnB1dFZhcmlhYmxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW1nVGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZFRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbE9wdGlvbnM/LnRlbXBsYXRlRm9ybWF0ID09PSBcIm11c3RhY2hlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFRlbXBsYXRlID0gcGFyc2VNdXN0YWNoZShpbWdUZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRUZW1wbGF0ZSA9IHBhcnNlRlN0cmluZyhpbWdUZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVzID0gcGFyc2VkVGVtcGxhdGUuZmxhdE1hcCgoaXRlbSkgPT4gaXRlbS50eXBlID09PSBcInZhcmlhYmxlXCIgPyBbaXRlbS5uYW1lXSA6IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2YXJpYWJsZXM/Lmxlbmd0aCA/PyAwKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBvbmUgZm9ybWF0IHZhcmlhYmxlIGFsbG93ZWQgcGVyIGltYWdlIHRlbXBsYXRlLlxcbkdvdDogJHt2YXJpYWJsZXN9XFxuRnJvbTogJHtpbWdUZW1wbGF0ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFyaWFibGVzID0gW3ZhcmlhYmxlc1swXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhcmlhYmxlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltZ1RlbXBsYXRlID0geyB1cmw6IGltZ1RlbXBsYXRlIH07XG4gICAgICAgICAgICAgICAgICAgIGltZ1RlbXBsYXRlT2JqZWN0ID0gbmV3IEltYWdlUHJvbXB0VGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGltZ1RlbXBsYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZUZvcm1hdDogYWRkaXRpb25hbE9wdGlvbnM/LnRlbXBsYXRlRm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbENvbnRlbnRGaWVsZHM6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW1nVGVtcGxhdGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidXJsXCIgaW4gaW1nVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWRUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsT3B0aW9ucz8udGVtcGxhdGVGb3JtYXQgPT09IFwibXVzdGFjaGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFRlbXBsYXRlID0gcGFyc2VNdXN0YWNoZShpbWdUZW1wbGF0ZS51cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkVGVtcGxhdGUgPSBwYXJzZUZTdHJpbmcoaW1nVGVtcGxhdGUudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFyaWFibGVzID0gcGFyc2VkVGVtcGxhdGUuZmxhdE1hcCgoaXRlbSkgPT4gaXRlbS50eXBlID09PSBcInZhcmlhYmxlXCIgPyBbaXRlbS5uYW1lXSA6IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFyaWFibGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW1nVGVtcGxhdGVPYmplY3QgPSBuZXcgSW1hZ2VQcm9tcHRUZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogaW1nVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlRm9ybWF0OiBhZGRpdGlvbmFsT3B0aW9ucz8udGVtcGxhdGVGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQ29udGVudEZpZWxkczogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGltYWdlIHRlbXBsYXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9tcHQucHVzaChpbWdUZW1wbGF0ZU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHByb21wdC5wdXNoKG5ldyBEaWN0UHJvbXB0VGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVGb3JtYXQ6IGFkZGl0aW9uYWxPcHRpb25zPy50ZW1wbGF0ZUZvcm1hdCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHsgcHJvbXB0LCBhZGRpdGlvbmFsT3B0aW9ucyB9KTtcbiAgICB9XG4gICAgYXN5bmMgZm9ybWF0KGlucHV0KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgaWYgKHRoaXMucHJvbXB0IGluc3RhbmNlb2YgQmFzZVN0cmluZ1Byb21wdFRlbXBsYXRlKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5wcm9tcHQuZm9ybWF0KGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU1lc3NhZ2UodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb21wdCBvZiB0aGlzLnByb21wdCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0cyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICghKFwiaW5wdXRWYXJpYWJsZXNcIiBpbiBwcm9tcHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvbXB0ICR7cHJvbXB0fSBkb2VzIG5vdCBoYXZlIGlucHV0VmFyaWFibGVzIGRlZmluZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwcm9tcHQuaW5wdXRWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cyA9IHsgW2l0ZW1dOiBpbnB1dFtpdGVtXSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cyA9IHsgLi4uaW5wdXRzLCBbaXRlbV06IGlucHV0W2l0ZW1dIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgICAgICBpZiAocHJvbXB0IGluc3RhbmNlb2YgQmFzZVN0cmluZ1Byb21wdFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGF3YWl0IHByb21wdC5mb3JtYXQoaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZGl0aW9uYWxDb250ZW50RmllbGRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJhZGRpdGlvbmFsQ29udGVudEZpZWxkc1wiIGluIHByb21wdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxDb250ZW50RmllbGRzID0gcHJvbXB0LmFkZGl0aW9uYWxDb250ZW50RmllbGRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYWRkaXRpb25hbENvbnRlbnRGaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZm9ybWF0dGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyoqIEBUT0RPIHJlcGxhY2UgdGhpcyAqL1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb21wdCBpbnN0YW5jZW9mIEltYWdlUHJvbXB0VGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gYXdhaXQgcHJvbXB0LmZvcm1hdChpbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkaXRpb25hbENvbnRlbnRGaWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImFkZGl0aW9uYWxDb250ZW50RmllbGRzXCIgaW4gcHJvbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbENvbnRlbnRGaWVsZHMgPSBwcm9tcHQuYWRkaXRpb25hbENvbnRlbnRGaWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxDb250ZW50RmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZV91cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlX3VybDogZm9ybWF0dGVkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9tcHQgaW5zdGFuY2VvZiBEaWN0UHJvbXB0VGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gYXdhaXQgcHJvbXB0LmZvcm1hdChpbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkaXRpb25hbENvbnRlbnRGaWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImFkZGl0aW9uYWxDb250ZW50RmllbGRzXCIgaW4gcHJvbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbENvbnRlbnRGaWVsZHMgPSBwcm9tcHQuYWRkaXRpb25hbENvbnRlbnRGaWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxDb250ZW50RmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZm9ybWF0dGVkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVNZXNzYWdlKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZvcm1hdE1lc3NhZ2VzKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gW2F3YWl0IHRoaXMuZm9ybWF0KHZhbHVlcyldO1xuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgaHVtYW4gbWVzc2FnZSBwcm9tcHQgdGVtcGxhdGUuIEl0IGV4dGVuZHMgdGhlXG4gKiBCYXNlTWVzc2FnZVN0cmluZ1Byb21wdFRlbXBsYXRlLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IG1lc3NhZ2UgPSBIdW1hbk1lc3NhZ2VQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXCJ7dGV4dH1cIik7XG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBhd2FpdCBtZXNzYWdlLmZvcm1hdCh7IHRleHQ6IFwiSGVsbG8gd29ybGQhXCIgfSk7XG4gKlxuICogY29uc3QgY2hhdFByb21wdCA9IENoYXRQcm9tcHRUZW1wbGF0ZS5mcm9tTWVzc2FnZXMoW21lc3NhZ2VdKTtcbiAqIGNvbnN0IGZvcm1hdHRlZENoYXRQcm9tcHQgPSBhd2FpdCBjaGF0UHJvbXB0Lmludm9rZSh7XG4gKiAgIHRleHQ6IFwiSGVsbG8gd29ybGQhXCIsXG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSHVtYW5NZXNzYWdlUHJvbXB0VGVtcGxhdGUgZXh0ZW5kcyBfU3RyaW5nSW1hZ2VNZXNzYWdlUHJvbXB0VGVtcGxhdGUge1xuICAgIHN0YXRpYyBfbWVzc2FnZUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gSHVtYW5NZXNzYWdlO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSHVtYW5NZXNzYWdlUHJvbXB0VGVtcGxhdGVcIjtcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhbiBBSSBtZXNzYWdlIHByb21wdCB0ZW1wbGF0ZS4gSXQgZXh0ZW5kcyB0aGVcbiAqIEJhc2VNZXNzYWdlU3RyaW5nUHJvbXB0VGVtcGxhdGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBBSU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZSBleHRlbmRzIF9TdHJpbmdJbWFnZU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZSB7XG4gICAgc3RhdGljIF9tZXNzYWdlQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiBBSU1lc3NhZ2U7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJBSU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZVwiO1xuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc3lzdGVtIG1lc3NhZ2UgcHJvbXB0IHRlbXBsYXRlLiBJdCBleHRlbmRzIHRoZVxuICogQmFzZU1lc3NhZ2VTdHJpbmdQcm9tcHRUZW1wbGF0ZS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBtZXNzYWdlID0gU3lzdGVtTWVzc2FnZVByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcInt0ZXh0fVwiKTtcbiAqIGNvbnN0IGZvcm1hdHRlZCA9IGF3YWl0IG1lc3NhZ2UuZm9ybWF0KHsgdGV4dDogXCJIZWxsbyB3b3JsZCFcIiB9KTtcbiAqXG4gKiBjb25zdCBjaGF0UHJvbXB0ID0gQ2hhdFByb21wdFRlbXBsYXRlLmZyb21NZXNzYWdlcyhbbWVzc2FnZV0pO1xuICogY29uc3QgZm9ybWF0dGVkQ2hhdFByb21wdCA9IGF3YWl0IGNoYXRQcm9tcHQuaW52b2tlKHtcbiAqICAgdGV4dDogXCJIZWxsbyB3b3JsZCFcIixcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTeXN0ZW1NZXNzYWdlUHJvbXB0VGVtcGxhdGUgZXh0ZW5kcyBfU3RyaW5nSW1hZ2VNZXNzYWdlUHJvbXB0VGVtcGxhdGUge1xuICAgIHN0YXRpYyBfbWVzc2FnZUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gU3lzdGVtTWVzc2FnZTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN5c3RlbU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZVwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9pc0Jhc2VNZXNzYWdlUHJvbXB0VGVtcGxhdGUoYmFzZU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZUxpa2UpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBiYXNlTWVzc2FnZVByb21wdFRlbXBsYXRlTGlrZVxuICAgICAgICAuZm9ybWF0TWVzc2FnZXMgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBfY29lcmNlTWVzc2FnZVByb21wdFRlbXBsYXRlTGlrZShtZXNzYWdlUHJvbXB0VGVtcGxhdGVMaWtlLCBleHRyYSkge1xuICAgIGlmIChfaXNCYXNlTWVzc2FnZVByb21wdFRlbXBsYXRlKG1lc3NhZ2VQcm9tcHRUZW1wbGF0ZUxpa2UpIHx8XG4gICAgICAgIGlzQmFzZU1lc3NhZ2UobWVzc2FnZVByb21wdFRlbXBsYXRlTGlrZSkpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VQcm9tcHRUZW1wbGF0ZUxpa2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2VQcm9tcHRUZW1wbGF0ZUxpa2UpICYmXG4gICAgICAgIG1lc3NhZ2VQcm9tcHRUZW1wbGF0ZUxpa2VbMF0gPT09IFwicGxhY2Vob2xkZXJcIikge1xuICAgICAgICBjb25zdCBtZXNzYWdlQ29udGVudCA9IG1lc3NhZ2VQcm9tcHRUZW1wbGF0ZUxpa2VbMV07XG4gICAgICAgIGlmIChleHRyYT8udGVtcGxhdGVGb3JtYXQgPT09IFwibXVzdGFjaGVcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2VDb250ZW50ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICBtZXNzYWdlQ29udGVudC5zbGljZSgwLCAyKSA9PT0gXCJ7e1wiICYmXG4gICAgICAgICAgICBtZXNzYWdlQ29udGVudC5zbGljZSgtMikgPT09IFwifX1cIikge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gbWVzc2FnZUNvbnRlbnQuc2xpY2UoMiwgLTIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlc1BsYWNlaG9sZGVyKHsgdmFyaWFibGVOYW1lLCBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZUNvbnRlbnQgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIG1lc3NhZ2VDb250ZW50WzBdID09PSBcIntcIiAmJlxuICAgICAgICAgICAgbWVzc2FnZUNvbnRlbnRbbWVzc2FnZUNvbnRlbnQubGVuZ3RoIC0gMV0gPT09IFwifVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBtZXNzYWdlQ29udGVudC5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2VzUGxhY2Vob2xkZXIoeyB2YXJpYWJsZU5hbWUsIG9wdGlvbmFsOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwbGFjZWhvbGRlciB0ZW1wbGF0ZSBmb3IgZm9ybWF0ICR7ZXh0cmE/LnRlbXBsYXRlRm9ybWF0ID8/IGBcImYtc3RyaW5nXCJgfTogXCIke21lc3NhZ2VQcm9tcHRUZW1wbGF0ZUxpa2VbMV19XCIuIEV4cGVjdGVkIGEgdmFyaWFibGUgbmFtZSBzdXJyb3VuZGVkIGJ5ICR7ZXh0cmE/LnRlbXBsYXRlRm9ybWF0ID09PSBcIm11c3RhY2hlXCIgPyBcImRvdWJsZVwiIDogXCJzaW5nbGVcIn0gY3VybHkgYnJhY2VzLmApO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UobWVzc2FnZVByb21wdFRlbXBsYXRlTGlrZSk7XG4gICAgbGV0IHRlbXBsYXRlRGF0YTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0ZW1wbGF0ZURhdGEgPSBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBBc3N1bWluZyBtZXNzYWdlLmNvbnRlbnQgaXMgYW4gYXJyYXkgb2YgY29tcGxleCBvYmplY3RzLCB0cmFuc2Zvcm0gaXQuXG4gICAgICAgIHRlbXBsYXRlRGF0YSA9IG1lc3NhZ2UuY29udGVudC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChcInRleHRcIiBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uaXRlbSwgdGV4dDogaXRlbS50ZXh0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcImltYWdlX3VybFwiIGluIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5pdGVtLCBpbWFnZV91cmw6IGl0ZW0uaW1hZ2VfdXJsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwiaHVtYW5cIikge1xuICAgICAgICByZXR1cm4gSHVtYW5NZXNzYWdlUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKHRlbXBsYXRlRGF0YSwgZXh0cmEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwiYWlcIikge1xuICAgICAgICByZXR1cm4gQUlNZXNzYWdlUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKHRlbXBsYXRlRGF0YSwgZXh0cmEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgcmV0dXJuIFN5c3RlbU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUodGVtcGxhdGVEYXRhLCBleHRyYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKENoYXRNZXNzYWdlLmlzSW5zdGFuY2UobWVzc2FnZSkpIHtcbiAgICAgICAgcmV0dXJuIENoYXRNZXNzYWdlUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKG1lc3NhZ2UuY29udGVudCwgbWVzc2FnZS5yb2xlLCBleHRyYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBjb2VyY2UgbWVzc2FnZSBwcm9tcHQgdGVtcGxhdGUgZnJvbSBpbnB1dC4gUmVjZWl2ZWQgbWVzc2FnZSB0eXBlOiBcIiR7bWVzc2FnZS5fZ2V0VHlwZSgpfVwiLmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTWVzc2FnZXNQbGFjZWhvbGRlcih4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4geC5jb25zdHJ1Y3Rvci5sY19uYW1lKCkgPT09IFwiTWVzc2FnZXNQbGFjZWhvbGRlclwiO1xufVxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBjaGF0IHByb21wdC4gSXQgZXh0ZW5kcyB0aGVcbiAqIEJhc2VDaGF0UHJvbXB0VGVtcGxhdGUgYW5kIHVzZXMgYW4gYXJyYXkgb2YgQmFzZU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZVxuICogaW5zdGFuY2VzIHRvIGZvcm1hdCBhIHNlcmllcyBvZiBtZXNzYWdlcyBmb3IgYSBjb252ZXJzYXRpb24uXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgbWVzc2FnZSA9IFN5c3RlbU1lc3NhZ2VQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXCJ7dGV4dH1cIik7XG4gKiBjb25zdCBjaGF0UHJvbXB0ID0gQ2hhdFByb21wdFRlbXBsYXRlLmZyb21NZXNzYWdlcyhbXG4gKiAgIFtcImFpXCIsIFwiWW91IGFyZSBhIGhlbHBmdWwgYXNzaXN0YW50LlwiXSxcbiAqICAgbWVzc2FnZSxcbiAqIF0pO1xuICogY29uc3QgZm9ybWF0dGVkQ2hhdFByb21wdCA9IGF3YWl0IGNoYXRQcm9tcHQuaW52b2tlKHtcbiAqICAgdGV4dDogXCJIZWxsbyB3b3JsZCFcIixcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGF0UHJvbXB0VGVtcGxhdGUgZXh0ZW5kcyBCYXNlQ2hhdFByb21wdFRlbXBsYXRlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdFByb21wdFRlbXBsYXRlXCI7XG4gICAgfVxuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvbXB0TWVzc2FnZXM6IFwibWVzc2FnZXNcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoaW5wdXQpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9tcHRNZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWxpZGF0ZVRlbXBsYXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZW1wbGF0ZUZvcm1hdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJmLXN0cmluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiBpbnB1dCBpcyBtdXN0YWNoZSBhbmQgdmFsaWRhdGVUZW1wbGF0ZSBpcyBub3QgZGVmaW5lZCwgc2V0IGl0IHRvIGZhbHNlXG4gICAgICAgIGlmIChpbnB1dC50ZW1wbGF0ZUZvcm1hdCA9PT0gXCJtdXN0YWNoZVwiICYmXG4gICAgICAgICAgICBpbnB1dC52YWxpZGF0ZVRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVUZW1wbGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgaW5wdXQpO1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZVRlbXBsYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFZhcmlhYmxlc01lc3NhZ2VzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9tcHRNZXNzYWdlIG9mIHRoaXMucHJvbXB0TWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgaWYgKHByb21wdE1lc3NhZ2UgaW5zdGFuY2VvZiBCYXNlTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbnB1dFZhcmlhYmxlIG9mIHByb21wdE1lc3NhZ2UuaW5wdXRWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYXJpYWJsZXNNZXNzYWdlcy5hZGQoaW5wdXRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG90YWxJbnB1dFZhcmlhYmxlcyA9IHRoaXMuaW5wdXRWYXJpYWJsZXM7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFZhcmlhYmxlc0luc3RhbmNlID0gbmV3IFNldCh0aGlzLnBhcnRpYWxWYXJpYWJsZXNcbiAgICAgICAgICAgICAgICA/IHRvdGFsSW5wdXRWYXJpYWJsZXMuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMucGFydGlhbFZhcmlhYmxlcykpXG4gICAgICAgICAgICAgICAgOiB0b3RhbElucHV0VmFyaWFibGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBuZXcgU2V0KFsuLi5pbnB1dFZhcmlhYmxlc0luc3RhbmNlXS5maWx0ZXIoKHgpID0+ICFpbnB1dFZhcmlhYmxlc01lc3NhZ2VzLmhhcyh4KSkpO1xuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2Uuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0IHZhcmlhYmxlcyBcXGAke1tcbiAgICAgICAgICAgICAgICAgICAgLi4uZGlmZmVyZW5jZSxcbiAgICAgICAgICAgICAgICBdfVxcYCBhcmUgbm90IHVzZWQgaW4gYW55IG9mIHRoZSBwcm9tcHQgbWVzc2FnZXMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvdGhlckRpZmZlcmVuY2UgPSBuZXcgU2V0KFsuLi5pbnB1dFZhcmlhYmxlc01lc3NhZ2VzXS5maWx0ZXIoKHgpID0+ICFpbnB1dFZhcmlhYmxlc0luc3RhbmNlLmhhcyh4KSkpO1xuICAgICAgICAgICAgaWYgKG90aGVyRGlmZmVyZW5jZS5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgdmFyaWFibGVzIFxcYCR7W1xuICAgICAgICAgICAgICAgICAgICAuLi5vdGhlckRpZmZlcmVuY2UsXG4gICAgICAgICAgICAgICAgXX1cXGAgYXJlIHVzZWQgaW4gcHJvbXB0IG1lc3NhZ2VzIGJ1dCBub3QgaW4gdGhlIHByb21wdCB0ZW1wbGF0ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0UHJvbXB0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiY2hhdFwiO1xuICAgIH1cbiAgICBhc3luYyBfcGFyc2VJbWFnZVByb21wdHMobWVzc2FnZSwgaW5wdXRWYWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2VDb250ZW50ID0gYXdhaXQgUHJvbWlzZS5hbGwobWVzc2FnZS5jb250ZW50Lm1hcChhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSAhPT0gXCJpbWFnZV91cmxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGltYWdlVXJsID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS5pbWFnZV91cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGl0ZW0uaW1hZ2VfdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VVcmwgPSBpdGVtLmltYWdlX3VybC51cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9tcHRUZW1wbGF0ZVBsYWNlaG9sZGVyID0gUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKGltYWdlVXJsLCB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVGb3JtYXQ6IHRoaXMudGVtcGxhdGVGb3JtYXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFVybCA9IGF3YWl0IHByb21wdFRlbXBsYXRlUGxhY2Vob2xkZXIuZm9ybWF0KGlucHV0VmFsdWVzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS5pbWFnZV91cmwgIT09IFwic3RyaW5nXCIgJiYgXCJ1cmxcIiBpbiBpdGVtLmltYWdlX3VybCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGl0ZW0uaW1hZ2VfdXJsLnVybCA9IGZvcm1hdHRlZFVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGl0ZW0uaW1hZ2VfdXJsID0gZm9ybWF0dGVkVXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIG1lc3NhZ2UuY29udGVudCA9IGZvcm1hdHRlZE1lc3NhZ2VDb250ZW50O1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgZm9ybWF0TWVzc2FnZXModmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGFsbFZhbHVlcyA9IGF3YWl0IHRoaXMubWVyZ2VQYXJ0aWFsQW5kVXNlclZhcmlhYmxlcyh2YWx1ZXMpO1xuICAgICAgICBsZXQgcmVzdWx0TWVzc2FnZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9tcHRNZXNzYWdlIG9mIHRoaXMucHJvbXB0TWVzc2FnZXMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChwcm9tcHRNZXNzYWdlIGluc3RhbmNlb2YgQmFzZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRNZXNzYWdlcy5wdXNoKGF3YWl0IHRoaXMuX3BhcnNlSW1hZ2VQcm9tcHRzKHByb21wdE1lc3NhZ2UsIGFsbFZhbHVlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0VmFsdWVzO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlbXBsYXRlRm9ybWF0ID09PSBcIm11c3RhY2hlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZXMgPSB7IC4uLmFsbFZhbHVlcyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZXMgPSBwcm9tcHRNZXNzYWdlLmlucHV0VmFyaWFibGVzLnJlZHVjZSgoYWNjLCBpbnB1dFZhcmlhYmxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbnB1dFZhcmlhYmxlIGluIGFsbFZhbHVlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGlzTWVzc2FnZXNQbGFjZWhvbGRlcihwcm9tcHRNZXNzYWdlKSAmJiBwcm9tcHRNZXNzYWdlLm9wdGlvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gYWRkTGFuZ0NoYWluRXJyb3JGaWVsZHMobmV3IEVycm9yKGBNaXNzaW5nIHZhbHVlIGZvciBpbnB1dCB2YXJpYWJsZSBcXGAke2lucHV0VmFyaWFibGUudG9TdHJpbmcoKX1cXGBgKSwgXCJJTlZBTElEX1BST01QVF9JTlBVVFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1tpbnB1dFZhcmlhYmxlXSA9IGFsbFZhbHVlc1tpbnB1dFZhcmlhYmxlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHByb21wdE1lc3NhZ2UuZm9ybWF0TWVzc2FnZXMoaW5wdXRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdE1lc3NhZ2VzID0gcmVzdWx0TWVzc2FnZXMuY29uY2F0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRNZXNzYWdlcztcbiAgICB9XG4gICAgYXN5bmMgcGFydGlhbCh2YWx1ZXMpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBhIHdheSBpdCBkb2Vzbid0IHJlcXVpcmUgbWFraW5nXG4gICAgICAgIC8vIEJhc2VNZXNzYWdlUHJvbXB0VGVtcGxhdGUgYXdhcmUgb2YgLnBhcnRpYWwoKVxuICAgICAgICBjb25zdCBuZXdJbnB1dFZhcmlhYmxlcyA9IHRoaXMuaW5wdXRWYXJpYWJsZXMuZmlsdGVyKChpdikgPT4gIShpdiBpbiB2YWx1ZXMpKTtcbiAgICAgICAgY29uc3QgbmV3UGFydGlhbFZhcmlhYmxlcyA9IHtcbiAgICAgICAgICAgIC4uLih0aGlzLnBhcnRpYWxWYXJpYWJsZXMgPz8ge30pLFxuICAgICAgICAgICAgLi4udmFsdWVzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm9tcHREaWN0ID0ge1xuICAgICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAgIGlucHV0VmFyaWFibGVzOiBuZXdJbnB1dFZhcmlhYmxlcyxcbiAgICAgICAgICAgIHBhcnRpYWxWYXJpYWJsZXM6IG5ld1BhcnRpYWxWYXJpYWJsZXMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdFByb21wdFRlbXBsYXRlKHByb21wdERpY3QpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb21wdCA9IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGh1bWFuVGVtcGxhdGUgPSBuZXcgSHVtYW5NZXNzYWdlUHJvbXB0VGVtcGxhdGUoeyBwcm9tcHQgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21NZXNzYWdlcyhbaHVtYW5UZW1wbGF0ZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjaGF0IG1vZGVsLXNwZWNpZmljIHByb21wdCBmcm9tIGluZGl2aWR1YWwgY2hhdCBtZXNzYWdlc1xuICAgICAqIG9yIG1lc3NhZ2UtbGlrZSB0dXBsZXMuXG4gICAgICogQHBhcmFtIHByb21wdE1lc3NhZ2VzIE1lc3NhZ2VzIHRvIGJlIHBhc3NlZCB0byB0aGUgY2hhdCBtb2RlbFxuICAgICAqIEByZXR1cm5zIEEgbmV3IENoYXRQcm9tcHRUZW1wbGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTWVzc2FnZXMocHJvbXB0TWVzc2FnZXMsIGV4dHJhKSB7XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5lZE1lc3NhZ2VzID0gcHJvbXB0TWVzc2FnZXMucmVkdWNlKChhY2MsIHByb21wdE1lc3NhZ2UpID0+IGFjYy5jb25jYXQoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgcHJvbXB0TWVzc2FnZSBpbnN0YW5jZW9mIENoYXRQcm9tcHRUZW1wbGF0ZVxuICAgICAgICAgICAgPyBwcm9tcHRNZXNzYWdlLnByb21wdE1lc3NhZ2VzXG4gICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICBfY29lcmNlTWVzc2FnZVByb21wdFRlbXBsYXRlTGlrZShwcm9tcHRNZXNzYWdlLCBleHRyYSksXG4gICAgICAgICAgICBdKSwgW10pO1xuICAgICAgICBjb25zdCBmbGF0dGVuZWRQYXJ0aWFsVmFyaWFibGVzID0gcHJvbXB0TWVzc2FnZXMucmVkdWNlKChhY2MsIHByb21wdE1lc3NhZ2UpID0+IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIHByb21wdE1lc3NhZ2UgaW5zdGFuY2VvZiBDaGF0UHJvbXB0VGVtcGxhdGVcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihhY2MsIHByb21wdE1lc3NhZ2UucGFydGlhbFZhcmlhYmxlcylcbiAgICAgICAgICAgIDogYWNjLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvbXB0TWVzc2FnZSBvZiBmbGF0dGVuZWRNZXNzYWdlcykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgaWYgKHByb21wdE1lc3NhZ2UgaW5zdGFuY2VvZiBCYXNlTWVzc2FnZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5wdXRWYXJpYWJsZSBvZiBwcm9tcHRNZXNzYWdlLmlucHV0VmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0VmFyaWFibGUgaW4gZmxhdHRlbmVkUGFydGlhbFZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5wdXRWYXJpYWJsZXMuYWRkKGlucHV0VmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICAuLi5leHRyYSxcbiAgICAgICAgICAgIGlucHV0VmFyaWFibGVzOiBbLi4uaW5wdXRWYXJpYWJsZXNdLFxuICAgICAgICAgICAgcHJvbXB0TWVzc2FnZXM6IGZsYXR0ZW5lZE1lc3NhZ2VzLFxuICAgICAgICAgICAgcGFydGlhbFZhcmlhYmxlczogZmxhdHRlbmVkUGFydGlhbFZhcmlhYmxlcyxcbiAgICAgICAgICAgIHRlbXBsYXRlRm9ybWF0OiBleHRyYT8udGVtcGxhdGVGb3JtYXQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byAuZnJvbU1lc3NhZ2VzICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgZnJvbVByb21wdE1lc3NhZ2VzKHByb21wdE1lc3NhZ2VzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21NZXNzYWdlcyhwcm9tcHRNZXNzYWdlcyk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/chat.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/dict.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/dict.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DictPromptTemplate: () => (/* binding */ DictPromptTemplate)\n/* harmony export */ });\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/template.js\");\n\n\nclass DictPromptTemplate extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    static lc_name() {\n        return \"DictPromptTemplate\";\n    }\n    constructor(fields) {\n        const templateFormat = fields.templateFormat ?? \"f-string\";\n        const inputVariables = _getInputVariables(fields.template, templateFormat);\n        super({ inputVariables, ...fields });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompts\", \"dict\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"template\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.template = fields.template;\n        this.templateFormat = templateFormat;\n        this.inputVariables = inputVariables;\n    }\n    async format(values) {\n        return _insertInputVariables(this.template, values, this.templateFormat);\n    }\n    async invoke(values) {\n        return await this._callWithConfig(this.format.bind(this), values, {\n            runType: \"prompt\",\n        });\n    }\n}\nfunction _getInputVariables(template, templateFormat) {\n    const inputVariables = [];\n    for (const v of Object.values(template)) {\n        if (typeof v === \"string\") {\n            (0,_template_js__WEBPACK_IMPORTED_MODULE_1__.parseTemplate)(v, templateFormat).forEach((t) => {\n                if (t.type === \"variable\") {\n                    inputVariables.push(t.name);\n                }\n            });\n        }\n        else if (Array.isArray(v)) {\n            for (const x of v) {\n                if (typeof x === \"string\") {\n                    (0,_template_js__WEBPACK_IMPORTED_MODULE_1__.parseTemplate)(x, templateFormat).forEach((t) => {\n                        if (t.type === \"variable\") {\n                            inputVariables.push(t.name);\n                        }\n                    });\n                }\n                else if (typeof x === \"object\") {\n                    inputVariables.push(..._getInputVariables(x, templateFormat));\n                }\n            }\n        }\n        else if (typeof v === \"object\" && v !== null) {\n            inputVariables.push(..._getInputVariables(v, templateFormat));\n        }\n    }\n    return Array.from(new Set(inputVariables));\n}\nfunction _insertInputVariables(template, inputs, templateFormat) {\n    const formatted = {};\n    for (const [k, v] of Object.entries(template)) {\n        if (typeof v === \"string\") {\n            formatted[k] = (0,_template_js__WEBPACK_IMPORTED_MODULE_1__.renderTemplate)(v, templateFormat, inputs);\n        }\n        else if (Array.isArray(v)) {\n            const formattedV = [];\n            for (const x of v) {\n                if (typeof x === \"string\") {\n                    formattedV.push((0,_template_js__WEBPACK_IMPORTED_MODULE_1__.renderTemplate)(x, templateFormat, inputs));\n                }\n                else if (typeof x === \"object\") {\n                    formattedV.push(_insertInputVariables(x, inputs, templateFormat));\n                }\n            }\n            formatted[k] = formattedV;\n        }\n        else if (typeof v === \"object\" && v !== null) {\n            formatted[k] = _insertInputVariables(v, inputs, templateFormat);\n        }\n        else {\n            formatted[k] = v;\n        }\n    }\n    return formatted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9kaWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnRDtBQUNjO0FBQ3ZELGlDQUFpQyx3REFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0REFBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxwcm9tcHRzXFxkaWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJ1bm5hYmxlIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVRlbXBsYXRlLCByZW5kZXJUZW1wbGF0ZSB9IGZyb20gXCIuL3RlbXBsYXRlLmpzXCI7XG5leHBvcnQgY2xhc3MgRGljdFByb21wdFRlbXBsYXRlIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJEaWN0UHJvbXB0VGVtcGxhdGVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlRm9ybWF0ID0gZmllbGRzLnRlbXBsYXRlRm9ybWF0ID8/IFwiZi1zdHJpbmdcIjtcbiAgICAgICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBfZ2V0SW5wdXRWYXJpYWJsZXMoZmllbGRzLnRlbXBsYXRlLCB0ZW1wbGF0ZUZvcm1hdCk7XG4gICAgICAgIHN1cGVyKHsgaW5wdXRWYXJpYWJsZXMsIC4uLmZpZWxkcyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdHNcIiwgXCJkaWN0XCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRlbXBsYXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRlbXBsYXRlRm9ybWF0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0VmFyaWFibGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBmaWVsZHMudGVtcGxhdGU7XG4gICAgICAgIHRoaXMudGVtcGxhdGVGb3JtYXQgPSB0ZW1wbGF0ZUZvcm1hdDtcbiAgICAgICAgdGhpcy5pbnB1dFZhcmlhYmxlcyA9IGlucHV0VmFyaWFibGVzO1xuICAgIH1cbiAgICBhc3luYyBmb3JtYXQodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBfaW5zZXJ0SW5wdXRWYXJpYWJsZXModGhpcy50ZW1wbGF0ZSwgdmFsdWVzLCB0aGlzLnRlbXBsYXRlRm9ybWF0KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5mb3JtYXQuYmluZCh0aGlzKSwgdmFsdWVzLCB7XG4gICAgICAgICAgICBydW5UeXBlOiBcInByb21wdFwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0SW5wdXRWYXJpYWJsZXModGVtcGxhdGUsIHRlbXBsYXRlRm9ybWF0KSB7XG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXJzZVRlbXBsYXRlKHYsIHRlbXBsYXRlRm9ybWF0KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHQudHlwZSA9PT0gXCJ2YXJpYWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFyaWFibGVzLnB1c2godC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHggb2Ygdikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVRlbXBsYXRlKHgsIHRlbXBsYXRlRm9ybWF0KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC50eXBlID09PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKHQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKC4uLl9nZXRJbnB1dFZhcmlhYmxlcyh4LCB0ZW1wbGF0ZUZvcm1hdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKC4uLl9nZXRJbnB1dFZhcmlhYmxlcyh2LCB0ZW1wbGF0ZUZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoaW5wdXRWYXJpYWJsZXMpKTtcbn1cbmZ1bmN0aW9uIF9pbnNlcnRJbnB1dFZhcmlhYmxlcyh0ZW1wbGF0ZSwgaW5wdXRzLCB0ZW1wbGF0ZUZvcm1hdCkge1xuICAgIGNvbnN0IGZvcm1hdHRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHRlbXBsYXRlKSkge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFtrXSA9IHJlbmRlclRlbXBsYXRlKHYsIHRlbXBsYXRlRm9ybWF0LCBpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFYgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeCBvZiB2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFYucHVzaChyZW5kZXJUZW1wbGF0ZSh4LCB0ZW1wbGF0ZUZvcm1hdCwgaW5wdXRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFYucHVzaChfaW5zZXJ0SW5wdXRWYXJpYWJsZXMoeCwgaW5wdXRzLCB0ZW1wbGF0ZUZvcm1hdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcm1hdHRlZFtrXSA9IGZvcm1hdHRlZFY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkW2tdID0gX2luc2VydElucHV0VmFyaWFibGVzKHYsIGlucHV0cywgdGVtcGxhdGVGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0dGVkW2tdID0gdjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0dGVkO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/dict.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/few_shot.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/few_shot.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FewShotChatMessagePromptTemplate: () => (/* binding */ FewShotChatMessagePromptTemplate),\n/* harmony export */   FewShotPromptTemplate: () => (/* binding */ FewShotPromptTemplate)\n/* harmony export */ });\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/string.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/template.js\");\n/* harmony import */ var _prompt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prompt.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/prompt.js\");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chat.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/chat.js\");\n\n\n\n\n/**\n * Prompt template that contains few-shot examples.\n * @augments BasePromptTemplate\n * @augments FewShotPromptTemplateInput\n * @example\n * ```typescript\n * const examplePrompt = PromptTemplate.fromTemplate(\n *   \"Input: {input}\\nOutput: {output}\",\n * );\n *\n * const exampleSelector = await SemanticSimilarityExampleSelector.fromExamples(\n *   [\n *     { input: \"happy\", output: \"sad\" },\n *     { input: \"tall\", output: \"short\" },\n *     { input: \"energetic\", output: \"lethargic\" },\n *     { input: \"sunny\", output: \"gloomy\" },\n *     { input: \"windy\", output: \"calm\" },\n *   ],\n *   new OpenAIEmbeddings(),\n *   HNSWLib,\n *   { k: 1 },\n * );\n *\n * const dynamicPrompt = new FewShotPromptTemplate({\n *   exampleSelector,\n *   examplePrompt,\n *   prefix: \"Give the antonym of every input\",\n *   suffix: \"Input: {adjective}\\nOutput:\",\n *   inputVariables: [\"adjective\"],\n * });\n *\n * // Format the dynamic prompt with the input 'rainy'\n * console.log(await dynamicPrompt.format({ adjective: \"rainy\" }));\n *\n * ```\n */\nclass FewShotPromptTemplate extends _string_js__WEBPACK_IMPORTED_MODULE_0__.BaseStringPromptTemplate {\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"examples\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exampleSelector\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"examplePrompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"suffix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"exampleSeparator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\\n\\n\"\n        });\n        Object.defineProperty(this, \"prefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.assign(this, input);\n        if (this.examples !== undefined && this.exampleSelector !== undefined) {\n            throw new Error(\"Only one of 'examples' and 'example_selector' should be provided\");\n        }\n        if (this.examples === undefined && this.exampleSelector === undefined) {\n            throw new Error(\"One of 'examples' and 'example_selector' should be provided\");\n        }\n        if (this.validateTemplate) {\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            (0,_template_js__WEBPACK_IMPORTED_MODULE_1__.checkValidTemplate)(this.prefix + this.suffix, this.templateFormat, totalInputVariables);\n        }\n    }\n    _getPromptType() {\n        return \"few_shot\";\n    }\n    static lc_name() {\n        return \"FewShotPromptTemplate\";\n    }\n    async getExamples(inputVariables) {\n        if (this.examples !== undefined) {\n            return this.examples;\n        }\n        if (this.exampleSelector !== undefined) {\n            return this.exampleSelector.selectExamples(inputVariables);\n        }\n        throw new Error(\"One of 'examples' and 'example_selector' should be provided\");\n    }\n    async partial(values) {\n        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new FewShotPromptTemplate(promptDict);\n    }\n    /**\n     * Formats the prompt with the given values.\n     * @param values The values to format the prompt with.\n     * @returns A promise that resolves to a string representing the formatted prompt.\n     */\n    async format(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        const examples = await this.getExamples(allValues);\n        const exampleStrings = await Promise.all(examples.map((example) => this.examplePrompt.format(example)));\n        const template = [this.prefix, ...exampleStrings, this.suffix].join(this.exampleSeparator);\n        return (0,_template_js__WEBPACK_IMPORTED_MODULE_1__.renderTemplate)(template, this.templateFormat, allValues);\n    }\n    serialize() {\n        if (this.exampleSelector || !this.examples) {\n            throw new Error(\"Serializing an example selector is not currently supported\");\n        }\n        if (this.outputParser !== undefined) {\n            throw new Error(\"Serializing an output parser is not currently supported\");\n        }\n        return {\n            _type: this._getPromptType(),\n            input_variables: this.inputVariables,\n            example_prompt: this.examplePrompt.serialize(),\n            example_separator: this.exampleSeparator,\n            suffix: this.suffix,\n            prefix: this.prefix,\n            template_format: this.templateFormat,\n            examples: this.examples,\n        };\n    }\n    static async deserialize(data) {\n        const { example_prompt } = data;\n        if (!example_prompt) {\n            throw new Error(\"Missing example prompt\");\n        }\n        const examplePrompt = await _prompt_js__WEBPACK_IMPORTED_MODULE_2__.PromptTemplate.deserialize(example_prompt);\n        let examples;\n        if (Array.isArray(data.examples)) {\n            examples = data.examples;\n        }\n        else {\n            throw new Error(\"Invalid examples format. Only list or string are supported.\");\n        }\n        return new FewShotPromptTemplate({\n            inputVariables: data.input_variables,\n            examplePrompt,\n            examples,\n            exampleSeparator: data.example_separator,\n            prefix: data.prefix,\n            suffix: data.suffix,\n            templateFormat: data.template_format,\n        });\n    }\n}\n/**\n * Chat prompt template that contains few-shot examples.\n * @augments BasePromptTemplateInput\n * @augments FewShotChatMessagePromptTemplateInput\n */\nclass FewShotChatMessagePromptTemplate extends _chat_js__WEBPACK_IMPORTED_MODULE_3__.BaseChatPromptTemplate {\n    _getPromptType() {\n        return \"few_shot_chat\";\n    }\n    static lc_name() {\n        return \"FewShotChatMessagePromptTemplate\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"examples\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exampleSelector\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"examplePrompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"suffix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"exampleSeparator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\\n\\n\"\n        });\n        Object.defineProperty(this, \"prefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.examples = fields.examples;\n        this.examplePrompt = fields.examplePrompt;\n        this.exampleSeparator = fields.exampleSeparator ?? \"\\n\\n\";\n        this.exampleSelector = fields.exampleSelector;\n        this.prefix = fields.prefix ?? \"\";\n        this.suffix = fields.suffix ?? \"\";\n        this.templateFormat = fields.templateFormat ?? \"f-string\";\n        this.validateTemplate = fields.validateTemplate ?? true;\n        if (this.examples !== undefined && this.exampleSelector !== undefined) {\n            throw new Error(\"Only one of 'examples' and 'example_selector' should be provided\");\n        }\n        if (this.examples === undefined && this.exampleSelector === undefined) {\n            throw new Error(\"One of 'examples' and 'example_selector' should be provided\");\n        }\n        if (this.validateTemplate) {\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            (0,_template_js__WEBPACK_IMPORTED_MODULE_1__.checkValidTemplate)(this.prefix + this.suffix, this.templateFormat, totalInputVariables);\n        }\n    }\n    async getExamples(inputVariables) {\n        if (this.examples !== undefined) {\n            return this.examples;\n        }\n        if (this.exampleSelector !== undefined) {\n            return this.exampleSelector.selectExamples(inputVariables);\n        }\n        throw new Error(\"One of 'examples' and 'example_selector' should be provided\");\n    }\n    /**\n     * Formats the list of values and returns a list of formatted messages.\n     * @param values The values to format the prompt with.\n     * @returns A promise that resolves to a string representing the formatted prompt.\n     */\n    async formatMessages(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        let examples = await this.getExamples(allValues);\n        examples = examples.map((example) => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const result = {};\n            this.examplePrompt.inputVariables.forEach((inputVariable) => {\n                result[inputVariable] = example[inputVariable];\n            });\n            return result;\n        });\n        const messages = [];\n        for (const example of examples) {\n            const exampleMessages = await this.examplePrompt.formatMessages(example);\n            messages.push(...exampleMessages);\n        }\n        return messages;\n    }\n    /**\n     * Formats the prompt with the given values.\n     * @param values The values to format the prompt with.\n     * @returns A promise that resolves to a string representing the formatted prompt.\n     */\n    async format(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        const examples = await this.getExamples(allValues);\n        const exampleMessages = await Promise.all(examples.map((example) => this.examplePrompt.formatMessages(example)));\n        const exampleStrings = exampleMessages\n            .flat()\n            .map((message) => message.content);\n        const template = [this.prefix, ...exampleStrings, this.suffix].join(this.exampleSeparator);\n        return (0,_template_js__WEBPACK_IMPORTED_MODULE_1__.renderTemplate)(template, this.templateFormat, allValues);\n    }\n    /**\n     * Partially formats the prompt with the given values.\n     * @param values The values to partially format the prompt with.\n     * @returns A promise that resolves to an instance of `FewShotChatMessagePromptTemplate` with the given values partially formatted.\n     */\n    async partial(values) {\n        const newInputVariables = this.inputVariables.filter((variable) => !(variable in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new FewShotChatMessagePromptTemplate(promptDict);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9mZXdfc2hvdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBdUQ7QUFDYTtBQUN2QjtBQUNPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNLFdBQVcsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0JBQStCO0FBQ3hDLFNBQVMsZ0NBQWdDO0FBQ3pDLFNBQVMseUNBQXlDO0FBQ2xELFNBQVMsa0NBQWtDO0FBQzNDLFNBQVMsZ0NBQWdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0Q0FBNEMsb0JBQW9CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQyxnRUFBd0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDREQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzREFBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQ0FBK0MsNERBQXNCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccHJvbXB0c1xcZmV3X3Nob3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZVN0cmluZ1Byb21wdFRlbXBsYXRlIH0gZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBjaGVja1ZhbGlkVGVtcGxhdGUsIHJlbmRlclRlbXBsYXRlLCB9IGZyb20gXCIuL3RlbXBsYXRlLmpzXCI7XG5pbXBvcnQgeyBQcm9tcHRUZW1wbGF0ZSB9IGZyb20gXCIuL3Byb21wdC5qc1wiO1xuaW1wb3J0IHsgQmFzZUNoYXRQcm9tcHRUZW1wbGF0ZSwgfSBmcm9tIFwiLi9jaGF0LmpzXCI7XG4vKipcbiAqIFByb21wdCB0ZW1wbGF0ZSB0aGF0IGNvbnRhaW5zIGZldy1zaG90IGV4YW1wbGVzLlxuICogQGF1Z21lbnRzIEJhc2VQcm9tcHRUZW1wbGF0ZVxuICogQGF1Z21lbnRzIEZld1Nob3RQcm9tcHRUZW1wbGF0ZUlucHV0XG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgZXhhbXBsZVByb21wdCA9IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcbiAqICAgXCJJbnB1dDoge2lucHV0fVxcbk91dHB1dDoge291dHB1dH1cIixcbiAqICk7XG4gKlxuICogY29uc3QgZXhhbXBsZVNlbGVjdG9yID0gYXdhaXQgU2VtYW50aWNTaW1pbGFyaXR5RXhhbXBsZVNlbGVjdG9yLmZyb21FeGFtcGxlcyhcbiAqICAgW1xuICogICAgIHsgaW5wdXQ6IFwiaGFwcHlcIiwgb3V0cHV0OiBcInNhZFwiIH0sXG4gKiAgICAgeyBpbnB1dDogXCJ0YWxsXCIsIG91dHB1dDogXCJzaG9ydFwiIH0sXG4gKiAgICAgeyBpbnB1dDogXCJlbmVyZ2V0aWNcIiwgb3V0cHV0OiBcImxldGhhcmdpY1wiIH0sXG4gKiAgICAgeyBpbnB1dDogXCJzdW5ueVwiLCBvdXRwdXQ6IFwiZ2xvb215XCIgfSxcbiAqICAgICB7IGlucHV0OiBcIndpbmR5XCIsIG91dHB1dDogXCJjYWxtXCIgfSxcbiAqICAgXSxcbiAqICAgbmV3IE9wZW5BSUVtYmVkZGluZ3MoKSxcbiAqICAgSE5TV0xpYixcbiAqICAgeyBrOiAxIH0sXG4gKiApO1xuICpcbiAqIGNvbnN0IGR5bmFtaWNQcm9tcHQgPSBuZXcgRmV3U2hvdFByb21wdFRlbXBsYXRlKHtcbiAqICAgZXhhbXBsZVNlbGVjdG9yLFxuICogICBleGFtcGxlUHJvbXB0LFxuICogICBwcmVmaXg6IFwiR2l2ZSB0aGUgYW50b255bSBvZiBldmVyeSBpbnB1dFwiLFxuICogICBzdWZmaXg6IFwiSW5wdXQ6IHthZGplY3RpdmV9XFxuT3V0cHV0OlwiLFxuICogICBpbnB1dFZhcmlhYmxlczogW1wiYWRqZWN0aXZlXCJdLFxuICogfSk7XG4gKlxuICogLy8gRm9ybWF0IHRoZSBkeW5hbWljIHByb21wdCB3aXRoIHRoZSBpbnB1dCAncmFpbnknXG4gKiBjb25zb2xlLmxvZyhhd2FpdCBkeW5hbWljUHJvbXB0LmZvcm1hdCh7IGFkamVjdGl2ZTogXCJyYWlueVwiIH0pKTtcbiAqXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEZld1Nob3RQcm9tcHRUZW1wbGF0ZSBleHRlbmRzIEJhc2VTdHJpbmdQcm9tcHRUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoaW5wdXQpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGFtcGxlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGFtcGxlU2VsZWN0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhhbXBsZVByb21wdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdWZmaXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4YW1wbGVTZXBhcmF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiXFxuXFxuXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByZWZpeFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGVtcGxhdGVGb3JtYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiZi1zdHJpbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsaWRhdGVUZW1wbGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLmV4YW1wbGVzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5leGFtcGxlU2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgb2YgJ2V4YW1wbGVzJyBhbmQgJ2V4YW1wbGVfc2VsZWN0b3InIHNob3VsZCBiZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGFtcGxlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZXhhbXBsZVNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9uZSBvZiAnZXhhbXBsZXMnIGFuZCAnZXhhbXBsZV9zZWxlY3Rvcicgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbElucHV0VmFyaWFibGVzID0gdGhpcy5pbnB1dFZhcmlhYmxlcztcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpYWxWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB0b3RhbElucHV0VmFyaWFibGVzID0gdG90YWxJbnB1dFZhcmlhYmxlcy5jb25jYXQoT2JqZWN0LmtleXModGhpcy5wYXJ0aWFsVmFyaWFibGVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja1ZhbGlkVGVtcGxhdGUodGhpcy5wcmVmaXggKyB0aGlzLnN1ZmZpeCwgdGhpcy50ZW1wbGF0ZUZvcm1hdCwgdG90YWxJbnB1dFZhcmlhYmxlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFByb21wdFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImZld19zaG90XCI7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJGZXdTaG90UHJvbXB0VGVtcGxhdGVcIjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RXhhbXBsZXMoaW5wdXRWYXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhhbXBsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhhbXBsZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhhbXBsZVNlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4YW1wbGVTZWxlY3Rvci5zZWxlY3RFeGFtcGxlcyhpbnB1dFZhcmlhYmxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25lIG9mICdleGFtcGxlcycgYW5kICdleGFtcGxlX3NlbGVjdG9yJyBzaG91bGQgYmUgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIGFzeW5jIHBhcnRpYWwodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IG5ld0lucHV0VmFyaWFibGVzID0gdGhpcy5pbnB1dFZhcmlhYmxlcy5maWx0ZXIoKGl2KSA9PiAhKGl2IGluIHZhbHVlcykpO1xuICAgICAgICBjb25zdCBuZXdQYXJ0aWFsVmFyaWFibGVzID0ge1xuICAgICAgICAgICAgLi4uKHRoaXMucGFydGlhbFZhcmlhYmxlcyA/PyB7fSksXG4gICAgICAgICAgICAuLi52YWx1ZXMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb21wdERpY3QgPSB7XG4gICAgICAgICAgICAuLi50aGlzLFxuICAgICAgICAgICAgaW5wdXRWYXJpYWJsZXM6IG5ld0lucHV0VmFyaWFibGVzLFxuICAgICAgICAgICAgcGFydGlhbFZhcmlhYmxlczogbmV3UGFydGlhbFZhcmlhYmxlcyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBGZXdTaG90UHJvbXB0VGVtcGxhdGUocHJvbXB0RGljdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgdGhlIHByb21wdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHZhbHVlcyBUaGUgdmFsdWVzIHRvIGZvcm1hdCB0aGUgcHJvbXB0IHdpdGguXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBmb3JtYXR0ZWQgcHJvbXB0LlxuICAgICAqL1xuICAgIGFzeW5jIGZvcm1hdCh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgYWxsVmFsdWVzID0gYXdhaXQgdGhpcy5tZXJnZVBhcnRpYWxBbmRVc2VyVmFyaWFibGVzKHZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGV4YW1wbGVzID0gYXdhaXQgdGhpcy5nZXRFeGFtcGxlcyhhbGxWYWx1ZXMpO1xuICAgICAgICBjb25zdCBleGFtcGxlU3RyaW5ncyA9IGF3YWl0IFByb21pc2UuYWxsKGV4YW1wbGVzLm1hcCgoZXhhbXBsZSkgPT4gdGhpcy5leGFtcGxlUHJvbXB0LmZvcm1hdChleGFtcGxlKSkpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IFt0aGlzLnByZWZpeCwgLi4uZXhhbXBsZVN0cmluZ3MsIHRoaXMuc3VmZml4XS5qb2luKHRoaXMuZXhhbXBsZVNlcGFyYXRvcik7XG4gICAgICAgIHJldHVybiByZW5kZXJUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGhpcy50ZW1wbGF0ZUZvcm1hdCwgYWxsVmFsdWVzKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBpZiAodGhpcy5leGFtcGxlU2VsZWN0b3IgfHwgIXRoaXMuZXhhbXBsZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlcmlhbGl6aW5nIGFuIGV4YW1wbGUgc2VsZWN0b3IgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0UGFyc2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlcmlhbGl6aW5nIGFuIG91dHB1dCBwYXJzZXIgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9nZXRQcm9tcHRUeXBlKCksXG4gICAgICAgICAgICBpbnB1dF92YXJpYWJsZXM6IHRoaXMuaW5wdXRWYXJpYWJsZXMsXG4gICAgICAgICAgICBleGFtcGxlX3Byb21wdDogdGhpcy5leGFtcGxlUHJvbXB0LnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgZXhhbXBsZV9zZXBhcmF0b3I6IHRoaXMuZXhhbXBsZVNlcGFyYXRvcixcbiAgICAgICAgICAgIHN1ZmZpeDogdGhpcy5zdWZmaXgsXG4gICAgICAgICAgICBwcmVmaXg6IHRoaXMucHJlZml4LFxuICAgICAgICAgICAgdGVtcGxhdGVfZm9ybWF0OiB0aGlzLnRlbXBsYXRlRm9ybWF0LFxuICAgICAgICAgICAgZXhhbXBsZXM6IHRoaXMuZXhhbXBsZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgZXhhbXBsZV9wcm9tcHQgfSA9IGRhdGE7XG4gICAgICAgIGlmICghZXhhbXBsZV9wcm9tcHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZXhhbXBsZSBwcm9tcHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhhbXBsZVByb21wdCA9IGF3YWl0IFByb21wdFRlbXBsYXRlLmRlc2VyaWFsaXplKGV4YW1wbGVfcHJvbXB0KTtcbiAgICAgICAgbGV0IGV4YW1wbGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmV4YW1wbGVzKSkge1xuICAgICAgICAgICAgZXhhbXBsZXMgPSBkYXRhLmV4YW1wbGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBleGFtcGxlcyBmb3JtYXQuIE9ubHkgbGlzdCBvciBzdHJpbmcgYXJlIHN1cHBvcnRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGZXdTaG90UHJvbXB0VGVtcGxhdGUoe1xuICAgICAgICAgICAgaW5wdXRWYXJpYWJsZXM6IGRhdGEuaW5wdXRfdmFyaWFibGVzLFxuICAgICAgICAgICAgZXhhbXBsZVByb21wdCxcbiAgICAgICAgICAgIGV4YW1wbGVzLFxuICAgICAgICAgICAgZXhhbXBsZVNlcGFyYXRvcjogZGF0YS5leGFtcGxlX3NlcGFyYXRvcixcbiAgICAgICAgICAgIHByZWZpeDogZGF0YS5wcmVmaXgsXG4gICAgICAgICAgICBzdWZmaXg6IGRhdGEuc3VmZml4LFxuICAgICAgICAgICAgdGVtcGxhdGVGb3JtYXQ6IGRhdGEudGVtcGxhdGVfZm9ybWF0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIENoYXQgcHJvbXB0IHRlbXBsYXRlIHRoYXQgY29udGFpbnMgZmV3LXNob3QgZXhhbXBsZXMuXG4gKiBAYXVnbWVudHMgQmFzZVByb21wdFRlbXBsYXRlSW5wdXRcbiAqIEBhdWdtZW50cyBGZXdTaG90Q2hhdE1lc3NhZ2VQcm9tcHRUZW1wbGF0ZUlucHV0XG4gKi9cbmV4cG9ydCBjbGFzcyBGZXdTaG90Q2hhdE1lc3NhZ2VQcm9tcHRUZW1wbGF0ZSBleHRlbmRzIEJhc2VDaGF0UHJvbXB0VGVtcGxhdGUge1xuICAgIF9nZXRQcm9tcHRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmZXdfc2hvdF9jaGF0XCI7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJGZXdTaG90Q2hhdE1lc3NhZ2VQcm9tcHRUZW1wbGF0ZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGFtcGxlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGFtcGxlU2VsZWN0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhhbXBsZVByb21wdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdWZmaXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4YW1wbGVTZXBhcmF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiXFxuXFxuXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByZWZpeFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGVtcGxhdGVGb3JtYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiZi1zdHJpbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsaWRhdGVUZW1wbGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5leGFtcGxlcyA9IGZpZWxkcy5leGFtcGxlcztcbiAgICAgICAgdGhpcy5leGFtcGxlUHJvbXB0ID0gZmllbGRzLmV4YW1wbGVQcm9tcHQ7XG4gICAgICAgIHRoaXMuZXhhbXBsZVNlcGFyYXRvciA9IGZpZWxkcy5leGFtcGxlU2VwYXJhdG9yID8/IFwiXFxuXFxuXCI7XG4gICAgICAgIHRoaXMuZXhhbXBsZVNlbGVjdG9yID0gZmllbGRzLmV4YW1wbGVTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBmaWVsZHMucHJlZml4ID8/IFwiXCI7XG4gICAgICAgIHRoaXMuc3VmZml4ID0gZmllbGRzLnN1ZmZpeCA/PyBcIlwiO1xuICAgICAgICB0aGlzLnRlbXBsYXRlRm9ybWF0ID0gZmllbGRzLnRlbXBsYXRlRm9ybWF0ID8/IFwiZi1zdHJpbmdcIjtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVRlbXBsYXRlID0gZmllbGRzLnZhbGlkYXRlVGVtcGxhdGUgPz8gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZXhhbXBsZXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmV4YW1wbGVTZWxlY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiAnZXhhbXBsZXMnIGFuZCAnZXhhbXBsZV9zZWxlY3Rvcicgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4YW1wbGVzID09PSB1bmRlZmluZWQgJiYgdGhpcy5leGFtcGxlU2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25lIG9mICdleGFtcGxlcycgYW5kICdleGFtcGxlX3NlbGVjdG9yJyBzaG91bGQgYmUgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgbGV0IHRvdGFsSW5wdXRWYXJpYWJsZXMgPSB0aGlzLmlucHV0VmFyaWFibGVzO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFydGlhbFZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIHRvdGFsSW5wdXRWYXJpYWJsZXMgPSB0b3RhbElucHV0VmFyaWFibGVzLmNvbmNhdChPYmplY3Qua2V5cyh0aGlzLnBhcnRpYWxWYXJpYWJsZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrVmFsaWRUZW1wbGF0ZSh0aGlzLnByZWZpeCArIHRoaXMuc3VmZml4LCB0aGlzLnRlbXBsYXRlRm9ybWF0LCB0b3RhbElucHV0VmFyaWFibGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRFeGFtcGxlcyhpbnB1dFZhcmlhYmxlcykge1xuICAgICAgICBpZiAodGhpcy5leGFtcGxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leGFtcGxlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGFtcGxlU2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhhbXBsZVNlbGVjdG9yLnNlbGVjdEV4YW1wbGVzKGlucHV0VmFyaWFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmUgb2YgJ2V4YW1wbGVzJyBhbmQgJ2V4YW1wbGVfc2VsZWN0b3InIHNob3VsZCBiZSBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIHJldHVybnMgYSBsaXN0IG9mIGZvcm1hdHRlZCBtZXNzYWdlcy5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZm9ybWF0IHRoZSBwcm9tcHQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZvcm1hdHRlZCBwcm9tcHQuXG4gICAgICovXG4gICAgYXN5bmMgZm9ybWF0TWVzc2FnZXModmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGFsbFZhbHVlcyA9IGF3YWl0IHRoaXMubWVyZ2VQYXJ0aWFsQW5kVXNlclZhcmlhYmxlcyh2YWx1ZXMpO1xuICAgICAgICBsZXQgZXhhbXBsZXMgPSBhd2FpdCB0aGlzLmdldEV4YW1wbGVzKGFsbFZhbHVlcyk7XG4gICAgICAgIGV4YW1wbGVzID0gZXhhbXBsZXMubWFwKChleGFtcGxlKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVQcm9tcHQuaW5wdXRWYXJpYWJsZXMuZm9yRWFjaCgoaW5wdXRWYXJpYWJsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpbnB1dFZhcmlhYmxlXSA9IGV4YW1wbGVbaW5wdXRWYXJpYWJsZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV4YW1wbGUgb2YgZXhhbXBsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVNZXNzYWdlcyA9IGF3YWl0IHRoaXMuZXhhbXBsZVByb21wdC5mb3JtYXRNZXNzYWdlcyhleGFtcGxlKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goLi4uZXhhbXBsZU1lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgdGhlIHByb21wdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHZhbHVlcyBUaGUgdmFsdWVzIHRvIGZvcm1hdCB0aGUgcHJvbXB0IHdpdGguXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBmb3JtYXR0ZWQgcHJvbXB0LlxuICAgICAqL1xuICAgIGFzeW5jIGZvcm1hdCh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgYWxsVmFsdWVzID0gYXdhaXQgdGhpcy5tZXJnZVBhcnRpYWxBbmRVc2VyVmFyaWFibGVzKHZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGV4YW1wbGVzID0gYXdhaXQgdGhpcy5nZXRFeGFtcGxlcyhhbGxWYWx1ZXMpO1xuICAgICAgICBjb25zdCBleGFtcGxlTWVzc2FnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChleGFtcGxlcy5tYXAoKGV4YW1wbGUpID0+IHRoaXMuZXhhbXBsZVByb21wdC5mb3JtYXRNZXNzYWdlcyhleGFtcGxlKSkpO1xuICAgICAgICBjb25zdCBleGFtcGxlU3RyaW5ncyA9IGV4YW1wbGVNZXNzYWdlc1xuICAgICAgICAgICAgLmZsYXQoKVxuICAgICAgICAgICAgLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBbdGhpcy5wcmVmaXgsIC4uLmV4YW1wbGVTdHJpbmdzLCB0aGlzLnN1ZmZpeF0uam9pbih0aGlzLmV4YW1wbGVTZXBhcmF0b3IpO1xuICAgICAgICByZXR1cm4gcmVuZGVyVGVtcGxhdGUodGVtcGxhdGUsIHRoaXMudGVtcGxhdGVGb3JtYXQsIGFsbFZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnRpYWxseSBmb3JtYXRzIHRoZSBwcm9tcHQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBwYXJ0aWFsbHkgZm9ybWF0IHRoZSBwcm9tcHQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBpbnN0YW5jZSBvZiBgRmV3U2hvdENoYXRNZXNzYWdlUHJvbXB0VGVtcGxhdGVgIHdpdGggdGhlIGdpdmVuIHZhbHVlcyBwYXJ0aWFsbHkgZm9ybWF0dGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHBhcnRpYWwodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IG5ld0lucHV0VmFyaWFibGVzID0gdGhpcy5pbnB1dFZhcmlhYmxlcy5maWx0ZXIoKHZhcmlhYmxlKSA9PiAhKHZhcmlhYmxlIGluIHZhbHVlcykpO1xuICAgICAgICBjb25zdCBuZXdQYXJ0aWFsVmFyaWFibGVzID0ge1xuICAgICAgICAgICAgLi4uKHRoaXMucGFydGlhbFZhcmlhYmxlcyA/PyB7fSksXG4gICAgICAgICAgICAuLi52YWx1ZXMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb21wdERpY3QgPSB7XG4gICAgICAgICAgICAuLi50aGlzLFxuICAgICAgICAgICAgaW5wdXRWYXJpYWJsZXM6IG5ld0lucHV0VmFyaWFibGVzLFxuICAgICAgICAgICAgcGFydGlhbFZhcmlhYmxlczogbmV3UGFydGlhbFZhcmlhYmxlcyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBGZXdTaG90Q2hhdE1lc3NhZ2VQcm9tcHRUZW1wbGF0ZShwcm9tcHREaWN0KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/few_shot.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/image.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/image.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImagePromptTemplate: () => (/* binding */ ImagePromptTemplate)\n/* harmony export */ });\n/* harmony import */ var _prompt_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../prompt_values.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/base.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./template.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/template.js\");\n\n\n\n/**\n * An image prompt template for a multimodal model.\n */\nclass ImagePromptTemplate extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BasePromptTemplate {\n    static lc_name() {\n        return \"ImagePromptTemplate\";\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompts\", \"image\"]\n        });\n        Object.defineProperty(this, \"template\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * Additional fields which should be included inside\n         * the message content array if using a complex message\n         * content.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"additionalContentFields\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.template = input.template;\n        this.templateFormat = input.templateFormat ?? this.templateFormat;\n        this.validateTemplate = input.validateTemplate ?? this.validateTemplate;\n        this.additionalContentFields = input.additionalContentFields;\n        if (this.validateTemplate) {\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            (0,_template_js__WEBPACK_IMPORTED_MODULE_2__.checkValidTemplate)([\n                { type: \"image_url\", image_url: this.template },\n            ], this.templateFormat, totalInputVariables);\n        }\n    }\n    _getPromptType() {\n        return \"prompt\";\n    }\n    /**\n     * Partially applies values to the prompt template.\n     * @param values The values to be partially applied to the prompt template.\n     * @returns A new instance of ImagePromptTemplate with the partially applied values.\n     */\n    async partial(values) {\n        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new ImagePromptTemplate(promptDict);\n    }\n    /**\n     * Formats the prompt template with the provided values.\n     * @param values The values to be used to format the prompt template.\n     * @returns A promise that resolves to a string which is the formatted prompt.\n     */\n    async format(values) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const formatted = {};\n        for (const [key, value] of Object.entries(this.template)) {\n            if (typeof value === \"string\") {\n                formatted[key] = (0,_template_js__WEBPACK_IMPORTED_MODULE_2__.renderTemplate)(value, this.templateFormat, values);\n            }\n            else {\n                formatted[key] = value;\n            }\n        }\n        const url = values.url || formatted.url;\n        const detail = values.detail || formatted.detail;\n        if (!url) {\n            throw new Error(\"Must provide either an image URL.\");\n        }\n        if (typeof url !== \"string\") {\n            throw new Error(\"url must be a string.\");\n        }\n        const output = { url };\n        if (detail) {\n            output.detail = detail;\n        }\n        return output;\n    }\n    /**\n     * Formats the prompt given the input values and returns a formatted\n     * prompt value.\n     * @param values The input values to format the prompt.\n     * @returns A Promise that resolves to a formatted prompt value.\n     */\n    async formatPromptValue(values) {\n        const formattedPrompt = await this.format(values);\n        return new _prompt_values_js__WEBPACK_IMPORTED_MODULE_0__.ImagePromptValue(formattedPrompt);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9pbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVEO0FBQ1A7QUFDb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLHdEQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQWtCO0FBQzlCLGtCQUFrQiw2Q0FBNkM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0REFBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBZ0I7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxwcm9tcHRzXFxpbWFnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbWFnZVByb21wdFZhbHVlIH0gZnJvbSBcIi4uL3Byb21wdF92YWx1ZXMuanNcIjtcbmltcG9ydCB7IEJhc2VQcm9tcHRUZW1wbGF0ZSwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBjaGVja1ZhbGlkVGVtcGxhdGUsIHJlbmRlclRlbXBsYXRlLCB9IGZyb20gXCIuL3RlbXBsYXRlLmpzXCI7XG4vKipcbiAqIEFuIGltYWdlIHByb21wdCB0ZW1wbGF0ZSBmb3IgYSBtdWx0aW1vZGFsIG1vZGVsLlxuICovXG5leHBvcnQgY2xhc3MgSW1hZ2VQcm9tcHRUZW1wbGF0ZSBleHRlbmRzIEJhc2VQcm9tcHRUZW1wbGF0ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkltYWdlUHJvbXB0VGVtcGxhdGVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoaW5wdXQpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicHJvbXB0c1wiLCBcImltYWdlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZW1wbGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZW1wbGF0ZUZvcm1hdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJmLXN0cmluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWxpZGF0ZVRlbXBsYXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCBmaWVsZHMgd2hpY2ggc2hvdWxkIGJlIGluY2x1ZGVkIGluc2lkZVxuICAgICAgICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IGFycmF5IGlmIHVzaW5nIGEgY29tcGxleCBtZXNzYWdlXG4gICAgICAgICAqIGNvbnRlbnQuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhZGRpdGlvbmFsQ29udGVudEZpZWxkc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gaW5wdXQudGVtcGxhdGU7XG4gICAgICAgIHRoaXMudGVtcGxhdGVGb3JtYXQgPSBpbnB1dC50ZW1wbGF0ZUZvcm1hdCA/PyB0aGlzLnRlbXBsYXRlRm9ybWF0O1xuICAgICAgICB0aGlzLnZhbGlkYXRlVGVtcGxhdGUgPSBpbnB1dC52YWxpZGF0ZVRlbXBsYXRlID8/IHRoaXMudmFsaWRhdGVUZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsQ29udGVudEZpZWxkcyA9IGlucHV0LmFkZGl0aW9uYWxDb250ZW50RmllbGRzO1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZVRlbXBsYXRlKSB7XG4gICAgICAgICAgICBsZXQgdG90YWxJbnB1dFZhcmlhYmxlcyA9IHRoaXMuaW5wdXRWYXJpYWJsZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWFsVmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgdG90YWxJbnB1dFZhcmlhYmxlcyA9IHRvdGFsSW5wdXRWYXJpYWJsZXMuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMucGFydGlhbFZhcmlhYmxlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tWYWxpZFRlbXBsYXRlKFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFwiaW1hZ2VfdXJsXCIsIGltYWdlX3VybDogdGhpcy50ZW1wbGF0ZSB9LFxuICAgICAgICAgICAgXSwgdGhpcy50ZW1wbGF0ZUZvcm1hdCwgdG90YWxJbnB1dFZhcmlhYmxlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFByb21wdFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcInByb21wdFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJ0aWFsbHkgYXBwbGllcyB2YWx1ZXMgdG8gdGhlIHByb21wdCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQgdG8gdGhlIHByb21wdCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiBJbWFnZVByb21wdFRlbXBsYXRlIHdpdGggdGhlIHBhcnRpYWxseSBhcHBsaWVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBhc3luYyBwYXJ0aWFsKHZhbHVlcykge1xuICAgICAgICBjb25zdCBuZXdJbnB1dFZhcmlhYmxlcyA9IHRoaXMuaW5wdXRWYXJpYWJsZXMuZmlsdGVyKChpdikgPT4gIShpdiBpbiB2YWx1ZXMpKTtcbiAgICAgICAgY29uc3QgbmV3UGFydGlhbFZhcmlhYmxlcyA9IHtcbiAgICAgICAgICAgIC4uLih0aGlzLnBhcnRpYWxWYXJpYWJsZXMgPz8ge30pLFxuICAgICAgICAgICAgLi4udmFsdWVzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm9tcHREaWN0ID0ge1xuICAgICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAgIGlucHV0VmFyaWFibGVzOiBuZXdJbnB1dFZhcmlhYmxlcyxcbiAgICAgICAgICAgIHBhcnRpYWxWYXJpYWJsZXM6IG5ld1BhcnRpYWxWYXJpYWJsZXMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VQcm9tcHRUZW1wbGF0ZShwcm9tcHREaWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyB0aGUgcHJvbXB0IHRlbXBsYXRlIHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYmUgdXNlZCB0byBmb3JtYXQgdGhlIHByb21wdCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHN0cmluZyB3aGljaCBpcyB0aGUgZm9ybWF0dGVkIHByb21wdC5cbiAgICAgKi9cbiAgICBhc3luYyBmb3JtYXQodmFsdWVzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnRlbXBsYXRlKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFtrZXldID0gcmVuZGVyVGVtcGxhdGUodmFsdWUsIHRoaXMudGVtcGxhdGVGb3JtYXQsIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IHZhbHVlcy51cmwgfHwgZm9ybWF0dGVkLnVybDtcbiAgICAgICAgY29uc3QgZGV0YWlsID0gdmFsdWVzLmRldGFpbCB8fCBmb3JtYXR0ZWQuZGV0YWlsO1xuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBhbiBpbWFnZSBVUkwuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cmwgbXVzdCBiZSBhIHN0cmluZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0geyB1cmwgfTtcbiAgICAgICAgaWYgKGRldGFpbCkge1xuICAgICAgICAgICAgb3V0cHV0LmRldGFpbCA9IGRldGFpbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIHRoZSBwcm9tcHQgZ2l2ZW4gdGhlIGlucHV0IHZhbHVlcyBhbmQgcmV0dXJucyBhIGZvcm1hdHRlZFxuICAgICAqIHByb21wdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIFRoZSBpbnB1dCB2YWx1ZXMgdG8gZm9ybWF0IHRoZSBwcm9tcHQuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBmb3JtYXR0ZWQgcHJvbXB0IHZhbHVlLlxuICAgICAqL1xuICAgIGFzeW5jIGZvcm1hdFByb21wdFZhbHVlKHZhbHVlcykge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRQcm9tcHQgPSBhd2FpdCB0aGlzLmZvcm1hdCh2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IEltYWdlUHJvbXB0VmFsdWUoZm9ybWF0dGVkUHJvbXB0KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/image.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIMessagePromptTemplate: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_1__.AIMessagePromptTemplate),\n/* harmony export */   BaseChatPromptTemplate: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_1__.BaseChatPromptTemplate),\n/* harmony export */   BaseMessagePromptTemplate: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessagePromptTemplate),\n/* harmony export */   BaseMessageStringPromptTemplate: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessageStringPromptTemplate),\n/* harmony export */   BasePromptTemplate: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.BasePromptTemplate),\n/* harmony export */   BaseStringPromptTemplate: () => (/* reexport safe */ _string_js__WEBPACK_IMPORTED_MODULE_6__.BaseStringPromptTemplate),\n/* harmony export */   ChatMessagePromptTemplate: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_1__.ChatMessagePromptTemplate),\n/* harmony export */   ChatPromptTemplate: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_1__.ChatPromptTemplate),\n/* harmony export */   DEFAULT_FORMATTER_MAPPING: () => (/* reexport safe */ _template_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_FORMATTER_MAPPING),\n/* harmony export */   DEFAULT_PARSER_MAPPING: () => (/* reexport safe */ _template_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_PARSER_MAPPING),\n/* harmony export */   DictPromptTemplate: () => (/* reexport safe */ _dict_js__WEBPACK_IMPORTED_MODULE_10__.DictPromptTemplate),\n/* harmony export */   FewShotChatMessagePromptTemplate: () => (/* reexport safe */ _few_shot_js__WEBPACK_IMPORTED_MODULE_2__.FewShotChatMessagePromptTemplate),\n/* harmony export */   FewShotPromptTemplate: () => (/* reexport safe */ _few_shot_js__WEBPACK_IMPORTED_MODULE_2__.FewShotPromptTemplate),\n/* harmony export */   HumanMessagePromptTemplate: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_1__.HumanMessagePromptTemplate),\n/* harmony export */   ImagePromptTemplate: () => (/* reexport safe */ _image_js__WEBPACK_IMPORTED_MODULE_8__.ImagePromptTemplate),\n/* harmony export */   MessagesPlaceholder: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_1__.MessagesPlaceholder),\n/* harmony export */   PipelinePromptTemplate: () => (/* reexport safe */ _pipeline_js__WEBPACK_IMPORTED_MODULE_3__.PipelinePromptTemplate),\n/* harmony export */   PromptTemplate: () => (/* reexport safe */ _prompt_js__WEBPACK_IMPORTED_MODULE_4__.PromptTemplate),\n/* harmony export */   StructuredPrompt: () => (/* reexport safe */ _structured_js__WEBPACK_IMPORTED_MODULE_9__.StructuredPrompt),\n/* harmony export */   SystemMessagePromptTemplate: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_1__.SystemMessagePromptTemplate),\n/* harmony export */   checkValidTemplate: () => (/* reexport safe */ _template_js__WEBPACK_IMPORTED_MODULE_7__.checkValidTemplate),\n/* harmony export */   interpolateFString: () => (/* reexport safe */ _template_js__WEBPACK_IMPORTED_MODULE_7__.interpolateFString),\n/* harmony export */   interpolateMustache: () => (/* reexport safe */ _template_js__WEBPACK_IMPORTED_MODULE_7__.interpolateMustache),\n/* harmony export */   parseFString: () => (/* reexport safe */ _template_js__WEBPACK_IMPORTED_MODULE_7__.parseFString),\n/* harmony export */   parseMustache: () => (/* reexport safe */ _template_js__WEBPACK_IMPORTED_MODULE_7__.parseMustache),\n/* harmony export */   parseTemplate: () => (/* reexport safe */ _template_js__WEBPACK_IMPORTED_MODULE_7__.parseTemplate),\n/* harmony export */   renderTemplate: () => (/* reexport safe */ _template_js__WEBPACK_IMPORTED_MODULE_7__.renderTemplate)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/base.js\");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chat.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/chat.js\");\n/* harmony import */ var _few_shot_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./few_shot.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/few_shot.js\");\n/* harmony import */ var _pipeline_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pipeline.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/pipeline.js\");\n/* harmony import */ var _prompt_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./prompt.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/prompt.js\");\n/* harmony import */ var _serde_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./serde.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/serde.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/string.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./template.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/template.js\");\n/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./image.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/image.js\");\n/* harmony import */ var _structured_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./structured.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/structured.js\");\n/* harmony import */ var _dict_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./dict.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/dict.js\");\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUNBO0FBQ0k7QUFDQTtBQUNGO0FBQ0Q7QUFDQztBQUNFO0FBQ0g7QUFDSztBQUNOIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHByb21wdHNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2Jhc2UuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NoYXQuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Zld19zaG90LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9waXBlbGluZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vcHJvbXB0LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXJkZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90ZW1wbGF0ZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW1hZ2UuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N0cnVjdHVyZWQuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RpY3QuanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/pipeline.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/pipeline.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PipelinePromptTemplate: () => (/* binding */ PipelinePromptTemplate)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/base.js\");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chat.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/chat.js\");\n\n\n/**\n * Class that handles a sequence of prompts, each of which may require\n * different input variables. Includes methods for formatting these\n * prompts, extracting required input values, and handling partial\n * prompts.\n * @example\n * ```typescript\n * const composedPrompt = new PipelinePromptTemplate({\n *   pipelinePrompts: [\n *     {\n *       name: \"introduction\",\n *       prompt: PromptTemplate.fromTemplate(`You are impersonating {person}.`),\n *     },\n *     {\n *       name: \"example\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Here's an example of an interaction:\n * Q: {example_q}\n * A: {example_a}`,\n *       ),\n *     },\n *     {\n *       name: \"start\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Now, do this for real!\n * Q: {input}\n * A:`,\n *       ),\n *     },\n *   ],\n *   finalPrompt: PromptTemplate.fromTemplate(\n *     `{introduction}\n * {example}\n * {start}`,\n *   ),\n * });\n *\n * const formattedPrompt = await composedPrompt.format({\n *   person: \"Elon Musk\",\n *   example_q: `What's your favorite car?`,\n *   example_a: \"Tesla\",\n *   input: `What's your favorite social media site?`,\n * });\n * ```\n */\nclass PipelinePromptTemplate extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BasePromptTemplate {\n    static lc_name() {\n        return \"PipelinePromptTemplate\";\n    }\n    constructor(input) {\n        super({ ...input, inputVariables: [] });\n        Object.defineProperty(this, \"pipelinePrompts\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"finalPrompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.pipelinePrompts = input.pipelinePrompts;\n        this.finalPrompt = input.finalPrompt;\n        this.inputVariables = this.computeInputValues();\n    }\n    /**\n     * Computes the input values required by the pipeline prompts.\n     * @returns Array of input values required by the pipeline prompts.\n     */\n    computeInputValues() {\n        const intermediateValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.name);\n        const inputValues = this.pipelinePrompts\n            .map((pipelinePrompt) => pipelinePrompt.prompt.inputVariables.filter((inputValue) => !intermediateValues.includes(inputValue)))\n            .flat();\n        return [...new Set(inputValues)];\n    }\n    static extractRequiredInputValues(allValues, requiredValueNames) {\n        return requiredValueNames.reduce((requiredValues, valueName) => {\n            // eslint-disable-next-line no-param-reassign\n            requiredValues[valueName] = allValues[valueName];\n            return requiredValues;\n        }, {});\n    }\n    /**\n     * Formats the pipeline prompts based on the provided input values.\n     * @param values Input values to format the pipeline prompts.\n     * @returns Promise that resolves with the formatted input values.\n     */\n    async formatPipelinePrompts(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this\n            .pipelinePrompts) {\n            const pipelinePromptInputValues = PipelinePromptTemplate.extractRequiredInputValues(allValues, pipelinePrompt.inputVariables);\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (pipelinePrompt instanceof _chat_js__WEBPACK_IMPORTED_MODULE_1__.ChatPromptTemplate) {\n                allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(pipelinePromptInputValues);\n            }\n            else {\n                allValues[pipelinePromptName] = await pipelinePrompt.format(pipelinePromptInputValues);\n            }\n        }\n        return PipelinePromptTemplate.extractRequiredInputValues(allValues, this.finalPrompt.inputVariables);\n    }\n    /**\n     * Formats the final prompt value based on the provided input values.\n     * @param values Input values to format the final prompt value.\n     * @returns Promise that resolves with the formatted final prompt value.\n     */\n    async formatPromptValue(values) {\n        return this.finalPrompt.formatPromptValue(await this.formatPipelinePrompts(values));\n    }\n    async format(values) {\n        return this.finalPrompt.format(await this.formatPipelinePrompts(values));\n    }\n    /**\n     * Handles partial prompts, which are prompts that have been partially\n     * filled with input values.\n     * @param values Partial input values.\n     * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.\n     */\n    async partial(values) {\n        const promptDict = { ...this };\n        promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        promptDict.partialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        return new PipelinePromptTemplate(promptDict);\n    }\n    serialize() {\n        throw new Error(\"Not implemented.\");\n    }\n    _getPromptType() {\n        return \"pipeline\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9waXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDQTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE9BQU87QUFDNUUsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE9BQU8sVUFBVTtBQUNqQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsSUFBSTtBQUNKLElBQUksTUFBTTtBQUNWO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ08scUNBQXFDLHdEQUFrQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0RBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHByb21wdHNcXHBpcGVsaW5lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VQcm9tcHRUZW1wbGF0ZSB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IENoYXRQcm9tcHRUZW1wbGF0ZSB9IGZyb20gXCIuL2NoYXQuanNcIjtcbi8qKlxuICogQ2xhc3MgdGhhdCBoYW5kbGVzIGEgc2VxdWVuY2Ugb2YgcHJvbXB0cywgZWFjaCBvZiB3aGljaCBtYXkgcmVxdWlyZVxuICogZGlmZmVyZW50IGlucHV0IHZhcmlhYmxlcy4gSW5jbHVkZXMgbWV0aG9kcyBmb3IgZm9ybWF0dGluZyB0aGVzZVxuICogcHJvbXB0cywgZXh0cmFjdGluZyByZXF1aXJlZCBpbnB1dCB2YWx1ZXMsIGFuZCBoYW5kbGluZyBwYXJ0aWFsXG4gKiBwcm9tcHRzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGNvbXBvc2VkUHJvbXB0ID0gbmV3IFBpcGVsaW5lUHJvbXB0VGVtcGxhdGUoe1xuICogICBwaXBlbGluZVByb21wdHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiBcImludHJvZHVjdGlvblwiLFxuICogICAgICAgcHJvbXB0OiBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoYFlvdSBhcmUgaW1wZXJzb25hdGluZyB7cGVyc29ufS5gKSxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6IFwiZXhhbXBsZVwiLFxuICogICAgICAgcHJvbXB0OiBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXG4gKiAgICAgICAgIGBIZXJlJ3MgYW4gZXhhbXBsZSBvZiBhbiBpbnRlcmFjdGlvbjpcbiAqIFE6IHtleGFtcGxlX3F9XG4gKiBBOiB7ZXhhbXBsZV9hfWAsXG4gKiAgICAgICApLFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgbmFtZTogXCJzdGFydFwiLFxuICogICAgICAgcHJvbXB0OiBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXG4gKiAgICAgICAgIGBOb3csIGRvIHRoaXMgZm9yIHJlYWwhXG4gKiBROiB7aW5wdXR9XG4gKiBBOmAsXG4gKiAgICAgICApLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIGZpbmFsUHJvbXB0OiBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXG4gKiAgICAgYHtpbnRyb2R1Y3Rpb259XG4gKiB7ZXhhbXBsZX1cbiAqIHtzdGFydH1gLFxuICogICApLFxuICogfSk7XG4gKlxuICogY29uc3QgZm9ybWF0dGVkUHJvbXB0ID0gYXdhaXQgY29tcG9zZWRQcm9tcHQuZm9ybWF0KHtcbiAqICAgcGVyc29uOiBcIkVsb24gTXVza1wiLFxuICogICBleGFtcGxlX3E6IGBXaGF0J3MgeW91ciBmYXZvcml0ZSBjYXI/YCxcbiAqICAgZXhhbXBsZV9hOiBcIlRlc2xhXCIsXG4gKiAgIGlucHV0OiBgV2hhdCdzIHlvdXIgZmF2b3JpdGUgc29jaWFsIG1lZGlhIHNpdGU/YCxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBQaXBlbGluZVByb21wdFRlbXBsYXRlIGV4dGVuZHMgQmFzZVByb21wdFRlbXBsYXRlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUGlwZWxpbmVQcm9tcHRUZW1wbGF0ZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBzdXBlcih7IC4uLmlucHV0LCBpbnB1dFZhcmlhYmxlczogW10gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBpcGVsaW5lUHJvbXB0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaW5hbFByb21wdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBpcGVsaW5lUHJvbXB0cyA9IGlucHV0LnBpcGVsaW5lUHJvbXB0cztcbiAgICAgICAgdGhpcy5maW5hbFByb21wdCA9IGlucHV0LmZpbmFsUHJvbXB0O1xuICAgICAgICB0aGlzLmlucHV0VmFyaWFibGVzID0gdGhpcy5jb21wdXRlSW5wdXRWYWx1ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGlucHV0IHZhbHVlcyByZXF1aXJlZCBieSB0aGUgcGlwZWxpbmUgcHJvbXB0cy5cbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBpbnB1dCB2YWx1ZXMgcmVxdWlyZWQgYnkgdGhlIHBpcGVsaW5lIHByb21wdHMuXG4gICAgICovXG4gICAgY29tcHV0ZUlucHV0VmFsdWVzKCkge1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVWYWx1ZXMgPSB0aGlzLnBpcGVsaW5lUHJvbXB0cy5tYXAoKHBpcGVsaW5lUHJvbXB0KSA9PiBwaXBlbGluZVByb21wdC5uYW1lKTtcbiAgICAgICAgY29uc3QgaW5wdXRWYWx1ZXMgPSB0aGlzLnBpcGVsaW5lUHJvbXB0c1xuICAgICAgICAgICAgLm1hcCgocGlwZWxpbmVQcm9tcHQpID0+IHBpcGVsaW5lUHJvbXB0LnByb21wdC5pbnB1dFZhcmlhYmxlcy5maWx0ZXIoKGlucHV0VmFsdWUpID0+ICFpbnRlcm1lZGlhdGVWYWx1ZXMuaW5jbHVkZXMoaW5wdXRWYWx1ZSkpKVxuICAgICAgICAgICAgLmZsYXQoKTtcbiAgICAgICAgcmV0dXJuIFsuLi5uZXcgU2V0KGlucHV0VmFsdWVzKV07XG4gICAgfVxuICAgIHN0YXRpYyBleHRyYWN0UmVxdWlyZWRJbnB1dFZhbHVlcyhhbGxWYWx1ZXMsIHJlcXVpcmVkVmFsdWVOYW1lcykge1xuICAgICAgICByZXR1cm4gcmVxdWlyZWRWYWx1ZU5hbWVzLnJlZHVjZSgocmVxdWlyZWRWYWx1ZXMsIHZhbHVlTmFtZSkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICByZXF1aXJlZFZhbHVlc1t2YWx1ZU5hbWVdID0gYWxsVmFsdWVzW3ZhbHVlTmFtZV07XG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZWRWYWx1ZXM7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyB0aGUgcGlwZWxpbmUgcHJvbXB0cyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgaW5wdXQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgSW5wdXQgdmFsdWVzIHRvIGZvcm1hdCB0aGUgcGlwZWxpbmUgcHJvbXB0cy5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZm9ybWF0dGVkIGlucHV0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBhc3luYyBmb3JtYXRQaXBlbGluZVByb21wdHModmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGFsbFZhbHVlcyA9IGF3YWl0IHRoaXMubWVyZ2VQYXJ0aWFsQW5kVXNlclZhcmlhYmxlcyh2YWx1ZXMpO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZTogcGlwZWxpbmVQcm9tcHROYW1lLCBwcm9tcHQ6IHBpcGVsaW5lUHJvbXB0IH0gb2YgdGhpc1xuICAgICAgICAgICAgLnBpcGVsaW5lUHJvbXB0cykge1xuICAgICAgICAgICAgY29uc3QgcGlwZWxpbmVQcm9tcHRJbnB1dFZhbHVlcyA9IFBpcGVsaW5lUHJvbXB0VGVtcGxhdGUuZXh0cmFjdFJlcXVpcmVkSW5wdXRWYWx1ZXMoYWxsVmFsdWVzLCBwaXBlbGluZVByb21wdC5pbnB1dFZhcmlhYmxlcyk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAocGlwZWxpbmVQcm9tcHQgaW5zdGFuY2VvZiBDaGF0UHJvbXB0VGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBhbGxWYWx1ZXNbcGlwZWxpbmVQcm9tcHROYW1lXSA9IGF3YWl0IHBpcGVsaW5lUHJvbXB0LmZvcm1hdE1lc3NhZ2VzKHBpcGVsaW5lUHJvbXB0SW5wdXRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxsVmFsdWVzW3BpcGVsaW5lUHJvbXB0TmFtZV0gPSBhd2FpdCBwaXBlbGluZVByb21wdC5mb3JtYXQocGlwZWxpbmVQcm9tcHRJbnB1dFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBpcGVsaW5lUHJvbXB0VGVtcGxhdGUuZXh0cmFjdFJlcXVpcmVkSW5wdXRWYWx1ZXMoYWxsVmFsdWVzLCB0aGlzLmZpbmFsUHJvbXB0LmlucHV0VmFyaWFibGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyB0aGUgZmluYWwgcHJvbXB0IHZhbHVlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBpbnB1dCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHZhbHVlcyBJbnB1dCB2YWx1ZXMgdG8gZm9ybWF0IHRoZSBmaW5hbCBwcm9tcHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGZvcm1hdHRlZCBmaW5hbCBwcm9tcHQgdmFsdWUuXG4gICAgICovXG4gICAgYXN5bmMgZm9ybWF0UHJvbXB0VmFsdWUodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmFsUHJvbXB0LmZvcm1hdFByb21wdFZhbHVlKGF3YWl0IHRoaXMuZm9ybWF0UGlwZWxpbmVQcm9tcHRzKHZhbHVlcykpO1xuICAgIH1cbiAgICBhc3luYyBmb3JtYXQodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmFsUHJvbXB0LmZvcm1hdChhd2FpdCB0aGlzLmZvcm1hdFBpcGVsaW5lUHJvbXB0cyh2YWx1ZXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBwYXJ0aWFsIHByb21wdHMsIHdoaWNoIGFyZSBwcm9tcHRzIHRoYXQgaGF2ZSBiZWVuIHBhcnRpYWxseVxuICAgICAqIGZpbGxlZCB3aXRoIGlucHV0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIFBhcnRpYWwgaW5wdXQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgbmV3IFBpcGVsaW5lUHJvbXB0VGVtcGxhdGUgaW5zdGFuY2Ugd2l0aCB1cGRhdGVkIGlucHV0IHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBhc3luYyBwYXJ0aWFsKHZhbHVlcykge1xuICAgICAgICBjb25zdCBwcm9tcHREaWN0ID0geyAuLi50aGlzIH07XG4gICAgICAgIHByb21wdERpY3QuaW5wdXRWYXJpYWJsZXMgPSB0aGlzLmlucHV0VmFyaWFibGVzLmZpbHRlcigoaXYpID0+ICEoaXYgaW4gdmFsdWVzKSk7XG4gICAgICAgIHByb21wdERpY3QucGFydGlhbFZhcmlhYmxlcyA9IHtcbiAgICAgICAgICAgIC4uLih0aGlzLnBhcnRpYWxWYXJpYWJsZXMgPz8ge30pLFxuICAgICAgICAgICAgLi4udmFsdWVzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFBpcGVsaW5lUHJvbXB0VGVtcGxhdGUocHJvbXB0RGljdCk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgX2dldFByb21wdFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcInBpcGVsaW5lXCI7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/pipeline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/prompt.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/prompt.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PromptTemplate: () => (/* binding */ PromptTemplate)\n/* harmony export */ });\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/string.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/template.js\");\n// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\n\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nclass PromptTemplate extends _string_js__WEBPACK_IMPORTED_MODULE_0__.BaseStringPromptTemplate {\n    static lc_name() {\n        return \"PromptTemplate\";\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"template\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * Additional fields which should be included inside\n         * the message content array if using a complex message\n         * content.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"additionalContentFields\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If input is mustache and validateTemplate is not defined, set it to false\n        if (input.templateFormat === \"mustache\" &&\n            input.validateTemplate === undefined) {\n            this.validateTemplate = false;\n        }\n        Object.assign(this, input);\n        if (this.validateTemplate) {\n            if (this.templateFormat === \"mustache\") {\n                throw new Error(\"Mustache templates cannot be validated.\");\n            }\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            (0,_template_js__WEBPACK_IMPORTED_MODULE_1__.checkValidTemplate)(this.template, this.templateFormat, totalInputVariables);\n        }\n    }\n    _getPromptType() {\n        return \"prompt\";\n    }\n    /**\n     * Formats the prompt template with the provided values.\n     * @param values The values to be used to format the prompt template.\n     * @returns A promise that resolves to a string which is the formatted prompt.\n     */\n    async format(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        return (0,_template_js__WEBPACK_IMPORTED_MODULE_1__.renderTemplate)(this.template, this.templateFormat, allValues);\n    }\n    /**\n     * Take examples in list format with prefix and suffix to create a prompt.\n     *\n     * Intended to be used a a way to dynamically create a prompt from examples.\n     *\n     * @param examples - List of examples to use in the prompt.\n     * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n     * @param inputVariables - A list of variable names the final prompt template will expect\n     * @param exampleSeparator - The separator to use in between examples\n     * @param prefix - String that should go before any examples. Generally includes examples.\n     *\n     * @returns The final prompt template generated.\n     */\n    static fromExamples(examples, suffix, inputVariables, exampleSeparator = \"\\n\\n\", prefix = \"\") {\n        const template = [prefix, ...examples, suffix].join(exampleSeparator);\n        return new PromptTemplate({\n            inputVariables,\n            template,\n        });\n    }\n    static fromTemplate(template, options) {\n        const { templateFormat = \"f-string\", ...rest } = options ?? {};\n        const names = new Set();\n        (0,_template_js__WEBPACK_IMPORTED_MODULE_1__.parseTemplate)(template, templateFormat).forEach((node) => {\n            if (node.type === \"variable\") {\n                names.add(node.name);\n            }\n        });\n        return new PromptTemplate({\n            // Rely on extracted types\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            inputVariables: [...names],\n            templateFormat,\n            template,\n            ...rest,\n        });\n    }\n    /**\n     * Partially applies values to the prompt template.\n     * @param values The values to be partially applied to the prompt template.\n     * @returns A new instance of PromptTemplate with the partially applied values.\n     */\n    async partial(values) {\n        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new PromptTemplate(promptDict);\n    }\n    serialize() {\n        if (this.outputParser !== undefined) {\n            throw new Error(\"Cannot serialize a prompt template with an output parser\");\n        }\n        return {\n            _type: this._getPromptType(),\n            input_variables: this.inputVariables,\n            template: this.template,\n            template_format: this.templateFormat,\n        };\n    }\n    static async deserialize(data) {\n        if (!data.template) {\n            throw new Error(\"Prompt template must have a template\");\n        }\n        const res = new PromptTemplate({\n            inputVariables: data.input_variables,\n            template: data.template,\n            templateFormat: data.template_format,\n        });\n        return res;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9wcm9tcHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUN1RDtBQUM0QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCLElBQUk7QUFDSjtBQUNBO0FBQ08sNkJBQTZCLGdFQUF3QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBLFFBQVEsMkRBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccHJvbXB0c1xccHJvbXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERlZmF1bHQgZ2VuZXJpYyBcImFueVwiIHZhbHVlcyBhcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuLy8gUmVwbGFjZSB3aXRoIFwic3RyaW5nXCIgd2hlbiB3ZSBhcmUgY29tZm9ydGFibGUgd2l0aCBhIGJyZWFraW5nIGNoYW5nZS5cbmltcG9ydCB7IEJhc2VTdHJpbmdQcm9tcHRUZW1wbGF0ZSB9IGZyb20gXCIuL3N0cmluZy5qc1wiO1xuaW1wb3J0IHsgY2hlY2tWYWxpZFRlbXBsYXRlLCBwYXJzZVRlbXBsYXRlLCByZW5kZXJUZW1wbGF0ZSwgfSBmcm9tIFwiLi90ZW1wbGF0ZS5qc1wiO1xuLyoqXG4gKiBTY2hlbWEgdG8gcmVwcmVzZW50IGEgYmFzaWMgcHJvbXB0IGZvciBhbiBMTE0uXG4gKiBAYXVnbWVudHMgQmFzZVByb21wdFRlbXBsYXRlXG4gKiBAYXVnbWVudHMgUHJvbXB0VGVtcGxhdGVJbnB1dFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUHJvbXB0VGVtcGxhdGUgfSBmcm9tIFwibGFuZ2NoYWluL3Byb21wdHNcIjtcbiAqXG4gKiBjb25zdCBwcm9tcHQgPSBuZXcgUHJvbXB0VGVtcGxhdGUoe1xuICogICBpbnB1dFZhcmlhYmxlczogW1wiZm9vXCJdLFxuICogICB0ZW1wbGF0ZTogXCJTYXkge2Zvb31cIixcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9tcHRUZW1wbGF0ZSBleHRlbmRzIEJhc2VTdHJpbmdQcm9tcHRUZW1wbGF0ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlByb21wdFRlbXBsYXRlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHN1cGVyKGlucHV0KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGVtcGxhdGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGVtcGxhdGVGb3JtYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiZi1zdHJpbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsaWRhdGVUZW1wbGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgZmllbGRzIHdoaWNoIHNob3VsZCBiZSBpbmNsdWRlZCBpbnNpZGVcbiAgICAgICAgICogdGhlIG1lc3NhZ2UgY29udGVudCBhcnJheSBpZiB1c2luZyBhIGNvbXBsZXggbWVzc2FnZVxuICAgICAgICAgKiBjb250ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRkaXRpb25hbENvbnRlbnRGaWVsZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgaW5wdXQgaXMgbXVzdGFjaGUgYW5kIHZhbGlkYXRlVGVtcGxhdGUgaXMgbm90IGRlZmluZWQsIHNldCBpdCB0byBmYWxzZVxuICAgICAgICBpZiAoaW5wdXQudGVtcGxhdGVGb3JtYXQgPT09IFwibXVzdGFjaGVcIiAmJlxuICAgICAgICAgICAgaW5wdXQudmFsaWRhdGVUZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlVGVtcGxhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGVtcGxhdGVGb3JtYXQgPT09IFwibXVzdGFjaGVcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3RhY2hlIHRlbXBsYXRlcyBjYW5ub3QgYmUgdmFsaWRhdGVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3RhbElucHV0VmFyaWFibGVzID0gdGhpcy5pbnB1dFZhcmlhYmxlcztcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpYWxWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB0b3RhbElucHV0VmFyaWFibGVzID0gdG90YWxJbnB1dFZhcmlhYmxlcy5jb25jYXQoT2JqZWN0LmtleXModGhpcy5wYXJ0aWFsVmFyaWFibGVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja1ZhbGlkVGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgdGhpcy50ZW1wbGF0ZUZvcm1hdCwgdG90YWxJbnB1dFZhcmlhYmxlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFByb21wdFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcInByb21wdFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIHRoZSBwcm9tcHQgdGVtcGxhdGUgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBiZSB1c2VkIHRvIGZvcm1hdCB0aGUgcHJvbXB0IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nIHdoaWNoIGlzIHRoZSBmb3JtYXR0ZWQgcHJvbXB0LlxuICAgICAqL1xuICAgIGFzeW5jIGZvcm1hdCh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgYWxsVmFsdWVzID0gYXdhaXQgdGhpcy5tZXJnZVBhcnRpYWxBbmRVc2VyVmFyaWFibGVzKHZhbHVlcyk7XG4gICAgICAgIHJldHVybiByZW5kZXJUZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCB0aGlzLnRlbXBsYXRlRm9ybWF0LCBhbGxWYWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlIGV4YW1wbGVzIGluIGxpc3QgZm9ybWF0IHdpdGggcHJlZml4IGFuZCBzdWZmaXggdG8gY3JlYXRlIGEgcHJvbXB0LlxuICAgICAqXG4gICAgICogSW50ZW5kZWQgdG8gYmUgdXNlZCBhIGEgd2F5IHRvIGR5bmFtaWNhbGx5IGNyZWF0ZSBhIHByb21wdCBmcm9tIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV4YW1wbGVzIC0gTGlzdCBvZiBleGFtcGxlcyB0byB1c2UgaW4gdGhlIHByb21wdC5cbiAgICAgKiBAcGFyYW0gc3VmZml4IC0gU3RyaW5nIHRvIGdvIGFmdGVyIHRoZSBsaXN0IG9mIGV4YW1wbGVzLiBTaG91bGQgZ2VuZXJhbGx5IHNldCB1cCB0aGUgdXNlcidzIGlucHV0LlxuICAgICAqIEBwYXJhbSBpbnB1dFZhcmlhYmxlcyAtIEEgbGlzdCBvZiB2YXJpYWJsZSBuYW1lcyB0aGUgZmluYWwgcHJvbXB0IHRlbXBsYXRlIHdpbGwgZXhwZWN0XG4gICAgICogQHBhcmFtIGV4YW1wbGVTZXBhcmF0b3IgLSBUaGUgc2VwYXJhdG9yIHRvIHVzZSBpbiBiZXR3ZWVuIGV4YW1wbGVzXG4gICAgICogQHBhcmFtIHByZWZpeCAtIFN0cmluZyB0aGF0IHNob3VsZCBnbyBiZWZvcmUgYW55IGV4YW1wbGVzLiBHZW5lcmFsbHkgaW5jbHVkZXMgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZmluYWwgcHJvbXB0IHRlbXBsYXRlIGdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUV4YW1wbGVzKGV4YW1wbGVzLCBzdWZmaXgsIGlucHV0VmFyaWFibGVzLCBleGFtcGxlU2VwYXJhdG9yID0gXCJcXG5cXG5cIiwgcHJlZml4ID0gXCJcIikge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IFtwcmVmaXgsIC4uLmV4YW1wbGVzLCBzdWZmaXhdLmpvaW4oZXhhbXBsZVNlcGFyYXRvcik7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbXB0VGVtcGxhdGUoe1xuICAgICAgICAgICAgaW5wdXRWYXJpYWJsZXMsXG4gICAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVGVtcGxhdGUodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB0ZW1wbGF0ZUZvcm1hdCA9IFwiZi1zdHJpbmdcIiwgLi4ucmVzdCB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHRlbXBsYXRlRm9ybWF0KS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lcy5hZGQobm9kZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbXB0VGVtcGxhdGUoe1xuICAgICAgICAgICAgLy8gUmVseSBvbiBleHRyYWN0ZWQgdHlwZXNcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBpbnB1dFZhcmlhYmxlczogWy4uLm5hbWVzXSxcbiAgICAgICAgICAgIHRlbXBsYXRlRm9ybWF0LFxuICAgICAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFydGlhbGx5IGFwcGxpZXMgdmFsdWVzIHRvIHRoZSBwcm9tcHQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHZhbHVlcyBUaGUgdmFsdWVzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkIHRvIHRoZSBwcm9tcHQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgUHJvbXB0VGVtcGxhdGUgd2l0aCB0aGUgcGFydGlhbGx5IGFwcGxpZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGFzeW5jIHBhcnRpYWwodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IG5ld0lucHV0VmFyaWFibGVzID0gdGhpcy5pbnB1dFZhcmlhYmxlcy5maWx0ZXIoKGl2KSA9PiAhKGl2IGluIHZhbHVlcykpO1xuICAgICAgICBjb25zdCBuZXdQYXJ0aWFsVmFyaWFibGVzID0ge1xuICAgICAgICAgICAgLi4uKHRoaXMucGFydGlhbFZhcmlhYmxlcyA/PyB7fSksXG4gICAgICAgICAgICAuLi52YWx1ZXMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb21wdERpY3QgPSB7XG4gICAgICAgICAgICAuLi50aGlzLFxuICAgICAgICAgICAgaW5wdXRWYXJpYWJsZXM6IG5ld0lucHV0VmFyaWFibGVzLFxuICAgICAgICAgICAgcGFydGlhbFZhcmlhYmxlczogbmV3UGFydGlhbFZhcmlhYmxlcyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9tcHRUZW1wbGF0ZShwcm9tcHREaWN0KTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRQYXJzZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBhIHByb21wdCB0ZW1wbGF0ZSB3aXRoIGFuIG91dHB1dCBwYXJzZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9nZXRQcm9tcHRUeXBlKCksXG4gICAgICAgICAgICBpbnB1dF92YXJpYWJsZXM6IHRoaXMuaW5wdXRWYXJpYWJsZXMsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlX2Zvcm1hdDogdGhpcy50ZW1wbGF0ZUZvcm1hdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9tcHQgdGVtcGxhdGUgbXVzdCBoYXZlIGEgdGVtcGxhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFByb21wdFRlbXBsYXRlKHtcbiAgICAgICAgICAgIGlucHV0VmFyaWFibGVzOiBkYXRhLmlucHV0X3ZhcmlhYmxlcyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBkYXRhLnRlbXBsYXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVGb3JtYXQ6IGRhdGEudGVtcGxhdGVfZm9ybWF0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/prompt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/serde.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/serde.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9zZXJkZS5qcyIsIm1hcHBpbmdzIjoiO0FBQVUiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccHJvbXB0c1xcc2VyZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/serde.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/string.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/string.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseStringPromptTemplate: () => (/* binding */ BaseStringPromptTemplate)\n/* harmony export */ });\n/* harmony import */ var _prompt_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../prompt_values.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/base.js\");\n// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\n\n/**\n * Base class for string prompt templates. It extends the\n * BasePromptTemplate class and overrides the formatPromptValue method to\n * return a StringPromptValue.\n */\nclass BaseStringPromptTemplate extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BasePromptTemplate {\n    /**\n     * Formats the prompt given the input values and returns a formatted\n     * prompt value.\n     * @param values The input values to format the prompt.\n     * @returns A Promise that resolves to a formatted prompt value.\n     */\n    async formatPromptValue(values) {\n        const formattedPrompt = await this.format(values);\n        return new _prompt_values_js__WEBPACK_IMPORTED_MODULE_0__.StringPromptValue(formattedPrompt);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUN5RDtBQUNWO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUMsd0RBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQWlCO0FBQ3BDO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccHJvbXB0c1xcc3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERlZmF1bHQgZ2VuZXJpYyBcImFueVwiIHZhbHVlcyBhcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuLy8gUmVwbGFjZSB3aXRoIFwic3RyaW5nXCIgd2hlbiB3ZSBhcmUgY29tZm9ydGFibGUgd2l0aCBhIGJyZWFraW5nIGNoYW5nZS5cbmltcG9ydCB7IFN0cmluZ1Byb21wdFZhbHVlLCB9IGZyb20gXCIuLi9wcm9tcHRfdmFsdWVzLmpzXCI7XG5pbXBvcnQgeyBCYXNlUHJvbXB0VGVtcGxhdGUgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHN0cmluZyBwcm9tcHQgdGVtcGxhdGVzLiBJdCBleHRlbmRzIHRoZVxuICogQmFzZVByb21wdFRlbXBsYXRlIGNsYXNzIGFuZCBvdmVycmlkZXMgdGhlIGZvcm1hdFByb21wdFZhbHVlIG1ldGhvZCB0b1xuICogcmV0dXJuIGEgU3RyaW5nUHJvbXB0VmFsdWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlU3RyaW5nUHJvbXB0VGVtcGxhdGUgZXh0ZW5kcyBCYXNlUHJvbXB0VGVtcGxhdGUge1xuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgdGhlIHByb21wdCBnaXZlbiB0aGUgaW5wdXQgdmFsdWVzIGFuZCByZXR1cm5zIGEgZm9ybWF0dGVkXG4gICAgICogcHJvbXB0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgVGhlIGlucHV0IHZhbHVlcyB0byBmb3JtYXQgdGhlIHByb21wdC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGZvcm1hdHRlZCBwcm9tcHQgdmFsdWUuXG4gICAgICovXG4gICAgYXN5bmMgZm9ybWF0UHJvbXB0VmFsdWUodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFByb21wdCA9IGF3YWl0IHRoaXMuZm9ybWF0KHZhbHVlcyk7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nUHJvbXB0VmFsdWUoZm9ybWF0dGVkUHJvbXB0KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/string.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/structured.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/structured.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StructuredPrompt: () => (/* binding */ StructuredPrompt)\n/* harmony export */ });\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chat.js */ \"(rsc)/./node_modules/@langchain/core/dist/prompts/chat.js\");\n\n\nfunction isWithStructuredOutput(x\n// eslint-disable-next-line @typescript-eslint/ban-types\n) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        \"withStructuredOutput\" in x &&\n        typeof x.withStructuredOutput === \"function\");\n}\nfunction isRunnableBinding(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        \"lc_id\" in x &&\n        Array.isArray(x.lc_id) &&\n        x.lc_id.join(\"/\") === \"langchain_core/runnables/RunnableBinding\");\n}\nclass StructuredPrompt extends _chat_js__WEBPACK_IMPORTED_MODULE_1__.ChatPromptTemplate {\n    get lc_aliases() {\n        return {\n            ...super.lc_aliases,\n            schema: \"schema_\",\n        };\n    }\n    constructor(input) {\n        super(input);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"method\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompts\", \"structured\"]\n        });\n        this.schema = input.schema;\n        this.method = input.method;\n    }\n    pipe(coerceable) {\n        if (isWithStructuredOutput(coerceable)) {\n            return super.pipe(coerceable.withStructuredOutput(this.schema));\n        }\n        if (isRunnableBinding(coerceable) &&\n            isWithStructuredOutput(coerceable.bound)) {\n            return super.pipe(new _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableBinding({\n                bound: coerceable.bound.withStructuredOutput(this.schema, ...(this.method ? [{ method: this.method }] : [])),\n                kwargs: coerceable.kwargs ?? {},\n                config: coerceable.config,\n                configFactories: coerceable.configFactories,\n            }));\n        }\n        throw new Error(`Structured prompts need to be piped to a language model that supports the \"withStructuredOutput()\" method.`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static fromMessagesAndSchema(promptMessages, schema, method\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return StructuredPrompt.fromMessages(promptMessages, { schema, method });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy9zdHJ1Y3R1cmVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RDtBQUNQO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQix3REFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtEQUFlO0FBQ2pELCtGQUErRixxQkFBcUI7QUFDcEgsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZ0JBQWdCO0FBQy9FO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccHJvbXB0c1xcc3RydWN0dXJlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSdW5uYWJsZUJpbmRpbmcgfSBmcm9tIFwiLi4vcnVubmFibGVzL2Jhc2UuanNcIjtcbmltcG9ydCB7IENoYXRQcm9tcHRUZW1wbGF0ZSwgfSBmcm9tIFwiLi9jaGF0LmpzXCI7XG5mdW5jdGlvbiBpc1dpdGhTdHJ1Y3R1cmVkT3V0cHV0KHhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4pIHtcbiAgICByZXR1cm4gKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHggIT0gbnVsbCAmJlxuICAgICAgICBcIndpdGhTdHJ1Y3R1cmVkT3V0cHV0XCIgaW4geCAmJlxuICAgICAgICB0eXBlb2YgeC53aXRoU3RydWN0dXJlZE91dHB1dCA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGlzUnVubmFibGVCaW5kaW5nKHgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHggIT0gbnVsbCAmJlxuICAgICAgICBcImxjX2lkXCIgaW4geCAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHgubGNfaWQpICYmXG4gICAgICAgIHgubGNfaWQuam9pbihcIi9cIikgPT09IFwibGFuZ2NoYWluX2NvcmUvcnVubmFibGVzL1J1bm5hYmxlQmluZGluZ1wiKTtcbn1cbmV4cG9ydCBjbGFzcyBTdHJ1Y3R1cmVkUHJvbXB0IGV4dGVuZHMgQ2hhdFByb21wdFRlbXBsYXRlIHtcbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLmxjX2FsaWFzZXMsXG4gICAgICAgICAgICBzY2hlbWE6IFwic2NoZW1hX1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBzdXBlcihpbnB1dCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRob2RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdHNcIiwgXCJzdHJ1Y3R1cmVkXCJdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGlucHV0LnNjaGVtYTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2Q7XG4gICAgfVxuICAgIHBpcGUoY29lcmNlYWJsZSkge1xuICAgICAgICBpZiAoaXNXaXRoU3RydWN0dXJlZE91dHB1dChjb2VyY2VhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnBpcGUoY29lcmNlYWJsZS53aXRoU3RydWN0dXJlZE91dHB1dCh0aGlzLnNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1J1bm5hYmxlQmluZGluZyhjb2VyY2VhYmxlKSAmJlxuICAgICAgICAgICAgaXNXaXRoU3RydWN0dXJlZE91dHB1dChjb2VyY2VhYmxlLmJvdW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnBpcGUobmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICAgICAgYm91bmQ6IGNvZXJjZWFibGUuYm91bmQud2l0aFN0cnVjdHVyZWRPdXRwdXQodGhpcy5zY2hlbWEsIC4uLih0aGlzLm1ldGhvZCA/IFt7IG1ldGhvZDogdGhpcy5tZXRob2QgfV0gOiBbXSkpLFxuICAgICAgICAgICAgICAgIGt3YXJnczogY29lcmNlYWJsZS5rd2FyZ3MgPz8ge30sXG4gICAgICAgICAgICAgICAgY29uZmlnOiBjb2VyY2VhYmxlLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBjb25maWdGYWN0b3JpZXM6IGNvZXJjZWFibGUuY29uZmlnRmFjdG9yaWVzLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RydWN0dXJlZCBwcm9tcHRzIG5lZWQgdG8gYmUgcGlwZWQgdG8gYSBsYW5ndWFnZSBtb2RlbCB0aGF0IHN1cHBvcnRzIHRoZSBcIndpdGhTdHJ1Y3R1cmVkT3V0cHV0KClcIiBtZXRob2QuYCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGZyb21NZXNzYWdlc0FuZFNjaGVtYShwcm9tcHRNZXNzYWdlcywgc2NoZW1hLCBtZXRob2RcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICkge1xuICAgICAgICByZXR1cm4gU3RydWN0dXJlZFByb21wdC5mcm9tTWVzc2FnZXMocHJvbXB0TWVzc2FnZXMsIHsgc2NoZW1hLCBtZXRob2QgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/structured.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompts/template.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompts/template.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_FORMATTER_MAPPING: () => (/* binding */ DEFAULT_FORMATTER_MAPPING),\n/* harmony export */   DEFAULT_PARSER_MAPPING: () => (/* binding */ DEFAULT_PARSER_MAPPING),\n/* harmony export */   checkValidTemplate: () => (/* binding */ checkValidTemplate),\n/* harmony export */   interpolateFString: () => (/* binding */ interpolateFString),\n/* harmony export */   interpolateMustache: () => (/* binding */ interpolateMustache),\n/* harmony export */   parseFString: () => (/* binding */ parseFString),\n/* harmony export */   parseMustache: () => (/* binding */ parseMustache),\n/* harmony export */   parseTemplate: () => (/* binding */ parseTemplate),\n/* harmony export */   renderTemplate: () => (/* binding */ renderTemplate)\n/* harmony export */ });\n/* harmony import */ var mustache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mustache */ \"(rsc)/./node_modules/mustache/mustache.mjs\");\n/* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/errors/index.js\");\n\n\nfunction configureMustache() {\n    // Use unescaped HTML\n    // https://github.com/janl/mustache.js?tab=readme-ov-file#variables\n    mustache__WEBPACK_IMPORTED_MODULE_0__[\"default\"].escape = (text) => text;\n}\nconst parseFString = (template) => {\n    // Core logic replicated from internals of pythons built in Formatter class.\n    // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n    const chars = template.split(\"\");\n    const nodes = [];\n    const nextBracket = (bracket, start) => {\n        for (let i = start; i < chars.length; i += 1) {\n            if (bracket.includes(chars[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    let i = 0;\n    while (i < chars.length) {\n        if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n            nodes.push({ type: \"literal\", text: \"{\" });\n            i += 2;\n        }\n        else if (chars[i] === \"}\" &&\n            i + 1 < chars.length &&\n            chars[i + 1] === \"}\") {\n            nodes.push({ type: \"literal\", text: \"}\" });\n            i += 2;\n        }\n        else if (chars[i] === \"{\") {\n            const j = nextBracket(\"}\", i);\n            if (j < 0) {\n                throw new Error(\"Unclosed '{' in template.\");\n            }\n            nodes.push({\n                type: \"variable\",\n                name: chars.slice(i + 1, j).join(\"\"),\n            });\n            i = j + 1;\n        }\n        else if (chars[i] === \"}\") {\n            throw new Error(\"Single '}' in template.\");\n        }\n        else {\n            const next = nextBracket(\"{}\", i);\n            const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n            nodes.push({ type: \"literal\", text });\n            i = next < 0 ? chars.length : next;\n        }\n    }\n    return nodes;\n};\n/**\n * Convert the result of mustache.parse into an array of ParsedTemplateNode,\n * to make it compatible with other LangChain string parsing template formats.\n *\n * @param {mustache.TemplateSpans} template The result of parsing a mustache template with the mustache.js library.\n * @param {string[]} context Array of section variable names for nested context\n * @returns {ParsedTemplateNode[]}\n */\nconst mustacheTemplateToNodes = (template, context = []) => {\n    const nodes = [];\n    for (const temp of template) {\n        if (temp[0] === \"name\") {\n            const name = temp[1].includes(\".\") ? temp[1].split(\".\")[0] : temp[1];\n            nodes.push({ type: \"variable\", name });\n        }\n        else if ([\"#\", \"&\", \"^\", \">\"].includes(temp[0])) {\n            // # represents a section, \"&\" represents an unescaped variable.\n            // These should both be considered variables.\n            nodes.push({ type: \"variable\", name: temp[1] });\n            // If this is a section with nested content, recursively process it\n            if (temp[0] === \"#\" && temp.length > 4 && Array.isArray(temp[4])) {\n                const newContext = [...context, temp[1]];\n                const nestedNodes = mustacheTemplateToNodes(temp[4], newContext);\n                nodes.push(...nestedNodes);\n            }\n        }\n        else {\n            nodes.push({ type: \"literal\", text: temp[1] });\n        }\n    }\n    return nodes;\n};\nconst parseMustache = (template) => {\n    configureMustache();\n    const parsed = mustache__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(template);\n    return mustacheTemplateToNodes(parsed);\n};\nconst interpolateFString = (template, values) => {\n    return parseFString(template).reduce((res, node) => {\n        if (node.type === \"variable\") {\n            if (node.name in values) {\n                const stringValue = typeof values[node.name] === \"string\"\n                    ? values[node.name]\n                    : JSON.stringify(values[node.name]);\n                return res + stringValue;\n            }\n            throw new Error(`(f-string) Missing value for input ${node.name}`);\n        }\n        return res + node.text;\n    }, \"\");\n};\nconst interpolateMustache = (template, values) => {\n    configureMustache();\n    return mustache__WEBPACK_IMPORTED_MODULE_0__[\"default\"].render(template, values);\n};\nconst DEFAULT_FORMATTER_MAPPING = {\n    \"f-string\": interpolateFString,\n    mustache: interpolateMustache,\n};\nconst DEFAULT_PARSER_MAPPING = {\n    \"f-string\": parseFString,\n    mustache: parseMustache,\n};\nconst renderTemplate = (template, templateFormat, inputValues) => {\n    try {\n        return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\n    }\n    catch (e) {\n        const error = (0,_errors_index_js__WEBPACK_IMPORTED_MODULE_1__.addLangChainErrorFields)(e, \"INVALID_PROMPT_INPUT\");\n        throw error;\n    }\n};\nconst parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);\nconst checkValidTemplate = (template, templateFormat, inputVariables) => {\n    if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n        const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n        throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n    }\n    try {\n        const dummyInputs = inputVariables.reduce((acc, v) => {\n            acc[v] = \"foo\";\n            return acc;\n        }, {});\n        if (Array.isArray(template)) {\n            template.forEach((message) => {\n                if (message.type === \"text\") {\n                    renderTemplate(message.text, templateFormat, dummyInputs);\n                }\n                else if (message.type === \"image_url\") {\n                    if (typeof message.image_url === \"string\") {\n                        renderTemplate(message.image_url, templateFormat, dummyInputs);\n                    }\n                    else {\n                        const imageUrl = message.image_url.url;\n                        renderTemplate(imageUrl, templateFormat, dummyInputs);\n                    }\n                }\n                else {\n                    throw new Error(`Invalid message template received. ${JSON.stringify(message, null, 2)}`);\n                }\n            });\n        }\n        else {\n            renderTemplate(template, templateFormat, dummyInputs);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        throw new Error(`Invalid prompt schema: ${e.message}`);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0cy90ZW1wbGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFnQztBQUM2QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFRO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWdEO0FBQzNFLHlCQUF5Qix5QkFBeUIsR0FBRztBQUNyRDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsK0JBQStCO0FBQy9CLHlCQUF5Qix5QkFBeUIsR0FBRztBQUNyRDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLG9DQUFvQztBQUNwQztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUNBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG1CQUFtQixnREFBUTtBQUMzQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFVBQVU7QUFDNUU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQSxXQUFXLGdEQUFRO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUVBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0EsMERBQTBELGVBQWU7QUFDekUsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxpQ0FBaUM7QUFDM0c7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHByb21wdHNcXHRlbXBsYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtdXN0YWNoZSBmcm9tIFwibXVzdGFjaGVcIjtcbmltcG9ydCB7IGFkZExhbmdDaGFpbkVycm9yRmllbGRzIH0gZnJvbSBcIi4uL2Vycm9ycy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gY29uZmlndXJlTXVzdGFjaGUoKSB7XG4gICAgLy8gVXNlIHVuZXNjYXBlZCBIVE1MXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanM/dGFiPXJlYWRtZS1vdi1maWxlI3ZhcmlhYmxlc1xuICAgIG11c3RhY2hlLmVzY2FwZSA9ICh0ZXh0KSA9PiB0ZXh0O1xufVxuZXhwb3J0IGNvbnN0IHBhcnNlRlN0cmluZyA9ICh0ZW1wbGF0ZSkgPT4ge1xuICAgIC8vIENvcmUgbG9naWMgcmVwbGljYXRlZCBmcm9tIGludGVybmFscyBvZiBweXRob25zIGJ1aWx0IGluIEZvcm1hdHRlciBjbGFzcy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcHl0aG9uL2NweXRob24vYmxvYi8xMzVlYzdjZWZiYWZmZDUxNmI3NzM2MmFkMmIyYWQxMDI1YWY0NjJlL09iamVjdHMvc3RyaW5nbGliL3VuaWNvZGVfZm9ybWF0LmgjTDcwMC1MNzA2XG4gICAgY29uc3QgY2hhcnMgPSB0ZW1wbGF0ZS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IG5leHRCcmFja2V0ID0gKGJyYWNrZXQsIHN0YXJ0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoYnJhY2tldC5pbmNsdWRlcyhjaGFyc1tpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGNoYXJzW2ldID09PSBcIntcIiAmJiBpICsgMSA8IGNoYXJzLmxlbmd0aCAmJiBjaGFyc1tpICsgMV0gPT09IFwie1wiKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHsgdHlwZTogXCJsaXRlcmFsXCIsIHRleHQ6IFwie1wiIH0pO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJzW2ldID09PSBcIn1cIiAmJlxuICAgICAgICAgICAgaSArIDEgPCBjaGFycy5sZW5ndGggJiZcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goeyB0eXBlOiBcImxpdGVyYWxcIiwgdGV4dDogXCJ9XCIgfSk7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcnNbaV0gPT09IFwie1wiKSB7XG4gICAgICAgICAgICBjb25zdCBqID0gbmV4dEJyYWNrZXQoXCJ9XCIsIGkpO1xuICAgICAgICAgICAgaWYgKGogPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jbG9zZWQgJ3snIGluIHRlbXBsYXRlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBjaGFycy5zbGljZShpICsgMSwgaikuam9pbihcIlwiKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaSA9IGogKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJzW2ldID09PSBcIn1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2luZ2xlICd9JyBpbiB0ZW1wbGF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV4dEJyYWNrZXQoXCJ7fVwiLCBpKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSAobmV4dCA8IDAgPyBjaGFycy5zbGljZShpKSA6IGNoYXJzLnNsaWNlKGksIG5leHQpKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh7IHR5cGU6IFwibGl0ZXJhbFwiLCB0ZXh0IH0pO1xuICAgICAgICAgICAgaSA9IG5leHQgPCAwID8gY2hhcnMubGVuZ3RoIDogbmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59O1xuLyoqXG4gKiBDb252ZXJ0IHRoZSByZXN1bHQgb2YgbXVzdGFjaGUucGFyc2UgaW50byBhbiBhcnJheSBvZiBQYXJzZWRUZW1wbGF0ZU5vZGUsXG4gKiB0byBtYWtlIGl0IGNvbXBhdGlibGUgd2l0aCBvdGhlciBMYW5nQ2hhaW4gc3RyaW5nIHBhcnNpbmcgdGVtcGxhdGUgZm9ybWF0cy5cbiAqXG4gKiBAcGFyYW0ge211c3RhY2hlLlRlbXBsYXRlU3BhbnN9IHRlbXBsYXRlIFRoZSByZXN1bHQgb2YgcGFyc2luZyBhIG11c3RhY2hlIHRlbXBsYXRlIHdpdGggdGhlIG11c3RhY2hlLmpzIGxpYnJhcnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBjb250ZXh0IEFycmF5IG9mIHNlY3Rpb24gdmFyaWFibGUgbmFtZXMgZm9yIG5lc3RlZCBjb250ZXh0XG4gKiBAcmV0dXJucyB7UGFyc2VkVGVtcGxhdGVOb2RlW119XG4gKi9cbmNvbnN0IG11c3RhY2hlVGVtcGxhdGVUb05vZGVzID0gKHRlbXBsYXRlLCBjb250ZXh0ID0gW10pID0+IHtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgdGVtcCBvZiB0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAodGVtcFswXSA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0ZW1wWzFdLmluY2x1ZGVzKFwiLlwiKSA/IHRlbXBbMV0uc3BsaXQoXCIuXCIpWzBdIDogdGVtcFsxXTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goeyB0eXBlOiBcInZhcmlhYmxlXCIsIG5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoW1wiI1wiLCBcIiZcIiwgXCJeXCIsIFwiPlwiXS5pbmNsdWRlcyh0ZW1wWzBdKSkge1xuICAgICAgICAgICAgLy8gIyByZXByZXNlbnRzIGEgc2VjdGlvbiwgXCImXCIgcmVwcmVzZW50cyBhbiB1bmVzY2FwZWQgdmFyaWFibGUuXG4gICAgICAgICAgICAvLyBUaGVzZSBzaG91bGQgYm90aCBiZSBjb25zaWRlcmVkIHZhcmlhYmxlcy5cbiAgICAgICAgICAgIG5vZGVzLnB1c2goeyB0eXBlOiBcInZhcmlhYmxlXCIsIG5hbWU6IHRlbXBbMV0gfSk7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc2VjdGlvbiB3aXRoIG5lc3RlZCBjb250ZW50LCByZWN1cnNpdmVseSBwcm9jZXNzIGl0XG4gICAgICAgICAgICBpZiAodGVtcFswXSA9PT0gXCIjXCIgJiYgdGVtcC5sZW5ndGggPiA0ICYmIEFycmF5LmlzQXJyYXkodGVtcFs0XSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gWy4uLmNvbnRleHQsIHRlbXBbMV1dO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5lc3RlZE5vZGVzID0gbXVzdGFjaGVUZW1wbGF0ZVRvTm9kZXModGVtcFs0XSwgbmV3Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaCguLi5uZXN0ZWROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHsgdHlwZTogXCJsaXRlcmFsXCIsIHRleHQ6IHRlbXBbMV0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufTtcbmV4cG9ydCBjb25zdCBwYXJzZU11c3RhY2hlID0gKHRlbXBsYXRlKSA9PiB7XG4gICAgY29uZmlndXJlTXVzdGFjaGUoKTtcbiAgICBjb25zdCBwYXJzZWQgPSBtdXN0YWNoZS5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIG11c3RhY2hlVGVtcGxhdGVUb05vZGVzKHBhcnNlZCk7XG59O1xuZXhwb3J0IGNvbnN0IGludGVycG9sYXRlRlN0cmluZyA9ICh0ZW1wbGF0ZSwgdmFsdWVzKSA9PiB7XG4gICAgcmV0dXJuIHBhcnNlRlN0cmluZyh0ZW1wbGF0ZSkucmVkdWNlKChyZXMsIG5vZGUpID0+IHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJ2YXJpYWJsZVwiKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5uYW1lIGluIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gdHlwZW9mIHZhbHVlc1tub2RlLm5hbWVdID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVzW25vZGUubmFtZV1cbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbbm9kZS5uYW1lXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcyArIHN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAoZi1zdHJpbmcpIE1pc3NpbmcgdmFsdWUgZm9yIGlucHV0ICR7bm9kZS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMgKyBub2RlLnRleHQ7XG4gICAgfSwgXCJcIik7XG59O1xuZXhwb3J0IGNvbnN0IGludGVycG9sYXRlTXVzdGFjaGUgPSAodGVtcGxhdGUsIHZhbHVlcykgPT4ge1xuICAgIGNvbmZpZ3VyZU11c3RhY2hlKCk7XG4gICAgcmV0dXJuIG11c3RhY2hlLnJlbmRlcih0ZW1wbGF0ZSwgdmFsdWVzKTtcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9GT1JNQVRURVJfTUFQUElORyA9IHtcbiAgICBcImYtc3RyaW5nXCI6IGludGVycG9sYXRlRlN0cmluZyxcbiAgICBtdXN0YWNoZTogaW50ZXJwb2xhdGVNdXN0YWNoZSxcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9QQVJTRVJfTUFQUElORyA9IHtcbiAgICBcImYtc3RyaW5nXCI6IHBhcnNlRlN0cmluZyxcbiAgICBtdXN0YWNoZTogcGFyc2VNdXN0YWNoZSxcbn07XG5leHBvcnQgY29uc3QgcmVuZGVyVGVtcGxhdGUgPSAodGVtcGxhdGUsIHRlbXBsYXRlRm9ybWF0LCBpbnB1dFZhbHVlcykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0ZPUk1BVFRFUl9NQVBQSU5HW3RlbXBsYXRlRm9ybWF0XSh0ZW1wbGF0ZSwgaW5wdXRWYWx1ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IGFkZExhbmdDaGFpbkVycm9yRmllbGRzKGUsIFwiSU5WQUxJRF9QUk9NUFRfSU5QVVRcIik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgcGFyc2VUZW1wbGF0ZSA9ICh0ZW1wbGF0ZSwgdGVtcGxhdGVGb3JtYXQpID0+IERFRkFVTFRfUEFSU0VSX01BUFBJTkdbdGVtcGxhdGVGb3JtYXRdKHRlbXBsYXRlKTtcbmV4cG9ydCBjb25zdCBjaGVja1ZhbGlkVGVtcGxhdGUgPSAodGVtcGxhdGUsIHRlbXBsYXRlRm9ybWF0LCBpbnB1dFZhcmlhYmxlcykgPT4ge1xuICAgIGlmICghKHRlbXBsYXRlRm9ybWF0IGluIERFRkFVTFRfRk9STUFUVEVSX01BUFBJTkcpKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkRm9ybWF0cyA9IE9iamVjdC5rZXlzKERFRkFVTFRfRk9STUFUVEVSX01BUFBJTkcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGVtcGxhdGUgZm9ybWF0LiBHb3QgXFxgJHt0ZW1wbGF0ZUZvcm1hdH1cXGA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGJlIG9uZSBvZiAke3ZhbGlkRm9ybWF0c31gKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZHVtbXlJbnB1dHMgPSBpbnB1dFZhcmlhYmxlcy5yZWR1Y2UoKGFjYywgdikgPT4ge1xuICAgICAgICAgICAgYWNjW3ZdID0gXCJmb29cIjtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGVtcGxhdGUpKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZS5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGVtcGxhdGUobWVzc2FnZS50ZXh0LCB0ZW1wbGF0ZUZvcm1hdCwgZHVtbXlJbnB1dHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiaW1hZ2VfdXJsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmltYWdlX3VybCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGVtcGxhdGUobWVzc2FnZS5pbWFnZV91cmwsIHRlbXBsYXRlRm9ybWF0LCBkdW1teUlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVVybCA9IG1lc3NhZ2UuaW1hZ2VfdXJsLnVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclRlbXBsYXRlKGltYWdlVXJsLCB0ZW1wbGF0ZUZvcm1hdCwgZHVtbXlJbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSB0ZW1wbGF0ZSByZWNlaXZlZC4gJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCAyKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclRlbXBsYXRlKHRlbXBsYXRlLCB0ZW1wbGF0ZUZvcm1hdCwgZHVtbXlJbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcm9tcHQgc2NoZW1hOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompts/template.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/retrievers/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/retrievers/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseRetriever: () => (/* binding */ BaseRetriever)\n/* harmony export */ });\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../callbacks/manager.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _runnables_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../runnables/config.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.js\");\n\n\n\n/**\n * Abstract base class for a document retrieval system, designed to\n * process string queries and return the most relevant documents from a source.\n *\n * `BaseRetriever` provides common properties and methods for derived retrievers,\n * such as callbacks, tagging, and verbose logging. Custom retrieval systems\n * should extend this class and implement `_getRelevantDocuments` to define\n * the specific retrieval logic.\n *\n * @template Metadata - The type of metadata associated with each document,\n *                      defaulting to `Record<string, any>`.\n */\nclass BaseRetriever extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_1__.Runnable {\n    /**\n     * Constructs a new `BaseRetriever` instance with optional configuration fields.\n     *\n     * @param fields - Optional input configuration that can include `callbacks`,\n     *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.\n     */\n    constructor(fields) {\n        super(fields);\n        /**\n         * Optional callbacks to handle various events in the retrieval process.\n         */\n        Object.defineProperty(this, \"callbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Tags to label or categorize the retrieval operation.\n         */\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Metadata to provide additional context or information about the retrieval\n         * operation.\n         */\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * If set to `true`, enables verbose logging for the retrieval process.\n         */\n        Object.defineProperty(this, \"verbose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.callbacks = fields?.callbacks;\n        this.tags = fields?.tags ?? [];\n        this.metadata = fields?.metadata ?? {};\n        this.verbose = fields?.verbose ?? false;\n    }\n    /**\n     * TODO: This should be an abstract method, but we'd like to avoid breaking\n     * changes to people currently using subclassed custom retrievers.\n     * Change it on next major release.\n     */\n    /**\n     * Placeholder method for retrieving relevant documents based on a query.\n     *\n     * This method is intended to be implemented by subclasses and will be\n     * converted to an abstract method in the next major release. Currently, it\n     * throws an error if not implemented, ensuring that custom retrievers define\n     * the specific retrieval logic.\n     *\n     * @param _query - The query string used to search for relevant documents.\n     * @param _callbacks - (optional) Callback manager for managing callbacks\n     *                     during retrieval.\n     * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.\n     * @throws {Error} Throws an error indicating the method is not implemented.\n     */\n    _getRelevantDocuments(_query, _callbacks) {\n        throw new Error(\"Not implemented!\");\n    }\n    /**\n     * Executes a retrieval operation.\n     *\n     * @param input - The query string used to search for relevant documents.\n     * @param options - (optional) Configuration options for the retrieval run,\n     *                  which may include callbacks, tags, and metadata.\n     * @returns A promise that resolves to an array of `DocumentInterface` instances\n     *          representing the most relevant documents to the query.\n     */\n    async invoke(input, options) {\n        return this.getRelevantDocuments(input, (0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_2__.ensureConfig)(options));\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Main method used to retrieve relevant documents. It takes a query\n     * string and an optional configuration object, and returns a promise that\n     * resolves to an array of `Document` objects. This method handles the\n     * retrieval process, including starting and ending callbacks, and error\n     * handling.\n     * @param query The query string to retrieve relevant documents for.\n     * @param config Optional configuration object for the retrieval process.\n     * @returns A promise that resolves to an array of `Document` objects.\n     */\n    async getRelevantDocuments(query, config) {\n        const parsedConfig = (0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_2__.ensureConfig)((0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.parseCallbackConfigArg)(config));\n        const callbackManager_ = await _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.CallbackManager.configure(parsedConfig.callbacks, this.callbacks, parsedConfig.tags, this.tags, parsedConfig.metadata, this.metadata, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleRetrieverStart(this.toJSON(), query, parsedConfig.runId, undefined, undefined, undefined, parsedConfig.runName);\n        try {\n            const results = await this._getRelevantDocuments(query, runManager);\n            await runManager?.handleRetrieverEnd(results);\n            return results;\n        }\n        catch (error) {\n            await runManager?.handleRetrieverError(error);\n            throw error;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcmV0cmlldmVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1GO0FBQ25DO0FBQ007QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLHdEQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtFQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0VBQVksQ0FBQyw2RUFBc0I7QUFDaEUsdUNBQXVDLGtFQUFlLHlIQUF5SCx1QkFBdUI7QUFDdE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHJldHJpZXZlcnNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhbGxiYWNrTWFuYWdlciwgcGFyc2VDYWxsYmFja0NvbmZpZ0FyZywgfSBmcm9tIFwiLi4vY2FsbGJhY2tzL21hbmFnZXIuanNcIjtcbmltcG9ydCB7IFJ1bm5hYmxlIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBlbnN1cmVDb25maWcgfSBmcm9tIFwiLi4vcnVubmFibGVzL2NvbmZpZy5qc1wiO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhIGRvY3VtZW50IHJldHJpZXZhbCBzeXN0ZW0sIGRlc2lnbmVkIHRvXG4gKiBwcm9jZXNzIHN0cmluZyBxdWVyaWVzIGFuZCByZXR1cm4gdGhlIG1vc3QgcmVsZXZhbnQgZG9jdW1lbnRzIGZyb20gYSBzb3VyY2UuXG4gKlxuICogYEJhc2VSZXRyaWV2ZXJgIHByb3ZpZGVzIGNvbW1vbiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciBkZXJpdmVkIHJldHJpZXZlcnMsXG4gKiBzdWNoIGFzIGNhbGxiYWNrcywgdGFnZ2luZywgYW5kIHZlcmJvc2UgbG9nZ2luZy4gQ3VzdG9tIHJldHJpZXZhbCBzeXN0ZW1zXG4gKiBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MgYW5kIGltcGxlbWVudCBgX2dldFJlbGV2YW50RG9jdW1lbnRzYCB0byBkZWZpbmVcbiAqIHRoZSBzcGVjaWZpYyByZXRyaWV2YWwgbG9naWMuXG4gKlxuICogQHRlbXBsYXRlIE1ldGFkYXRhIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGVhY2ggZG9jdW1lbnQsXG4gKiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0aW5nIHRvIGBSZWNvcmQ8c3RyaW5nLCBhbnk+YC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VSZXRyaWV2ZXIgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBgQmFzZVJldHJpZXZlcmAgaW5zdGFuY2Ugd2l0aCBvcHRpb25hbCBjb25maWd1cmF0aW9uIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZHMgLSBPcHRpb25hbCBpbnB1dCBjb25maWd1cmF0aW9uIHRoYXQgY2FuIGluY2x1ZGUgYGNhbGxiYWNrc2AsXG4gICAgICogICAgICAgICAgICAgICAgIGB0YWdzYCwgYG1ldGFkYXRhYCwgYW5kIGB2ZXJib3NlYCBzZXR0aW5ncyBmb3IgY3VzdG9tIHJldHJpZXZlciBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIGNhbGxiYWNrcyB0byBoYW5kbGUgdmFyaW91cyBldmVudHMgaW4gdGhlIHJldHJpZXZhbCBwcm9jZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWdzIHRvIGxhYmVsIG9yIGNhdGVnb3JpemUgdGhlIHJldHJpZXZhbCBvcGVyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRhZGF0YSB0byBwcm92aWRlIGFkZGl0aW9uYWwgY29udGV4dCBvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmV0cmlldmFsXG4gICAgICAgICAqIG9wZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCBlbmFibGVzIHZlcmJvc2UgbG9nZ2luZyBmb3IgdGhlIHJldHJpZXZhbCBwcm9jZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyYm9zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGZpZWxkcz8uY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnRhZ3MgPSBmaWVsZHM/LnRhZ3MgPz8gW107XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBmaWVsZHM/Lm1ldGFkYXRhID8/IHt9O1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSBmaWVsZHM/LnZlcmJvc2UgPz8gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRPRE86IFRoaXMgc2hvdWxkIGJlIGFuIGFic3RyYWN0IG1ldGhvZCwgYnV0IHdlJ2QgbGlrZSB0byBhdm9pZCBicmVha2luZ1xuICAgICAqIGNoYW5nZXMgdG8gcGVvcGxlIGN1cnJlbnRseSB1c2luZyBzdWJjbGFzc2VkIGN1c3RvbSByZXRyaWV2ZXJzLlxuICAgICAqIENoYW5nZSBpdCBvbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIGZvciByZXRyaWV2aW5nIHJlbGV2YW50IGRvY3VtZW50cyBiYXNlZCBvbiBhIHF1ZXJ5LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgdG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyBhbmQgd2lsbCBiZVxuICAgICAqIGNvbnZlcnRlZCB0byBhbiBhYnN0cmFjdCBtZXRob2QgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gQ3VycmVudGx5LCBpdFxuICAgICAqIHRocm93cyBhbiBlcnJvciBpZiBub3QgaW1wbGVtZW50ZWQsIGVuc3VyaW5nIHRoYXQgY3VzdG9tIHJldHJpZXZlcnMgZGVmaW5lXG4gICAgICogdGhlIHNwZWNpZmljIHJldHJpZXZhbCBsb2dpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfcXVlcnkgLSBUaGUgcXVlcnkgc3RyaW5nIHVzZWQgdG8gc2VhcmNoIGZvciByZWxldmFudCBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIF9jYWxsYmFja3MgLSAob3B0aW9uYWwpIENhbGxiYWNrIG1hbmFnZXIgZm9yIG1hbmFnaW5nIGNhbGxiYWNrc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgZHVyaW5nIHJldHJpZXZhbC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIGBEb2N1bWVudEludGVyZmFjZWAgaW5zdGFuY2VzIHJlbGV2YW50IHRvIHRoZSBxdWVyeS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGFuIGVycm9yIGluZGljYXRpbmcgdGhlIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXG4gICAgICovXG4gICAgX2dldFJlbGV2YW50RG9jdW1lbnRzKF9xdWVyeSwgX2NhbGxiYWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQhXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIHJldHJpZXZhbCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgcXVlcnkgc3RyaW5nIHVzZWQgdG8gc2VhcmNoIGZvciByZWxldmFudCBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSAob3B0aW9uYWwpIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHJldHJpZXZhbCBydW4sXG4gICAgICogICAgICAgICAgICAgICAgICB3aGljaCBtYXkgaW5jbHVkZSBjYWxsYmFja3MsIHRhZ3MsIGFuZCBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBgRG9jdW1lbnRJbnRlcmZhY2VgIGluc3RhbmNlc1xuICAgICAqICAgICAgICAgIHJlcHJlc2VudGluZyB0aGUgbW9zdCByZWxldmFudCBkb2N1bWVudHMgdG8gdGhlIHF1ZXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWxldmFudERvY3VtZW50cyhpbnB1dCwgZW5zdXJlQ29uZmlnKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4zLjAuXG4gICAgICpcbiAgICAgKiBNYWluIG1ldGhvZCB1c2VkIHRvIHJldHJpZXZlIHJlbGV2YW50IGRvY3VtZW50cy4gSXQgdGFrZXMgYSBxdWVyeVxuICAgICAqIHN0cmluZyBhbmQgYW4gb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QsIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0XG4gICAgICogcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgYERvY3VtZW50YCBvYmplY3RzLiBUaGlzIG1ldGhvZCBoYW5kbGVzIHRoZVxuICAgICAqIHJldHJpZXZhbCBwcm9jZXNzLCBpbmNsdWRpbmcgc3RhcnRpbmcgYW5kIGVuZGluZyBjYWxsYmFja3MsIGFuZCBlcnJvclxuICAgICAqIGhhbmRsaW5nLlxuICAgICAqIEBwYXJhbSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRvIHJldHJpZXZlIHJlbGV2YW50IGRvY3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHJldHJpZXZhbCBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIGBEb2N1bWVudGAgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZWxldmFudERvY3VtZW50cyhxdWVyeSwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZENvbmZpZyA9IGVuc3VyZUNvbmZpZyhwYXJzZUNhbGxiYWNrQ29uZmlnQXJnKGNvbmZpZykpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShwYXJzZWRDb25maWcuY2FsbGJhY2tzLCB0aGlzLmNhbGxiYWNrcywgcGFyc2VkQ29uZmlnLnRhZ3MsIHRoaXMudGFncywgcGFyc2VkQ29uZmlnLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZVJldHJpZXZlclN0YXJ0KHRoaXMudG9KU09OKCksIHF1ZXJ5LCBwYXJzZWRDb25maWcucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHBhcnNlZENvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLl9nZXRSZWxldmFudERvY3VtZW50cyhxdWVyeSwgcnVuTWFuYWdlcik7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVSZXRyaWV2ZXJFbmQocmVzdWx0cyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZVJldHJpZXZlckVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/retrievers/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/base.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/base.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Runnable: () => (/* binding */ Runnable),\n/* harmony export */   RunnableAssign: () => (/* binding */ RunnableAssign),\n/* harmony export */   RunnableBinding: () => (/* binding */ RunnableBinding),\n/* harmony export */   RunnableEach: () => (/* binding */ RunnableEach),\n/* harmony export */   RunnableLambda: () => (/* binding */ RunnableLambda),\n/* harmony export */   RunnableMap: () => (/* binding */ RunnableMap),\n/* harmony export */   RunnableParallel: () => (/* binding */ RunnableParallel),\n/* harmony export */   RunnablePick: () => (/* binding */ RunnablePick),\n/* harmony export */   RunnableRetry: () => (/* binding */ RunnableRetry),\n/* harmony export */   RunnableSequence: () => (/* binding */ RunnableSequence),\n/* harmony export */   RunnableToolLike: () => (/* binding */ RunnableToolLike),\n/* harmony export */   RunnableTraceable: () => (/* binding */ RunnableTraceable),\n/* harmony export */   RunnableWithFallbacks: () => (/* binding */ RunnableWithFallbacks),\n/* harmony export */   _coerceToDict: () => (/* binding */ _coerceToDict),\n/* harmony export */   _coerceToRunnable: () => (/* binding */ _coerceToRunnable),\n/* harmony export */   convertRunnableToTool: () => (/* binding */ convertRunnableToTool)\n/* harmony export */ });\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langsmith/singletons/traceable */ \"(rsc)/./node_modules/langsmith/singletons/traceable.js\");\n/* harmony import */ var _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tracers/log_stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.js\");\n/* harmony import */ var _tracers_event_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tracers/event_stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.js\");\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../load/serializable.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _utils_signal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/signal.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/signal.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./config.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/async_caller.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.js\");\n/* harmony import */ var _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tracers/root_listener.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/utils.js\");\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../singletons/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.js\");\n/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./graph.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/graph.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./wrappers.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.js\");\n/* harmony import */ var _iter_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./iter.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/iter.js\");\n/* harmony import */ var _tools_utils_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../tools/utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.js\");\n/* harmony import */ var _utils_types_zod_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/types/zod.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nclass Runnable extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_4__.Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     *\n     * @deprecated This will be removed in the next breaking release.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param fields.stopAfterAttempt The number of attempts to retry.\n     * @param fields.onFailedAttempt A function that is called when a retry fails.\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options) && options.length !== length) {\n            throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n        }\n        if (Array.isArray(options)) {\n            return options.map(_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig);\n        }\n        if (length > 1 && !Array.isArray(options) && options.runId) {\n            console.warn(\"Provided runId will be used only for the first element of the batch.\");\n            const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n            return Array.from({ length }, (_, i) => (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(i === 0 ? options : subsequent));\n        }\n        return Array.from({ length }, () => (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_8__.AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({\n            generator: this._streamIterator(input, config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        let runnableConfig;\n        if (options === undefined) {\n            runnableConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        }\n        else {\n            runnableConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)({\n                callbacks: options.callbacks,\n                tags: options.tags,\n                metadata: options.metadata,\n                runName: options.runName,\n                configurable: options.configurable,\n                recursionLimit: options.recursionLimit,\n                maxConcurrency: options.maxConcurrency,\n                runId: options.runId,\n                timeout: options.timeout,\n                signal: options.signal,\n            });\n        }\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        delete callOptions.runId;\n        delete callOptions.timeout;\n        delete callOptions.signal;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        delete config.runId;\n        let output;\n        try {\n            const promise = func.call(this, input, config, runManager);\n            output = await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n            delete optionsList[i].runId;\n            return handleStartRes;\n        }));\n        let outputs;\n        try {\n            const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);\n            outputs = await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, optionsList?.[0]?.signal);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(first, second);\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const outerThis = this;\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            finalInput = outerThis._concatOutputChunks(finalInput, \n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.pipeGeneratorWithSetup)(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), options?.signal, config);\n            delete config.runId;\n            runManager = pipe.setup;\n            const streamEventsHandler = runManager?.handlers.find(_tracers_event_stream_js__WEBPACK_IMPORTED_MODULE_3__.isStreamEventsHandler);\n            let iterator = pipe.output;\n            if (streamEventsHandler !== undefined && runManager !== undefined) {\n                iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            const streamLogHandler = runManager?.handlers.find(_tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.isLogStreamHandler);\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            finalOutput = this._concatOutputChunks(finalOutput, \n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    getGraph(_) {\n        const graph = new _graph_js__WEBPACK_IMPORTED_MODULE_12__.Graph();\n        // TODO: Add input schema for runnables\n        const inputNode = graph.addNode({\n            name: `${this.getName()}Input`,\n            schema: zod_v3__WEBPACK_IMPORTED_MODULE_17__.any(),\n        });\n        const runnableNode = graph.addNode(this);\n        // TODO: Add output schemas for runnables\n        const outputNode = graph.addNode({\n            name: `${this.getName()}Output`,\n            schema: zod_v3__WEBPACK_IMPORTED_MODULE_17__.any(),\n        });\n        graph.addEdge(inputNode, runnableNode);\n        graph.addEdge(runnableNode, outputNode);\n        return graph;\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = this._concatOutputChunks(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options));\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    streamEvents(input, options, streamOptions) {\n        let stream;\n        if (options.version === \"v1\") {\n            stream = this._streamEventsV1(input, options, streamOptions);\n        }\n        else if (options.version === \"v2\") {\n            stream = this._streamEventsV2(input, options, streamOptions);\n        }\n        else {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n        }\n        if (options.encoding === \"text/event-stream\") {\n            return (0,_wrappers_js__WEBPACK_IMPORTED_MODULE_13__.convertToHttpEventStream)(stream);\n        }\n        else {\n            return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(stream);\n        }\n    }\n    async *_streamEventsV2(input, options, streamOptions) {\n        const eventStreamer = new _tracers_event_stream_js__WEBPACK_IMPORTED_MODULE_3__.EventStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n        });\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const runId = config.runId ?? (0,uuid__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n        config.runId = runId;\n        const callbacks = config.callbacks;\n        if (callbacks === undefined) {\n            config.callbacks = [eventStreamer];\n        }\n        else if (Array.isArray(callbacks)) {\n            config.callbacks = callbacks.concat(eventStreamer);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(eventStreamer, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const abortController = new AbortController();\n        // Call the runnable in streaming mode,\n        // add each chunk to the output stream\n        const outerThis = this;\n        async function consumeRunnableStream() {\n            let signal;\n            let listener = null;\n            try {\n                if (options?.signal) {\n                    if (\"any\" in AbortSignal) {\n                        // Use native AbortSignal.any() if available (Node 19+)\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        signal = AbortSignal.any([\n                            abortController.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        // Fallback for Node 18 and below - just use the provided signal\n                        signal = options.signal;\n                        // Ensure we still abort our controller when the parent signal aborts\n                        listener = () => {\n                            abortController.abort();\n                        };\n                        options.signal.addEventListener(\"abort\", listener, { once: true });\n                    }\n                }\n                else {\n                    signal = abortController.signal;\n                }\n                const runnableStream = await outerThis.stream(input, {\n                    ...config,\n                    signal,\n                });\n                const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                for await (const _ of tappedStream) {\n                    // Just iterate so that the callback handler picks up events\n                    if (abortController.signal.aborted)\n                        break;\n                }\n            }\n            finally {\n                await eventStreamer.finish();\n                if (signal && listener) {\n                    signal.removeEventListener(\"abort\", listener);\n                }\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        let firstEventSent = false;\n        let firstEventRunId;\n        try {\n            for await (const event of eventStreamer) {\n                // This is a work-around an issue where the inputs into the\n                // chain are not available until the entire input is consumed.\n                // As a temporary solution, we'll modify the input to be the input\n                // that was passed into the chain.\n                if (!firstEventSent) {\n                    event.data.input = input;\n                    firstEventSent = true;\n                    firstEventRunId = event.run_id;\n                    yield event;\n                    continue;\n                }\n                if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n                    // If it's the end event corresponding to the root runnable\n                    // we dont include the input in the event since it's guaranteed\n                    // to be included in the first event.\n                    if (event.data?.input) {\n                        delete event.data.input;\n                    }\n                }\n                yield event;\n            }\n        }\n        finally {\n            abortController.abort();\n            await runnableStreamConsumePromise;\n        }\n    }\n    async *_streamEventsV1(input, options, streamOptions) {\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new _utils_js__WEBPACK_IMPORTED_MODULE_10__._RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_10__.isRunnableInterface)(thing);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_9__.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n    /**\n     * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n     * which contains the runnable, name, description and schema.\n     *\n     * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n     *\n     * @param fields\n     * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n     * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n     * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n     * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n     */\n    asTool(fields) {\n        return convertRunnableToTool(this, fields);\n    }\n}\n/**\n * Wraps a runnable and applies partial config upon invocation.\n *\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.bind({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.bind({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nclass RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.mergeConfigs)(this.config, ...options);\n        return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.mergeConfigs)(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableBinding` class that is bound with the specified arguments.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(individualOption), this.kwargs)))\n            : await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return this.bound._concatOutputChunks(first, second);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs));\n    }\n    async *transform(generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs));\n    }\n    streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            yield* outerThis.bound.streamEvents(input, {\n                ...(await outerThis._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), outerThis.kwargs)),\n                version: options.version,\n            }, streamOptions);\n        };\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(generator());\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_9__.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n *\n * @deprecated This will be removed in the next breaking release.\n */\nclass RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke.bind(this), inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nclass RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return p_retry__WEBPACK_IMPORTED_MODULE_0__((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onFailedAttempt: (error) => this.onFailedAttempt(error, input),\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke.bind(this), input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await p_retry__WEBPACK_IMPORTED_MODULE_0__(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            firstException.input = remainingInputs[i];\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({ model: \"gpt-4o-mini\" })]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nclass RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"omitSequenceTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n        this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                const promise = step.invoke(nextStepInput, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n                nextStepInput = await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, options?.signal);\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            if (options?.signal?.aborted) {\n                throw new Error(\"Aborted\");\n            }\n            finalOutput = await this.last.invoke(nextStepInput, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`);\n                    return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n                nextStepInputs = await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, configList[0]?.signal);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return this.last._concatOutputChunks(first, second);\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(options);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherOptions, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherOptions, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                options?.signal?.throwIfAborted();\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = this._concatOutputChunks(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    getGraph(config) {\n        const graph = new _graph_js__WEBPACK_IMPORTED_MODULE_12__.Graph();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let currentLastNode = null;\n        this.steps.forEach((step, index) => {\n            const stepGraph = step.getGraph(config);\n            if (index !== 0) {\n                stepGraph.trimFirstNode();\n            }\n            if (index !== this.steps.length - 1) {\n                stepGraph.trimLastNode();\n            }\n            graph.extend(stepGraph);\n            const stepFirstNode = stepGraph.firstNode();\n            if (!stepFirstNode) {\n                throw new Error(`Runnable ${step} has no first node`);\n            }\n            if (currentLastNode) {\n                graph.addEdge(currentLastNode, stepFirstNode);\n            }\n            currentLastNode = stepGraph.lastNode();\n        });\n        return graph;\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], nameOrFields) {\n        let extra = {};\n        if (typeof nameOrFields === \"string\") {\n            extra.name = nameOrFields;\n        }\n        else if (nameOrFields !== undefined) {\n            extra = nameOrFields;\n        }\n        return new RunnableSequence({\n            ...extra,\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nclass RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            const promises = Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            });\n            await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(Promise.all(promises), options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.atee)(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const promise = Promise.race(tasks.values());\n            const { key, result, gen } = await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, options?.signal);\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nclass RunnableTraceable extends Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (!(0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__.isTraceableFunction)(fields.func)) {\n            throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n        }\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const callbacks = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const promise = this.func((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, { callbacks }), input);\n        return (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, config?.signal);\n    }\n    async *_streamIterator(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const result = await this.invoke(input, options);\n        if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isAsyncIterable)(result)) {\n            for await (const item of result) {\n                config?.signal?.throwIfAborted();\n                yield item;\n            }\n            return;\n        }\n        if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isIterator)(result)) {\n            while (true) {\n                config?.signal?.throwIfAborted();\n                const state = result.next();\n                if (state.done)\n                    break;\n                yield state.value;\n            }\n            return;\n        }\n        yield result;\n    }\n    static from(func) {\n        return new RunnableTraceable({ func });\n    }\n}\nfunction assertNonTraceableFunction(func) {\n    if ((0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__.isTraceableFunction)(func)) {\n        throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n    }\n}\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nclass RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        if ((0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__.isTraceableFunction)(fields.func)) {\n            // eslint-disable-next-line no-constructor-return\n            return RunnableTraceable.from(fields.func);\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        assertNonTraceableFunction(fields.func);\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? _config_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_RECURSION_LIMIT) - 1,\n            });\n            void _singletons_index_js__WEBPACK_IMPORTED_MODULE_11__.AsyncLocalStorageProviderSingleton.runWithConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.pickRunnableConfigKeys)(childConfig), async () => {\n                try {\n                    let output = await this.func(input, {\n                        ...childConfig,\n                    });\n                    if (output && Runnable.isRunnable(output)) {\n                        if (config?.recursionLimit === 0) {\n                            throw new Error(\"Recursion limit reached.\");\n                        }\n                        output = await output.invoke(input, {\n                            ...childConfig,\n                            recursionLimit: (childConfig.recursionLimit ?? _config_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_RECURSION_LIMIT) - 1,\n                        });\n                    }\n                    else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isAsyncIterable)(output)) {\n                        let finalOutput;\n                        for await (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeAsyncIterableInContext)(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    finalOutput = this._concatOutputChunks(finalOutput, \n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isIterableIterator)(output)) {\n                        let finalOutput;\n                        for (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeIteratorInContext)(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    finalOutput = this._concatOutputChunks(finalOutput, \n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke.bind(this), input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = this._concatOutputChunks(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {\n            callbacks: runManager?.getChild(),\n            recursionLimit: (config?.recursionLimit ?? _config_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_RECURSION_LIMIT) - 1,\n        });\n        const output = await new Promise((resolve, reject) => {\n            void _singletons_index_js__WEBPACK_IMPORTED_MODULE_11__.AsyncLocalStorageProviderSingleton.runWithConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.pickRunnableConfigKeys)(childConfig), async () => {\n                try {\n                    const res = await this.func(finalChunk, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, childConfig);\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isAsyncIterable)(output)) {\n            for await (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeAsyncIterableInContext)(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isIterableIterator)(output)) {\n            for (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeIteratorInContext)(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = await sequence.invoke(25);\n *\n * // { years_to_fifty: 20, years_to_hundred: 70 }\n * ```\n */\nclass RunnableParallel extends RunnableMap {\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nclass RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        const childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherConfigFields, {\n            callbacks: runManager?.getChild(),\n        });\n        const res = await _singletons_index_js__WEBPACK_IMPORTED_MODULE_11__.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n            let firstError;\n            for (const runnable of this.runnables()) {\n                config?.signal?.throwIfAborted();\n                try {\n                    const output = await runnable.invoke(input, childConfig);\n                    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                    return output;\n                }\n                catch (e) {\n                    if (firstError === undefined) {\n                        firstError = e;\n                    }\n                }\n            }\n            if (firstError === undefined) {\n                throw new Error(\"No error stored at end of fallback.\");\n            }\n            await runManager?.handleChainError(firstError);\n            throw firstError;\n        });\n        return res;\n    }\n    async *_streamIterator(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        let firstError;\n        let stream;\n        for (const runnable of this.runnables()) {\n            config?.signal?.throwIfAborted();\n            const childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherConfigFields, {\n                callbacks: runManager?.getChild(),\n            });\n            try {\n                const originalStream = await runnable.stream(input, childConfig);\n                stream = (0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeAsyncIterableInContext)(childConfig, originalStream);\n                break;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (stream === undefined) {\n            const error = firstError ?? new Error(\"No error stored at end of fallback.\");\n            await runManager?.handleChainError(error);\n            throw error;\n        }\n        let output;\n        try {\n            for await (const chunk of stream) {\n                yield chunk;\n                try {\n                    output =\n                        output === undefined\n                            ? output\n                            : this._concatOutputChunks(output, chunk);\n                }\n                catch (e) {\n                    output = undefined;\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config)));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            configList[0].signal?.throwIfAborted();\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nfunction _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nclass RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.atee)(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nclass RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0\n                ? undefined\n                : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nclass RunnableToolLike extends RunnableBinding {\n    constructor(fields) {\n        const sequence = RunnableSequence.from([\n            RunnableLambda.from(async (input) => {\n                let toolInput;\n                if ((0,_tools_utils_js__WEBPACK_IMPORTED_MODULE_15__._isToolCall)(input)) {\n                    try {\n                        toolInput = await (0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_16__.interopParseAsync)(this.schema, input.args);\n                    }\n                    catch (e) {\n                        throw new _tools_utils_js__WEBPACK_IMPORTED_MODULE_15__.ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));\n                    }\n                }\n                else {\n                    toolInput = input;\n                }\n                return toolInput;\n            }).withConfig({ runName: `${fields.name}:parse_input` }),\n            fields.bound,\n        ]).withConfig({ runName: fields.name });\n        super({\n            bound: sequence,\n            config: fields.config ?? {},\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.schema = fields.schema;\n    }\n    static lc_name() {\n        return \"RunnableToolLike\";\n    }\n}\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {InteropZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<InteropZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nfunction convertRunnableToTool(runnable, fields) {\n    const name = fields.name ?? runnable.getName();\n    const description = fields.description ?? (0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_16__.getSchemaDescription)(fields.schema);\n    if ((0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_16__.isSimpleStringZodSchema)(fields.schema)) {\n        return new RunnableToolLike({\n            name,\n            description,\n            schema: zod_v3__WEBPACK_IMPORTED_MODULE_17__.object({ input: zod_v3__WEBPACK_IMPORTED_MODULE_17__.string() })\n                .transform((input) => input.input),\n            bound: runnable,\n        });\n    }\n    return new RunnableToolLike({\n        name,\n        description,\n        schema: fields.schema,\n        bound: runnable,\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkI7QUFDRTtBQUNPO0FBQ2tDO0FBQ3dDO0FBQ2Q7QUFDekM7QUFDcUU7QUFDeEU7QUFDaUc7QUFDOUY7QUFDVztBQUNDO0FBQ1M7QUFDekM7QUFDc0I7QUFDNkU7QUFDM0Q7QUFDK0I7QUFDMUc7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUJBQXVCLCtEQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLLEVBQUUsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsZ0JBQWdCLGNBQWMsUUFBUTtBQUNuSjtBQUNBO0FBQ0EsK0JBQStCLG9EQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVEsWUFBWSx3REFBWTtBQUNoRTtBQUNBLDRCQUE0QixRQUFRLFFBQVEsd0RBQVk7QUFDeEQ7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLDJCQUEyQiwrREFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBWTtBQUNuQyxxQ0FBcUMscUVBQXVCO0FBQzVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLG9FQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3REFBWTtBQUN6QztBQUNBO0FBQ0EsNkJBQTZCLHdEQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DLHVDQUF1Qyx1RUFBMkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnRUFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsbUVBQW1FLG1FQUEyQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMsdUNBQXVDLHVFQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0VBQXNCLGdIQUFnSCxXQUFXO0FBQ2hMO0FBQ0E7QUFDQSxrRUFBa0UsMkVBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHNFQUFrQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwREFBMEQscUNBQXFDLDRDQUE0QztBQUMzSTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFLO0FBQy9CO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQyxvQkFBb0Isd0NBQUs7QUFDekIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDLG9CQUFvQix3Q0FBSztBQUN6QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsd0RBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEVBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsd0RBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0RBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVFQUF3QjtBQUMzQztBQUNBO0FBQ0EsbUJBQW1CLG9FQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0ZBQTBCO0FBQzVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLHdEQUFZO0FBQ25DLHNDQUFzQyxpREFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFlBQVk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0RUFBd0I7QUFDckU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyx3REFBZ0I7QUFDcEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBEQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLFlBQVksNEJBQTRCLGNBQWM7QUFDcEo7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjLEdBQUcsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsWUFBWSw0QkFBNEIsV0FBVztBQUM3STtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwRUFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsMkNBQTJDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0IsaUJBQWlCO0FBQzFFLHdDQUF3QyxnQkFBZ0IsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMsZUFBZSx3REFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0VBQWdFLHdEQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRix3REFBWTtBQUN0RyxzQ0FBc0Msd0RBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsd0RBQVk7QUFDckY7QUFDQTtBQUNBLGdFQUFnRSx3REFBWTtBQUM1RTtBQUNBO0FBQ0EsdUVBQXVFLHdEQUFZO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3REFBWTtBQUM3RDtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWUsb0VBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBFQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQSw0REFBNEQsTUFBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVEQUFXLFdBQVcsbUNBQW1DO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBLDhDQUE4Qyx5QkFBeUI7QUFDdkUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNELGVBQWUsdURBQVcsV0FBVyxzQ0FBc0M7QUFDM0U7QUFDQTtBQUNBLGVBQWUsb0NBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQ0FBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBLHlFQUF5RSxzQkFBc0I7QUFDL0YsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBWTtBQUNuQyx1Q0FBdUMsdUVBQTJCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQSwyREFBMkQsdURBQVc7QUFDdEUsb0dBQW9HLE1BQU07QUFDMUcsaUJBQWlCO0FBQ2pCLHNDQUFzQyxnRUFBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHVEQUFXO0FBQzNFLGdHQUFnRyxrQkFBa0I7QUFDbEgsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxrRUFBa0UsbUVBQTJCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBLGlIQUFpSCxNQUFNO0FBQ3ZILDJCQUEyQix1REFBVyxrQkFBa0IsNEJBQTRCO0FBQ3BGLGlCQUFpQjtBQUNqQix1Q0FBdUMsZ0VBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1RUFBMkI7QUFDbEUsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHVEQUFXO0FBQ2pGO0FBQ0EsYUFBYTtBQUNiLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQSxzRUFBc0UsdURBQVc7QUFDakYsb0dBQW9HLE1BQU07QUFDMUcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsTUFBTTtBQUNwRSwyQkFBMkI7QUFDM0I7QUFDQSxtRUFBbUUsTUFBTTtBQUN6RSwyQkFBMkI7QUFDM0I7QUFDQSxJQUFJO0FBQ0osMENBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMsdUNBQXVDLHVFQUEyQjtBQUNsRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsdURBQVc7QUFDdEUsK0RBQStELElBQUk7QUFDbkUsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixrQkFBa0IsZ0VBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw0QkFBNEIsc0RBQUk7QUFDaEM7QUFDQTtBQUNBLDJEQUEyRCx1REFBVztBQUN0RSwyREFBMkQsSUFBSTtBQUMvRCxhQUFhO0FBQ2Isd0RBQXdELGtCQUFrQjtBQUMxRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUIsUUFBUSxnRUFBYztBQUM3RDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDhEQUE4RCxrQkFBa0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMscUNBQXFDLHFFQUF1QjtBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSxvRUFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWEsbUZBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsZ0NBQWdDLHVFQUEyQjtBQUMzRCxrQ0FBa0MsdURBQVcsV0FBVyxXQUFXO0FBQ25FLGVBQWUsZ0VBQWM7QUFDN0I7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLFlBQVksMERBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxRQUFRLG1GQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0EseUJBQXlCLFdBQVcsV0FBVztBQUMvQztBQUNBLDhCQUE4QixlQUFlLG9CQUFvQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1GQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFXO0FBQzNDO0FBQ0EsMkRBQTJELCtEQUF1QjtBQUNsRixhQUFhO0FBQ2IsaUJBQWlCLHFGQUFrQyxlQUFlLGtFQUFzQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLCtEQUF1QjtBQUNsRyx5QkFBeUI7QUFDekI7QUFDQSw2QkFBNkIsMERBQWU7QUFDNUM7QUFDQSxrREFBa0Qsd0VBQTZCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2REFBa0I7QUFDL0M7QUFDQSw0Q0FBNEMsbUVBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1REFBVztBQUN2QztBQUNBLHVEQUF1RCwrREFBdUI7QUFDOUUsU0FBUztBQUNUO0FBQ0EsaUJBQWlCLHFGQUFrQyxlQUFlLGtFQUFzQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWU7QUFDaEMsc0NBQXNDLHdFQUE2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBa0I7QUFDbkMsZ0NBQWdDLG1FQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMscUNBQXFDLHFFQUF1QjtBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSxvRUFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMsdUNBQXVDLHVFQUEyQjtBQUNsRSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0EsNEJBQTRCLHVEQUFXO0FBQ3ZDO0FBQ0EsU0FBUztBQUNULDBCQUEwQixxRkFBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DLHVDQUF1Qyx1RUFBMkI7QUFDbEUsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFXO0FBQzNDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx5QkFBeUIsd0VBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsOEVBQThFLHVFQUEyQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHVEQUFXO0FBQzNHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCLG1CQUFtQixLQUFLLGNBQWM7QUFDcEU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdDQUFnQyxjQUFjLEtBQUssbUJBQW1CO0FBQ3RFLGNBQWMsb0JBQW9CLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0EsNkNBQTZDLGdDQUFnQztBQUM3RTtBQUNBLFFBQVEsNENBQTRDLFNBQVMsbUJBQW1CO0FBQ2hGO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzREFBSTtBQUNoRDtBQUNBLDhEQUE4RCx1REFBVyxZQUFZLG1DQUFtQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGFBQWE7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMscUNBQXFDLHFFQUF1QjtBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSxvRUFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMscUNBQXFDLHFFQUF1QjtBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSxvRUFBc0I7QUFDckM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQVc7QUFDL0I7QUFDQSwwQ0FBMEMsdUVBQWlCO0FBQzNEO0FBQ0E7QUFDQSxrQ0FBa0MsdUVBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZSxZQUFZLFlBQVksZUFBZTtBQUNuRTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVywwQkFBMEI7QUFDckMsYUFBYSx1REFBdUQ7QUFDcEU7QUFDTztBQUNQO0FBQ0EsOENBQThDLDBFQUFvQjtBQUNsRSxRQUFRLDZFQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQ0csR0FBRyxPQUFPLDJDQUFRLElBQUk7QUFDN0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccnVubmFibGVzXFxiYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHogfSBmcm9tIFwiem9kL3YzXCI7XG5pbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgaXNUcmFjZWFibGVGdW5jdGlvbiwgfSBmcm9tIFwibGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlXCI7XG5pbXBvcnQgeyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIFJ1bkxvZywgUnVuTG9nUGF0Y2gsIGlzTG9nU3RyZWFtSGFuZGxlciwgfSBmcm9tIFwiLi4vdHJhY2Vycy9sb2dfc3RyZWFtLmpzXCI7XG5pbXBvcnQgeyBFdmVudFN0cmVhbUNhbGxiYWNrSGFuZGxlciwgaXNTdHJlYW1FdmVudHNIYW5kbGVyLCB9IGZyb20gXCIuLi90cmFjZXJzL2V2ZW50X3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgU2VyaWFsaXphYmxlIH0gZnJvbSBcIi4uL2xvYWQvc2VyaWFsaXphYmxlLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLCBjb25jYXQsIGF0ZWUsIHBpcGVHZW5lcmF0b3JXaXRoU2V0dXAsIEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwLCB9IGZyb20gXCIuLi91dGlscy9zdHJlYW0uanNcIjtcbmltcG9ydCB7IHJhY2VXaXRoU2lnbmFsIH0gZnJvbSBcIi4uL3V0aWxzL3NpZ25hbC5qc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9SRUNVUlNJT05fTElNSVQsIGVuc3VyZUNvbmZpZywgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnLCBtZXJnZUNvbmZpZ3MsIHBhdGNoQ29uZmlnLCBwaWNrUnVubmFibGVDb25maWdLZXlzLCB9IGZyb20gXCIuL2NvbmZpZy5qc1wiO1xuaW1wb3J0IHsgQXN5bmNDYWxsZXIgfSBmcm9tIFwiLi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG5pbXBvcnQgeyBSb290TGlzdGVuZXJzVHJhY2VyIH0gZnJvbSBcIi4uL3RyYWNlcnMvcm9vdF9saXN0ZW5lci5qc1wiO1xuaW1wb3J0IHsgX1Jvb3RFdmVudEZpbHRlciwgaXNSdW5uYWJsZUludGVyZmFjZSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIH0gZnJvbSBcIi4uL3NpbmdsZXRvbnMvaW5kZXguanNcIjtcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSBcIi4vZ3JhcGguanNcIjtcbmltcG9ydCB7IGNvbnZlcnRUb0h0dHBFdmVudFN0cmVhbSB9IGZyb20gXCIuL3dyYXBwZXJzLmpzXCI7XG5pbXBvcnQgeyBjb25zdW1lQXN5bmNJdGVyYWJsZUluQ29udGV4dCwgY29uc3VtZUl0ZXJhdG9ySW5Db250ZXh0LCBpc0FzeW5jSXRlcmFibGUsIGlzSXRlcmFibGVJdGVyYXRvciwgaXNJdGVyYXRvciwgfSBmcm9tIFwiLi9pdGVyLmpzXCI7XG5pbXBvcnQgeyBfaXNUb29sQ2FsbCwgVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbiB9IGZyb20gXCIuLi90b29scy91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0U2NoZW1hRGVzY3JpcHRpb24sIGludGVyb3BQYXJzZUFzeW5jLCBpc1NpbXBsZVN0cmluZ1pvZFNjaGVtYSwgfSBmcm9tIFwiLi4vdXRpbHMvdHlwZXMvem9kLmpzXCI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VUb0RpY3QodmFsdWUsIGRlZmF1bHRLZXkpIHtcbiAgICByZXR1cm4gdmFsdWUgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogeyBbZGVmYXVsdEtleV06IHZhbHVlIH07XG59XG4vKipcbiAqIEEgUnVubmFibGUgaXMgYSBnZW5lcmljIHVuaXQgb2Ygd29yayB0aGF0IGNhbiBiZSBpbnZva2VkLCBiYXRjaGVkLCBzdHJlYW1lZCwgYW5kL29yXG4gKiB0cmFuc2Zvcm1lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfcnVubmFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TmFtZShzdWZmaXgpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLm5hbWUgPz8gdGhpcy5jb25zdHJ1Y3Rvci5sY19uYW1lKCkgPz8gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICByZXR1cm4gc3VmZml4ID8gYCR7bmFtZX0ke3N1ZmZpeH1gIDogbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBhcmd1bWVudHMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBrd2FyZ3NcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBSdW5uYWJsZUJpbmRpbmcgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIGFwcGx5IHRoZSBib3VuZCBhcmdzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayB3aXRoQ29uZmlnfSBpbnN0ZWFkLiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBicmVha2luZyByZWxlYXNlLlxuICAgICAqL1xuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUJpbmRpbmcoeyBib3VuZDogdGhpcywga3dhcmdzLCBjb25maWc6IHt9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgUnVubmFibGUgdGhhdCBtYXBzIGEgbGlzdCBvZiBpbnB1dHMgdG8gYSBsaXN0IG9mIG91dHB1dHMsXG4gICAgICogYnkgY2FsbGluZyBpbnZva2UoKSB3aXRoIGVhY2ggaW5wdXQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBicmVha2luZyByZWxlYXNlLlxuICAgICAqL1xuICAgIG1hcCgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlRWFjaCh7IGJvdW5kOiB0aGlzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcmV0cnkgbG9naWMgdG8gYW4gZXhpc3RpbmcgcnVubmFibGUuXG4gICAgICogQHBhcmFtIGZpZWxkcy5zdG9wQWZ0ZXJBdHRlbXB0IFRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gcmV0cnkuXG4gICAgICogQHBhcmFtIGZpZWxkcy5vbkZhaWxlZEF0dGVtcHQgQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgcmV0cnkgZmFpbHMuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVSZXRyeSB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgcmV0cnkgYWNjb3JkaW5nIHRvIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHdpdGhSZXRyeShmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlUmV0cnkoe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMsXG4gICAgICAgICAgICBrd2FyZ3M6IHt9LFxuICAgICAgICAgICAgY29uZmlnOiB7fSxcbiAgICAgICAgICAgIG1heEF0dGVtcHROdW1iZXI6IGZpZWxkcz8uc3RvcEFmdGVyQXR0ZW1wdCxcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgY29uZmlnIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE5ldyBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdG8gYXR0YWNoIHRvIHRoZSBuZXcgcnVubmFibGUuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVCaW5kaW5nIHdpdGggYSBjb25maWcgbWF0Y2hpbmcgd2hhdCdzIHBhc3NlZC5cbiAgICAgKi9cbiAgICB3aXRoQ29uZmlnKGNvbmZpZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAga3dhcmdzOiB7fSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBydW5uYWJsZSBmcm9tIHRoZSBjdXJyZW50IG9uZSB0aGF0IHdpbGwgdHJ5IGludm9raW5nXG4gICAgICogb3RoZXIgcGFzc2VkIGZhbGxiYWNrIHJ1bm5hYmxlcyBpZiB0aGUgaW5pdGlhbCBpbnZvY2F0aW9uIGZhaWxzLlxuICAgICAqIEBwYXJhbSBmaWVsZHMuZmFsbGJhY2tzIE90aGVyIHJ1bm5hYmxlcyB0byBjYWxsIGlmIHRoZSBydW5uYWJsZSBlcnJvcnMuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVXaXRoRmFsbGJhY2tzLlxuICAgICAqL1xuICAgIHdpdGhGYWxsYmFja3MoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IEFycmF5LmlzQXJyYXkoZmllbGRzKSA/IGZpZWxkcyA6IGZpZWxkcy5mYWxsYmFja3M7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVdpdGhGYWxsYmFja3Moe1xuICAgICAgICAgICAgcnVubmFibGU6IHRoaXMsXG4gICAgICAgICAgICBmYWxsYmFja3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucywgbGVuZ3RoID0gMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhc3NlZCBcIm9wdGlvbnNcIiBtdXN0IGJlIGFuIGFycmF5IHdpdGggdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBpbnB1dHMsIGJ1dCBnb3QgJHtvcHRpb25zLmxlbmd0aH0gb3B0aW9ucyBmb3IgJHtsZW5ndGh9IGlucHV0c2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5tYXAoZW5zdXJlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gMSAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLnJ1bklkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQcm92aWRlZCBydW5JZCB3aWxsIGJlIHVzZWQgb25seSBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGJhdGNoLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNlcXVlbnQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZmlsdGVyKChba2V5XSkgPT4ga2V5ICE9PSBcInJ1bklkXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIChfLCBpKSA9PiBlbnN1cmVDb25maWcoaSA9PT0gMCA/IG9wdGlvbnMgOiBzdWJzZXF1ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGggfSwgKCkgPT4gZW5zdXJlQ29uZmlnKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnTGlzdCA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBtYXhDb25jdXJyZW5jeSA9IGNvbmZpZ0xpc3RbMF0/Lm1heENvbmN1cnJlbmN5ID8/IGJhdGNoT3B0aW9ucz8ubWF4Q29uY3VycmVuY3k7XG4gICAgICAgIGNvbnN0IGNhbGxlciA9IG5ldyBBc3luY0NhbGxlcih7XG4gICAgICAgICAgICBtYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJhdGNoQ2FsbHMgPSBpbnB1dHMubWFwKChpbnB1dCwgaSkgPT4gY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmludm9rZShpbnB1dCwgY29uZmlnTGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhdGNoT3B0aW9ucz8ucmV0dXJuRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYmF0Y2hDYWxscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RyZWFtaW5nIGltcGxlbWVudGF0aW9uLlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXkgc3VwcG9ydCBzdHJlYW1pbmcgb3V0cHV0LlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICB5aWVsZCB0aGlzLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSBvdXRwdXQgaW4gY2h1bmtzLlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybnMgQSByZWFkYWJsZSBzdHJlYW0gdGhhdCBpcyBhbHNvIGFuIGl0ZXJhYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBCdWZmZXIgdGhlIGZpcnN0IHN0cmVhbWVkIGNodW5rIHRvIGFsbG93IGZvciBpbml0aWFsIGVycm9yc1xuICAgICAgICAvLyB0byBzdXJmYWNlIGltbWVkaWF0ZWx5LlxuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG4gICAgX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBsZXQgcnVubmFibGVDb25maWc7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bm5hYmxlQ29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcnVubmFibGVDb25maWcgPSBlbnN1cmVDb25maWcoe1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogb3B0aW9ucy5jYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgdGFnczogb3B0aW9ucy50YWdzLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHJ1bk5hbWU6IG9wdGlvbnMucnVuTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IG9wdGlvbnMuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiBvcHRpb25zLnJlY3Vyc2lvbkxpbWl0LFxuICAgICAgICAgICAgICAgIG1heENvbmN1cnJlbmN5OiBvcHRpb25zLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgICAgIHJ1bklkOiBvcHRpb25zLnJ1bklkLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCxcbiAgICAgICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLmNhbGxiYWNrcztcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnRhZ3M7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5tZXRhZGF0YTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnJ1bk5hbWU7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5jb25maWd1cmFibGU7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5yZWN1cnNpb25MaW1pdDtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLm1heENvbmN1cnJlbmN5O1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMucnVuSWQ7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy50aW1lb3V0O1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMuc2lnbmFsO1xuICAgICAgICByZXR1cm4gW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc107XG4gICAgfVxuICAgIGFzeW5jIF9jYWxsV2l0aENvbmZpZyhmdW5jLCBpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnLnJ1bklkLCBjb25maWc/LnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCkpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGZ1bmMuY2FsbCh0aGlzLCBpbnB1dCwgY29uZmlnLCBydW5NYW5hZ2VyKTtcbiAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIG9wdGlvbnM/LnNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0aGF0IGhhbmRsZXMgYmF0Y2hpbmcgYW5kIGNvbmZpZ3VyYXRpb24gZm9yIGEgcnVubmFibGVcbiAgICAgKiBJdCB0YWtlcyBhIGZ1bmN0aW9uLCBpbnB1dCB2YWx1ZXMsIGFuZCBvcHRpb25hbCBjb25maWd1cmF0aW9uLCBhbmRcbiAgICAgKiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBmb3IgZWFjaCBpbnB1dCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHZhbHVlcyB0byBiZSBwcm9jZXNzZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgdmFsdWVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9iYXRjaFdpdGhDb25maWcoZnVuYywgaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uc0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnNMaXN0Lm1hcChnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja01hbmFnZXJzLm1hcChhc3luYyAoY2FsbGJhY2tNYW5hZ2VyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVTdGFydFJlcyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0c1tpXSwgXCJpbnB1dFwiKSwgb3B0aW9uc0xpc3RbaV0ucnVuSWQsIG9wdGlvbnNMaXN0W2ldLnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zTGlzdFtpXS5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zTGlzdFtpXS5ydW5JZDtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdGFydFJlcztcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgb3V0cHV0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBmdW5jLmNhbGwodGhpcywgaW5wdXRzLCBvcHRpb25zTGlzdCwgcnVuTWFuYWdlcnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgICAgICAgICBvdXRwdXRzID0gYXdhaXQgcmFjZVdpdGhTaWduYWwocHJvbWlzZSwgb3B0aW9uc0xpc3Q/LlswXT8uc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpKSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXRzLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY29uY2F0T3V0cHV0Q2h1bmtzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChmaXJzdCwgc2Vjb25kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byB0cmFuc2Zvcm0gYW4gSXRlcmF0b3Igb2YgSW5wdXQgdmFsdWVzIGludG8gYW4gSXRlcmF0b3Igb2ZcbiAgICAgKiBPdXRwdXQgdmFsdWVzLCB3aXRoIGNhbGxiYWNrcy5cbiAgICAgKiBVc2UgdGhpcyB0byBpbXBsZW1lbnQgYHN0cmVhbSgpYCBvciBgdHJhbnNmb3JtKClgIGluIFJ1bm5hYmxlIHN1YmNsYXNzZXMuXG4gICAgICovXG4gICAgYXN5bmMgKl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGlucHV0R2VuZXJhdG9yLCB0cmFuc2Zvcm1lciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZmluYWxJbnB1dDtcbiAgICAgICAgbGV0IGZpbmFsSW5wdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhjb25maWcpO1xuICAgICAgICBjb25zdCBvdXRlclRoaXMgPSB0aGlzO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogd3JhcElucHV0Rm9yVHJhY2luZygpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxJbnB1dFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxJbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXQgPSBvdXRlclRoaXMuX2NvbmNhdE91dHB1dENodW5rcyhmaW5hbElucHV0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVuTWFuYWdlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBpcGUgPSBhd2FpdCBwaXBlR2VuZXJhdG9yV2l0aFNldHVwKHRyYW5zZm9ybWVyLmJpbmQodGhpcyksIHdyYXBJbnB1dEZvclRyYWNpbmcoKSwgYXN5bmMgKCkgPT4gY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCB7IGlucHV0OiBcIlwiIH0sIGNvbmZpZy5ydW5JZCwgY29uZmlnLnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWcucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKSksIG9wdGlvbnM/LnNpZ25hbCwgY29uZmlnKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgICAgICBydW5NYW5hZ2VyID0gcGlwZS5zZXR1cDtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUV2ZW50c0hhbmRsZXIgPSBydW5NYW5hZ2VyPy5oYW5kbGVycy5maW5kKGlzU3RyZWFtRXZlbnRzSGFuZGxlcik7XG4gICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSBwaXBlLm91dHB1dDtcbiAgICAgICAgICAgIGlmIChzdHJlYW1FdmVudHNIYW5kbGVyICE9PSB1bmRlZmluZWQgJiYgcnVuTWFuYWdlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBzdHJlYW1FdmVudHNIYW5kbGVyLnRhcE91dHB1dEl0ZXJhYmxlKHJ1bk1hbmFnZXIucnVuSWQsIGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUxvZ0hhbmRsZXIgPSBydW5NYW5hZ2VyPy5oYW5kbGVycy5maW5kKGlzTG9nU3RyZWFtSGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoc3RyZWFtTG9nSGFuZGxlciAhPT0gdW5kZWZpbmVkICYmIHJ1bk1hbmFnZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gc3RyZWFtTG9nSGFuZGxlci50YXBPdXRwdXRJdGVyYWJsZShydW5NYW5hZ2VyLnJ1bklkLCBpdGVyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IHRoaXMuX2NvbmNhdE91dHB1dENodW5rcyhmaW5hbE91dHB1dCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBfY29lcmNlVG9EaWN0KGZpbmFsSW5wdXQsIFwiaW5wdXRcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoZmluYWxPdXRwdXQgPz8ge30sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgaW5wdXRzOiBfY29lcmNlVG9EaWN0KGZpbmFsSW5wdXQsIFwiaW5wdXRcIikgfSk7XG4gICAgfVxuICAgIGdldEdyYXBoKF8pIHtcbiAgICAgICAgY29uc3QgZ3JhcGggPSBuZXcgR3JhcGgoKTtcbiAgICAgICAgLy8gVE9ETzogQWRkIGlucHV0IHNjaGVtYSBmb3IgcnVubmFibGVzXG4gICAgICAgIGNvbnN0IGlucHV0Tm9kZSA9IGdyYXBoLmFkZE5vZGUoe1xuICAgICAgICAgICAgbmFtZTogYCR7dGhpcy5nZXROYW1lKCl9SW5wdXRgLFxuICAgICAgICAgICAgc2NoZW1hOiB6LmFueSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcnVubmFibGVOb2RlID0gZ3JhcGguYWRkTm9kZSh0aGlzKTtcbiAgICAgICAgLy8gVE9ETzogQWRkIG91dHB1dCBzY2hlbWFzIGZvciBydW5uYWJsZXNcbiAgICAgICAgY29uc3Qgb3V0cHV0Tm9kZSA9IGdyYXBoLmFkZE5vZGUoe1xuICAgICAgICAgICAgbmFtZTogYCR7dGhpcy5nZXROYW1lKCl9T3V0cHV0YCxcbiAgICAgICAgICAgIHNjaGVtYTogei5hbnkoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGdyYXBoLmFkZEVkZ2UoaW5wdXROb2RlLCBydW5uYWJsZU5vZGUpO1xuICAgICAgICBncmFwaC5hZGRFZGdlKHJ1bm5hYmxlTm9kZSwgb3V0cHV0Tm9kZSk7XG4gICAgICAgIHJldHVybiBncmFwaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJ1bm5hYmxlIHNlcXVlbmNlIHRoYXQgcnVucyBlYWNoIGluZGl2aWR1YWwgcnVubmFibGUgaW4gc2VyaWVzLFxuICAgICAqIHBpcGluZyB0aGUgb3V0cHV0IG9mIG9uZSBydW5uYWJsZSBpbnRvIGFub3RoZXIgcnVubmFibGUgb3IgcnVubmFibGUtbGlrZS5cbiAgICAgKiBAcGFyYW0gY29lcmNlYWJsZSBBIHJ1bm5hYmxlLCBmdW5jdGlvbiwgb3Igb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZnVuY3Rpb25zIG9yIHJ1bm5hYmxlcy5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBydW5uYWJsZSBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBwaXBlKGNvZXJjZWFibGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgZmlyc3Q6IHRoaXMsXG4gICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpY2sga2V5cyBmcm9tIHRoZSBkaWN0IG91dHB1dCBvZiB0aGlzIHJ1bm5hYmxlLiBSZXR1cm5zIGEgbmV3IHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIHBpY2soa2V5cykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiB0aGlzLnBpcGUobmV3IFJ1bm5hYmxlUGljayhrZXlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgbmV3IGZpZWxkcyB0byB0aGUgZGljdCBvdXRwdXQgb2YgdGhpcyBydW5uYWJsZS4gUmV0dXJucyBhIG5ldyBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3NpZ24obWFwcGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5waXBlKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIG5ldyBSdW5uYWJsZUFzc2lnbihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBuZXcgUnVubmFibGVNYXAoeyBzdGVwczogbWFwcGluZyB9KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRyYW5zZm9ybSwgd2hpY2ggYnVmZmVycyBpbnB1dCBhbmQgdGhlbiBjYWxscyBzdHJlYW0uXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBjYW4gc3RhcnQgcHJvZHVjaW5nIG91dHB1dCB3aGlsZVxuICAgICAqIGlucHV0IGlzIHN0aWxsIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0gZ2VuZXJhdG9yXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZmluYWxDaHVuaztcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbENodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIGdhdGhlcmluZyBmYWlscy5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSB0aGlzLl9jb25jYXRPdXRwdXRDaHVua3MoZmluYWxDaHVuaywgY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLl9zdHJlYW1JdGVyYXRvcihmaW5hbENodW5rLCBlbnN1cmVDb25maWcob3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gYWxsIG91dHB1dCBmcm9tIGEgcnVubmFibGUsIGFzIHJlcG9ydGVkIHRvIHRoZSBjYWxsYmFjayBzeXN0ZW0uXG4gICAgICogVGhpcyBpbmNsdWRlcyBhbGwgaW5uZXIgcnVucyBvZiBMTE1zLCBSZXRyaWV2ZXJzLCBUb29scywgZXRjLlxuICAgICAqIE91dHB1dCBpcyBzdHJlYW1lZCBhcyBMb2cgb2JqZWN0cywgd2hpY2ggaW5jbHVkZSBhIGxpc3Qgb2ZcbiAgICAgKiBqc29ucGF0Y2ggb3BzIHRoYXQgZGVzY3JpYmUgaG93IHRoZSBzdGF0ZSBvZiB0aGUgcnVuIGhhcyBjaGFuZ2VkIGluIGVhY2hcbiAgICAgKiBzdGVwLCBhbmQgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBydW4uXG4gICAgICogVGhlIGpzb25wYXRjaCBvcHMgY2FuIGJlIGFwcGxpZWQgaW4gb3JkZXIgdG8gY29uc3RydWN0IHN0YXRlLlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHN0cmVhbU9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqc3RyZWFtTG9nKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciA9IG5ldyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgICAgICBfc2NoZW1hRm9ybWF0OiBcIm9yaWdpbmFsXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIHlpZWxkKiB0aGlzLl9zdHJlYW1Mb2coaW5wdXQsIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1Mb2coaW5wdXQsIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2tzIH0gPSBjb25maWc7XG4gICAgICAgIGlmIChjYWxsYmFja3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gW2xvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjYWxsYmFja3MuY29uY2F0KFtsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcGllZENhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICBjb3BpZWRDYWxsYmFja3MuYWRkSGFuZGxlcihsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIHRydWUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY29waWVkQ2FsbGJhY2tzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtUHJvbWlzZSA9IHRoaXMuc3RyZWFtKGlucHV0LCBjb25maWcpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb25zdW1lUnVubmFibGVTdHJlYW0oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtID0gYXdhaXQgcnVubmFibGVTdHJlYW1Qcm9taXNlO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcnVubmFibGVTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCIvc3RyZWFtZWRfb3V0cHV0Ly1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLndyaXRlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtQ29uc3VtZVByb21pc2UgPSBjb25zdW1lUnVubmFibGVTdHJlYW0oKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgbG9nIG9mIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIGxvZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bm5hYmxlU3RyZWFtQ29uc3VtZVByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24gPT09IFwidjFcIikge1xuICAgICAgICAgICAgc3RyZWFtID0gdGhpcy5fc3RyZWFtRXZlbnRzVjEoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudmVyc2lvbiA9PT0gXCJ2MlwiKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSB0aGlzLl9zdHJlYW1FdmVudHNWMihpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgdmVyc2lvbnMgXCJ2MVwiIGFuZCBcInYyXCIgb2YgdGhlIHNjaGVtYSBhcmUgY3VycmVudGx5IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvSHR0cEV2ZW50U3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Ioc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUV2ZW50c1YyKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50U3RyZWFtZXIgPSBuZXcgRXZlbnRTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJ1bklkID0gY29uZmlnLnJ1bklkID8/IHV1aWR2NCgpO1xuICAgICAgICBjb25maWcucnVuSWQgPSBydW5JZDtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gY29uZmlnLmNhbGxiYWNrcztcbiAgICAgICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gW2V2ZW50U3RyZWFtZXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb25jYXQoZXZlbnRTdHJlYW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb3BpZWRDYWxsYmFja3MgPSBjYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgY29waWVkQ2FsbGJhY2tzLmFkZEhhbmRsZXIoZXZlbnRTdHJlYW1lciwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjb3BpZWRDYWxsYmFja3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAvLyBDYWxsIHRoZSBydW5uYWJsZSBpbiBzdHJlYW1pbmcgbW9kZSxcbiAgICAgICAgLy8gYWRkIGVhY2ggY2h1bmsgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgICAgICAgY29uc3Qgb3V0ZXJUaGlzID0gdGhpcztcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCkge1xuICAgICAgICAgICAgbGV0IHNpZ25hbDtcbiAgICAgICAgICAgIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zPy5zaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiYW55XCIgaW4gQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgQWJvcnRTaWduYWwuYW55KCkgaWYgYXZhaWxhYmxlIChOb2RlIDE5KylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBOb2RlIDE4IGFuZCBiZWxvdyAtIGp1c3QgdXNlIHRoZSBwcm92aWRlZCBzaWduYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdlIHN0aWxsIGFib3J0IG91ciBjb250cm9sbGVyIHdoZW4gdGhlIHBhcmVudCBzaWduYWwgYWJvcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW0gPSBhd2FpdCBvdXRlclRoaXMuc3RyZWFtKGlucHV0LCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcHBlZFN0cmVhbSA9IGV2ZW50U3RyZWFtZXIudGFwT3V0cHV0SXRlcmFibGUocnVuSWQsIHJ1bm5hYmxlU3RyZWFtKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBfIG9mIHRhcHBlZFN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGl0ZXJhdGUgc28gdGhhdCB0aGUgY2FsbGJhY2sgaGFuZGxlciBwaWNrcyB1cCBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGV2ZW50U3RyZWFtZXIuZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbCAmJiBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW1Db25zdW1lUHJvbWlzZSA9IGNvbnN1bWVSdW5uYWJsZVN0cmVhbSgpO1xuICAgICAgICBsZXQgZmlyc3RFdmVudFNlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZpcnN0RXZlbnRSdW5JZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2YgZXZlbnRTdHJlYW1lcikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrLWFyb3VuZCBhbiBpc3N1ZSB3aGVyZSB0aGUgaW5wdXRzIGludG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hhaW4gYXJlIG5vdCBhdmFpbGFibGUgdW50aWwgdGhlIGVudGlyZSBpbnB1dCBpcyBjb25zdW1lZC5cbiAgICAgICAgICAgICAgICAvLyBBcyBhIHRlbXBvcmFyeSBzb2x1dGlvbiwgd2UnbGwgbW9kaWZ5IHRoZSBpbnB1dCB0byBiZSB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdhcyBwYXNzZWQgaW50byB0aGUgY2hhaW4uXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdEV2ZW50U2VudCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RXZlbnRTZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFdmVudFJ1bklkID0gZXZlbnQucnVuX2lkO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5ydW5faWQgPT09IGZpcnN0RXZlbnRSdW5JZCAmJiBldmVudC5ldmVudC5lbmRzV2l0aChcIl9lbmRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyB0aGUgZW5kIGV2ZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJvb3QgcnVubmFibGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9udCBpbmNsdWRlIHRoZSBpbnB1dCBpbiB0aGUgZXZlbnQgc2luY2UgaXQncyBndWFyYW50ZWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBmaXJzdCBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnQuZGF0YS5pbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgYXdhaXQgcnVubmFibGVTdHJlYW1Db25zdW1lUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUV2ZW50c1YxKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGxldCBydW5Mb2c7XG4gICAgICAgIGxldCBoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByb290VGFncyA9IGNvbmZpZy50YWdzID8/IFtdO1xuICAgICAgICBjb25zdCByb290TWV0YWRhdGEgPSBjb25maWcubWV0YWRhdGEgPz8ge307XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gY29uZmlnLnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCk7XG4gICAgICAgIGNvbnN0IGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciA9IG5ldyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgICAgICBfc2NoZW1hRm9ybWF0OiBcInN0cmVhbWluZ19ldmVudHNcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJvb3RFdmVudEZpbHRlciA9IG5ldyBfUm9vdEV2ZW50RmlsdGVyKHtcbiAgICAgICAgICAgIC4uLnN0cmVhbU9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBsb2dTdHJlYW0gPSB0aGlzLl9zdHJlYW1Mb2coaW5wdXQsIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgY29uZmlnKTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBsb2cgb2YgbG9nU3RyZWFtKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bkxvZykge1xuICAgICAgICAgICAgICAgIHJ1bkxvZyA9IFJ1bkxvZy5mcm9tUnVuTG9nUGF0Y2gobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bkxvZyA9IHJ1bkxvZy5jb25jYXQobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5Mb2cuc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgZXJyb3I6IFwic3RyZWFtRXZlbnRzXCIgc3RhdGUgaXMgbWlzc2luZy4gUGxlYXNlIG9wZW4gYSBidWcgcmVwb3J0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gWWllbGQgdGhlIHN0YXJ0IGV2ZW50IGZvciB0aGUgcm9vdCBydW5uYWJsZSBpZiBpdCBoYXNuJ3QgYmVlbiBzZWVuLlxuICAgICAgICAgICAgLy8gVGhlIHJvb3QgcnVuIGlzIG5ldmVyIGZpbHRlcmVkIG91dFxuICAgICAgICAgICAgaWYgKCFoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICBoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0geyAuLi5ydW5Mb2cuc3RhdGUgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBzdGF0ZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3N0YXRlLnR5cGV9X3N0YXJ0YCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcm9vdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJvb3RUYWdzLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcm9vdE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyb290RXZlbnRGaWx0ZXIuaW5jbHVkZUV2ZW50KGV2ZW50LCBzdGF0ZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRocyA9IGxvZy5vcHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcCkgPT4gb3AucGF0aC5zdGFydHNXaXRoKFwiL2xvZ3MvXCIpKVxuICAgICAgICAgICAgICAgIC5tYXAoKG9wKSA9PiBvcC5wYXRoLnNwbGl0KFwiL1wiKVsyXSk7XG4gICAgICAgICAgICBjb25zdCBkZWR1cGVkUGF0aHMgPSBbLi4ubmV3IFNldChwYXRocyldO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGRlZHVwZWRQYXRocykge1xuICAgICAgICAgICAgICAgIGxldCBldmVudFR5cGU7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dFbnRyeSA9IHJ1bkxvZy5zdGF0ZS5sb2dzW3BhdGhdO1xuICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5lbmRfdGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJzdHJlYW1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IFwic3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJlbmRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIGlucHV0cyB3aXRoIHRoZSBzdGFydCBldmVudCBpZiB0aGV5IGFyZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzdWFsbHkgdGhleSB3aWxsIE5PVCBiZSBhdmFpbGFibGUgZm9yIGNvbXBvbmVudHMgdGhhdCBvcGVyYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHN0cmVhbXMsIHNpbmNlIHRob3NlIGNvbXBvbmVudHMgc3RyZWFtIHRoZSBpbnB1dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qga25vdyBpdHMgZmluYWwgdmFsdWUgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobG9nRW50cnkuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaW5wdXQgPSBsb2dFbnRyeS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5pbnB1dCA9IGxvZ0VudHJ5LmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhLm91dHB1dCA9IGxvZ0VudHJ5LmZpbmFsX291dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInN0cmVhbVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBleGFjdGx5IG9uZSBjaHVuayBvZiBzdHJlYW1lZCBvdXRwdXQsIGdvdCAke2NodW5rQ291bnR9IGluc3RlYWQuIEVuY291bnRlcmVkIGluOiBcIiR7bG9nRW50cnkubmFtZX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7IGNodW5rOiBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXRbMF0gfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHN0cmVhbSwgd2UgZG9uJ3QgbmVlZCBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgdGhpcyBhdm9pZHMgZHVwbGljYXRlcyBhcyB3ZWxsIVxuICAgICAgICAgICAgICAgICAgICBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7bG9nRW50cnkudHlwZX1fJHtldmVudFR5cGV9YCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbG9nRW50cnkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBsb2dFbnRyeS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogbG9nRW50cnkudGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IGxvZ0VudHJ5Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB3ZSB0YWtlIGNhcmUgb2YgdGhlIHN0cmVhbWluZyBvdXRwdXQgZnJvbSB0aGUgcm9vdCBjaGFpblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55LlxuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gcnVuTG9nO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnN0cmVhbWVkX291dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IHN0YXRlLnN0cmVhbWVkX291dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBleGFjdGx5IG9uZSBjaHVuayBvZiBzdHJlYW1lZCBvdXRwdXQsIGdvdCAke2NodW5rQ291bnR9IGluc3RlYWQuIEVuY291bnRlcmVkIGluOiBcIiR7c3RhdGUubmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geyBjaHVuazogc3RhdGUuc3RyZWFtZWRfb3V0cHV0WzBdIH07XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHN0cmVhbSwgd2UgZG9uJ3QgbmVlZCBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICAgIHN0YXRlLnN0cmVhbWVkX291dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7c3RhdGUudHlwZX1fc3RyZWFtYCxcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBzdGF0ZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcm9vdFRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiByb290TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHJvb3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFdmVudEZpbHRlci5pbmNsdWRlRXZlbnQoZXZlbnQsIHN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHJ1bkxvZz8uc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB5aWVsZCB0aGUgZW5kIGV2ZW50IGZvciB0aGUgcm9vdCBydW5uYWJsZS5cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtzdGF0ZS50eXBlfV9lbmRgLFxuICAgICAgICAgICAgICAgIG5hbWU6IHJvb3ROYW1lLFxuICAgICAgICAgICAgICAgIHJ1bl9pZDogc3RhdGUuaWQsXG4gICAgICAgICAgICAgICAgdGFnczogcm9vdFRhZ3MsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJvb3RNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogc3RhdGUuZmluYWxfb3V0cHV0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJvb3RFdmVudEZpbHRlci5pbmNsdWRlRXZlbnQoZXZlbnQsIHN0YXRlLnR5cGUpKVxuICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGlzUnVubmFibGUodGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIGlzUnVubmFibGVJbnRlcmZhY2UodGhpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGxpZmVjeWNsZSBsaXN0ZW5lcnMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIFRoZSBSdW4gb2JqZWN0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBydW4sIGluY2x1ZGluZyBpdHMgaWQsXG4gICAgICogdHlwZSwgaW5wdXQsIG91dHB1dCwgZXJyb3IsIHN0YXJ0VGltZSwgZW5kVGltZSwgYW5kIGFueSB0YWdzIG9yIG1ldGFkYXRhXG4gICAgICogYWRkZWQgdG8gdGhlIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uU3RhcnQgLSBDYWxsZWQgYmVmb3JlIHRoZSBydW5uYWJsZSBzdGFydHMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRW5kIC0gQ2FsbGVkIGFmdGVyIHRoZSBydW5uYWJsZSBmaW5pc2hlcyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FcnJvciAtIENhbGxlZCBpZiB0aGUgcnVubmFibGUgdGhyb3dzIGFuIGVycm9yLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqL1xuICAgIHdpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciwgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLFxuICAgICAgICAgICAgY29uZmlnOiB7fSxcbiAgICAgICAgICAgIGNvbmZpZ0ZhY3RvcmllczogW1xuICAgICAgICAgICAgICAgIChjb25maWcpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJvb3RMaXN0ZW5lcnNUcmFjZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgcnVubmFibGUgdG8gYSB0b29sLiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYFJ1bm5hYmxlVG9vbExpa2VgXG4gICAgICogd2hpY2ggY29udGFpbnMgdGhlIHJ1bm5hYmxlLCBuYW1lLCBkZXNjcmlwdGlvbiBhbmQgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIHtUIGV4dGVuZHMgUnVuSW5wdXQgPSBSdW5JbnB1dH0gUnVuSW5wdXQgLSBUaGUgaW5wdXQgdHlwZSBvZiB0aGUgcnVubmFibGUuIFNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGUgYFJ1bklucHV0YCB0eXBlIG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2ZpZWxkcy5uYW1lXSBUaGUgbmFtZSBvZiB0aGUgdG9vbC4gSWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIG5hbWUgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbZmllbGRzLmRlc2NyaXB0aW9uXSBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIHRvb2wuIEZhbGxzIGJhY2sgdG8gdGhlIGRlc2NyaXB0aW9uIG9uIHRoZSBab2Qgc2NoZW1hIGlmIG5vdCBwcm92aWRlZCwgb3IgdW5kZWZpbmVkIGlmIG5laXRoZXIgYXJlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7ei5ab2RUeXBlPFQ+fSBbZmllbGRzLnNjaGVtYV0gVGhlIFpvZCBzY2hlbWEgZm9yIHRoZSBpbnB1dCBvZiB0aGUgdG9vbC4gSW5mZXJzIHRoZSBab2QgdHlwZSBmcm9tIHRoZSBpbnB1dCB0eXBlIG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7UnVubmFibGVUb29sTGlrZTx6LlpvZFR5cGU8VD4sIFJ1bk91dHB1dD59IEFuIGluc3RhbmNlIG9mIGBSdW5uYWJsZVRvb2xMaWtlYCB3aGljaCBpcyBhIHJ1bm5hYmxlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSB0b29sLlxuICAgICAqL1xuICAgIGFzVG9vbChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRSdW5uYWJsZVRvVG9vbCh0aGlzLCBmaWVsZHMpO1xuICAgIH1cbn1cbi8qKlxuICogV3JhcHMgYSBydW5uYWJsZSBhbmQgYXBwbGllcyBwYXJ0aWFsIGNvbmZpZyB1cG9uIGludm9jYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIHR5cGUgUnVubmFibGVDb25maWcsXG4gKiAgIFJ1bm5hYmxlTGFtYmRhLFxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IGVuaGFuY2VQcm9maWxlID0gKFxuICogICBwcm9maWxlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICogICBjb25maWc/OiBSdW5uYWJsZUNvbmZpZ1xuICogKSA9PiB7XG4gKiAgIGlmIChjb25maWc/LmNvbmZpZ3VyYWJsZT8ucm9sZSkge1xuICogICAgIHJldHVybiB7IC4uLnByb2ZpbGUsIHJvbGU6IGNvbmZpZy5jb25maWd1cmFibGUucm9sZSB9O1xuICogICB9XG4gKiAgIHJldHVybiBwcm9maWxlO1xuICogfTtcbiAqXG4gKiBjb25zdCBydW5uYWJsZSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oZW5oYW5jZVByb2ZpbGUpO1xuICpcbiAqIC8vIEJpbmQgY29uZmlndXJhdGlvbiB0byB0aGUgcnVubmFibGUgdG8gc2V0IHRoZSB1c2VyJ3Mgcm9sZSBkeW5hbWljYWxseVxuICogY29uc3QgYWRtaW5SdW5uYWJsZSA9IHJ1bm5hYmxlLmJpbmQoeyBjb25maWd1cmFibGU6IHsgcm9sZTogXCJBZG1pblwiIH0gfSk7XG4gKiBjb25zdCB1c2VyUnVubmFibGUgPSBydW5uYWJsZS5iaW5kKHsgY29uZmlndXJhYmxlOiB7IHJvbGU6IFwiVXNlclwiIH0gfSk7XG4gKlxuICogY29uc3QgcmVzdWx0MSA9IGF3YWl0IGFkbWluUnVubmFibGUuaW52b2tlKHtcbiAqICAgbmFtZTogXCJBbGljZVwiLFxuICogICBlbWFpbDogXCJhbGljZUBleGFtcGxlLmNvbVwiXG4gKiB9KTtcbiAqXG4gKiAvLyB7IG5hbWU6IFwiQWxpY2VcIiwgZW1haWw6IFwiYWxpY2VAZXhhbXBsZS5jb21cIiwgcm9sZTogXCJBZG1pblwiIH1cbiAqXG4gKiBjb25zdCByZXN1bHQyID0gYXdhaXQgdXNlclJ1bm5hYmxlLmludm9rZSh7XG4gKiAgIG5hbWU6IFwiQm9iXCIsXG4gKiAgIGVtYWlsOiBcImJvYkBleGFtcGxlLmNvbVwiXG4gKiB9KTtcbiAqXG4gKiAvLyB7IG5hbWU6IFwiQm9iXCIsIGVtYWlsOiBcImJvYkBleGFtcGxlLmNvbVwiLCByb2xlOiBcIlVzZXJcIiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlQmluZGluZyBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVCaW5kaW5nXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJvdW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnRmFjdG9yaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm91bmQgPSBmaWVsZHMuYm91bmQ7XG4gICAgICAgIHRoaXMua3dhcmdzID0gZmllbGRzLmt3YXJncztcbiAgICAgICAgdGhpcy5jb25maWcgPSBmaWVsZHMuY29uZmlnO1xuICAgICAgICB0aGlzLmNvbmZpZ0ZhY3RvcmllcyA9IGZpZWxkcy5jb25maWdGYWN0b3JpZXM7XG4gICAgfVxuICAgIGdldE5hbWUoc3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmdldE5hbWUoc3VmZml4KTtcbiAgICB9XG4gICAgYXN5bmMgX21lcmdlQ29uZmlnKC4uLm9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gbWVyZ2VDb25maWdzKHRoaXMuY29uZmlnLCAuLi5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlQ29uZmlncyhjb25maWcsIC4uLih0aGlzLmNvbmZpZ0ZhY3Rvcmllc1xuICAgICAgICAgICAgPyBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNvbmZpZ0ZhY3Rvcmllcy5tYXAoYXN5bmMgKGNvbmZpZ0ZhY3RvcnkpID0+IGF3YWl0IGNvbmZpZ0ZhY3RvcnkoY29uZmlnKSkpXG4gICAgICAgICAgICA6IFtdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBrd2FyZ3MgVGhlIGFyZ3VtZW50cyB0byBiaW5kIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUnVubmFibGVCaW5kaW5nYCBjbGFzcyB0aGF0IGlzIGJvdW5kIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHdpdGhDb25maWd9IGluc3RlYWQuIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IGJyZWFraW5nIHJlbGVhc2UuXG4gICAgICovXG4gICAgYmluZChrd2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB7IC4uLnRoaXMua3dhcmdzLCAuLi5rd2FyZ3MgfSxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3aXRoQ29uZmlnKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQsXG4gICAgICAgICAgICBrd2FyZ3M6IHRoaXMua3dhcmdzLFxuICAgICAgICAgICAgY29uZmlnOiB7IC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdpdGhSZXRyeShmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlUmV0cnkoe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQsXG4gICAgICAgICAgICBrd2FyZ3M6IHRoaXMua3dhcmdzLFxuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIG1heEF0dGVtcHROdW1iZXI6IGZpZWxkcz8uc3RvcEFmdGVyQXR0ZW1wdCxcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5pbnZva2UoaW5wdXQsIGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKGVuc3VyZUNvbmZpZyhvcHRpb25zKSwgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucylcbiAgICAgICAgICAgID8gYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKGluZGl2aWR1YWxPcHRpb24pID0+IHRoaXMuX21lcmdlQ29uZmlnKGVuc3VyZUNvbmZpZyhpbmRpdmlkdWFsT3B0aW9uKSwgdGhpcy5rd2FyZ3MpKSlcbiAgICAgICAgICAgIDogYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoZW5zdXJlQ29uZmlnKG9wdGlvbnMpLCB0aGlzLmt3YXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmJhdGNoKGlucHV0cywgbWVyZ2VkT3B0aW9ucywgYmF0Y2hPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jb25jYXRPdXRwdXRDaHVua3MoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5fY29uY2F0T3V0cHV0Q2h1bmtzKGZpcnN0LCBzZWNvbmQpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvdW5kLl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoZW5zdXJlQ29uZmlnKG9wdGlvbnMpLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuc3RyZWFtKGlucHV0LCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZyhlbnN1cmVDb25maWcob3B0aW9ucyksIHRoaXMua3dhcmdzKSk7XG4gICAgfVxuICAgIGFzeW5jICp0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvdW5kLnRyYW5zZm9ybShnZW5lcmF0b3IsIGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKGVuc3VyZUNvbmZpZyhvcHRpb25zKSwgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBjb25zdCBvdXRlclRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQqIG91dGVyVGhpcy5ib3VuZC5zdHJlYW1FdmVudHMoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAuLi4oYXdhaXQgb3V0ZXJUaGlzLl9tZXJnZUNvbmZpZyhlbnN1cmVDb25maWcob3B0aW9ucyksIG91dGVyVGhpcy5rd2FyZ3MpKSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24sXG4gICAgICAgICAgICB9LCBzdHJlYW1PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKGdlbmVyYXRvcigpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUnVubmFibGVCaW5kaW5nKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdGhpbmdcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICkge1xuICAgICAgICByZXR1cm4gdGhpbmcuYm91bmQgJiYgUnVubmFibGUuaXNSdW5uYWJsZSh0aGluZy5ib3VuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgbGlmZWN5Y2xlIGxpc3RlbmVycyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogVGhlIFJ1biBvYmplY3QgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1biwgaW5jbHVkaW5nIGl0cyBpZCxcbiAgICAgKiB0eXBlLCBpbnB1dCwgb3V0cHV0LCBlcnJvciwgc3RhcnRUaW1lLCBlbmRUaW1lLCBhbmQgYW55IHRhZ3Mgb3IgbWV0YWRhdGFcbiAgICAgKiBhZGRlZCB0byB0aGUgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25TdGFydCAtIENhbGxlZCBiZWZvcmUgdGhlIHJ1bm5hYmxlIHN0YXJ0cyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FbmQgLSBDYWxsZWQgYWZ0ZXIgdGhlIHJ1bm5hYmxlIGZpbmlzaGVzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVycm9yIC0gQ2FsbGVkIGlmIHRoZSBydW5uYWJsZSB0aHJvd3MgYW4gZXJyb3IsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICovXG4gICAgd2l0aExpc3RlbmVycyh7IG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgICAgICBjb25maWdGYWN0b3JpZXM6IFtcbiAgICAgICAgICAgICAgICAoY29uZmlnKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSb290TGlzdGVuZXJzVHJhY2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBkZWxlZ2F0ZXMgY2FsbHMgdG8gYW5vdGhlciBydW5uYWJsZVxuICogd2l0aCBlYWNoIGVsZW1lbnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IFJ1bm5hYmxlRWFjaCwgUnVubmFibGVMYW1iZGEgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IHRvVXBwZXJDYXNlID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT4gaW5wdXQudG9VcHBlckNhc2UoKTtcbiAqIGNvbnN0IGFkZEdyZWV0aW5nID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT4gYEhlbGxvLCAke2lucHV0fSFgO1xuICpcbiAqIGNvbnN0IHVwcGVyQ2FzZUxhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20odG9VcHBlckNhc2UpO1xuICogY29uc3QgZ3JlZXRpbmdMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGFkZEdyZWV0aW5nKTtcbiAqXG4gKiBjb25zdCBjaGFpbiA9IG5ldyBSdW5uYWJsZUVhY2goe1xuICogICBib3VuZDogdXBwZXJDYXNlTGFtYmRhLnBpcGUoZ3JlZXRpbmdMYW1iZGEpLFxuICogfSk7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW4uaW52b2tlKFtcImFsaWNlXCIsIFwiYm9iXCIsIFwiY2Fyb2xcIl0pXG4gKlxuICogLy8gW1wiSGVsbG8sIEFMSUNFIVwiLCBcIkhlbGxvLCBCT0IhXCIsIFwiSGVsbG8sIENBUk9MIVwiXVxuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgYnJlYWtpbmcgcmVsZWFzZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlRWFjaCBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVFYWNoXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJvdW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm91bmQgPSBmaWVsZHMuYm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBrd2FyZ3MgVGhlIGFyZ3VtZW50cyB0byBiaW5kIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUnVubmFibGVFYWNoYCBjbGFzcyB0aGF0IGlzIGJvdW5kIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHdpdGhDb25maWd9IGluc3RlYWQuIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IGJyZWFraW5nIHJlbGVhc2UuXG4gICAgICovXG4gICAgYmluZChrd2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUVhY2goe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQuYmluZChrd2FyZ3MpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0IGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLmJpbmQodGhpcyksIGlucHV0cywgY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBpbnB1dCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBfaW52b2tlKGlucHV0cywgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmJhdGNoKGlucHV0cywgcGF0Y2hDb25maWcoY29uZmlnLCB7IGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgbGlmZWN5Y2xlIGxpc3RlbmVycyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogVGhlIFJ1biBvYmplY3QgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1biwgaW5jbHVkaW5nIGl0cyBpZCxcbiAgICAgKiB0eXBlLCBpbnB1dCwgb3V0cHV0LCBlcnJvciwgc3RhcnRUaW1lLCBlbmRUaW1lLCBhbmQgYW55IHRhZ3Mgb3IgbWV0YWRhdGFcbiAgICAgKiBhZGRlZCB0byB0aGUgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25TdGFydCAtIENhbGxlZCBiZWZvcmUgdGhlIHJ1bm5hYmxlIHN0YXJ0cyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FbmQgLSBDYWxsZWQgYWZ0ZXIgdGhlIHJ1bm5hYmxlIGZpbmlzaGVzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVycm9yIC0gQ2FsbGVkIGlmIHRoZSBydW5uYWJsZSB0aHJvd3MgYW4gZXJyb3IsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICovXG4gICAgd2l0aExpc3RlbmVycyh7IG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVFYWNoKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLndpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBydW5uYWJsZXMgdGhhdCBjYW4gYmUgcmV0cmllZCBhXG4gKiBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlTGFtYmRhLFxuICogICBSdW5uYWJsZVJldHJ5LFxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIC8vIFNpbXVsYXRlIGFuIEFQSSBjYWxsIHRoYXQgZmFpbHNcbiAqIGNvbnN0IHNpbXVsYXRlQXBpQ2FsbCA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAqICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgQVBJIGNhbGwgd2l0aCBpbnB1dDogJHtpbnB1dH1gKTtcbiAqICAgdGhyb3cgbmV3IEVycm9yKFwiQVBJIGNhbGwgZmFpbGVkIGR1ZSB0byBuZXR3b3JrIGlzc3VlXCIpO1xuICogfTtcbiAqXG4gKiBjb25zdCBhcGlDYWxsTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShzaW11bGF0ZUFwaUNhbGwpO1xuICpcbiAqIC8vIEFwcGx5IHJldHJ5IGxvZ2ljIHVzaW5nIHRoZSAud2l0aFJldHJ5KCkgbWV0aG9kXG4gKiBjb25zdCBhcGlDYWxsV2l0aFJldHJ5ID0gYXBpQ2FsbExhbWJkYS53aXRoUmV0cnkoeyBzdG9wQWZ0ZXJBdHRlbXB0OiAzIH0pO1xuICpcbiAqIC8vIEFsdGVybmF0aXZlbHksIGNyZWF0ZSBhIFJ1bm5hYmxlUmV0cnkgaW5zdGFuY2UgbWFudWFsbHlcbiAqIGNvbnN0IG1hbnVhbFJldHJ5ID0gbmV3IFJ1bm5hYmxlUmV0cnkoe1xuICogICBib3VuZDogYXBpQ2FsbExhbWJkYSxcbiAqICAgbWF4QXR0ZW1wdE51bWJlcjogMyxcbiAqICAgY29uZmlnOiB7fSxcbiAqIH0pO1xuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvbiB1c2luZyB0aGUgLndpdGhSZXRyeSgpIG1ldGhvZFxuICogY29uc3QgcmVzID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeVxuICogICAuaW52b2tlKFwiUmVxdWVzdCAxXCIpXG4gKiAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIGFmdGVyIG11bHRpcGxlIHJldHJpZXM6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICB9KTtcbiAqXG4gKiAvLyBFeGFtcGxlIGludm9jYXRpb24gdXNpbmcgdGhlIG1hbnVhbCByZXRyeSBpbnN0YW5jZVxuICogY29uc3QgcmVzMiA9IGF3YWl0IG1hbnVhbFJldHJ5XG4gKiAgIC5pbnZva2UoXCJSZXF1ZXN0IDJcIilcbiAqICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICogICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgYWZ0ZXIgbXVsdGlwbGUgcmV0cmllczpcIiwgZXJyb3IubWVzc2FnZSk7XG4gKiAgIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVJldHJ5IGV4dGVuZHMgUnVubmFibGVCaW5kaW5nIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVSZXRyeVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4QXR0ZW1wdE51bWJlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogM1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRBdHRlbXB0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAoKSA9PiB7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4QXR0ZW1wdE51bWJlciA9IGZpZWxkcy5tYXhBdHRlbXB0TnVtYmVyID8/IHRoaXMubWF4QXR0ZW1wdE51bWJlcjtcbiAgICAgICAgdGhpcy5vbkZhaWxlZEF0dGVtcHQgPSBmaWVsZHMub25GYWlsZWRBdHRlbXB0ID8/IHRoaXMub25GYWlsZWRBdHRlbXB0O1xuICAgIH1cbiAgICBfcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgY29uc3QgdGFnID0gYXR0ZW1wdCA+IDEgPyBgcmV0cnk6YXR0ZW1wdDoke2F0dGVtcHR9YCA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHBhdGNoQ29uZmlnKGNvbmZpZywgeyBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRhZykgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gcFJldHJ5KChhdHRlbXB0TnVtYmVyKSA9PiBzdXBlci5pbnZva2UoaW5wdXQsIHRoaXMuX3BhdGNoQ29uZmlnRm9yUmV0cnkoYXR0ZW1wdE51bWJlciwgY29uZmlnLCBydW5NYW5hZ2VyKSksIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IChlcnJvcikgPT4gdGhpcy5vbkZhaWxlZEF0dGVtcHQoZXJyb3IsIGlucHV0KSxcbiAgICAgICAgICAgIHJldHJpZXM6IE1hdGgubWF4KHRoaXMubWF4QXR0ZW1wdE51bWJlciAtIDEsIDApLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgaW52b2tlcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0LCBydW4gbWFuYWdlcixcbiAgICAgKiBhbmQgY29uZmlnLiBJdCBoYW5kbGVzIHRoZSByZXRyeSBsb2dpYyBieSBjYXRjaGluZyBhbnkgZXJyb3JzIGFuZFxuICAgICAqIHJlY3Vyc2l2ZWx5IGludm9raW5nIGl0c2VsZiB3aXRoIHRoZSB1cGRhdGVkIGNvbmZpZyBmb3IgdGhlIG5leHQgcmV0cnlcbiAgICAgKiBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgZm9yIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcGFyYW0gcnVuTWFuYWdlciBUaGUgcnVuIG1hbmFnZXIgZm9yIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWcgZm9yIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLmJpbmQodGhpcyksIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgICBhc3luYyBfYmF0Y2goaW5wdXRzLCBjb25maWdzLCBydW5NYW5hZ2VycywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHNNYXAgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHBSZXRyeShhc3luYyAoYXR0ZW1wdE51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0luZGV4ZXMgPSBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoXywgaSkgPT4gaSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaSkgPT4gcmVzdWx0c01hcFtpLnRvU3RyaW5nKCldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzTWFwW2kudG9TdHJpbmcoKV0gaW5zdGFuY2VvZiBFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nSW5wdXRzID0gcmVtYWluaW5nSW5kZXhlcy5tYXAoKGkpID0+IGlucHV0c1tpXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZENvbmZpZ3MgPSByZW1haW5pbmdJbmRleGVzLm1hcCgoaSkgPT4gdGhpcy5fcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0TnVtYmVyLCBjb25maWdzPy5baV0sIHJ1bk1hbmFnZXJzPy5baV0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc3VwZXIuYmF0Y2gocmVtYWluaW5nSW5wdXRzLCBwYXRjaGVkQ29uZmlncywge1xuICAgICAgICAgICAgICAgICAgICAuLi5iYXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkV4Y2VwdGlvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRNYXBJbmRleCA9IHJlbWFpbmluZ0luZGV4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFeGNlcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RXhjZXB0aW9uID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24uaW5wdXQgPSByZW1haW5pbmdJbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c01hcFtyZXN1bHRNYXBJbmRleC50b1N0cmluZygpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZpcnN0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogKGVycm9yKSA9PiB0aGlzLm9uRmFpbGVkQXR0ZW1wdChlcnJvciwgZXJyb3IuaW5wdXQpLFxuICAgICAgICAgICAgICAgIHJldHJpZXM6IE1hdGgubWF4KHRoaXMubWF4QXR0ZW1wdE51bWJlciAtIDEsIDApLFxuICAgICAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzdWx0c01hcClcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhLCAxMCkgLSBwYXJzZUludChiLCAxMCkpXG4gICAgICAgICAgICAubWFwKChrZXkpID0+IHJlc3VsdHNNYXBbcGFyc2VJbnQoa2V5LCAxMCldKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoV2l0aENvbmZpZyh0aGlzLl9iYXRjaC5iaW5kKHRoaXMpLCBpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNlcXVlbmNlIG9mIHJ1bm5hYmxlcywgd2hlcmUgdGhlIG91dHB1dCBvZiBlYWNoIGlzIHRoZSBpbnB1dCBvZiB0aGUgbmV4dC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHRUZW1wbGF0ZSA9IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcbiAqICAgXCJUZWxsIG1lIGEgam9rZSBhYm91dCB7dG9waWN9XCIsXG4gKiApO1xuICogY29uc3QgY2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW3Byb21wdFRlbXBsYXRlLCBuZXcgQ2hhdE9wZW5BSSh7IG1vZGVsOiBcImdwdC00by1taW5pXCIgfSldKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmludm9rZSh7IHRvcGljOiBcImJlYXJzXCIgfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlU2VxdWVuY2UgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlU2VxdWVuY2VcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpcnN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pZGRsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib21pdFNlcXVlbmNlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maXJzdCA9IGZpZWxkcy5maXJzdDtcbiAgICAgICAgdGhpcy5taWRkbGUgPSBmaWVsZHMubWlkZGxlID8/IHRoaXMubWlkZGxlO1xuICAgICAgICB0aGlzLmxhc3QgPSBmaWVsZHMubGFzdDtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMub21pdFNlcXVlbmNlVGFncyA9IGZpZWxkcy5vbWl0U2VxdWVuY2VUYWdzID8/IHRoaXMub21pdFNlcXVlbmNlVGFncztcbiAgICB9XG4gICAgZ2V0IHN0ZXBzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlLCB0aGlzLmxhc3RdO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIGNvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5OYW1lKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgbGV0IG5leHRTdGVwSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFN0ZXBzID0gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdGlhbFN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IGluaXRpYWxTdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gc3RlcC5pbnZva2UobmV4dFN0ZXBJbnB1dCwgcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGhpcy5vbWl0U2VxdWVuY2VUYWdzID8gdW5kZWZpbmVkIDogYHNlcTpzdGVwOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIG5leHRTdGVwSW5wdXQgPSBhd2FpdCByYWNlV2l0aFNpZ25hbChwcm9taXNlLCBvcHRpb25zPy5zaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBjYW4ndCBkZXRlY3QgdGhhdCB0aGUgbGFzdCBvdXRwdXQgb2YgdGhlIHNlcXVlbmNlIHJldHVybnMgUnVuT3V0cHV0LCBzbyBjYWxsIGl0IG91dCBvZiB0aGUgbG9vcCBoZXJlXG4gICAgICAgICAgICBpZiAob3B0aW9ucz8uc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gYXdhaXQgdGhpcy5sYXN0Lmludm9rZShuZXh0U3RlcElucHV0LCBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRoaXMub21pdFNlcXVlbmNlVGFncyA/IHVuZGVmaW5lZCA6IGBzZXE6c3RlcDoke3RoaXMuc3RlcHMubGVuZ3RofWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KGZpbmFsT3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgICAgIHJldHVybiBmaW5hbE91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnTGlzdCA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY29uZmlnTGlzdC5tYXAoZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoYXN5bmMgKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnRSZXMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dHNbaV0sIFwiaW5wdXRcIiksIGNvbmZpZ0xpc3RbaV0ucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZ0xpc3RbaV0ucnVuTmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnTGlzdFtpXS5ydW5JZDtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdGFydFJlcztcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgbmV4dFN0ZXBJbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5zdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gc3RlcC5iYXRjaChuZXh0U3RlcElucHV0cywgcnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUnVuTWFuYWdlciA9IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRoaXMub21pdFNlcXVlbmNlVGFncyA/IHVuZGVmaW5lZCA6IGBzZXE6c3RlcDoke2kgKyAxfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hDb25maWcoY29uZmlnTGlzdFtqXSwgeyBjYWxsYmFja3M6IGNoaWxkUnVuTWFuYWdlciB9KTtcbiAgICAgICAgICAgICAgICB9KSwgYmF0Y2hPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBuZXh0U3RlcElucHV0cyA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIGNvbmZpZ0xpc3RbMF0/LnNpZ25hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKSkpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QobmV4dFN0ZXBJbnB1dHMsIFwib3V0cHV0XCIpKSkpO1xuICAgICAgICByZXR1cm4gbmV4dFN0ZXBJbnB1dHM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY29uY2F0T3V0cHV0Q2h1bmtzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdC5fY29uY2F0T3V0cHV0Q2h1bmtzKGZpcnN0LCBzZWNvbmQpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgcnVuSWQsIC4uLm90aGVyT3B0aW9ucyB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgcnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG90aGVyT3B0aW9ucz8ucnVuTmFtZSk7XG4gICAgICAgIGNvbnN0IHN0ZXBzID0gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlLCB0aGlzLmxhc3RdO1xuICAgICAgICBsZXQgY29uY2F0U3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogaW5wdXRHZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGZpbmFsR2VuZXJhdG9yID0gc3RlcHNbMF0udHJhbnNmb3JtKGlucHV0R2VuZXJhdG9yKCksIHBhdGNoQ29uZmlnKG90aGVyT3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGhpcy5vbWl0U2VxdWVuY2VUYWdzID8gdW5kZWZpbmVkIDogYHNlcTpzdGVwOjFgKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gc3RlcHNbaV07XG4gICAgICAgICAgICAgICAgZmluYWxHZW5lcmF0b3IgPSBhd2FpdCBzdGVwLnRyYW5zZm9ybShmaW5hbEdlbmVyYXRvciwgcGF0Y2hDb25maWcob3RoZXJPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGhpcy5vbWl0U2VxdWVuY2VUYWdzID8gdW5kZWZpbmVkIDogYHNlcTpzdGVwOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBmaW5hbEdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICBpZiAoY29uY2F0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdGhpcy5fY29uY2F0T3V0cHV0Q2h1bmtzKGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KGZpbmFsT3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgfVxuICAgIGdldEdyYXBoKGNvbmZpZykge1xuICAgICAgICBjb25zdCBncmFwaCA9IG5ldyBHcmFwaCgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgY3VycmVudExhc3ROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RlcEdyYXBoID0gc3RlcC5nZXRHcmFwaChjb25maWcpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RlcEdyYXBoLnRyaW1GaXJzdE5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdGhpcy5zdGVwcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgc3RlcEdyYXBoLnRyaW1MYXN0Tm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhcGguZXh0ZW5kKHN0ZXBHcmFwaCk7XG4gICAgICAgICAgICBjb25zdCBzdGVwRmlyc3ROb2RlID0gc3RlcEdyYXBoLmZpcnN0Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKCFzdGVwRmlyc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSdW5uYWJsZSAke3N0ZXB9IGhhcyBubyBmaXJzdCBub2RlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudExhc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGguYWRkRWRnZShjdXJyZW50TGFzdE5vZGUsIHN0ZXBGaXJzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudExhc3ROb2RlID0gc3RlcEdyYXBoLmxhc3ROb2RlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ3JhcGg7XG4gICAgfVxuICAgIHBpcGUoY29lcmNlYWJsZSkge1xuICAgICAgICBpZiAoUnVubmFibGVTZXF1ZW5jZS5pc1J1bm5hYmxlU2VxdWVuY2UoY29lcmNlYWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QsXG4gICAgICAgICAgICAgICAgbWlkZGxlOiB0aGlzLm1pZGRsZS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3QsXG4gICAgICAgICAgICAgICAgICAgIGNvZXJjZWFibGUuZmlyc3QsXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvZXJjZWFibGUubWlkZGxlLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIGxhc3Q6IGNvZXJjZWFibGUubGFzdCxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgPz8gY29lcmNlYWJsZS5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgICAgIGZpcnN0OiB0aGlzLmZpcnN0LFxuICAgICAgICAgICAgICAgIG1pZGRsZTogWy4uLnRoaXMubWlkZGxlLCB0aGlzLmxhc3RdLFxuICAgICAgICAgICAgICAgIGxhc3Q6IF9jb2VyY2VUb1J1bm5hYmxlKGNvZXJjZWFibGUpLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGlzUnVubmFibGVTZXF1ZW5jZSh0aGluZykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZy5taWRkbGUpICYmIFJ1bm5hYmxlLmlzUnVubmFibGUodGhpbmcpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBmcm9tKFtmaXJzdCwgLi4ucnVubmFibGVzXSwgbmFtZU9yRmllbGRzKSB7XG4gICAgICAgIGxldCBleHRyYSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG5hbWVPckZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXh0cmEubmFtZSA9IG5hbWVPckZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lT3JGaWVsZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXh0cmEgPSBuYW1lT3JGaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgIC4uLmV4dHJhLFxuICAgICAgICAgICAgZmlyc3Q6IF9jb2VyY2VUb1J1bm5hYmxlKGZpcnN0KSxcbiAgICAgICAgICAgIG1pZGRsZTogcnVubmFibGVzLnNsaWNlKDAsIC0xKS5tYXAoX2NvZXJjZVRvUnVubmFibGUpLFxuICAgICAgICAgICAgbGFzdDogX2NvZXJjZVRvUnVubmFibGUocnVubmFibGVzW3J1bm5hYmxlcy5sZW5ndGggLSAxXSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IHJ1bnMgYSBtYXBwaW5nIG9mIHJ1bm5hYmxlcyBpbiBwYXJhbGxlbCxcbiAqIGFuZCByZXR1cm5zIGEgbWFwcGluZyBvZiB0aGVpciBvdXRwdXRzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IG1hcENoYWluID0gUnVubmFibGVNYXAuZnJvbSh7XG4gKiAgIGpva2U6IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIlRlbGwgbWUgYSBqb2tlIGFib3V0IHt0b3BpY31cIikucGlwZShcbiAqICAgICBuZXcgQ2hhdEFudGhyb3BpYyh7fSksXG4gKiAgICksXG4gKiAgIHBvZW06IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIndyaXRlIGEgMi1saW5lIHBvZW0gYWJvdXQge3RvcGljfVwiKS5waXBlKFxuICogICAgIG5ldyBDaGF0QW50aHJvcGljKHt9KSxcbiAqICAgKSxcbiAqIH0pO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbWFwQ2hhaW4uaW52b2tlKHsgdG9waWM6IFwiYmVhclwiIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZU1hcCBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVNYXBcIjtcbiAgICB9XG4gICAgZ2V0U3RlcHNLZXlzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdGVwcyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RlcHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRzLnN0ZXBzKSkge1xuICAgICAgICAgICAgdGhpcy5zdGVwc1trZXldID0gX2NvZXJjZVRvUnVubmFibGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVNYXAoeyBzdGVwcyB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhjb25maWcpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCB7XG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgfSwgY29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gT2JqZWN0LmVudHJpZXModGhpcy5zdGVwcykubWFwKGFzeW5jIChba2V5LCBydW5uYWJsZV0pID0+IHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IGF3YWl0IHJ1bm5hYmxlLmludm9rZShpbnB1dCwgcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYG1hcDprZXk6JHtrZXl9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWNlV2l0aFNpZ25hbChQcm9taXNlLmFsbChwcm9taXNlcyksIG9wdGlvbnM/LnNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKG91dHB1dCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGdlbmVyYXRvciwgcnVuTWFuYWdlciwgb3B0aW9ucykge1xuICAgICAgICAvLyBzaGFsbG93IGNvcHkgc3RlcHMgdG8gaWdub3JlIGNoYW5nZXMgd2hpbGUgaXRlcmF0aW5nXG4gICAgICAgIGNvbnN0IHN0ZXBzID0geyAuLi50aGlzLnN0ZXBzIH07XG4gICAgICAgIC8vIGVhY2ggc3RlcCBnZXRzIGEgY29weSBvZiB0aGUgaW5wdXQgaXRlcmF0b3JcbiAgICAgICAgY29uc3QgaW5wdXRDb3BpZXMgPSBhdGVlKGdlbmVyYXRvciwgT2JqZWN0LmtleXMoc3RlcHMpLmxlbmd0aCk7XG4gICAgICAgIC8vIHN0YXJ0IHRoZSBmaXJzdCBpdGVyYXRpb24gb2YgZWFjaCBvdXRwdXQgaXRlcmF0b3JcbiAgICAgICAgY29uc3QgdGFza3MgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHN0ZXBzKS5tYXAoKFtrZXksIHJ1bm5hYmxlXSwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ2VuID0gcnVubmFibGUudHJhbnNmb3JtKGlucHV0Q29waWVzW2ldLCBwYXRjaENvbmZpZyhvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgbWFwOmtleToke2tleX1gKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBba2V5LCBnZW4ubmV4dCgpLnRoZW4oKHJlc3VsdCkgPT4gKHsga2V5LCBnZW4sIHJlc3VsdCB9KSldO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIHlpZWxkIGNodW5rcyBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUsXG4gICAgICAgIC8vIHN0YXJ0aW5nIG5ldyBpdGVyYXRpb25zIGFzIG5lZWRlZCxcbiAgICAgICAgLy8gdW50aWwgYWxsIGl0ZXJhdG9ycyBhcmUgZG9uZVxuICAgICAgICB3aGlsZSAodGFza3Muc2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmFjZSh0YXNrcy52YWx1ZXMoKSk7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgcmVzdWx0LCBnZW4gfSA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIG9wdGlvbnM/LnNpZ25hbCk7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7IFtrZXldOiByZXN1bHQudmFsdWUgfTtcbiAgICAgICAgICAgICAgICB0YXNrcy5zZXQoa2V5LCBnZW4ubmV4dCgpLnRoZW4oKHJlc3VsdCkgPT4gKHsga2V5LCBnZW4sIHJlc3VsdCB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy50cmFuc2Zvcm0oZ2VuZXJhdG9yKCksIGNvbmZpZyksXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgd3JhcHMgYSB0cmFjZWQgTGFuZ1NtaXRoIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVUcmFjZWFibGUgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpc1RyYWNlYWJsZUZ1bmN0aW9uKGZpZWxkcy5mdW5jKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVubmFibGVUcmFjZWFibGUgcmVxdWlyZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHdyYXBwZWQgaW4gdHJhY2VhYmxlIGhpZ2hlci1vcmRlciBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZ1bmMgPSBmaWVsZHMuZnVuYztcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtjb25maWddID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgMSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGF3YWl0IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhjb25maWcpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5mdW5jKHBhdGNoQ29uZmlnKGNvbmZpZywgeyBjYWxsYmFja3MgfSksIGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIGNvbmZpZz8uc2lnbmFsKTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBbY29uZmlnXSA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIDEpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChpc0FzeW5jSXRlcmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSXRlcmF0b3IocmVzdWx0KSkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHJlc3VsdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHlpZWxkIHN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZnVuYykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlVHJhY2VhYmxlKHsgZnVuYyB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnROb25UcmFjZWFibGVGdW5jdGlvbihmdW5jKSB7XG4gICAgaWYgKGlzVHJhY2VhYmxlRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVubmFibGVMYW1iZGEgcmVxdWlyZXMgYSBmdW5jdGlvbiB0aGF0IGlzIG5vdCB3cmFwcGVkIGluIHRyYWNlYWJsZSBoaWdoZXItb3JkZXIgZnVuY3Rpb24uIFRoaXMgc2hvdWxkbid0IGhhcHBlbi5cIik7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgd3JhcHMgYW4gYXJiaXRyYXJ5IGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgUnVubmFibGVMYW1iZGEgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IGFkZCA9IChpbnB1dDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9KSA9PiBpbnB1dC54ICsgaW5wdXQueTtcbiAqXG4gKiBjb25zdCBtdWx0aXBseSA9IChpbnB1dDogeyB2YWx1ZTogbnVtYmVyOyBtdWx0aXBsaWVyOiBudW1iZXIgfSkgPT5cbiAqICAgaW5wdXQudmFsdWUgKiBpbnB1dC5tdWx0aXBsaWVyO1xuICpcbiAqIC8vIENyZWF0ZSBydW5uYWJsZXMgZm9yIHRoZSBmdW5jdGlvbnNcbiAqIGNvbnN0IGFkZExhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oYWRkKTtcbiAqIGNvbnN0IG11bHRpcGx5TGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShtdWx0aXBseSk7XG4gKlxuICogLy8gQ2hhaW4gdGhlIGxhbWJkYXMgZm9yIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvblxuICogY29uc3QgY2hhaW5lZExhbWJkYSA9IGFkZExhbWJkYS5waXBlKChyZXN1bHQpID0+XG4gKiAgIG11bHRpcGx5TGFtYmRhLmludm9rZSh7IHZhbHVlOiByZXN1bHQsIG11bHRpcGxpZXI6IDIgfSlcbiAqICk7XG4gKlxuICogLy8gRXhhbXBsZSBpbnZvY2F0aW9uIG9mIHRoZSBjaGFpbmVkTGFtYmRhXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbmVkTGFtYmRhLmludm9rZSh7IHg6IDIsIHk6IDMgfSk7XG4gKlxuICogLy8gV2lsbCBsb2cgXCIxMFwiIChzaW5jZSAoMiArIDMpICogMiA9IDEwKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZUxhbWJkYSBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVMYW1iZGFcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmIChpc1RyYWNlYWJsZUZ1bmN0aW9uKGZpZWxkcy5mdW5jKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgICAgICAgICAgcmV0dXJuIFJ1bm5hYmxlVHJhY2VhYmxlLmZyb20oZmllbGRzLmZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0Tm9uVHJhY2VhYmxlRnVuY3Rpb24oZmllbGRzLmZ1bmMpO1xuICAgICAgICB0aGlzLmZ1bmMgPSBmaWVsZHMuZnVuYztcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZnVuYykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTGFtYmRhKHtcbiAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAoY29uZmlnPy5yZWN1cnNpb25MaW1pdCA/PyBERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCkgLSAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2b2lkIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhwaWNrUnVubmFibGVDb25maWdLZXlzKGNoaWxkQ29uZmlnKSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCB0aGlzLmZ1bmMoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjdXJzaW9uIGxpbWl0IHJlYWNoZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gYXdhaXQgb3V0cHV0Lmludm9rZShpbnB1dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAoY2hpbGRDb25maWcucmVjdXJzaW9uTGltaXQgPz8gREVGQVVMVF9SRUNVUlNJT05fTElNSVQpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXN5bmNJdGVyYWJsZShvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0KGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBiZXN0IGVmZm9ydCB0byBnYXRoZXIsIGZvciBhbnkgdHlwZSB0aGF0IHN1cHBvcnRzIGNvbmNhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdGhpcy5fY29uY2F0T3V0cHV0Q2h1bmtzKGZpbmFsT3V0cHV0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBmaW5hbE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0l0ZXJhYmxlSXRlcmF0b3Iob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjb25zdW1lSXRlcmF0b3JJbkNvbnRleHQoY2hpbGRDb25maWcsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB0aGlzLl9jb25jYXRPdXRwdXRDaHVua3MoZmluYWxPdXRwdXQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9pbnZva2UuYmluZCh0aGlzKSwgaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShnZW5lcmF0b3IsIHJ1bk1hbmFnZXIsIGNvbmZpZykge1xuICAgICAgICBsZXQgZmluYWxDaHVuaztcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbENodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IHRoaXMuX2NvbmNhdE91dHB1dENodW5rcyhmaW5hbENodW5rLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAoY29uZmlnPy5yZWN1cnNpb25MaW1pdCA/PyBERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCkgLSAxLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdm9pZCBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcocGlja1J1bm5hYmxlQ29uZmlnS2V5cyhjaGlsZENvbmZpZyksIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZ1bmMoZmluYWxDaHVuaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0cHV0ICYmIFJ1bm5hYmxlLmlzUnVubmFibGUob3V0cHV0KSkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZz8ucmVjdXJzaW9uTGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWN1cnNpb24gbGltaXQgcmVhY2hlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBvdXRwdXQuc3RyZWFtKGZpbmFsQ2h1bmssIGNoaWxkQ29uZmlnKTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBc3luY0l0ZXJhYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQoY2hpbGRDb25maWcsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0l0ZXJhYmxlSXRlcmF0b3Iob3V0cHV0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjb25zdW1lSXRlcmF0b3JJbkNvbnRleHQoY2hpbGRDb25maWcsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh7XG4gICAgICAgICAgICBnZW5lcmF0b3I6IHRoaXMudHJhbnNmb3JtKGdlbmVyYXRvcigpLCBjb25maWcpLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgd3JhcHBlZEdlbmVyYXRvci5zZXR1cDtcbiAgICAgICAgcmV0dXJuIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKHdyYXBwZWRHZW5lcmF0b3IpO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IHJ1bnMgYSBtYXBwaW5nIG9mIHJ1bm5hYmxlcyBpbiBwYXJhbGxlbCxcbiAqIGFuZCByZXR1cm5zIGEgbWFwcGluZyBvZiB0aGVpciBvdXRwdXRzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlTGFtYmRhLFxuICogICBSdW5uYWJsZVBhcmFsbGVsLFxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IGFkZFllYXJzID0gKGFnZTogbnVtYmVyKTogbnVtYmVyID0+IGFnZSArIDU7XG4gKiBjb25zdCB5ZWFyc1RvRmlmdHkgPSAoYWdlOiBudW1iZXIpOiBudW1iZXIgPT4gNTAgLSBhZ2U7XG4gKiBjb25zdCB5ZWFyc1RvSHVuZHJlZCA9IChhZ2U6IG51bWJlcik6IG51bWJlciA9PiAxMDAgLSBhZ2U7XG4gKlxuICogY29uc3QgYWRkWWVhcnNMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGFkZFllYXJzKTtcbiAqIGNvbnN0IG1pbGVzdG9uZUZpZnR5TGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbSh5ZWFyc1RvRmlmdHkpO1xuICogY29uc3QgbWlsZXN0b25lSHVuZHJlZExhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oeWVhcnNUb0h1bmRyZWQpO1xuICpcbiAqIC8vIFBpcGUgd2lsbCBjb2VyY2Ugb2JqZWN0cyBpbnRvIFJ1bm5hYmxlUGFyYWxsZWwgYnkgZGVmYXVsdCwgYnV0IHdlXG4gKiAvLyBleHBsaWNpdGx5IGluc3RhbnRpYXRlIG9uZSBoZXJlIHRvIGRlbW9uc3RyYXRlXG4gKiBjb25zdCBzZXF1ZW5jZSA9IGFkZFllYXJzTGFtYmRhLnBpcGUoXG4gKiAgIFJ1bm5hYmxlUGFyYWxsZWwuZnJvbSh7XG4gKiAgICAgeWVhcnNfdG9fZmlmdHk6IG1pbGVzdG9uZUZpZnR5TGFtYmRhLFxuICogICAgIHllYXJzX3RvX2h1bmRyZWQ6IG1pbGVzdG9uZUh1bmRyZWRMYW1iZGEsXG4gKiAgIH0pXG4gKiApO1xuICpcbiAqIC8vIEludm9rZSB0aGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSBhZ2UgaW5wdXRcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IHNlcXVlbmNlLmludm9rZSgyNSk7XG4gKlxuICogLy8geyB5ZWFyc190b19maWZ0eTogMjAsIHllYXJzX3RvX2h1bmRyZWQ6IDcwIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVQYXJhbGxlbCBleHRlbmRzIFJ1bm5hYmxlTWFwIHtcbn1cbi8qKlxuICogQSBSdW5uYWJsZSB0aGF0IGNhbiBmYWxsYmFjayB0byBvdGhlciBSdW5uYWJsZXMgaWYgaXQgZmFpbHMuXG4gKiBFeHRlcm5hbCBBUElzIChlLmcuLCBBUElzIGZvciBhIGxhbmd1YWdlIG1vZGVsKSBtYXkgYXQgdGltZXMgZXhwZXJpZW5jZVxuICogZGVncmFkZWQgcGVyZm9ybWFuY2Ugb3IgZXZlbiBkb3dudGltZS5cbiAqXG4gKiBJbiB0aGVzZSBjYXNlcywgaXQgY2FuIGJlIHVzZWZ1bCB0byBoYXZlIGEgZmFsbGJhY2sgUnVubmFibGUgdGhhdCBjYW4gYmVcbiAqIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIG9yaWdpbmFsIFJ1bm5hYmxlIChlLmcuLCBmYWxsYmFjayB0byBhbm90aGVyIExMTSBwcm92aWRlcikuXG4gKlxuICogRmFsbGJhY2tzIGNhbiBiZSBkZWZpbmVkIGF0IHRoZSBsZXZlbCBvZiBhIHNpbmdsZSBSdW5uYWJsZSwgb3IgYXQgdGhlIGxldmVsXG4gKiBvZiBhIGNoYWluIG9mIFJ1bm5hYmxlcy4gRmFsbGJhY2tzIGFyZSB0cmllZCBpbiBvcmRlciB1bnRpbCBvbmUgc3VjY2VlZHMgb3JcbiAqIGFsbCBmYWlsLlxuICpcbiAqIFdoaWxlIHlvdSBjYW4gaW5zdGFudGlhdGUgYSBgUnVubmFibGVXaXRoRmFsbGJhY2tzYCBkaXJlY3RseSwgaXQgaXMgdXN1YWxseVxuICogbW9yZSBjb252ZW5pZW50IHRvIHVzZSB0aGUgYHdpdGhGYWxsYmFja3NgIG1ldGhvZCBvbiBhbiBleGlzdGluZyBSdW5uYWJsZS5cbiAqXG4gKiBXaGVuIHN0cmVhbWluZywgZmFsbGJhY2tzIHdpbGwgb25seSBiZSBjYWxsZWQgb24gZmFpbHVyZXMgZHVyaW5nIHRoZSBpbml0aWFsXG4gKiBzdHJlYW0gY3JlYXRpb24uIEVycm9ycyB0aGF0IG9jY3VyIGFmdGVyIGEgc3RyZWFtIHN0YXJ0cyB3aWxsIG5vdCBmYWxsYmFja1xuICogdG8gdGhlIG5leHQgUnVubmFibGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlTGFtYmRhLFxuICogICBSdW5uYWJsZVdpdGhGYWxsYmFja3MsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgcHJpbWFyeU9wZXJhdGlvbiA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAqICAgaWYgKGlucHV0ICE9PSBcInNhZmVcIikge1xuICogICAgIHRocm93IG5ldyBFcnJvcihcIlByaW1hcnkgb3BlcmF0aW9uIGZhaWxlZCBkdWUgdG8gdW5zYWZlIGlucHV0XCIpO1xuICogICB9XG4gKiAgIHJldHVybiBgUHJvY2Vzc2VkOiAke2lucHV0fWA7XG4gKiB9O1xuICpcbiAqIC8vIERlZmluZSBhIGZhbGxiYWNrIG9wZXJhdGlvbiB0aGF0IHByb2Nlc3NlcyB0aGUgaW5wdXQgZGlmZmVyZW50bHlcbiAqIGNvbnN0IGZhbGxiYWNrT3BlcmF0aW9uID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAqICAgYEZhbGxiYWNrIHByb2Nlc3NlZDogJHtpbnB1dH1gO1xuICpcbiAqIGNvbnN0IHByaW1hcnlSdW5uYWJsZSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20ocHJpbWFyeU9wZXJhdGlvbik7XG4gKiBjb25zdCBmYWxsYmFja1J1bm5hYmxlID0gUnVubmFibGVMYW1iZGEuZnJvbShmYWxsYmFja09wZXJhdGlvbik7XG4gKlxuICogLy8gQXBwbHkgdGhlIGZhbGxiYWNrIGxvZ2ljIHVzaW5nIHRoZSAud2l0aEZhbGxiYWNrcygpIG1ldGhvZFxuICogY29uc3QgcnVubmFibGVXaXRoRmFsbGJhY2sgPSBwcmltYXJ5UnVubmFibGUud2l0aEZhbGxiYWNrcyhbZmFsbGJhY2tSdW5uYWJsZV0pO1xuICpcbiAqIC8vIEFsdGVybmF0aXZlbHksIGNyZWF0ZSBhIFJ1bm5hYmxlV2l0aEZhbGxiYWNrcyBpbnN0YW5jZSBtYW51YWxseVxuICogY29uc3QgbWFudWFsRmFsbGJhY2tDaGFpbiA9IG5ldyBSdW5uYWJsZVdpdGhGYWxsYmFja3Moe1xuICogICBydW5uYWJsZTogcHJpbWFyeVJ1bm5hYmxlLFxuICogICBmYWxsYmFja3M6IFtmYWxsYmFja1J1bm5hYmxlXSxcbiAqIH0pO1xuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvbiB1c2luZyAud2l0aEZhbGxiYWNrcygpXG4gKiBjb25zdCByZXMgPSBhd2FpdCBydW5uYWJsZVdpdGhGYWxsYmFja1xuICogICAuaW52b2tlKFwidW5zYWZlIGlucHV0XCIpXG4gKiAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIGFmdGVyIGFsbCBhdHRlbXB0czpcIiwgZXJyb3IubWVzc2FnZSk7XG4gKiAgIH0pO1xuICpcbiAqIC8vIFwiRmFsbGJhY2sgcHJvY2Vzc2VkOiB1bnNhZmUgaW5wdXRcIlxuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvbiB1c2luZyBtYW51YWwgaW5zdGFudGlhdGlvblxuICogY29uc3QgcmVzID0gYXdhaXQgbWFudWFsRmFsbGJhY2tDaGFpblxuICogICAuaW52b2tlKFwic2FmZVwiKVxuICogICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gKiAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCBhZnRlciBhbGwgYXR0ZW1wdHM6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICB9KTtcbiAqXG4gKiAvLyBcIlByb2Nlc3NlZDogc2FmZVwiXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlV2l0aEZhbGxiYWNrcyBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVXaXRoRmFsbGJhY2tzXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bm5hYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZhbGxiYWNrc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJ1bm5hYmxlID0gZmllbGRzLnJ1bm5hYmxlO1xuICAgICAgICB0aGlzLmZhbGxiYWNrcyA9IGZpZWxkcy5mYWxsYmFja3M7XG4gICAgfVxuICAgICpydW5uYWJsZXMoKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucnVubmFibGU7XG4gICAgICAgIGZvciAoY29uc3QgZmFsbGJhY2sgb2YgdGhpcy5mYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHlpZWxkIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgeyBydW5JZCwgLi4ub3RoZXJDb25maWdGaWVsZHMgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgcnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG90aGVyQ29uZmlnRmllbGRzPy5ydW5OYW1lKTtcbiAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSBwYXRjaENvbmZpZyhvdGhlckNvbmZpZ0ZpZWxkcywge1xuICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKGNoaWxkQ29uZmlnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZmlyc3RFcnJvcjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVubmFibGUgb2YgdGhpcy5ydW5uYWJsZXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJ1bm5hYmxlLmludm9rZShpbnB1dCwgY2hpbGRDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBzdG9yZWQgYXQgZW5kIG9mIGZhbGxiYWNrLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZmlyc3RFcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBmaXJzdEVycm9yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgeyBydW5JZCwgLi4ub3RoZXJDb25maWdGaWVsZHMgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgcnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG90aGVyQ29uZmlnRmllbGRzPy5ydW5OYW1lKTtcbiAgICAgICAgbGV0IGZpcnN0RXJyb3I7XG4gICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgIGZvciAoY29uc3QgcnVubmFibGUgb2YgdGhpcy5ydW5uYWJsZXMoKSkge1xuICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENvbmZpZyA9IHBhdGNoQ29uZmlnKG90aGVyQ29uZmlnRmllbGRzLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RyZWFtID0gYXdhaXQgcnVubmFibGUuc3RyZWFtKGlucHV0LCBjaGlsZENvbmZpZyk7XG4gICAgICAgICAgICAgICAgc3RyZWFtID0gY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQoY2hpbGRDb25maWcsIG9yaWdpbmFsU3RyZWFtKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGZpcnN0RXJyb3IgPz8gbmV3IEVycm9yKFwiTm8gZXJyb3Igc3RvcmVkIGF0IGVuZCBvZiBmYWxsYmFjay5cIik7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jb25jYXRPdXRwdXRDaHVua3Mob3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGlmIChiYXRjaE9wdGlvbnM/LnJldHVybkV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnTGlzdCA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY29uZmlnTGlzdC5tYXAoKGNvbmZpZykgPT4gZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja01hbmFnZXJzLm1hcChhc3luYyAoY2FsbGJhY2tNYW5hZ2VyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVTdGFydFJlcyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0c1tpXSwgXCJpbnB1dFwiKSwgY29uZmlnTGlzdFtpXS5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnTGlzdFtpXS5ydW5OYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWdMaXN0W2ldLnJ1bklkO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0YXJ0UmVzO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBmaXJzdEVycm9yO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5hYmxlIG9mIHRoaXMucnVubmFibGVzKCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0xpc3RbMF0uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gYXdhaXQgcnVubmFibGUuYmF0Y2goaW5wdXRzLCBydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIsIGopID0+IHBhdGNoQ29uZmlnKGNvbmZpZ0xpc3Rbal0sIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICAgICAgICAgIH0pKSwgYmF0Y2hPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIsIGkpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0c1tpXSwgXCJvdXRwdXRcIikpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZmlyc3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXJyb3Igc3RvcmVkIGF0IGVuZCBvZiBmYWxsYmFja3MuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihmaXJzdEVycm9yKSkpO1xuICAgICAgICB0aHJvdyBmaXJzdEVycm9yO1xuICAgIH1cbn1cbi8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSBjb21waWxlciBuZWVkcyBoZWxwIGVsaW1pbmF0aW5nIEVycm9yIGFzIGEgUnVuT3V0cHV0IHR5cGVcbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSB7XG4gICAgaWYgKHR5cGVvZiBjb2VyY2VhYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUxhbWJkYSh7IGZ1bmM6IGNvZXJjZWFibGUgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFJ1bm5hYmxlLmlzUnVubmFibGUoY29lcmNlYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWFibGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGNvZXJjZWFibGUpICYmIHR5cGVvZiBjb2VyY2VhYmxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjb2VyY2VhYmxlKSkge1xuICAgICAgICAgICAgcnVubmFibGVzW2tleV0gPSBfY29lcmNlVG9SdW5uYWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZU1hcCh7XG4gICAgICAgICAgICBzdGVwczogcnVubmFibGVzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBSdW5uYWJsZSwgZnVuY3Rpb24gb3Igb2JqZWN0Llxcbkluc3RlYWQgZ290IGFuIHVuc3VwcG9ydGVkIHR5cGUuYCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgYXNzaWducyBrZXktdmFsdWUgcGFpcnMgdG8gaW5wdXRzIG9mIHR5cGUgYFJlY29yZDxzdHJpbmcsIHVua25vd24+YC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge1xuICogICBSdW5uYWJsZUFzc2lnbixcbiAqICAgUnVubmFibGVMYW1iZGEsXG4gKiAgIFJ1bm5hYmxlUGFyYWxsZWwsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgY2FsY3VsYXRlQWdlID0gKHg6IHsgYmlydGhZZWFyOiBudW1iZXIgfSk6IHsgYWdlOiBudW1iZXIgfSA9PiB7XG4gKiAgIGNvbnN0IGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICogICByZXR1cm4geyBhZ2U6IGN1cnJlbnRZZWFyIC0geC5iaXJ0aFllYXIgfTtcbiAqIH07XG4gKlxuICogY29uc3QgY3JlYXRlR3JlZXRpbmcgPSAoeDogeyBuYW1lOiBzdHJpbmcgfSk6IHsgZ3JlZXRpbmc6IHN0cmluZyB9ID0+IHtcbiAqICAgcmV0dXJuIHsgZ3JlZXRpbmc6IGBIZWxsbywgJHt4Lm5hbWV9IWAgfTtcbiAqIH07XG4gKlxuICogY29uc3QgbWFwcGVyID0gUnVubmFibGVQYXJhbGxlbC5mcm9tKHtcbiAqICAgYWdlX3N0ZXA6IFJ1bm5hYmxlTGFtYmRhLmZyb20oY2FsY3VsYXRlQWdlKSxcbiAqICAgZ3JlZXRpbmdfc3RlcDogUnVubmFibGVMYW1iZGEuZnJvbShjcmVhdGVHcmVldGluZyksXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBydW5uYWJsZUFzc2lnbiA9IG5ldyBSdW5uYWJsZUFzc2lnbih7IG1hcHBlciB9KTtcbiAqXG4gKiBjb25zdCByZXMgPSBhd2FpdCBydW5uYWJsZUFzc2lnbi5pbnZva2UoeyBuYW1lOiBcIkFsaWNlXCIsIGJpcnRoWWVhcjogMTk5MCB9KTtcbiAqXG4gKiAvLyB7IG5hbWU6IFwiQWxpY2VcIiwgYmlydGhZZWFyOiAxOTkwLCBhZ2Vfc3RlcDogeyBhZ2U6IDM0IH0sIGdyZWV0aW5nX3N0ZXA6IHsgZ3JlZXRpbmc6IFwiSGVsbG8sIEFsaWNlIVwiIH0gfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZUFzc2lnbiBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVBc3NpZ25cIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgaWYgKGZpZWxkcyBpbnN0YW5jZW9mIFJ1bm5hYmxlTWFwKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgbWFwcGVyOiBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hcHBlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcHBlciA9IGZpZWxkcy5tYXBwZXI7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtYXBwZXJSZXN1bHQgPSBhd2FpdCB0aGlzLm1hcHBlci5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaW5wdXQsXG4gICAgICAgICAgICAuLi5tYXBwZXJSZXN1bHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGdlbmVyYXRvciwgcnVuTWFuYWdlciwgb3B0aW9ucykge1xuICAgICAgICAvLyBjb2xsZWN0IG1hcHBlciBrZXlzXG4gICAgICAgIGNvbnN0IG1hcHBlcktleXMgPSB0aGlzLm1hcHBlci5nZXRTdGVwc0tleXMoKTtcbiAgICAgICAgLy8gY3JlYXRlIHR3byBpbnB1dCBnZW5zLCBvbmUgZm9yIHRoZSBtYXBwZXIsIG9uZSBmb3IgdGhlIGlucHV0XG4gICAgICAgIGNvbnN0IFtmb3JQYXNzdGhyb3VnaCwgZm9yTWFwcGVyXSA9IGF0ZWUoZ2VuZXJhdG9yKTtcbiAgICAgICAgLy8gY3JlYXRlIG1hcHBlciBvdXRwdXQgZ2VuXG4gICAgICAgIGNvbnN0IG1hcHBlck91dHB1dCA9IHRoaXMubWFwcGVyLnRyYW5zZm9ybShmb3JNYXBwZXIsIHBhdGNoQ29uZmlnKG9wdGlvbnMsIHsgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpIH0pKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIG1hcHBlclxuICAgICAgICBjb25zdCBmaXJzdE1hcHBlckNodW5rUHJvbWlzZSA9IG1hcHBlck91dHB1dC5uZXh0KCk7XG4gICAgICAgIC8vIHlpZWxkIHRoZSBwYXNzdGhyb3VnaFxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGZvclBhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSdW5uYWJsZUFzc2lnbiBjYW4gb25seSBiZSB1c2VkIHdpdGggb2JqZWN0cyBhcyBpbnB1dCwgZ290ICR7dHlwZW9mIGNodW5rfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2h1bmspLmZpbHRlcigoW2tleV0pID0+ICFtYXBwZXJLZXlzLmluY2x1ZGVzKGtleSkpKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhmaWx0ZXJlZCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGZpbHRlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHlpZWxkIHRoZSBtYXBwZXIgb3V0cHV0XG4gICAgICAgIHlpZWxkIChhd2FpdCBmaXJzdE1hcHBlckNodW5rUHJvbWlzZSkudmFsdWU7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgbWFwcGVyT3V0cHV0KSB7XG4gICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh7XG4gICAgICAgICAgICBnZW5lcmF0b3I6IHRoaXMudHJhbnNmb3JtKGdlbmVyYXRvcigpLCBjb25maWcpLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgd3JhcHBlZEdlbmVyYXRvci5zZXR1cDtcbiAgICAgICAgcmV0dXJuIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKHdyYXBwZWRHZW5lcmF0b3IpO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IGFzc2lnbnMga2V5LXZhbHVlIHBhaXJzIHRvIGlucHV0cyBvZiB0eXBlIGBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPmAuXG4gKiBVc2VmdWwgZm9yIHN0cmVhbWluZywgY2FuIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBhbmQgY2hhaW5lZCBieSBjYWxsaW5nIGBydW5uYWJsZS5waWNrKCk7YC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBSdW5uYWJsZVBpY2sgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IGlucHV0RGF0YSA9IHtcbiAqICAgbmFtZTogXCJKb2huXCIsXG4gKiAgIGFnZTogMzAsXG4gKiAgIGNpdHk6IFwiTmV3IFlvcmtcIixcbiAqICAgY291bnRyeTogXCJVU0FcIixcbiAqICAgZW1haWw6IFwiam9obi5kb2VAZXhhbXBsZS5jb21cIixcbiAqICAgcGhvbmU6IFwiKzEyMzQ1Njc4OTBcIixcbiAqIH07XG4gKlxuICogY29uc3QgYmFzaWNJbmZvUnVubmFibGUgPSBuZXcgUnVubmFibGVQaWNrKFtcIm5hbWVcIiwgXCJjaXR5XCJdKTtcbiAqXG4gKiAvLyBFeGFtcGxlIGludm9jYXRpb25cbiAqIGNvbnN0IHJlcyA9IGF3YWl0IGJhc2ljSW5mb1J1bm5hYmxlLmludm9rZShpbnB1dERhdGEpO1xuICpcbiAqIC8vIHsgbmFtZTogJ0pvaG4nLCBjaXR5OiAnTmV3IFlvcmsnIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVQaWNrIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVBpY2tcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGtleXM6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmtleXMgPSBmaWVsZHMua2V5cztcbiAgICB9XG4gICAgYXN5bmMgX3BpY2soaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmtleXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFt0aGlzLmtleXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGlja2VkID0gdGhpcy5rZXlzXG4gICAgICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiBba2V5LCBpbnB1dFtrZXldXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh2KSA9PiB2WzFdICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHBpY2tlZC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogT2JqZWN0LmZyb21FbnRyaWVzKHBpY2tlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9waWNrLmJpbmQodGhpcyksIGlucHV0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwaWNrZWQgPSBhd2FpdCB0aGlzLl9waWNrKGNodW5rKTtcbiAgICAgICAgICAgIGlmIChwaWNrZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHBpY2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh7XG4gICAgICAgICAgICBnZW5lcmF0b3I6IHRoaXMudHJhbnNmb3JtKGdlbmVyYXRvcigpLCBjb25maWcpLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgd3JhcHBlZEdlbmVyYXRvci5zZXR1cDtcbiAgICAgICAgcmV0dXJuIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKHdyYXBwZWRHZW5lcmF0b3IpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVRvb2xMaWtlIGV4dGVuZHMgUnVubmFibGVCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2UgPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICAgICAgICAgICAgUnVubmFibGVMYW1iZGEuZnJvbShhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbElucHV0O1xuICAgICAgICAgICAgICAgIGlmIChfaXNUb29sQ2FsbChpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xJbnB1dCA9IGF3YWl0IGludGVyb3BQYXJzZUFzeW5jKHRoaXMuc2NoZW1hLCBpbnB1dC5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24oYFJlY2VpdmVkIHRvb2wgaW5wdXQgZGlkIG5vdCBtYXRjaCBleHBlY3RlZCBzY2hlbWFgLCBKU09OLnN0cmluZ2lmeShpbnB1dC5hcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbElucHV0O1xuICAgICAgICAgICAgfSkud2l0aENvbmZpZyh7IHJ1bk5hbWU6IGAke2ZpZWxkcy5uYW1lfTpwYXJzZV9pbnB1dGAgfSksXG4gICAgICAgICAgICBmaWVsZHMuYm91bmQsXG4gICAgICAgIF0pLndpdGhDb25maWcoeyBydW5OYW1lOiBmaWVsZHMubmFtZSB9KTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYm91bmQ6IHNlcXVlbmNlLFxuICAgICAgICAgICAgY29uZmlnOiBmaWVsZHMuY29uZmlnID8/IHt9LFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXNjcmlwdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2hlbWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZmllbGRzLnNjaGVtYTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlVG9vbExpa2VcIjtcbiAgICB9XG59XG4vKipcbiAqIEdpdmVuIGEgcnVubmFibGUgYW5kIGEgWm9kIHNjaGVtYSwgY29udmVydCB0aGUgcnVubmFibGUgdG8gYSB0b29sLlxuICpcbiAqIEB0ZW1wbGF0ZSBSdW5JbnB1dCBUaGUgaW5wdXQgdHlwZSBmb3IgdGhlIHJ1bm5hYmxlLlxuICogQHRlbXBsYXRlIFJ1bk91dHB1dCBUaGUgb3V0cHV0IHR5cGUgZm9yIHRoZSBydW5uYWJsZS5cbiAqXG4gKiBAcGFyYW0ge1J1bm5hYmxlPFJ1bklucHV0LCBSdW5PdXRwdXQ+fSBydW5uYWJsZSBUaGUgcnVubmFibGUgdG8gY29udmVydCB0byBhIHRvb2wuXG4gKiBAcGFyYW0gZmllbGRzXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2ZpZWxkcy5uYW1lXSBUaGUgbmFtZSBvZiB0aGUgdG9vbC4gSWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIG5hbWUgb2YgdGhlIHJ1bm5hYmxlLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtmaWVsZHMuZGVzY3JpcHRpb25dIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgdG9vbC4gRmFsbHMgYmFjayB0byB0aGUgZGVzY3JpcHRpb24gb24gdGhlIFpvZCBzY2hlbWEgaWYgbm90IHByb3ZpZGVkLCBvciB1bmRlZmluZWQgaWYgbmVpdGhlciBhcmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge0ludGVyb3Bab2RUeXBlPFJ1bklucHV0Pn0gW2ZpZWxkcy5zY2hlbWFdIFRoZSBab2Qgc2NoZW1hIGZvciB0aGUgaW5wdXQgb2YgdGhlIHRvb2wuIEluZmVycyB0aGUgWm9kIHR5cGUgZnJvbSB0aGUgaW5wdXQgdHlwZSBvZiB0aGUgcnVubmFibGUuXG4gKiBAcmV0dXJucyB7UnVubmFibGVUb29sTGlrZTxJbnRlcm9wWm9kVHlwZTxSdW5JbnB1dD4sIFJ1bk91dHB1dD59IEFuIGluc3RhbmNlIG9mIGBSdW5uYWJsZVRvb2xMaWtlYCB3aGljaCBpcyBhIHJ1bm5hYmxlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSB0b29sLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFJ1bm5hYmxlVG9Ub29sKHJ1bm5hYmxlLCBmaWVsZHMpIHtcbiAgICBjb25zdCBuYW1lID0gZmllbGRzLm5hbWUgPz8gcnVubmFibGUuZ2V0TmFtZSgpO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZmllbGRzLmRlc2NyaXB0aW9uID8/IGdldFNjaGVtYURlc2NyaXB0aW9uKGZpZWxkcy5zY2hlbWEpO1xuICAgIGlmIChpc1NpbXBsZVN0cmluZ1pvZFNjaGVtYShmaWVsZHMuc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlVG9vbExpa2Uoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgc2NoZW1hOiB6XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7IGlucHV0OiB6LnN0cmluZygpIH0pXG4gICAgICAgICAgICAgICAgLnRyYW5zZm9ybSgoaW5wdXQpID0+IGlucHV0LmlucHV0KSxcbiAgICAgICAgICAgIGJvdW5kOiBydW5uYWJsZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUnVubmFibGVUb29sTGlrZSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBzY2hlbWE6IGZpZWxkcy5zY2hlbWEsXG4gICAgICAgIGJvdW5kOiBydW5uYWJsZSxcbiAgICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/branch.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/branch.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunnableBranch: () => (/* binding */ RunnableBranch)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.js\");\n\n\n\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass RunnableBranch extends _base_js__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    static lc_name() {\n        return \"RunnableBranch\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"default\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"branches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.branches = fields.branches;\n        this.default = fields.default;\n    }\n    /**\n     * Convenience method for instantiating a RunnableBranch from\n     * RunnableLikes (objects, functions, or Runnables).\n     *\n     * Each item in the input except for the last one should be a\n     * tuple with two items. The first is a \"condition\" RunnableLike that\n     * returns \"true\" if the second RunnableLike in the tuple should run.\n     *\n     * The final item in the input should be a RunnableLike that acts as a\n     * default branch if no other branches match.\n     *\n     * @example\n     * ```ts\n     * import { RunnableBranch } from \"@langchain/core/runnables\";\n     *\n     * const branch = RunnableBranch.from([\n     *   [(x: number) => x > 0, (x: number) => x + 1],\n     *   [(x: number) => x < 0, (x: number) => x - 1],\n     *   (x: number) => x\n     * ]);\n     * ```\n     * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n     *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n     * @returns A new RunnableBranch.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from(branches) {\n        if (branches.length < 1) {\n            throw new Error(\"RunnableBranch requires at least one branch\");\n        }\n        const branchLikes = branches.slice(0, -1);\n        const coercedBranches = branchLikes.map(([condition, runnable]) => [\n            (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(condition),\n            (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(runnable),\n        ]);\n        const defaultBranch = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(branches[branches.length - 1]);\n        return new this({\n            branches: coercedBranches,\n            default: defaultBranch,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        let result;\n        for (let i = 0; i < this.branches.length; i += 1) {\n            const [condition, branchRunnable] = this.branches[i];\n            const conditionValue = await condition.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_1__.patchConfig)(config, {\n                callbacks: runManager?.getChild(`condition:${i + 1}`),\n            }));\n            if (conditionValue) {\n                result = await branchRunnable.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_1__.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`branch:${i + 1}`),\n                }));\n                break;\n            }\n        }\n        if (!result) {\n            result = await this.default.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_1__.patchConfig)(config, {\n                callbacks: runManager?.getChild(\"branch:default\"),\n            }));\n        }\n        return result;\n    }\n    async invoke(input, config = {}) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async *_streamIterator(input, config) {\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_1__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._coerceToDict)(input, \"input\"), config?.runId, undefined, undefined, undefined, config?.runName);\n        let finalOutput;\n        let finalOutputSupported = true;\n        let stream;\n        try {\n            for (let i = 0; i < this.branches.length; i += 1) {\n                const [condition, branchRunnable] = this.branches[i];\n                const conditionValue = await condition.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_1__.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`condition:${i + 1}`),\n                }));\n                if (conditionValue) {\n                    stream = await branchRunnable.stream(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_1__.patchConfig)(config, {\n                        callbacks: runManager?.getChild(`branch:${i + 1}`),\n                    }));\n                    for await (const chunk of stream) {\n                        yield chunk;\n                        if (finalOutputSupported) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                try {\n                                    finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.concat)(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = undefined;\n                                    finalOutputSupported = false;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (stream === undefined) {\n                stream = await this.default.stream(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_1__.patchConfig)(config, {\n                    callbacks: runManager?.getChild(\"branch:default\"),\n                }));\n                for await (const chunk of stream) {\n                    yield chunk;\n                    if (finalOutputSupported) {\n                        if (finalOutput === undefined) {\n                            finalOutput = chunk;\n                        }\n                        else {\n                            try {\n                                finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.concat)(finalOutput, chunk);\n                            }\n                            catch (e) {\n                                finalOutput = undefined;\n                                finalOutputSupported = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2JyYW5jaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdFO0FBQ0E7QUFDNUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWUsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPLDZCQUE2Qiw4Q0FBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyREFBaUI7QUFDN0IsWUFBWSwyREFBaUI7QUFDN0I7QUFDQSw4QkFBOEIsMkRBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0EsaUVBQWlFLHVEQUFXO0FBQzVFLDZEQUE2RCxNQUFNO0FBQ25FLGFBQWE7QUFDYjtBQUNBLDREQUE0RCx1REFBVztBQUN2RSw4REFBOEQsTUFBTTtBQUNwRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsdURBQVc7QUFDakU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1RUFBMkI7QUFDbEUsbUZBQW1GLHVEQUFhO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBLHFFQUFxRSx1REFBVztBQUNoRixpRUFBaUUsTUFBTTtBQUN2RSxpQkFBaUI7QUFDakI7QUFDQSxnRUFBZ0UsdURBQVc7QUFDM0Usa0VBQWtFLE1BQU07QUFDeEUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsd0RBQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHVEQUFXO0FBQ3JFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0RBQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHJ1bm5hYmxlc1xcYnJhbmNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJ1bm5hYmxlLCBfY29lcmNlVG9EaWN0LCBfY29lcmNlVG9SdW5uYWJsZSwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcsIHBhdGNoQ29uZmlnLCB9IGZyb20gXCIuL2NvbmZpZy5qc1wiO1xuaW1wb3J0IHsgY29uY2F0IH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBydW5uYWJsZSBicmFuY2guIFRoZSBSdW5uYWJsZUJyYW5jaCBpc1xuICogaW5pdGlhbGl6ZWQgd2l0aCBhbiBhcnJheSBvZiBicmFuY2hlcyBhbmQgYSBkZWZhdWx0IGJyYW5jaC4gV2hlbiBpbnZva2VkLFxuICogaXQgZXZhbHVhdGVzIHRoZSBjb25kaXRpb24gb2YgZWFjaCBicmFuY2ggaW4gb3JkZXIgYW5kIGV4ZWN1dGVzIHRoZVxuICogY29ycmVzcG9uZGluZyBicmFuY2ggaWYgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLiBJZiBub25lIG9mIHRoZSBjb25kaXRpb25zXG4gKiBhcmUgdHJ1ZSwgaXQgZXhlY3V0ZXMgdGhlIGRlZmF1bHQgYnJhbmNoLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGJyYW5jaCA9IFJ1bm5hYmxlQnJhbmNoLmZyb20oW1xuICogICBbXG4gKiAgICAgKHg6IHsgdG9waWM6IHN0cmluZzsgcXVlc3Rpb246IHN0cmluZyB9KSA9PlxuICogICAgICAgeC50b3BpYy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiYW50aHJvcGljXCIpLFxuICogICAgIGFudGhyb3BpY0NoYWluLFxuICogICBdLFxuICogICBbXG4gKiAgICAgKHg6IHsgdG9waWM6IHN0cmluZzsgcXVlc3Rpb246IHN0cmluZyB9KSA9PlxuICogICAgICAgeC50b3BpYy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibGFuZ2NoYWluXCIpLFxuICogICAgIGxhbmdDaGFpbkNoYWluLFxuICogICBdLFxuICogICBnZW5lcmFsQ2hhaW4sXG4gKiBdKTtcbiAqXG4gKiBjb25zdCBmdWxsQ2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICogICB7XG4gKiAgICAgdG9waWM6IGNsYXNzaWZpY2F0aW9uQ2hhaW4sXG4gKiAgICAgcXVlc3Rpb246IChpbnB1dDogeyBxdWVzdGlvbjogc3RyaW5nIH0pID0+IGlucHV0LnF1ZXN0aW9uLFxuICogICB9LFxuICogICBicmFuY2gsXG4gKiBdKTtcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBmdWxsQ2hhaW4uaW52b2tlKHtcbiAqICAgcXVlc3Rpb246IFwiaG93IGRvIEkgdXNlIExhbmdDaGFpbj9cIixcbiAqIH0pO1xuICogYGBgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgY2xhc3MgUnVubmFibGVCcmFuY2ggZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlQnJhbmNoXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYnJhbmNoZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5icmFuY2hlcyA9IGZpZWxkcy5icmFuY2hlcztcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gZmllbGRzLmRlZmF1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgaW5zdGFudGlhdGluZyBhIFJ1bm5hYmxlQnJhbmNoIGZyb21cbiAgICAgKiBSdW5uYWJsZUxpa2VzIChvYmplY3RzLCBmdW5jdGlvbnMsIG9yIFJ1bm5hYmxlcykuXG4gICAgICpcbiAgICAgKiBFYWNoIGl0ZW0gaW4gdGhlIGlucHV0IGV4Y2VwdCBmb3IgdGhlIGxhc3Qgb25lIHNob3VsZCBiZSBhXG4gICAgICogdHVwbGUgd2l0aCB0d28gaXRlbXMuIFRoZSBmaXJzdCBpcyBhIFwiY29uZGl0aW9uXCIgUnVubmFibGVMaWtlIHRoYXRcbiAgICAgKiByZXR1cm5zIFwidHJ1ZVwiIGlmIHRoZSBzZWNvbmQgUnVubmFibGVMaWtlIGluIHRoZSB0dXBsZSBzaG91bGQgcnVuLlxuICAgICAqXG4gICAgICogVGhlIGZpbmFsIGl0ZW0gaW4gdGhlIGlucHV0IHNob3VsZCBiZSBhIFJ1bm5hYmxlTGlrZSB0aGF0IGFjdHMgYXMgYVxuICAgICAqIGRlZmF1bHQgYnJhbmNoIGlmIG5vIG90aGVyIGJyYW5jaGVzIG1hdGNoLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IFJ1bm5hYmxlQnJhbmNoIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGJyYW5jaCA9IFJ1bm5hYmxlQnJhbmNoLmZyb20oW1xuICAgICAqICAgWyh4OiBudW1iZXIpID0+IHggPiAwLCAoeDogbnVtYmVyKSA9PiB4ICsgMV0sXG4gICAgICogICBbKHg6IG51bWJlcikgPT4geCA8IDAsICh4OiBudW1iZXIpID0+IHggLSAxXSxcbiAgICAgKiAgICh4OiBudW1iZXIpID0+IHhcbiAgICAgKiBdKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gYnJhbmNoZXMgQW4gYXJyYXkgd2hlcmUgdGhlIGV2ZXJ5IGl0ZW0gZXhjZXB0IHRoZSBsYXN0IGlzIGEgdHVwbGUgb2YgW2NvbmRpdGlvbiwgcnVubmFibGVdXG4gICAgICogICBwYWlycy4gVGhlIGxhc3QgaXRlbSBpcyBhIGRlZmF1bHQgcnVubmFibGUgd2hpY2ggaXMgaW52b2tlZCBpZiBubyBvdGhlciBjb25kaXRpb24gbWF0Y2hlcy5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBSdW5uYWJsZUJyYW5jaC5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBmcm9tKGJyYW5jaGVzKSB7XG4gICAgICAgIGlmIChicmFuY2hlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uYWJsZUJyYW5jaCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYnJhbmNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyYW5jaExpa2VzID0gYnJhbmNoZXMuc2xpY2UoMCwgLTEpO1xuICAgICAgICBjb25zdCBjb2VyY2VkQnJhbmNoZXMgPSBicmFuY2hMaWtlcy5tYXAoKFtjb25kaXRpb24sIHJ1bm5hYmxlXSkgPT4gW1xuICAgICAgICAgICAgX2NvZXJjZVRvUnVubmFibGUoY29uZGl0aW9uKSxcbiAgICAgICAgICAgIF9jb2VyY2VUb1J1bm5hYmxlKHJ1bm5hYmxlKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRCcmFuY2ggPSBfY29lcmNlVG9SdW5uYWJsZShicmFuY2hlc1ticmFuY2hlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICBicmFuY2hlczogY29lcmNlZEJyYW5jaGVzLFxuICAgICAgICAgICAgZGVmYXVsdDogZGVmYXVsdEJyYW5jaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnJhbmNoZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjb25kaXRpb24sIGJyYW5jaFJ1bm5hYmxlXSA9IHRoaXMuYnJhbmNoZXNbaV07XG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IGF3YWl0IGNvbmRpdGlvbi5pbnZva2UoaW5wdXQsIHBhdGNoQ29uZmlnKGNvbmZpZywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYGNvbmRpdGlvbjoke2kgKyAxfWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgYnJhbmNoUnVubmFibGUuaW52b2tlKGlucHV0LCBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgYnJhbmNoOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLmRlZmF1bHQuaW52b2tlKGlucHV0LCBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKFwiYnJhbmNoOmRlZmF1bHRcIiksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnPy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5OYW1lKTtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJyYW5jaGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2NvbmRpdGlvbiwgYnJhbmNoUnVubmFibGVdID0gdGhpcy5icmFuY2hlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IGF3YWl0IGNvbmRpdGlvbi5pbnZva2UoaW5wdXQsIHBhdGNoQ29uZmlnKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBjb25kaXRpb246JHtpICsgMX1gKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbSA9IGF3YWl0IGJyYW5jaFJ1bm5hYmxlLnN0cmVhbShpbnB1dCwgcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBicmFuY2g6JHtpICsgMX1gKSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY29uY2F0KGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0gPSBhd2FpdCB0aGlzLmRlZmF1bHQuc3RyZWFtKGlucHV0LCBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChcImJyYW5jaDpkZWZhdWx0XCIpLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNvbmNhdChmaW5hbE91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGZpbmFsT3V0cHV0ID8/IHt9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/branch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/config.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/config.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_RECURSION_LIMIT: () => (/* binding */ DEFAULT_RECURSION_LIMIT),\n/* harmony export */   ensureConfig: () => (/* binding */ ensureConfig),\n/* harmony export */   getCallbackManagerForConfig: () => (/* binding */ getCallbackManagerForConfig),\n/* harmony export */   mergeConfigs: () => (/* binding */ mergeConfigs),\n/* harmony export */   patchConfig: () => (/* binding */ patchConfig),\n/* harmony export */   pickRunnableConfigKeys: () => (/* binding */ pickRunnableConfigKeys)\n/* harmony export */ });\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../callbacks/manager.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../singletons/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.js\");\n\n\nconst DEFAULT_RECURSION_LIMIT = 25;\nasync function getCallbackManagerForConfig(config) {\n    return _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nfunction mergeConfigs(...configs) {\n    // We do not want to call ensureConfig on the empty state here as this may cause\n    // double loading of callbacks if async local storage is being used.\n    const copy = {};\n    for (const options of configs.filter((c) => !!c)) {\n        for (const key of Object.keys(options)) {\n            if (key === \"metadata\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"tags\") {\n                const baseKeys = copy[key] ?? [];\n                copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n            }\n            else if (key === \"configurable\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"timeout\") {\n                if (copy.timeout === undefined) {\n                    copy.timeout = options.timeout;\n                }\n                else if (options.timeout !== undefined) {\n                    copy.timeout = Math.min(copy.timeout, options.timeout);\n                }\n            }\n            else if (key === \"signal\") {\n                if (copy.signal === undefined) {\n                    copy.signal = options.signal;\n                }\n                else if (options.signal !== undefined) {\n                    if (\"any\" in AbortSignal) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        copy.signal = AbortSignal.any([\n                            copy.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        copy.signal = options.signal;\n                    }\n                }\n            }\n            else if (key === \"callbacks\") {\n                const baseCallbacks = copy.callbacks;\n                const providedCallbacks = options.callbacks;\n                // callbacks can be either undefined, Array<handler> or manager\n                // so merging two callbacks values has 6 cases\n                if (Array.isArray(providedCallbacks)) {\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n                    }\n                    else {\n                        // baseCallbacks is a manager\n                        const manager = baseCallbacks.copy();\n                        for (const callback of providedCallbacks) {\n                            manager.addHandler((0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                }\n                else if (providedCallbacks) {\n                    // providedCallbacks is a manager\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        const manager = providedCallbacks.copy();\n                        for (const callback of baseCallbacks) {\n                            manager.addHandler((0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                    else {\n                        // baseCallbacks is also a manager\n                        copy.callbacks = new _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.CallbackManager(providedCallbacks._parentRunId, {\n                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n                            metadata: {\n                                ...baseCallbacks.metadata,\n                                ...providedCallbacks.metadata,\n                            },\n                        });\n                    }\n                }\n            }\n            else {\n                const typedKey = key;\n                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n            }\n        }\n    }\n    return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nfunction ensureConfig(config) {\n    const implicitConfig = _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    let empty = {\n        tags: [],\n        metadata: {},\n        recursionLimit: 25,\n        runId: undefined,\n    };\n    if (implicitConfig) {\n        // Don't allow runId and runName to be loaded implicitly, as this can cause\n        // child runs to improperly inherit their parents' run ids.\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { runId, runName, ...rest } = implicitConfig;\n        empty = Object.entries(rest).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (config) {\n        empty = Object.entries(config).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (empty?.configurable) {\n        for (const key of Object.keys(empty.configurable)) {\n            if (PRIMITIVES.has(typeof empty.configurable[key]) &&\n                !empty.metadata?.[key]) {\n                if (!empty.metadata) {\n                    empty.metadata = {};\n                }\n                empty.metadata[key] = empty.configurable[key];\n            }\n        }\n    }\n    if (empty.timeout !== undefined) {\n        if (empty.timeout <= 0) {\n            throw new Error(\"Timeout must be a positive number\");\n        }\n        const timeoutSignal = AbortSignal.timeout(empty.timeout);\n        if (empty.signal !== undefined) {\n            if (\"any\" in AbortSignal) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);\n            }\n        }\n        else {\n            empty.signal = timeoutSignal;\n        }\n        delete empty.timeout;\n    }\n    return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nfunction patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId, } = {}) {\n    const newConfig = ensureConfig(config);\n    if (callbacks !== undefined) {\n        /**\n         * If we're replacing callbacks we need to unset runName\n         * since that should apply only to the same run as the original callbacks\n         */\n        delete newConfig.runName;\n        newConfig.callbacks = callbacks;\n    }\n    if (recursionLimit !== undefined) {\n        newConfig.recursionLimit = recursionLimit;\n    }\n    if (maxConcurrency !== undefined) {\n        newConfig.maxConcurrency = maxConcurrency;\n    }\n    if (runName !== undefined) {\n        newConfig.runName = runName;\n    }\n    if (configurable !== undefined) {\n        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n    }\n    if (runId !== undefined) {\n        delete newConfig.runId;\n    }\n    return newConfig;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction pickRunnableConfigKeys(config) {\n    return config\n        ? {\n            configurable: config.configurable,\n            recursionLimit: config.recursionLimit,\n            callbacks: config.callbacks,\n            tags: config.tags,\n            metadata: config.metadata,\n            maxConcurrency: config.maxConcurrency,\n            timeout: config.timeout,\n            signal: config.signal,\n        }\n        : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF5RTtBQUNHO0FBQ3JFO0FBQ0E7QUFDUCxXQUFXLGtFQUFlO0FBQzFCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvRUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0VBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrRUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwyQkFBMkIsb0ZBQWtDO0FBQzdEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLElBQUksMkVBQTJFLElBQUk7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHJ1bm5hYmxlc1xcY29uZmlnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhbGxiYWNrTWFuYWdlciwgZW5zdXJlSGFuZGxlciB9IGZyb20gXCIuLi9jYWxsYmFja3MvbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2luZGV4LmpzXCI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9SRUNVUlNJT05fTElNSVQgPSAyNTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIENhbGxiYWNrTWFuYWdlci5fY29uZmlndXJlU3luYyhjb25maWc/LmNhbGxiYWNrcywgdW5kZWZpbmVkLCBjb25maWc/LnRhZ3MsIHVuZGVmaW5lZCwgY29uZmlnPy5tZXRhZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDb25maWdzKC4uLmNvbmZpZ3MpIHtcbiAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBjYWxsIGVuc3VyZUNvbmZpZyBvbiB0aGUgZW1wdHkgc3RhdGUgaGVyZSBhcyB0aGlzIG1heSBjYXVzZVxuICAgIC8vIGRvdWJsZSBsb2FkaW5nIG9mIGNhbGxiYWNrcyBpZiBhc3luYyBsb2NhbCBzdG9yYWdlIGlzIGJlaW5nIHVzZWQuXG4gICAgY29uc3QgY29weSA9IHt9O1xuICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBjb25maWdzLmZpbHRlcigoYykgPT4gISFjKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRpb25zKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJtZXRhZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29weVtrZXldID0geyAuLi5jb3B5W2tleV0sIC4uLm9wdGlvbnNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcInRhZ3NcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VLZXlzID0gY29weVtrZXldID8/IFtdO1xuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IFsuLi5uZXcgU2V0KGJhc2VLZXlzLmNvbmNhdChvcHRpb25zW2tleV0gPz8gW10pKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiY29uZmlndXJhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSB7IC4uLmNvcHlba2V5XSwgLi4ub3B0aW9uc1trZXldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwidGltZW91dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvcHkudGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy50aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weS50aW1lb3V0ID0gTWF0aC5taW4oY29weS50aW1lb3V0LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJzaWduYWxcIikge1xuICAgICAgICAgICAgICAgIGlmIChjb3B5LnNpZ25hbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkuc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiYW55XCIgaW4gQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LnNpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weS5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiY2FsbGJhY2tzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlQ2FsbGJhY2tzID0gY29weS5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZWRDYWxsYmFja3MgPSBvcHRpb25zLmNhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAvLyBjYWxsYmFja3MgY2FuIGJlIGVpdGhlciB1bmRlZmluZWQsIEFycmF5PGhhbmRsZXI+IG9yIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAvLyBzbyBtZXJnaW5nIHR3byBjYWxsYmFja3MgdmFsdWVzIGhhcyA2IGNhc2VzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdmlkZWRDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBwcm92aWRlZENhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJhc2VDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IGJhc2VDYWxsYmFja3MuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VDYWxsYmFja3MgaXMgYSBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYW5hZ2VyID0gYmFzZUNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHByb3ZpZGVkQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGVuc3VyZUhhbmRsZXIoY2FsbGJhY2spLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbWFuYWdlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlZENhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlZENhbGxiYWNrcyBpcyBhIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiYXNlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IHByb3ZpZGVkQ2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYmFzZUNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hbmFnZXIgPSBwcm92aWRlZENhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGJhc2VDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIoZW5zdXJlSGFuZGxlcihjYWxsYmFjayksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBtYW5hZ2VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFzZUNhbGxiYWNrcyBpcyBhbHNvIGEgbWFuYWdlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHByb3ZpZGVkQ2FsbGJhY2tzLl9wYXJlbnRSdW5JZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzOiBiYXNlQ2FsbGJhY2tzLmhhbmRsZXJzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy5oYW5kbGVycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGFibGVIYW5kbGVyczogYmFzZUNhbGxiYWNrcy5pbmhlcml0YWJsZUhhbmRsZXJzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy5pbmhlcml0YWJsZUhhbmRsZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiBBcnJheS5mcm9tKG5ldyBTZXQoYmFzZUNhbGxiYWNrcy50YWdzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy50YWdzKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRhYmxlVGFnczogQXJyYXkuZnJvbShuZXcgU2V0KGJhc2VDYWxsYmFja3MuaW5oZXJpdGFibGVUYWdzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy5pbmhlcml0YWJsZVRhZ3MpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYmFzZUNhbGxiYWNrcy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJvdmlkZWRDYWxsYmFja3MubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgY29weVt0eXBlZEtleV0gPSBvcHRpb25zW3R5cGVkS2V5XSA/PyBjb3B5W3R5cGVkS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cbmNvbnN0IFBSSU1JVElWRVMgPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0pO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHBhc3NlZCBjb25maWcgaXMgYW4gb2JqZWN0IHdpdGggYWxsIHJlcXVpcmVkIGtleXMgcHJlc2VudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25zdCBpbXBsaWNpdENvbmZpZyA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0UnVubmFibGVDb25maWcoKTtcbiAgICBsZXQgZW1wdHkgPSB7XG4gICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAyNSxcbiAgICAgICAgcnVuSWQ6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIGlmIChpbXBsaWNpdENvbmZpZykge1xuICAgICAgICAvLyBEb24ndCBhbGxvdyBydW5JZCBhbmQgcnVuTmFtZSB0byBiZSBsb2FkZWQgaW1wbGljaXRseSwgYXMgdGhpcyBjYW4gY2F1c2VcbiAgICAgICAgLy8gY2hpbGQgcnVucyB0byBpbXByb3Blcmx5IGluaGVyaXQgdGhlaXIgcGFyZW50cycgcnVuIGlkcy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCB7IHJ1bklkLCBydW5OYW1lLCAuLi5yZXN0IH0gPSBpbXBsaWNpdENvbmZpZztcbiAgICAgICAgZW1wdHkgPSBPYmplY3QuZW50cmllcyhyZXN0KS5yZWR1Y2UoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChjdXJyZW50Q29uZmlnLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY3VycmVudENvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENvbmZpZztcbiAgICAgICAgfSwgZW1wdHkpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIGVtcHR5ID0gT2JqZWN0LmVudHJpZXMoY29uZmlnKS5yZWR1Y2UoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChjdXJyZW50Q29uZmlnLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY3VycmVudENvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENvbmZpZztcbiAgICAgICAgfSwgZW1wdHkpO1xuICAgIH1cbiAgICBpZiAoZW1wdHk/LmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhlbXB0eS5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICBpZiAoUFJJTUlUSVZFUy5oYXModHlwZW9mIGVtcHR5LmNvbmZpZ3VyYWJsZVtrZXldKSAmJlxuICAgICAgICAgICAgICAgICFlbXB0eS5tZXRhZGF0YT8uW2tleV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5Lm1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5Lm1ldGFkYXRhID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtcHR5Lm1ldGFkYXRhW2tleV0gPSBlbXB0eS5jb25maWd1cmFibGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW1wdHkudGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChlbXB0eS50aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0U2lnbmFsID0gQWJvcnRTaWduYWwudGltZW91dChlbXB0eS50aW1lb3V0KTtcbiAgICAgICAgaWYgKGVtcHR5LnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoXCJhbnlcIiBpbiBBYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgZW1wdHkuc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFtlbXB0eS5zaWduYWwsIHRpbWVvdXRTaWduYWxdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVtcHR5LnNpZ25hbCA9IHRpbWVvdXRTaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGVtcHR5LnRpbWVvdXQ7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcGF0Y2hlcyBydW5uYWJsZSBjb25maWdzIHdpdGggdXBkYXRlZCBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDb25maWcoY29uZmlnID0ge30sIHsgY2FsbGJhY2tzLCBtYXhDb25jdXJyZW5jeSwgcmVjdXJzaW9uTGltaXQsIHJ1bk5hbWUsIGNvbmZpZ3VyYWJsZSwgcnVuSWQsIH0gPSB7fSkge1xuICAgIGNvbnN0IG5ld0NvbmZpZyA9IGVuc3VyZUNvbmZpZyhjb25maWcpO1xuICAgIGlmIChjYWxsYmFja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgcmVwbGFjaW5nIGNhbGxiYWNrcyB3ZSBuZWVkIHRvIHVuc2V0IHJ1bk5hbWVcbiAgICAgICAgICogc2luY2UgdGhhdCBzaG91bGQgYXBwbHkgb25seSB0byB0aGUgc2FtZSBydW4gYXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrc1xuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5ydW5OYW1lO1xuICAgICAgICBuZXdDb25maWcuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH1cbiAgICBpZiAocmVjdXJzaW9uTGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcucmVjdXJzaW9uTGltaXQgPSByZWN1cnNpb25MaW1pdDtcbiAgICB9XG4gICAgaWYgKG1heENvbmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLm1heENvbmN1cnJlbmN5ID0gbWF4Q29uY3VycmVuY3k7XG4gICAgfVxuICAgIGlmIChydW5OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLnJ1bk5hbWUgPSBydW5OYW1lO1xuICAgIH1cbiAgICBpZiAoY29uZmlndXJhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLmNvbmZpZ3VyYWJsZSA9IHsgLi4ubmV3Q29uZmlnLmNvbmZpZ3VyYWJsZSwgLi4uY29uZmlndXJhYmxlIH07XG4gICAgfVxuICAgIGlmIChydW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBuZXdDb25maWcucnVuSWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdDb25maWc7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZ1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogY29uZmlnLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiBjb25maWcucmVjdXJzaW9uTGltaXQsXG4gICAgICAgICAgICBjYWxsYmFja3M6IGNvbmZpZy5jYWxsYmFja3MsXG4gICAgICAgICAgICB0YWdzOiBjb25maWcudGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjb25maWcubWV0YWRhdGEsXG4gICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogY29uZmlnLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgdGltZW91dDogY29uZmlnLnRpbWVvdXQsXG4gICAgICAgICAgICBzaWduYWw6IGNvbmZpZy5zaWduYWwsXG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/graph.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Graph: () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/utils.js\");\n/* harmony import */ var _graph_mermaid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graph_mermaid.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.js\");\n/* harmony import */ var _utils_json_schema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/json_schema.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.js\");\n\n\n\n\nfunction nodeDataStr(id, data) {\n    if (id !== undefined && !(0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(id)) {\n        return id;\n    }\n    else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableInterface)(data)) {\n        try {\n            let dataStr = data.getName();\n            dataStr = dataStr.startsWith(\"Runnable\")\n                ? dataStr.slice(\"Runnable\".length)\n                : dataStr;\n            return dataStr;\n        }\n        catch (error) {\n            return data.getName();\n        }\n    }\n    else {\n        return data.name ?? \"UnknownSchema\";\n    }\n}\nfunction nodeDataJson(node) {\n    // if node.data implements Runnable\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableInterface)(node.data)) {\n        return {\n            type: \"runnable\",\n            data: {\n                id: node.data.lc_id,\n                name: node.data.getName(),\n            },\n        };\n    }\n    else {\n        return {\n            type: \"schema\",\n            data: { ...(0,_utils_json_schema_js__WEBPACK_IMPORTED_MODULE_2__.toJsonSchema)(node.data.schema), title: node.data.name },\n        };\n    }\n}\nclass Graph {\n    constructor(params) {\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"edges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.nodes = params?.nodes ?? this.nodes;\n        this.edges = params?.edges ?? this.edges;\n    }\n    // Convert the graph to a JSON-serializable format.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    toJSON() {\n        const stableNodeIds = {};\n        Object.values(this.nodes).forEach((node, i) => {\n            stableNodeIds[node.id] = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node.id) ? i : node.id;\n        });\n        return {\n            nodes: Object.values(this.nodes).map((node) => ({\n                id: stableNodeIds[node.id],\n                ...nodeDataJson(node),\n            })),\n            edges: this.edges.map((edge) => {\n                const item = {\n                    source: stableNodeIds[edge.source],\n                    target: stableNodeIds[edge.target],\n                };\n                if (typeof edge.data !== \"undefined\") {\n                    item.data = edge.data;\n                }\n                if (typeof edge.conditional !== \"undefined\") {\n                    item.conditional = edge.conditional;\n                }\n                return item;\n            }),\n        };\n    }\n    addNode(data, id, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata) {\n        if (id !== undefined && this.nodes[id] !== undefined) {\n            throw new Error(`Node with id ${id} already exists`);\n        }\n        const nodeId = id ?? (0,uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n        const node = {\n            id: nodeId,\n            data,\n            name: nodeDataStr(id, data),\n            metadata,\n        };\n        this.nodes[nodeId] = node;\n        return node;\n    }\n    removeNode(node) {\n        // Remove the node from the nodes map\n        delete this.nodes[node.id];\n        // Filter out edges connected to the node\n        this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);\n    }\n    addEdge(source, target, data, conditional) {\n        if (this.nodes[source.id] === undefined) {\n            throw new Error(`Source node ${source.id} not in graph`);\n        }\n        if (this.nodes[target.id] === undefined) {\n            throw new Error(`Target node ${target.id} not in graph`);\n        }\n        const edge = {\n            source: source.id,\n            target: target.id,\n            data,\n            conditional,\n        };\n        this.edges.push(edge);\n        return edge;\n    }\n    firstNode() {\n        return _firstNode(this);\n    }\n    lastNode() {\n        return _lastNode(this);\n    }\n    /**\n     * Add all nodes and edges from another graph.\n     * Note this doesn't check for duplicates, nor does it connect the graphs.\n     */\n    extend(graph, prefix = \"\") {\n        let finalPrefix = prefix;\n        const nodeIds = Object.values(graph.nodes).map((node) => node.id);\n        if (nodeIds.every(uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) {\n            finalPrefix = \"\";\n        }\n        const prefixed = (id) => {\n            return finalPrefix ? `${finalPrefix}:${id}` : id;\n        };\n        Object.entries(graph.nodes).forEach(([key, value]) => {\n            this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };\n        });\n        const newEdges = graph.edges.map((edge) => {\n            return {\n                ...edge,\n                source: prefixed(edge.source),\n                target: prefixed(edge.target),\n            };\n        });\n        // Add all edges from the other graph\n        this.edges = [...this.edges, ...newEdges];\n        const first = graph.firstNode();\n        const last = graph.lastNode();\n        return [\n            first ? { id: prefixed(first.id), data: first.data } : undefined,\n            last ? { id: prefixed(last.id), data: last.data } : undefined,\n        ];\n    }\n    trimFirstNode() {\n        const firstNode = this.firstNode();\n        if (firstNode && _firstNode(this, [firstNode.id])) {\n            this.removeNode(firstNode);\n        }\n    }\n    trimLastNode() {\n        const lastNode = this.lastNode();\n        if (lastNode && _lastNode(this, [lastNode.id])) {\n            this.removeNode(lastNode);\n        }\n    }\n    /**\n     * Return a new graph with all nodes re-identified,\n     * using their unique, readable names where possible.\n     */\n    reid() {\n        const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));\n        const nodeLabelCounts = new Map();\n        Object.values(nodeLabels).forEach((label) => {\n            nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);\n        });\n        const getNodeId = (nodeId) => {\n            const label = nodeLabels[nodeId];\n            if ((0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(nodeId) && nodeLabelCounts.get(label) === 1) {\n                return label;\n            }\n            else {\n                return nodeId;\n            }\n        };\n        return new Graph({\n            nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [\n                getNodeId(id),\n                { ...node, id: getNodeId(id) },\n            ])),\n            edges: this.edges.map((edge) => ({\n                ...edge,\n                source: getNodeId(edge.source),\n                target: getNodeId(edge.target),\n            })),\n        });\n    }\n    drawMermaid(params) {\n        const { withStyles, curveStyle, nodeColors = {\n            default: \"fill:#f2f0ff,line-height:1.2\",\n            first: \"fill-opacity:0\",\n            last: \"fill:#bfb6fc\",\n        }, wrapLabelNWords, } = params ?? {};\n        const graph = this.reid();\n        const firstNode = graph.firstNode();\n        const lastNode = graph.lastNode();\n        return (0,_graph_mermaid_js__WEBPACK_IMPORTED_MODULE_1__.drawMermaid)(graph.nodes, graph.edges, {\n            firstNode: firstNode?.id,\n            lastNode: lastNode?.id,\n            withStyles,\n            curveStyle,\n            nodeColors,\n            wrapLabelNWords,\n        });\n    }\n    async drawMermaidPng(params) {\n        const mermaidSyntax = this.drawMermaid(params);\n        return (0,_graph_mermaid_js__WEBPACK_IMPORTED_MODULE_1__.drawMermaidPng)(mermaidSyntax, {\n            backgroundColor: params?.backgroundColor,\n        });\n    }\n}\n/**\n * Find the single node that is not a target of any edge.\n * Exclude nodes/sources with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the origin.\n */\nfunction _firstNode(graph, exclude = []) {\n    const targets = new Set(graph.edges\n        .filter((edge) => !exclude.includes(edge.source))\n        .map((edge) => edge.target));\n    const found = [];\n    for (const node of Object.values(graph.nodes)) {\n        if (!exclude.includes(node.id) && !targets.has(node.id)) {\n            found.push(node);\n        }\n    }\n    return found.length === 1 ? found[0] : undefined;\n}\n/**\n * Find the single node that is not a source of any edge.\n * Exclude nodes/targets with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the destination.\n */\nfunction _lastNode(graph, exclude = []) {\n    const sources = new Set(graph.edges\n        .filter((edge) => !exclude.includes(edge.target))\n        .map((edge) => edge.source));\n    const found = [];\n    for (const node of Object.values(graph.nodes)) {\n        if (!exclude.includes(node.id) && !sources.has(node.id)) {\n            found.push(node);\n        }\n    }\n    return found.length === 1 ? found[0] : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF3RDtBQUNQO0FBQ2dCO0FBQ1Y7QUFDdkQ7QUFDQSw2QkFBNkIsZ0RBQU07QUFDbkM7QUFDQTtBQUNBLGFBQWEsOERBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRyxtRUFBWSwyQ0FBMkM7QUFDOUU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdEQUFNO0FBQzNDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQSw2QkFBNkIsZ0RBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLEdBQUcsR0FBRztBQUN0RDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBMkM7QUFDakUscUJBQXFCLHlDQUF5QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQWM7QUFDN0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxydW5uYWJsZXNcXGdyYXBoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHY0IGFzIHV1aWR2NCwgdmFsaWRhdGUgYXMgaXNVdWlkIH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IGlzUnVubmFibGVJbnRlcmZhY2UgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgZHJhd01lcm1haWQsIGRyYXdNZXJtYWlkUG5nIH0gZnJvbSBcIi4vZ3JhcGhfbWVybWFpZC5qc1wiO1xuaW1wb3J0IHsgdG9Kc29uU2NoZW1hIH0gZnJvbSBcIi4uL3V0aWxzL2pzb25fc2NoZW1hLmpzXCI7XG5mdW5jdGlvbiBub2RlRGF0YVN0cihpZCwgZGF0YSkge1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmICFpc1V1aWQoaWQpKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSdW5uYWJsZUludGVyZmFjZShkYXRhKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGRhdGFTdHIgPSBkYXRhLmdldE5hbWUoKTtcbiAgICAgICAgICAgIGRhdGFTdHIgPSBkYXRhU3RyLnN0YXJ0c1dpdGgoXCJSdW5uYWJsZVwiKVxuICAgICAgICAgICAgICAgID8gZGF0YVN0ci5zbGljZShcIlJ1bm5hYmxlXCIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogZGF0YVN0cjtcbiAgICAgICAgICAgIHJldHVybiBkYXRhU3RyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuZ2V0TmFtZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF0YS5uYW1lID8/IFwiVW5rbm93blNjaGVtYVwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVEYXRhSnNvbihub2RlKSB7XG4gICAgLy8gaWYgbm9kZS5kYXRhIGltcGxlbWVudHMgUnVubmFibGVcbiAgICBpZiAoaXNSdW5uYWJsZUludGVyZmFjZShub2RlLmRhdGEpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInJ1bm5hYmxlXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaWQ6IG5vZGUuZGF0YS5sY19pZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLmRhdGEuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInNjaGVtYVwiLFxuICAgICAgICAgICAgZGF0YTogeyAuLi50b0pzb25TY2hlbWEobm9kZS5kYXRhLnNjaGVtYSksIHRpdGxlOiBub2RlLmRhdGEubmFtZSB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBHcmFwaCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5vZGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZWRnZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vZGVzID0gcGFyYW1zPy5ub2RlcyA/PyB0aGlzLm5vZGVzO1xuICAgICAgICB0aGlzLmVkZ2VzID0gcGFyYW1zPy5lZGdlcyA/PyB0aGlzLmVkZ2VzO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBncmFwaCB0byBhIEpTT04tc2VyaWFsaXphYmxlIGZvcm1hdC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qgc3RhYmxlTm9kZUlkcyA9IHt9O1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICAgICAgICAgIHN0YWJsZU5vZGVJZHNbbm9kZS5pZF0gPSBpc1V1aWQobm9kZS5pZCkgPyBpIDogbm9kZS5pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlczogT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5tYXAoKG5vZGUpID0+ICh7XG4gICAgICAgICAgICAgICAgaWQ6IHN0YWJsZU5vZGVJZHNbbm9kZS5pZF0sXG4gICAgICAgICAgICAgICAgLi4ubm9kZURhdGFKc29uKG5vZGUpLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgZWRnZXM6IHRoaXMuZWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzdGFibGVOb2RlSWRzW2VkZ2Uuc291cmNlXSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBzdGFibGVOb2RlSWRzW2VkZ2UudGFyZ2V0XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWRnZS5kYXRhICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGF0YSA9IGVkZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlZGdlLmNvbmRpdGlvbmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY29uZGl0aW9uYWwgPSBlZGdlLmNvbmRpdGlvbmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGROb2RlKGRhdGEsIGlkLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubm9kZXNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSB3aXRoIGlkICR7aWR9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZUlkID0gaWQgPz8gdXVpZHY0KCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIG5hbWU6IG5vZGVEYXRhU3RyKGlkLCBkYXRhKSxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmVtb3ZlTm9kZShub2RlKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBub2RlcyBtYXBcbiAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbbm9kZS5pZF07XG4gICAgICAgIC8vIEZpbHRlciBvdXQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBub2RlXG4gICAgICAgIHRoaXMuZWRnZXMgPSB0aGlzLmVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gZWRnZS5zb3VyY2UgIT09IG5vZGUuaWQgJiYgZWRnZS50YXJnZXQgIT09IG5vZGUuaWQpO1xuICAgIH1cbiAgICBhZGRFZGdlKHNvdXJjZSwgdGFyZ2V0LCBkYXRhLCBjb25kaXRpb25hbCkge1xuICAgICAgICBpZiAodGhpcy5ub2Rlc1tzb3VyY2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU291cmNlIG5vZGUgJHtzb3VyY2UuaWR9IG5vdCBpbiBncmFwaGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vZGVzW3RhcmdldC5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgbm9kZSAke3RhcmdldC5pZH0gbm90IGluIGdyYXBoYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRnZSA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLmlkLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQuaWQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgY29uZGl0aW9uYWwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuICAgIGZpcnN0Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9maXJzdE5vZGUodGhpcyk7XG4gICAgfVxuICAgIGxhc3ROb2RlKCkge1xuICAgICAgICByZXR1cm4gX2xhc3ROb2RlKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYWxsIG5vZGVzIGFuZCBlZGdlcyBmcm9tIGFub3RoZXIgZ3JhcGguXG4gICAgICogTm90ZSB0aGlzIGRvZXNuJ3QgY2hlY2sgZm9yIGR1cGxpY2F0ZXMsIG5vciBkb2VzIGl0IGNvbm5lY3QgdGhlIGdyYXBocy5cbiAgICAgKi9cbiAgICBleHRlbmQoZ3JhcGgsIHByZWZpeCA9IFwiXCIpIHtcbiAgICAgICAgbGV0IGZpbmFsUHJlZml4ID0gcHJlZml4O1xuICAgICAgICBjb25zdCBub2RlSWRzID0gT2JqZWN0LnZhbHVlcyhncmFwaC5ub2RlcykubWFwKChub2RlKSA9PiBub2RlLmlkKTtcbiAgICAgICAgaWYgKG5vZGVJZHMuZXZlcnkoaXNVdWlkKSkge1xuICAgICAgICAgICAgZmluYWxQcmVmaXggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeGVkID0gKGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxQcmVmaXggPyBgJHtmaW5hbFByZWZpeH06JHtpZH1gIDogaWQ7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGdyYXBoLm5vZGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbcHJlZml4ZWQoa2V5KV0gPSB7IC4uLnZhbHVlLCBpZDogcHJlZml4ZWQoa2V5KSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3RWRnZXMgPSBncmFwaC5lZGdlcy5tYXAoKGVkZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uZWRnZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHByZWZpeGVkKGVkZ2Uuc291cmNlKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHByZWZpeGVkKGVkZ2UudGFyZ2V0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgYWxsIGVkZ2VzIGZyb20gdGhlIG90aGVyIGdyYXBoXG4gICAgICAgIHRoaXMuZWRnZXMgPSBbLi4udGhpcy5lZGdlcywgLi4ubmV3RWRnZXNdO1xuICAgICAgICBjb25zdCBmaXJzdCA9IGdyYXBoLmZpcnN0Tm9kZSgpO1xuICAgICAgICBjb25zdCBsYXN0ID0gZ3JhcGgubGFzdE5vZGUoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZpcnN0ID8geyBpZDogcHJlZml4ZWQoZmlyc3QuaWQpLCBkYXRhOiBmaXJzdC5kYXRhIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsYXN0ID8geyBpZDogcHJlZml4ZWQobGFzdC5pZCksIGRhdGE6IGxhc3QuZGF0YSB9IDogdW5kZWZpbmVkLFxuICAgICAgICBdO1xuICAgIH1cbiAgICB0cmltRmlyc3ROb2RlKCkge1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSB0aGlzLmZpcnN0Tm9kZSgpO1xuICAgICAgICBpZiAoZmlyc3ROb2RlICYmIF9maXJzdE5vZGUodGhpcywgW2ZpcnN0Tm9kZS5pZF0pKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUoZmlyc3ROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmltTGFzdE5vZGUoKSB7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gdGhpcy5sYXN0Tm9kZSgpO1xuICAgICAgICBpZiAobGFzdE5vZGUgJiYgX2xhc3ROb2RlKHRoaXMsIFtsYXN0Tm9kZS5pZF0pKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUobGFzdE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBncmFwaCB3aXRoIGFsbCBub2RlcyByZS1pZGVudGlmaWVkLFxuICAgICAqIHVzaW5nIHRoZWlyIHVuaXF1ZSwgcmVhZGFibGUgbmFtZXMgd2hlcmUgcG9zc2libGUuXG4gICAgICovXG4gICAgcmVpZCgpIHtcbiAgICAgICAgY29uc3Qgbm9kZUxhYmVscyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLm1hcCgobm9kZSkgPT4gW25vZGUuaWQsIG5vZGUubmFtZV0pKTtcbiAgICAgICAgY29uc3Qgbm9kZUxhYmVsQ291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBPYmplY3QudmFsdWVzKG5vZGVMYWJlbHMpLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICBub2RlTGFiZWxDb3VudHMuc2V0KGxhYmVsLCAobm9kZUxhYmVsQ291bnRzLmdldChsYWJlbCkgfHwgMCkgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGdldE5vZGVJZCA9IChub2RlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gbm9kZUxhYmVsc1tub2RlSWRdO1xuICAgICAgICAgICAgaWYgKGlzVXVpZChub2RlSWQpICYmIG5vZGVMYWJlbENvdW50cy5nZXQobGFiZWwpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFwaCh7XG4gICAgICAgICAgICBub2RlczogT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHRoaXMubm9kZXMpLm1hcCgoW2lkLCBub2RlXSkgPT4gW1xuICAgICAgICAgICAgICAgIGdldE5vZGVJZChpZCksXG4gICAgICAgICAgICAgICAgeyAuLi5ub2RlLCBpZDogZ2V0Tm9kZUlkKGlkKSB9LFxuICAgICAgICAgICAgXSkpLFxuICAgICAgICAgICAgZWRnZXM6IHRoaXMuZWRnZXMubWFwKChlZGdlKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmVkZ2UsXG4gICAgICAgICAgICAgICAgc291cmNlOiBnZXROb2RlSWQoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgICAgICAgIHRhcmdldDogZ2V0Tm9kZUlkKGVkZ2UudGFyZ2V0KSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYXdNZXJtYWlkKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IHdpdGhTdHlsZXMsIGN1cnZlU3R5bGUsIG5vZGVDb2xvcnMgPSB7XG4gICAgICAgICAgICBkZWZhdWx0OiBcImZpbGw6I2YyZjBmZixsaW5lLWhlaWdodDoxLjJcIixcbiAgICAgICAgICAgIGZpcnN0OiBcImZpbGwtb3BhY2l0eTowXCIsXG4gICAgICAgICAgICBsYXN0OiBcImZpbGw6I2JmYjZmY1wiLFxuICAgICAgICB9LCB3cmFwTGFiZWxOV29yZHMsIH0gPSBwYXJhbXMgPz8ge307XG4gICAgICAgIGNvbnN0IGdyYXBoID0gdGhpcy5yZWlkKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0Tm9kZSA9IGdyYXBoLmZpcnN0Tm9kZSgpO1xuICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IGdyYXBoLmxhc3ROb2RlKCk7XG4gICAgICAgIHJldHVybiBkcmF3TWVybWFpZChncmFwaC5ub2RlcywgZ3JhcGguZWRnZXMsIHtcbiAgICAgICAgICAgIGZpcnN0Tm9kZTogZmlyc3ROb2RlPy5pZCxcbiAgICAgICAgICAgIGxhc3ROb2RlOiBsYXN0Tm9kZT8uaWQsXG4gICAgICAgICAgICB3aXRoU3R5bGVzLFxuICAgICAgICAgICAgY3VydmVTdHlsZSxcbiAgICAgICAgICAgIG5vZGVDb2xvcnMsXG4gICAgICAgICAgICB3cmFwTGFiZWxOV29yZHMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkcmF3TWVybWFpZFBuZyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgbWVybWFpZFN5bnRheCA9IHRoaXMuZHJhd01lcm1haWQocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIGRyYXdNZXJtYWlkUG5nKG1lcm1haWRTeW50YXgsIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcGFyYW1zPy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogRmluZCB0aGUgc2luZ2xlIG5vZGUgdGhhdCBpcyBub3QgYSB0YXJnZXQgb2YgYW55IGVkZ2UuXG4gKiBFeGNsdWRlIG5vZGVzL3NvdXJjZXMgd2l0aCBpZHMgaW4gdGhlIGV4Y2x1ZGUgbGlzdC5cbiAqIElmIHRoZXJlIGlzIG5vIHN1Y2ggbm9kZSwgb3IgdGhlcmUgYXJlIG11bHRpcGxlLCByZXR1cm4gdW5kZWZpbmVkLlxuICogV2hlbiBkcmF3aW5nIHRoZSBncmFwaCwgdGhpcyBub2RlIHdvdWxkIGJlIHRoZSBvcmlnaW4uXG4gKi9cbmZ1bmN0aW9uIF9maXJzdE5vZGUoZ3JhcGgsIGV4Y2x1ZGUgPSBbXSkge1xuICAgIGNvbnN0IHRhcmdldHMgPSBuZXcgU2V0KGdyYXBoLmVkZ2VzXG4gICAgICAgIC5maWx0ZXIoKGVkZ2UpID0+ICFleGNsdWRlLmluY2x1ZGVzKGVkZ2Uuc291cmNlKSlcbiAgICAgICAgLm1hcCgoZWRnZSkgPT4gZWRnZS50YXJnZXQpKTtcbiAgICBjb25zdCBmb3VuZCA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBPYmplY3QudmFsdWVzKGdyYXBoLm5vZGVzKSkge1xuICAgICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXMobm9kZS5pZCkgJiYgIXRhcmdldHMuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZC5sZW5ndGggPT09IDEgPyBmb3VuZFswXSA6IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogRmluZCB0aGUgc2luZ2xlIG5vZGUgdGhhdCBpcyBub3QgYSBzb3VyY2Ugb2YgYW55IGVkZ2UuXG4gKiBFeGNsdWRlIG5vZGVzL3RhcmdldHMgd2l0aCBpZHMgaW4gdGhlIGV4Y2x1ZGUgbGlzdC5cbiAqIElmIHRoZXJlIGlzIG5vIHN1Y2ggbm9kZSwgb3IgdGhlcmUgYXJlIG11bHRpcGxlLCByZXR1cm4gdW5kZWZpbmVkLlxuICogV2hlbiBkcmF3aW5nIHRoZSBncmFwaCwgdGhpcyBub2RlIHdvdWxkIGJlIHRoZSBkZXN0aW5hdGlvbi5cbiAqL1xuZnVuY3Rpb24gX2xhc3ROb2RlKGdyYXBoLCBleGNsdWRlID0gW10pIHtcbiAgICBjb25zdCBzb3VyY2VzID0gbmV3IFNldChncmFwaC5lZGdlc1xuICAgICAgICAuZmlsdGVyKChlZGdlKSA9PiAhZXhjbHVkZS5pbmNsdWRlcyhlZGdlLnRhcmdldCkpXG4gICAgICAgIC5tYXAoKGVkZ2UpID0+IGVkZ2Uuc291cmNlKSk7XG4gICAgY29uc3QgZm91bmQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyhncmFwaC5ub2RlcykpIHtcbiAgICAgICAgaWYgKCFleGNsdWRlLmluY2x1ZGVzKG5vZGUuaWQpICYmICFzb3VyY2VzLmhhcyhub2RlLmlkKSkge1xuICAgICAgICAgICAgZm91bmQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQubGVuZ3RoID09PSAxID8gZm91bmRbMF0gOiB1bmRlZmluZWQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/graph.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph_mermaid.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawMermaid: () => (/* binding */ drawMermaid),\n/* harmony export */   drawMermaidImage: () => (/* binding */ drawMermaidImage),\n/* harmony export */   drawMermaidPng: () => (/* binding */ drawMermaidPng)\n/* harmony export */ });\nfunction _escapeNodeLabel(nodeLabel) {\n    // Escapes the node label for Mermaid syntax.\n    return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, \"_\");\n}\nconst MARKDOWN_SPECIAL_CHARS = [\"*\", \"_\", \"`\"];\nfunction _generateMermaidGraphStyles(nodeColors) {\n    let styles = \"\";\n    for (const [className, color] of Object.entries(nodeColors)) {\n        styles += `\\tclassDef ${className} ${color};\\n`;\n    }\n    return styles;\n}\n/**\n * Draws a Mermaid graph using the provided graph data\n */\nfunction drawMermaid(nodes, edges, config) {\n    const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = \"linear\", wrapLabelNWords = 9, } = config ?? {};\n    // Initialize Mermaid graph configuration\n    let mermaidGraph = withStyles\n        ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%\\ngraph TD;\\n`\n        : \"graph TD;\\n\";\n    if (withStyles) {\n        // Node formatting templates\n        const defaultClassLabel = \"default\";\n        const formatDict = {\n            [defaultClassLabel]: \"{0}({1})\",\n        };\n        if (firstNode !== undefined) {\n            formatDict[firstNode] = \"{0}([{1}]):::first\";\n        }\n        if (lastNode !== undefined) {\n            formatDict[lastNode] = \"{0}([{1}]):::last\";\n        }\n        // Add nodes to the graph\n        for (const [key, node] of Object.entries(nodes)) {\n            const nodeName = node.name.split(\":\").pop() ?? \"\";\n            const label = MARKDOWN_SPECIAL_CHARS.some((char) => nodeName.startsWith(char) && nodeName.endsWith(char))\n                ? `<p>${nodeName}</p>`\n                : nodeName;\n            let finalLabel = label;\n            if (Object.keys(node.metadata ?? {}).length) {\n                finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {})\n                    .map(([k, v]) => `${k} = ${v}`)\n                    .join(\"\\n\")}</em></small>`;\n            }\n            const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel])\n                .replace(\"{0}\", _escapeNodeLabel(key))\n                .replace(\"{1}\", finalLabel);\n            mermaidGraph += `\\t${nodeLabel}\\n`;\n        }\n    }\n    // Group edges by their common prefixes\n    const edgeGroups = {};\n    for (const edge of edges) {\n        const srcParts = edge.source.split(\":\");\n        const tgtParts = edge.target.split(\":\");\n        const commonPrefix = srcParts\n            .filter((src, i) => src === tgtParts[i])\n            .join(\":\");\n        if (!edgeGroups[commonPrefix]) {\n            edgeGroups[commonPrefix] = [];\n        }\n        edgeGroups[commonPrefix].push(edge);\n    }\n    const seenSubgraphs = new Set();\n    function addSubgraph(edges, prefix) {\n        const selfLoop = edges.length === 1 && edges[0].source === edges[0].target;\n        if (prefix && !selfLoop) {\n            const subgraph = prefix.split(\":\").pop();\n            if (seenSubgraphs.has(subgraph)) {\n                throw new Error(`Found duplicate subgraph '${subgraph}' -- this likely means that ` +\n                    \"you're reusing a subgraph node with the same name. \" +\n                    \"Please adjust your graph to have subgraph nodes with unique names.\");\n            }\n            seenSubgraphs.add(subgraph);\n            mermaidGraph += `\\tsubgraph ${subgraph}\\n`;\n        }\n        for (const edge of edges) {\n            const { source, target, data, conditional } = edge;\n            let edgeLabel = \"\";\n            if (data !== undefined) {\n                let edgeData = data;\n                const words = edgeData.split(\" \");\n                if (words.length > wrapLabelNWords) {\n                    edgeData = Array.from({ length: Math.ceil(words.length / wrapLabelNWords) }, (_, i) => words\n                        .slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords)\n                        .join(\" \")).join(\"&nbsp;<br>&nbsp;\");\n                }\n                edgeLabel = conditional\n                    ? ` -. &nbsp;${edgeData}&nbsp; .-> `\n                    : ` -- &nbsp;${edgeData}&nbsp; --> `;\n            }\n            else {\n                edgeLabel = conditional ? \" -.-> \" : \" --> \";\n            }\n            mermaidGraph += `\\t${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};\\n`;\n        }\n        // Recursively add nested subgraphs\n        for (const nestedPrefix in edgeGroups) {\n            if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) {\n                addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);\n            }\n        }\n        if (prefix && !selfLoop) {\n            mermaidGraph += \"\\tend\\n\";\n        }\n    }\n    // Start with the top-level edges (no common prefix)\n    addSubgraph(edgeGroups[\"\"] ?? [], \"\");\n    // Add remaining subgraphs\n    for (const prefix in edgeGroups) {\n        if (!prefix.includes(\":\") && prefix !== \"\") {\n            addSubgraph(edgeGroups[prefix], prefix);\n        }\n    }\n    // Add custom styles for nodes\n    if (withStyles) {\n        mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});\n    }\n    return mermaidGraph;\n}\n/**\n * @deprecated Use `drawMermaidImage` instead.\n */\nasync function drawMermaidPng(mermaidSyntax, config) {\n    return drawMermaidImage(mermaidSyntax, {\n        ...config,\n        imageType: \"png\",\n    });\n}\n/**\n * Renders Mermaid graph using the Mermaid.INK API.\n *\n * @example\n * ```javascript\n * const image = await drawMermaidImage(mermaidSyntax, {\n *   backgroundColor: \"white\",\n *   imageType: \"png\",\n * });\n * fs.writeFileSync(\"image.png\", image);\n * ```\n *\n * @param mermaidSyntax - The Mermaid syntax to render.\n * @param config - The configuration for the image.\n * @returns The image as a Blob.\n */\nasync function drawMermaidImage(mermaidSyntax, config) {\n    let backgroundColor = config?.backgroundColor ?? \"white\";\n    const imageType = config?.imageType ?? \"png\";\n    // Use btoa for compatibility, assume ASCII\n    const mermaidSyntaxEncoded = btoa(mermaidSyntax);\n    // Check if the background color is a hexadecimal color code using regex\n    if (backgroundColor !== undefined) {\n        const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;\n        if (!hexColorPattern.test(backgroundColor)) {\n            backgroundColor = `!${backgroundColor}`;\n        }\n    }\n    const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}&type=${imageType}`;\n    const res = await fetch(imageUrl);\n    if (!res.ok) {\n        throw new Error([\n            `Failed to render the graph using the Mermaid.INK API.`,\n            `Status code: ${res.status}`,\n            `Status text: ${res.statusText}`,\n        ].join(\"\\n\"));\n    }\n    const content = await res.blob();\n    return content;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoX21lcm1haWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLEVBQUUsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksa0dBQWtHO0FBQzlHO0FBQ0E7QUFDQSxjQUFjLE9BQU8sY0FBYyxZQUFZLFdBQVcsSUFBSSxhQUFhO0FBQzNFLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxFQUFFLEVBQUUsRUFBRTtBQUN6QztBQUNBO0FBQ0Esc0NBQXNDLEVBQUUsR0FBRyxFQUFFO0FBQzdDO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRSxHQUFHLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsaURBQWlELGtDQUFrQztBQUNuRix3Q0FBd0MsR0FBRyxJQUFJLEVBQUU7QUFDakQsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSwyQkFBMkIsRUFBRTtBQUM3QiwyQkFBMkIsRUFBRTtBQUM3QixpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbURBQW1EO0FBQy9GO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBLGlDQUFpQyxFQUFFLFNBQVMsT0FBTztBQUNuRCxpQ0FBaUMsRUFBRSxTQUFTLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCLEVBQUUsVUFBVSxFQUFFLDBCQUEwQjtBQUNsRztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUUsRUFBRSxJQUFJO0FBQzFEO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQixXQUFXLGdCQUFnQixRQUFRLFVBQVU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2Qyw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHJ1bm5hYmxlc1xcZ3JhcGhfbWVybWFpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZXNjYXBlTm9kZUxhYmVsKG5vZGVMYWJlbCkge1xuICAgIC8vIEVzY2FwZXMgdGhlIG5vZGUgbGFiZWwgZm9yIE1lcm1haWQgc3ludGF4LlxuICAgIHJldHVybiBub2RlTGFiZWwucmVwbGFjZSgvW15hLXpBLVotXzAtOV0vZywgXCJfXCIpO1xufVxuY29uc3QgTUFSS0RPV05fU1BFQ0lBTF9DSEFSUyA9IFtcIipcIiwgXCJfXCIsIFwiYFwiXTtcbmZ1bmN0aW9uIF9nZW5lcmF0ZU1lcm1haWRHcmFwaFN0eWxlcyhub2RlQ29sb3JzKSB7XG4gICAgbGV0IHN0eWxlcyA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBbY2xhc3NOYW1lLCBjb2xvcl0gb2YgT2JqZWN0LmVudHJpZXMobm9kZUNvbG9ycykpIHtcbiAgICAgICAgc3R5bGVzICs9IGBcXHRjbGFzc0RlZiAke2NsYXNzTmFtZX0gJHtjb2xvcn07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbn1cbi8qKlxuICogRHJhd3MgYSBNZXJtYWlkIGdyYXBoIHVzaW5nIHRoZSBwcm92aWRlZCBncmFwaCBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3TWVybWFpZChub2RlcywgZWRnZXMsIGNvbmZpZykge1xuICAgIGNvbnN0IHsgZmlyc3ROb2RlLCBsYXN0Tm9kZSwgbm9kZUNvbG9ycywgd2l0aFN0eWxlcyA9IHRydWUsIGN1cnZlU3R5bGUgPSBcImxpbmVhclwiLCB3cmFwTGFiZWxOV29yZHMgPSA5LCB9ID0gY29uZmlnID8/IHt9O1xuICAgIC8vIEluaXRpYWxpemUgTWVybWFpZCBncmFwaCBjb25maWd1cmF0aW9uXG4gICAgbGV0IG1lcm1haWRHcmFwaCA9IHdpdGhTdHlsZXNcbiAgICAgICAgPyBgJSV7aW5pdDogeydmbG93Y2hhcnQnOiB7J2N1cnZlJzogJyR7Y3VydmVTdHlsZX0nfX19JSVcXG5ncmFwaCBURDtcXG5gXG4gICAgICAgIDogXCJncmFwaCBURDtcXG5cIjtcbiAgICBpZiAod2l0aFN0eWxlcykge1xuICAgICAgICAvLyBOb2RlIGZvcm1hdHRpbmcgdGVtcGxhdGVzXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDbGFzc0xhYmVsID0gXCJkZWZhdWx0XCI7XG4gICAgICAgIGNvbnN0IGZvcm1hdERpY3QgPSB7XG4gICAgICAgICAgICBbZGVmYXVsdENsYXNzTGFiZWxdOiBcInswfSh7MX0pXCIsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaXJzdE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0RGljdFtmaXJzdE5vZGVdID0gXCJ7MH0oW3sxfV0pOjo6Zmlyc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0RGljdFtsYXN0Tm9kZV0gPSBcInswfShbezF9XSk6OjpsYXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIG5vZGVzIHRvIHRoZSBncmFwaFxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGVzKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5hbWUuc3BsaXQoXCI6XCIpLnBvcCgpID8/IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IE1BUktET1dOX1NQRUNJQUxfQ0hBUlMuc29tZSgoY2hhcikgPT4gbm9kZU5hbWUuc3RhcnRzV2l0aChjaGFyKSAmJiBub2RlTmFtZS5lbmRzV2l0aChjaGFyKSlcbiAgICAgICAgICAgICAgICA/IGA8cD4ke25vZGVOYW1lfTwvcD5gXG4gICAgICAgICAgICAgICAgOiBub2RlTmFtZTtcbiAgICAgICAgICAgIGxldCBmaW5hbExhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobm9kZS5tZXRhZGF0YSA/PyB7fSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmluYWxMYWJlbCArPSBgPGhyLz48c21hbGw+PGVtPiR7T2JqZWN0LmVudHJpZXMobm9kZS5tZXRhZGF0YSA/PyB7fSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtrfSA9ICR7dn1gKVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKX08L2VtPjwvc21hbGw+YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGVMYWJlbCA9IChmb3JtYXREaWN0W2tleV0gPz8gZm9ybWF0RGljdFtkZWZhdWx0Q2xhc3NMYWJlbF0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJ7MH1cIiwgX2VzY2FwZU5vZGVMYWJlbChrZXkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiezF9XCIsIGZpbmFsTGFiZWwpO1xuICAgICAgICAgICAgbWVybWFpZEdyYXBoICs9IGBcXHQke25vZGVMYWJlbH1cXG5gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdyb3VwIGVkZ2VzIGJ5IHRoZWlyIGNvbW1vbiBwcmVmaXhlc1xuICAgIGNvbnN0IGVkZ2VHcm91cHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgY29uc3Qgc3JjUGFydHMgPSBlZGdlLnNvdXJjZS5zcGxpdChcIjpcIik7XG4gICAgICAgIGNvbnN0IHRndFBhcnRzID0gZWRnZS50YXJnZXQuc3BsaXQoXCI6XCIpO1xuICAgICAgICBjb25zdCBjb21tb25QcmVmaXggPSBzcmNQYXJ0c1xuICAgICAgICAgICAgLmZpbHRlcigoc3JjLCBpKSA9PiBzcmMgPT09IHRndFBhcnRzW2ldKVxuICAgICAgICAgICAgLmpvaW4oXCI6XCIpO1xuICAgICAgICBpZiAoIWVkZ2VHcm91cHNbY29tbW9uUHJlZml4XSkge1xuICAgICAgICAgICAgZWRnZUdyb3Vwc1tjb21tb25QcmVmaXhdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWRnZUdyb3Vwc1tjb21tb25QcmVmaXhdLnB1c2goZWRnZSk7XG4gICAgfVxuICAgIGNvbnN0IHNlZW5TdWJncmFwaHMgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gYWRkU3ViZ3JhcGgoZWRnZXMsIHByZWZpeCkge1xuICAgICAgICBjb25zdCBzZWxmTG9vcCA9IGVkZ2VzLmxlbmd0aCA9PT0gMSAmJiBlZGdlc1swXS5zb3VyY2UgPT09IGVkZ2VzWzBdLnRhcmdldDtcbiAgICAgICAgaWYgKHByZWZpeCAmJiAhc2VsZkxvb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmdyYXBoID0gcHJlZml4LnNwbGl0KFwiOlwiKS5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzZWVuU3ViZ3JhcGhzLmhhcyhzdWJncmFwaCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGR1cGxpY2F0ZSBzdWJncmFwaCAnJHtzdWJncmFwaH0nIC0tIHRoaXMgbGlrZWx5IG1lYW5zIHRoYXQgYCArXG4gICAgICAgICAgICAgICAgICAgIFwieW91J3JlIHJldXNpbmcgYSBzdWJncmFwaCBub2RlIHdpdGggdGhlIHNhbWUgbmFtZS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlBsZWFzZSBhZGp1c3QgeW91ciBncmFwaCB0byBoYXZlIHN1YmdyYXBoIG5vZGVzIHdpdGggdW5pcXVlIG5hbWVzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5TdWJncmFwaHMuYWRkKHN1YmdyYXBoKTtcbiAgICAgICAgICAgIG1lcm1haWRHcmFwaCArPSBgXFx0c3ViZ3JhcGggJHtzdWJncmFwaH1cXG5gO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UsIHRhcmdldCwgZGF0YSwgY29uZGl0aW9uYWwgfSA9IGVkZ2U7XG4gICAgICAgICAgICBsZXQgZWRnZUxhYmVsID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZWRnZURhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gZWRnZURhdGEuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgIGlmICh3b3Jkcy5sZW5ndGggPiB3cmFwTGFiZWxOV29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZURhdGEgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBNYXRoLmNlaWwod29yZHMubGVuZ3RoIC8gd3JhcExhYmVsTldvcmRzKSB9LCAoXywgaSkgPT4gd29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZShpICogd3JhcExhYmVsTldvcmRzLCAoaSArIDEpICogd3JhcExhYmVsTldvcmRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCIgXCIpKS5qb2luKFwiJm5ic3A7PGJyPiZuYnNwO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWRnZUxhYmVsID0gY29uZGl0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgPyBgIC0uICZuYnNwOyR7ZWRnZURhdGF9Jm5ic3A7IC4tPiBgXG4gICAgICAgICAgICAgICAgICAgIDogYCAtLSAmbmJzcDske2VkZ2VEYXRhfSZuYnNwOyAtLT4gYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkZ2VMYWJlbCA9IGNvbmRpdGlvbmFsID8gXCIgLS4tPiBcIiA6IFwiIC0tPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lcm1haWRHcmFwaCArPSBgXFx0JHtfZXNjYXBlTm9kZUxhYmVsKHNvdXJjZSl9JHtlZGdlTGFiZWx9JHtfZXNjYXBlTm9kZUxhYmVsKHRhcmdldCl9O1xcbmA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgYWRkIG5lc3RlZCBzdWJncmFwaHNcbiAgICAgICAgZm9yIChjb25zdCBuZXN0ZWRQcmVmaXggaW4gZWRnZUdyb3Vwcykge1xuICAgICAgICAgICAgaWYgKG5lc3RlZFByZWZpeC5zdGFydHNXaXRoKGAke3ByZWZpeH06YCkgJiYgbmVzdGVkUHJlZml4ICE9PSBwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBhZGRTdWJncmFwaChlZGdlR3JvdXBzW25lc3RlZFByZWZpeF0sIG5lc3RlZFByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeCAmJiAhc2VsZkxvb3ApIHtcbiAgICAgICAgICAgIG1lcm1haWRHcmFwaCArPSBcIlxcdGVuZFxcblwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFN0YXJ0IHdpdGggdGhlIHRvcC1sZXZlbCBlZGdlcyAobm8gY29tbW9uIHByZWZpeClcbiAgICBhZGRTdWJncmFwaChlZGdlR3JvdXBzW1wiXCJdID8/IFtdLCBcIlwiKTtcbiAgICAvLyBBZGQgcmVtYWluaW5nIHN1YmdyYXBoc1xuICAgIGZvciAoY29uc3QgcHJlZml4IGluIGVkZ2VHcm91cHMpIHtcbiAgICAgICAgaWYgKCFwcmVmaXguaW5jbHVkZXMoXCI6XCIpICYmIHByZWZpeCAhPT0gXCJcIikge1xuICAgICAgICAgICAgYWRkU3ViZ3JhcGgoZWRnZUdyb3Vwc1twcmVmaXhdLCBwcmVmaXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBjdXN0b20gc3R5bGVzIGZvciBub2Rlc1xuICAgIGlmICh3aXRoU3R5bGVzKSB7XG4gICAgICAgIG1lcm1haWRHcmFwaCArPSBfZ2VuZXJhdGVNZXJtYWlkR3JhcGhTdHlsZXMobm9kZUNvbG9ycyA/PyB7fSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJtYWlkR3JhcGg7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgZHJhd01lcm1haWRJbWFnZWAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRyYXdNZXJtYWlkUG5nKG1lcm1haWRTeW50YXgsIGNvbmZpZykge1xuICAgIHJldHVybiBkcmF3TWVybWFpZEltYWdlKG1lcm1haWRTeW50YXgsIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBpbWFnZVR5cGU6IFwicG5nXCIsXG4gICAgfSk7XG59XG4vKipcbiAqIFJlbmRlcnMgTWVybWFpZCBncmFwaCB1c2luZyB0aGUgTWVybWFpZC5JTksgQVBJLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBpbWFnZSA9IGF3YWl0IGRyYXdNZXJtYWlkSW1hZ2UobWVybWFpZFN5bnRheCwge1xuICogICBiYWNrZ3JvdW5kQ29sb3I6IFwid2hpdGVcIixcbiAqICAgaW1hZ2VUeXBlOiBcInBuZ1wiLFxuICogfSk7XG4gKiBmcy53cml0ZUZpbGVTeW5jKFwiaW1hZ2UucG5nXCIsIGltYWdlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBtZXJtYWlkU3ludGF4IC0gVGhlIE1lcm1haWQgc3ludGF4IHRvIHJlbmRlci5cbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGltYWdlLlxuICogQHJldHVybnMgVGhlIGltYWdlIGFzIGEgQmxvYi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRyYXdNZXJtYWlkSW1hZ2UobWVybWFpZFN5bnRheCwgY29uZmlnKSB7XG4gICAgbGV0IGJhY2tncm91bmRDb2xvciA9IGNvbmZpZz8uYmFja2dyb3VuZENvbG9yID8/IFwid2hpdGVcIjtcbiAgICBjb25zdCBpbWFnZVR5cGUgPSBjb25maWc/LmltYWdlVHlwZSA/PyBcInBuZ1wiO1xuICAgIC8vIFVzZSBidG9hIGZvciBjb21wYXRpYmlsaXR5LCBhc3N1bWUgQVNDSUlcbiAgICBjb25zdCBtZXJtYWlkU3ludGF4RW5jb2RlZCA9IGJ0b2EobWVybWFpZFN5bnRheCk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGJhY2tncm91bmQgY29sb3IgaXMgYSBoZXhhZGVjaW1hbCBjb2xvciBjb2RlIHVzaW5nIHJlZ2V4XG4gICAgaWYgKGJhY2tncm91bmRDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGhleENvbG9yUGF0dGVybiA9IC9eIyg/OlswLTlhLWZBLUZdezN9KXsxLDJ9JC87XG4gICAgICAgIGlmICghaGV4Q29sb3JQYXR0ZXJuLnRlc3QoYmFja2dyb3VuZENvbG9yKSkge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gYCEke2JhY2tncm91bmRDb2xvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGltYWdlVXJsID0gYGh0dHBzOi8vbWVybWFpZC5pbmsvaW1nLyR7bWVybWFpZFN5bnRheEVuY29kZWR9P2JnQ29sb3I9JHtiYWNrZ3JvdW5kQ29sb3J9JnR5cGU9JHtpbWFnZVR5cGV9YDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChpbWFnZVVybCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gcmVuZGVyIHRoZSBncmFwaCB1c2luZyB0aGUgTWVybWFpZC5JTksgQVBJLmAsXG4gICAgICAgICAgICBgU3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c31gLFxuICAgICAgICAgICAgYFN0YXR1cyB0ZXh0OiAke3Jlcy5zdGF0dXNUZXh0fWAsXG4gICAgICAgIF0uam9pbihcIlxcblwiKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZXMuYmxvYigpO1xuICAgIHJldHVybiBjb250ZW50O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/history.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/history.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunnableWithMessageHistory: () => (/* binding */ RunnableWithMessageHistory)\n/* harmony export */ });\n/* harmony import */ var _messages_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../messages/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _passthrough_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./passthrough.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.js\");\n\n\n\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nclass RunnableWithMessageHistory extends _base_js__WEBPACK_IMPORTED_MODULE_1__.RunnableBinding {\n    constructor(fields) {\n        let historyChain = _base_js__WEBPACK_IMPORTED_MODULE_1__.RunnableLambda.from((input, options) => this._enterHistory(input, options ?? {})).withConfig({ runName: \"loadHistory\" });\n        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n        if (messagesKey) {\n            historyChain = _passthrough_js__WEBPACK_IMPORTED_MODULE_2__.RunnablePassthrough.assign({\n                [messagesKey]: historyChain,\n            }).withConfig({ runName: \"insertHistory\" });\n        }\n        const bound = historyChain\n            .pipe(fields.runnable.withListeners({\n            onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        }))\n            .withConfig({ runName: \"RunnableWithMessageHistory\" });\n        const config = fields.config ?? {};\n        super({\n            ...fields,\n            config,\n            bound,\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"historyMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"getMessageHistory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.getMessageHistory = fields.getMessageHistory;\n        this.inputMessagesKey = fields.inputMessagesKey;\n        this.outputMessagesKey = fields.outputMessagesKey;\n        this.historyMessagesKey = fields.historyMessagesKey;\n    }\n    _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue) {\n        let parsedInputValue;\n        if (typeof inputValue === \"object\" &&\n            !Array.isArray(inputValue) &&\n            !(0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isBaseMessage)(inputValue)) {\n            let key;\n            if (this.inputMessagesKey) {\n                key = this.inputMessagesKey;\n            }\n            else if (Object.keys(inputValue).length === 1) {\n                key = Object.keys(inputValue)[0];\n            }\n            else {\n                key = \"input\";\n            }\n            if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n                parsedInputValue = inputValue[key][0];\n            }\n            else {\n                parsedInputValue = inputValue[key];\n            }\n        }\n        else {\n            parsedInputValue = inputValue;\n        }\n        if (typeof parsedInputValue === \"string\") {\n            return [new _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.HumanMessage(parsedInputValue)];\n        }\n        else if (Array.isArray(parsedInputValue)) {\n            return parsedInputValue;\n        }\n        else if ((0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isBaseMessage)(parsedInputValue)) {\n            return [parsedInputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(parsedInputValue, null, 2)}`);\n        }\n    }\n    _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue) {\n        let parsedOutputValue;\n        if (!Array.isArray(outputValue) &&\n            !(0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isBaseMessage)(outputValue) &&\n            typeof outputValue !== \"string\") {\n            let key;\n            if (this.outputMessagesKey !== undefined) {\n                key = this.outputMessagesKey;\n            }\n            else if (Object.keys(outputValue).length === 1) {\n                key = Object.keys(outputValue)[0];\n            }\n            else {\n                key = \"output\";\n            }\n            // If you are wrapping a chat model directly\n            // The output is actually this weird generations object\n            if (outputValue.generations !== undefined) {\n                parsedOutputValue = outputValue.generations[0][0].message;\n            }\n            else {\n                parsedOutputValue = outputValue[key];\n            }\n        }\n        else {\n            parsedOutputValue = outputValue;\n        }\n        if (typeof parsedOutputValue === \"string\") {\n            return [new _messages_index_js__WEBPACK_IMPORTED_MODULE_0__.AIMessage(parsedOutputValue)];\n        }\n        else if (Array.isArray(parsedOutputValue)) {\n            return parsedOutputValue;\n        }\n        else if ((0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isBaseMessage)(parsedOutputValue)) {\n            return [parsedOutputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);\n        }\n    }\n    async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, kwargs) {\n        const history = kwargs?.configurable?.messageHistory;\n        const messages = await history.getMessages();\n        if (this.historyMessagesKey === undefined) {\n            return messages.concat(this._getInputMessages(input));\n        }\n        return messages;\n    }\n    async _exitHistory(run, config) {\n        const history = config.configurable?.messageHistory;\n        // Get input messages\n        let inputs;\n        // Chat model inputs are nested arrays\n        if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n            inputs = run.inputs[0];\n        }\n        else {\n            inputs = run.inputs;\n        }\n        let inputMessages = this._getInputMessages(inputs);\n        // If historic messages were prepended to the input messages, remove them to\n        // avoid adding duplicate messages to history.\n        if (this.historyMessagesKey === undefined) {\n            const existingMessages = await history.getMessages();\n            inputMessages = inputMessages.slice(existingMessages.length);\n        }\n        // Get output messages\n        const outputValue = run.outputs;\n        if (!outputValue) {\n            throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n        }\n        const outputMessages = this._getOutputMessages(outputValue);\n        await history.addMessages([...inputMessages, ...outputMessages]);\n    }\n    async _mergeConfig(...configs) {\n        const config = await super._mergeConfig(...configs);\n        // Extract sessionId\n        if (!config.configurable || !config.configurable.sessionId) {\n            const exampleInput = {\n                [this.inputMessagesKey ?? \"input\"]: \"foo\",\n            };\n            const exampleConfig = { configurable: { sessionId: \"123\" } };\n            throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n                `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n        }\n        // attach messageHistory\n        const { sessionId } = config.configurable;\n        config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n        return config;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2hpc3RvcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErRTtBQUNsQjtBQUNOO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUMscURBQWU7QUFDL0Q7QUFDQSwyQkFBMkIsb0RBQWMsaUVBQWlFLGdCQUFnQix3QkFBd0I7QUFDbEo7QUFDQTtBQUNBLDJCQUEyQixnRUFBbUI7QUFDOUM7QUFDQSxhQUFhLGVBQWUsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxTQUFTO0FBQ1QsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpRUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsMENBQTBDO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseURBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUVBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLDJDQUEyQztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsNkJBQTZCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0Esb0NBQW9DLDZCQUE2QixJQUFJLDhCQUE4QjtBQUNuRztBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccnVubmFibGVzXFxoaXN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFJTWVzc2FnZSwgSHVtYW5NZXNzYWdlLCBpc0Jhc2VNZXNzYWdlLCB9IGZyb20gXCIuLi9tZXNzYWdlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUnVubmFibGVCaW5kaW5nLCBSdW5uYWJsZUxhbWJkYSwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBSdW5uYWJsZVBhc3N0aHJvdWdoIH0gZnJvbSBcIi4vcGFzc3Rocm91Z2guanNcIjtcbi8qKlxuICogV3JhcHMgYSBMQ0VMIGNoYWluIGFuZCBtYW5hZ2VzIGhpc3RvcnkuIEl0IGFwcGVuZHMgaW5wdXQgbWVzc2FnZXNcbiAqIGFuZCBjaGFpbiBvdXRwdXRzIGFzIGhpc3RvcnksIGFuZCBhZGRzIHRoZSBjdXJyZW50IGhpc3RvcnkgbWVzc2FnZXMgdG9cbiAqIHRoZSBjaGFpbiBpbnB1dC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyB5YXJuIGFkZCBAbGFuZ2NoYWluL2FudGhyb3BpYyBAbGFuZ2NoYWluL2NvbW11bml0eSBAdXBzdGFzaC9yZWRpc1xuICpcbiAqIGltcG9ydCB7XG4gKiAgIENoYXRQcm9tcHRUZW1wbGF0ZSxcbiAqICAgTWVzc2FnZXNQbGFjZWhvbGRlcixcbiAqIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9wcm9tcHRzXCI7XG4gKiBpbXBvcnQgeyBDaGF0QW50aHJvcGljIH0gZnJvbSBcIkBsYW5nY2hhaW4vYW50aHJvcGljXCI7XG4gKiBpbXBvcnQgeyBVcHN0YXNoUmVkaXNDaGF0TWVzc2FnZUhpc3RvcnkgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb21tdW5pdHkvc3RvcmVzL21lc3NhZ2UvdXBzdGFzaF9yZWRpc1wiO1xuICogLy8gRm9yIGRlbW9zLCB5b3UgY2FuIGFsc28gdXNlIGFuIGluLW1lbW9yeSBzdG9yZTpcbiAqIC8vIGltcG9ydCB7IENoYXRNZXNzYWdlSGlzdG9yeSB9IGZyb20gXCJsYW5nY2hhaW4vc3RvcmVzL21lc3NhZ2UvaW5fbWVtb3J5XCI7XG4gKlxuICogY29uc3QgcHJvbXB0ID0gQ2hhdFByb21wdFRlbXBsYXRlLmZyb21NZXNzYWdlcyhbXG4gKiAgIFtcInN5c3RlbVwiLCBcIllvdSdyZSBhbiBhc3Npc3RhbnQgd2hvJ3MgZ29vZCBhdCB7YWJpbGl0eX1cIl0sXG4gKiAgIG5ldyBNZXNzYWdlc1BsYWNlaG9sZGVyKFwiaGlzdG9yeVwiKSxcbiAqICAgW1wiaHVtYW5cIiwgXCJ7cXVlc3Rpb259XCJdLFxuICogXSk7XG4gKlxuICogY29uc3QgY2hhaW4gPSBwcm9tcHQucGlwZShuZXcgQ2hhdEFudGhyb3BpYyh7fSkpO1xuICpcbiAqIGNvbnN0IGNoYWluV2l0aEhpc3RvcnkgPSBuZXcgUnVubmFibGVXaXRoTWVzc2FnZUhpc3Rvcnkoe1xuICogICBydW5uYWJsZTogY2hhaW4sXG4gKiAgIGdldE1lc3NhZ2VIaXN0b3J5OiAoc2Vzc2lvbklkKSA9PlxuICogICAgIG5ldyBVcHN0YXNoUmVkaXNDaGF0TWVzc2FnZUhpc3Rvcnkoe1xuICogICAgICAgc2Vzc2lvbklkLFxuICogICAgICAgY29uZmlnOiB7XG4gKiAgICAgICAgIHVybDogcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1VSTCEsXG4gKiAgICAgICAgIHRva2VuOiBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVE9LRU4hLFxuICogICAgICAgfSxcbiAqICAgICB9KSxcbiAqICAgaW5wdXRNZXNzYWdlc0tleTogXCJxdWVzdGlvblwiLFxuICogICBoaXN0b3J5TWVzc2FnZXNLZXk6IFwiaGlzdG9yeVwiLFxuICogfSk7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW5XaXRoSGlzdG9yeS5pbnZva2UoXG4gKiAgIHtcbiAqICAgICBhYmlsaXR5OiBcIm1hdGhcIixcbiAqICAgICBxdWVzdGlvbjogXCJXaGF0IGRvZXMgY29zaW5lIG1lYW4/XCIsXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBjb25maWd1cmFibGU6IHtcbiAqICAgICAgIHNlc3Npb25JZDogXCJzb21lX3N0cmluZ19pZGVudGlmeWluZ19hX3VzZXJcIixcbiAqICAgICB9LFxuICogICB9XG4gKiApO1xuICpcbiAqIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBjaGFpbldpdGhIaXN0b3J5Lmludm9rZShcbiAqICAge1xuICogICAgIGFiaWxpdHk6IFwibWF0aFwiLFxuICogICAgIHF1ZXN0aW9uOiBcIldoYXQncyBpdHMgaW52ZXJzZT9cIixcbiAqICAgfSxcbiAqICAge1xuICogICAgIGNvbmZpZ3VyYWJsZToge1xuICogICAgICAgc2Vzc2lvbklkOiBcInNvbWVfc3RyaW5nX2lkZW50aWZ5aW5nX2FfdXNlclwiLFxuICogICAgIH0sXG4gKiAgIH1cbiAqICk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5IGV4dGVuZHMgUnVubmFibGVCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgbGV0IGhpc3RvcnlDaGFpbiA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oKGlucHV0LCBvcHRpb25zKSA9PiB0aGlzLl9lbnRlckhpc3RvcnkoaW5wdXQsIG9wdGlvbnMgPz8ge30pKS53aXRoQ29uZmlnKHsgcnVuTmFtZTogXCJsb2FkSGlzdG9yeVwiIH0pO1xuICAgICAgICBjb25zdCBtZXNzYWdlc0tleSA9IGZpZWxkcy5oaXN0b3J5TWVzc2FnZXNLZXkgPz8gZmllbGRzLmlucHV0TWVzc2FnZXNLZXk7XG4gICAgICAgIGlmIChtZXNzYWdlc0tleSkge1xuICAgICAgICAgICAgaGlzdG9yeUNoYWluID0gUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIFttZXNzYWdlc0tleV06IGhpc3RvcnlDaGFpbixcbiAgICAgICAgICAgIH0pLndpdGhDb25maWcoeyBydW5OYW1lOiBcImluc2VydEhpc3RvcnlcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib3VuZCA9IGhpc3RvcnlDaGFpblxuICAgICAgICAgICAgLnBpcGUoZmllbGRzLnJ1bm5hYmxlLndpdGhMaXN0ZW5lcnMoe1xuICAgICAgICAgICAgb25FbmQ6IChydW4sIGNvbmZpZykgPT4gdGhpcy5fZXhpdEhpc3RvcnkocnVuLCBjb25maWcgPz8ge30pLFxuICAgICAgICB9KSlcbiAgICAgICAgICAgIC53aXRoQ29uZmlnKHsgcnVuTmFtZTogXCJSdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeVwiIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSBmaWVsZHMuY29uZmlnID8/IHt9O1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBib3VuZCxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bm5hYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0TWVzc2FnZXNLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3V0cHV0TWVzc2FnZXNLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlzdG9yeU1lc3NhZ2VzS2V5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldE1lc3NhZ2VIaXN0b3J5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucnVubmFibGUgPSBmaWVsZHMucnVubmFibGU7XG4gICAgICAgIHRoaXMuZ2V0TWVzc2FnZUhpc3RvcnkgPSBmaWVsZHMuZ2V0TWVzc2FnZUhpc3Rvcnk7XG4gICAgICAgIHRoaXMuaW5wdXRNZXNzYWdlc0tleSA9IGZpZWxkcy5pbnB1dE1lc3NhZ2VzS2V5O1xuICAgICAgICB0aGlzLm91dHB1dE1lc3NhZ2VzS2V5ID0gZmllbGRzLm91dHB1dE1lc3NhZ2VzS2V5O1xuICAgICAgICB0aGlzLmhpc3RvcnlNZXNzYWdlc0tleSA9IGZpZWxkcy5oaXN0b3J5TWVzc2FnZXNLZXk7XG4gICAgfVxuICAgIF9nZXRJbnB1dE1lc3NhZ2VzKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaW5wdXRWYWx1ZSkge1xuICAgICAgICBsZXQgcGFyc2VkSW5wdXRWYWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dFZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSAmJlxuICAgICAgICAgICAgIWlzQmFzZU1lc3NhZ2UoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dE1lc3NhZ2VzS2V5KSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5pbnB1dE1lc3NhZ2VzS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmtleXMoaW5wdXRWYWx1ZSkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gT2JqZWN0LmtleXMoaW5wdXRWYWx1ZSlbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBcImlucHV0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlW2tleV0pICYmIEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZVtrZXldWzBdKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZElucHV0VmFsdWUgPSBpbnB1dFZhbHVlW2tleV1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFZhbHVlID0gaW5wdXRWYWx1ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkSW5wdXRWYWx1ZSA9IGlucHV0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRJbnB1dFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBIdW1hbk1lc3NhZ2UocGFyc2VkSW5wdXRWYWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkSW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRJbnB1dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmFzZU1lc3NhZ2UocGFyc2VkSW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbcGFyc2VkSW5wdXRWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nLCBCYXNlTWVzc2FnZSwgb3IgYXJyYXkgb2YgQmFzZU1lc3NhZ2VzLlxcbkdvdCAke0pTT04uc3RyaW5naWZ5KHBhcnNlZElucHV0VmFsdWUsIG51bGwsIDIpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRPdXRwdXRNZXNzYWdlcyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG91dHB1dFZhbHVlKSB7XG4gICAgICAgIGxldCBwYXJzZWRPdXRwdXRWYWx1ZTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG91dHB1dFZhbHVlKSAmJlxuICAgICAgICAgICAgIWlzQmFzZU1lc3NhZ2Uob3V0cHV0VmFsdWUpICYmXG4gICAgICAgICAgICB0eXBlb2Ygb3V0cHV0VmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRNZXNzYWdlc0tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5vdXRwdXRNZXNzYWdlc0tleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5rZXlzKG91dHB1dFZhbHVlKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBPYmplY3Qua2V5cyhvdXRwdXRWYWx1ZSlbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBcIm91dHB1dFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgeW91IGFyZSB3cmFwcGluZyBhIGNoYXQgbW9kZWwgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIFRoZSBvdXRwdXQgaXMgYWN0dWFsbHkgdGhpcyB3ZWlyZCBnZW5lcmF0aW9ucyBvYmplY3RcbiAgICAgICAgICAgIGlmIChvdXRwdXRWYWx1ZS5nZW5lcmF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkT3V0cHV0VmFsdWUgPSBvdXRwdXRWYWx1ZS5nZW5lcmF0aW9uc1swXVswXS5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkT3V0cHV0VmFsdWUgPSBvdXRwdXRWYWx1ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkT3V0cHV0VmFsdWUgPSBvdXRwdXRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZE91dHB1dFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBBSU1lc3NhZ2UocGFyc2VkT3V0cHV0VmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZE91dHB1dFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZE91dHB1dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmFzZU1lc3NhZ2UocGFyc2VkT3V0cHV0VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3BhcnNlZE91dHB1dFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcsIEJhc2VNZXNzYWdlLCBvciBhcnJheSBvZiBCYXNlTWVzc2FnZXMuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHBhcnNlZE91dHB1dFZhbHVlLCBudWxsLCAyKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZW50ZXJIaXN0b3J5KFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaW5wdXQsIGt3YXJncykge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0ga3dhcmdzPy5jb25maWd1cmFibGU/Lm1lc3NhZ2VIaXN0b3J5O1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IGhpc3RvcnkuZ2V0TWVzc2FnZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeU1lc3NhZ2VzS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlcy5jb25jYXQodGhpcy5fZ2V0SW5wdXRNZXNzYWdlcyhpbnB1dCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9XG4gICAgYXN5bmMgX2V4aXRIaXN0b3J5KHJ1biwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSBjb25maWcuY29uZmlndXJhYmxlPy5tZXNzYWdlSGlzdG9yeTtcbiAgICAgICAgLy8gR2V0IGlucHV0IG1lc3NhZ2VzXG4gICAgICAgIGxldCBpbnB1dHM7XG4gICAgICAgIC8vIENoYXQgbW9kZWwgaW5wdXRzIGFyZSBuZXN0ZWQgYXJyYXlzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bi5pbnB1dHMpICYmIEFycmF5LmlzQXJyYXkocnVuLmlucHV0c1swXSkpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IHJ1bi5pbnB1dHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBydW4uaW5wdXRzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnB1dE1lc3NhZ2VzID0gdGhpcy5fZ2V0SW5wdXRNZXNzYWdlcyhpbnB1dHMpO1xuICAgICAgICAvLyBJZiBoaXN0b3JpYyBtZXNzYWdlcyB3ZXJlIHByZXBlbmRlZCB0byB0aGUgaW5wdXQgbWVzc2FnZXMsIHJlbW92ZSB0aGVtIHRvXG4gICAgICAgIC8vIGF2b2lkIGFkZGluZyBkdXBsaWNhdGUgbWVzc2FnZXMgdG8gaGlzdG9yeS5cbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeU1lc3NhZ2VzS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWVzc2FnZXMgPSBhd2FpdCBoaXN0b3J5LmdldE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICBpbnB1dE1lc3NhZ2VzID0gaW5wdXRNZXNzYWdlcy5zbGljZShleGlzdGluZ01lc3NhZ2VzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IG91dHB1dCBtZXNzYWdlc1xuICAgICAgICBjb25zdCBvdXRwdXRWYWx1ZSA9IHJ1bi5vdXRwdXRzO1xuICAgICAgICBpZiAoIW91dHB1dFZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCB2YWx1ZXMgZnJvbSAnUnVuJyB1bmRlZmluZWQuIFJ1bjogJHtKU09OLnN0cmluZ2lmeShydW4sIG51bGwsIDIpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dE1lc3NhZ2VzID0gdGhpcy5fZ2V0T3V0cHV0TWVzc2FnZXMob3V0cHV0VmFsdWUpO1xuICAgICAgICBhd2FpdCBoaXN0b3J5LmFkZE1lc3NhZ2VzKFsuLi5pbnB1dE1lc3NhZ2VzLCAuLi5vdXRwdXRNZXNzYWdlc10pO1xuICAgIH1cbiAgICBhc3luYyBfbWVyZ2VDb25maWcoLi4uY29uZmlncykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBhd2FpdCBzdXBlci5fbWVyZ2VDb25maWcoLi4uY29uZmlncyk7XG4gICAgICAgIC8vIEV4dHJhY3Qgc2Vzc2lvbklkXG4gICAgICAgIGlmICghY29uZmlnLmNvbmZpZ3VyYWJsZSB8fCAhY29uZmlnLmNvbmZpZ3VyYWJsZS5zZXNzaW9uSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVJbnB1dCA9IHtcbiAgICAgICAgICAgICAgICBbdGhpcy5pbnB1dE1lc3NhZ2VzS2V5ID8/IFwiaW5wdXRcIl06IFwiZm9vXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUNvbmZpZyA9IHsgY29uZmlndXJhYmxlOiB7IHNlc3Npb25JZDogXCIxMjNcIiB9IH07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNlc3Npb25JZCBpcyByZXF1aXJlZC4gUGFzcyBpdCBpbiBhcyBwYXJ0IG9mIHRoZSBjb25maWcgYXJndW1lbnQgdG8gLmludm9rZSgpIG9yIC5zdHJlYW0oKVxcbmAgK1xuICAgICAgICAgICAgICAgIGBlZy4gY2hhaW4uaW52b2tlKCR7SlNPTi5zdHJpbmdpZnkoZXhhbXBsZUlucHV0KX0sICR7SlNPTi5zdHJpbmdpZnkoZXhhbXBsZUNvbmZpZyl9KWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGFjaCBtZXNzYWdlSGlzdG9yeVxuICAgICAgICBjb25zdCB7IHNlc3Npb25JZCB9ID0gY29uZmlnLmNvbmZpZ3VyYWJsZTtcbiAgICAgICAgY29uZmlnLmNvbmZpZ3VyYWJsZS5tZXNzYWdlSGlzdG9yeSA9IGF3YWl0IHRoaXMuZ2V0TWVzc2FnZUhpc3Rvcnkoc2Vzc2lvbklkKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/history.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RouterRunnable: () => (/* reexport safe */ _router_js__WEBPACK_IMPORTED_MODULE_3__.RouterRunnable),\n/* harmony export */   Runnable: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.Runnable),\n/* harmony export */   RunnableAssign: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableAssign),\n/* harmony export */   RunnableBinding: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableBinding),\n/* harmony export */   RunnableBranch: () => (/* reexport safe */ _branch_js__WEBPACK_IMPORTED_MODULE_4__.RunnableBranch),\n/* harmony export */   RunnableEach: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableEach),\n/* harmony export */   RunnableLambda: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableLambda),\n/* harmony export */   RunnableMap: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableMap),\n/* harmony export */   RunnableParallel: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableParallel),\n/* harmony export */   RunnablePassthrough: () => (/* reexport safe */ _passthrough_js__WEBPACK_IMPORTED_MODULE_2__.RunnablePassthrough),\n/* harmony export */   RunnablePick: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnablePick),\n/* harmony export */   RunnableRetry: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableRetry),\n/* harmony export */   RunnableSequence: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableSequence),\n/* harmony export */   RunnableToolLike: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableToolLike),\n/* harmony export */   RunnableWithFallbacks: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.RunnableWithFallbacks),\n/* harmony export */   RunnableWithMessageHistory: () => (/* reexport safe */ _history_js__WEBPACK_IMPORTED_MODULE_5__.RunnableWithMessageHistory),\n/* harmony export */   _coerceToRunnable: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable),\n/* harmony export */   ensureConfig: () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_1__.ensureConfig),\n/* harmony export */   getCallbackManagerForConfig: () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_1__.getCallbackManagerForConfig),\n/* harmony export */   mergeConfigs: () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_1__.mergeConfigs),\n/* harmony export */   patchConfig: () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_1__.patchConfig),\n/* harmony export */   pickRunnableConfigKeys: () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_1__.pickRunnableConfigKeys)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.js\");\n/* harmony import */ var _passthrough_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./passthrough.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.js\");\n/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./router.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/router.js\");\n/* harmony import */ var _branch_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./branch.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/branch.js\");\n/* harmony import */ var _history_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./history.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/history.js\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK087QUFDbkg7QUFDckU7QUFDVjtBQUNBO0FBQ2MiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccnVubmFibGVzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBSdW5uYWJsZSwgUnVubmFibGVCaW5kaW5nLCBSdW5uYWJsZUVhY2gsIFJ1bm5hYmxlUmV0cnksIFJ1bm5hYmxlU2VxdWVuY2UsIFJ1bm5hYmxlTWFwLCBSdW5uYWJsZVBhcmFsbGVsLCBSdW5uYWJsZUxhbWJkYSwgUnVubmFibGVXaXRoRmFsbGJhY2tzLCBSdW5uYWJsZUFzc2lnbiwgUnVubmFibGVQaWNrLCBfY29lcmNlVG9SdW5uYWJsZSwgUnVubmFibGVUb29sTGlrZSwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgeyBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcsIHBhdGNoQ29uZmlnLCBlbnN1cmVDb25maWcsIG1lcmdlQ29uZmlncywgcGlja1J1bm5hYmxlQ29uZmlnS2V5cywgfSBmcm9tIFwiLi9jb25maWcuanNcIjtcbmV4cG9ydCB7IFJ1bm5hYmxlUGFzc3Rocm91Z2ggfSBmcm9tIFwiLi9wYXNzdGhyb3VnaC5qc1wiO1xuZXhwb3J0IHsgUm91dGVyUnVubmFibGUgfSBmcm9tIFwiLi9yb3V0ZXIuanNcIjtcbmV4cG9ydCB7IFJ1bm5hYmxlQnJhbmNoIH0gZnJvbSBcIi4vYnJhbmNoLmpzXCI7XG5leHBvcnQgeyBSdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeSwgfSBmcm9tIFwiLi9oaXN0b3J5LmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/iter.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/iter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   consumeAsyncIterableInContext: () => (/* binding */ consumeAsyncIterableInContext),\n/* harmony export */   consumeIteratorInContext: () => (/* binding */ consumeIteratorInContext),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isIterableIterator: () => (/* binding */ isIterableIterator),\n/* harmony export */   isIterator: () => (/* binding */ isIterator)\n/* harmony export */ });\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.js\");\n\n\nfunction isIterableIterator(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.iterator] === \"function\" &&\n        // avoid detecting array/set as iterator\n        typeof thing.next === \"function\");\n}\nconst isIterator = (x) => x != null &&\n    typeof x === \"object\" &&\n    \"next\" in x &&\n    typeof x.next === \"function\";\nfunction isAsyncIterable(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.asyncIterator] ===\n            \"function\");\n}\nfunction* consumeIteratorInContext(context, iter) {\n    while (true) {\n        const { value, done } = _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.runWithConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_1__.pickRunnableConfigKeys)(context), iter.next.bind(iter), true);\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\nasync function* consumeAsyncIterableInContext(context, iter) {\n    const iterator = iter[Symbol.asyncIterator]();\n    while (true) {\n        const { value, done } = await _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.runWithConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_1__.pickRunnableConfigKeys)(context), iterator.next.bind(iter), true);\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2l0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE0RTtBQUN2QjtBQUM5QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQixjQUFjLEVBQUUsb0ZBQWtDLGVBQWUsa0VBQXNCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYyxRQUFRLG9GQUFrQyxlQUFlLGtFQUFzQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHJ1bm5hYmxlc1xcaXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIH0gZnJvbSBcIi4uL3NpbmdsZXRvbnMvaW5kZXguanNcIjtcbmltcG9ydCB7IHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMgfSBmcm9tIFwiLi9jb25maWcuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc0l0ZXJhYmxlSXRlcmF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB0aGluZyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0aGluZyAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdGhpbmdbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIC8vIGF2b2lkIGRldGVjdGluZyBhcnJheS9zZXQgYXMgaXRlcmF0b3JcbiAgICAgICAgdHlwZW9mIHRoaW5nLm5leHQgPT09IFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnQgY29uc3QgaXNJdGVyYXRvciA9ICh4KSA9PiB4ICE9IG51bGwgJiZcbiAgICB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgIFwibmV4dFwiIGluIHggJiZcbiAgICB0eXBlb2YgeC5uZXh0ID09PSBcImZ1bmN0aW9uXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHRoaW5nKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdGhpbmcgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHRoaW5nW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT1cbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnQgZnVuY3Rpb24qIGNvbnN1bWVJdGVyYXRvckluQ29udGV4dChjb250ZXh0LCBpdGVyKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMoY29udGV4dCksIGl0ZXIubmV4dC5iaW5kKGl0ZXIpLCB0cnVlKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0KGNvbnRleHQsIGl0ZXIpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IGl0ZXJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMoY29udGV4dCksIGl0ZXJhdG9yLm5leHQuYmluZChpdGVyKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/iter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/passthrough.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunnablePassthrough: () => (/* binding */ RunnablePassthrough)\n/* harmony export */ });\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.js\");\n\n\n\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass RunnablePassthrough extends _base_js__WEBPACK_IMPORTED_MODULE_1__.Runnable {\n    static lc_name() {\n        return \"RunnablePassthrough\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (fields) {\n            this.func = fields.func;\n        }\n    }\n    async invoke(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_2__.ensureConfig)(options);\n        if (this.func) {\n            await this.func(input, config);\n        }\n        return this._callWithConfig((input) => Promise.resolve(input), input, config);\n    }\n    async *transform(generator, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_2__.ensureConfig)(options);\n        let finalOutput;\n        let finalOutputSupported = true;\n        for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config)) {\n            yield chunk;\n            if (finalOutputSupported) {\n                if (finalOutput === undefined) {\n                    finalOutput = chunk;\n                }\n                else {\n                    try {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.concat)(finalOutput, chunk);\n                    }\n                    catch {\n                        finalOutput = undefined;\n                        finalOutputSupported = false;\n                    }\n                }\n            }\n        }\n        if (this.func && finalOutput !== undefined) {\n            await this.func(finalOutput, config);\n        }\n    }\n    /**\n     * A runnable that assigns key-value pairs to the input.\n     *\n     * The example below shows how you could use it with an inline function.\n     *\n     * @example\n     * ```typescript\n     * const prompt =\n     *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n     * Question: {question}\n     * SQL Query:`);\n     *\n     * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n     * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n     * // In this case, we're passing the schema.\n     * const sqlQueryGeneratorChain = RunnableSequence.from([\n     *   RunnablePassthrough.assign({\n     *     schema: async () => db.getTableInfo(),\n     *   }),\n     *   prompt,\n     *   new ChatOpenAI({ model: \"gpt-4o-mini\" }).withConfig({ stop: [\"\\nSQLResult:\"] }),\n     *   new StringOutputParser(),\n     * ]);\n     * const result = await sqlQueryGeneratorChain.invoke({\n     *   question: \"How many employees are there?\",\n     * });\n     * ```\n     */\n    static assign(mapping) {\n        return new _base_js__WEBPACK_IMPORTED_MODULE_1__.RunnableAssign(new _base_js__WEBPACK_IMPORTED_MODULE_1__.RunnableMap({ steps: mapping }));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3Bhc3N0aHJvdWdoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEM7QUFDdUI7QUFDeEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsOENBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0RBQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBCQUEwQixzQkFBc0IsZUFBZSx3QkFBd0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFjLEtBQUssaURBQVcsR0FBRyxnQkFBZ0I7QUFDcEU7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxydW5uYWJsZXNcXHBhc3N0aHJvdWdoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbmNhdCB9IGZyb20gXCIuLi91dGlscy9zdHJlYW0uanNcIjtcbmltcG9ydCB7IFJ1bm5hYmxlLCBSdW5uYWJsZUFzc2lnbiwgUnVubmFibGVNYXAsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgZW5zdXJlQ29uZmlnIH0gZnJvbSBcIi4vY29uZmlnLmpzXCI7XG4vKipcbiAqIEEgcnVubmFibGUgdG8gcGFzc3Rocm91Z2ggaW5wdXRzIHVuY2hhbmdlZCBvciB3aXRoIGFkZGl0aW9uYWwga2V5cy5cbiAqXG4gKiBUaGlzIHJ1bm5hYmxlIGJlaGF2ZXMgYWxtb3N0IGxpa2UgdGhlIGlkZW50aXR5IGZ1bmN0aW9uLCBleGNlcHQgdGhhdCBpdFxuICogY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYWRkIGFkZGl0aW9uYWwga2V5cyB0byB0aGUgb3V0cHV0LCBpZiB0aGUgaW5wdXQgaXNcbiAqIGFuIG9iamVjdC5cbiAqXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIHVzZSBgUnVubmFibGVQYXNzdGhyb3VnaCB0b1xuICogcGFzc3Rocm91Z2ggdGhlIGlucHV0IGZyb20gdGhlIGAuaW52b2tlKClgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGNoYWluID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAqICAge1xuICogICAgIHF1ZXN0aW9uOiBuZXcgUnVubmFibGVQYXNzdGhyb3VnaCgpLFxuICogICAgIGNvbnRleHQ6IGFzeW5jICgpID0+IGxvYWRDb250ZXh0RnJvbVN0b3JlKCksXG4gKiAgIH0sXG4gKiAgIHByb21wdCxcbiAqICAgbGxtLFxuICogICBvdXRwdXRQYXJzZXIsXG4gKiBdKTtcbiAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhaW4uaW52b2tlKFxuICogICBcIkkgY2FuIHBhc3MgYSBzaW5nbGUgc3RyaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHNpbmNlIEknbSB1c2luZyBgUnVubmFibGVQYXNzdGhyb3VnaGAuXCJcbiAqICk7XG4gKiBgYGBcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVBhc3N0aHJvdWdoIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVBhc3N0aHJvdWdoXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgdGhpcy5mdW5jID0gZmllbGRzLmZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuZnVuYykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mdW5jKGlucHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZygoaW5wdXQpID0+IFByb21pc2UucmVzb2x2ZShpbnB1dCksIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgICBhc3luYyAqdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgKGlucHV0KSA9PiBpbnB1dCwgY29uZmlnKSkge1xuICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICBpZiAoZmluYWxPdXRwdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNvbmNhdChmaW5hbE91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mdW5jICYmIGZpbmFsT3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZnVuYyhmaW5hbE91dHB1dCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJ1bm5hYmxlIHRoYXQgYXNzaWducyBrZXktdmFsdWUgcGFpcnMgdG8gdGhlIGlucHV0LlxuICAgICAqXG4gICAgICogVGhlIGV4YW1wbGUgYmVsb3cgc2hvd3MgaG93IHlvdSBjb3VsZCB1c2UgaXQgd2l0aCBhbiBpbmxpbmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwcm9tcHQgPVxuICAgICAqICAgUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKGBXcml0ZSBhIFNRTCBxdWVyeSB0byBhbnN3ZXIgdGhlIHF1ZXN0aW9uIHVzaW5nIHRoZSBmb2xsb3dpbmcgc2NoZW1hOiB7c2NoZW1hfVxuICAgICAqIFF1ZXN0aW9uOiB7cXVlc3Rpb259XG4gICAgICogU1FMIFF1ZXJ5OmApO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBSdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbigpYCBpcyB1c2VkIGhlcmUgdG8gcGFzc3Rocm91Z2ggdGhlIGlucHV0IGZyb20gdGhlIGAuaW52b2tlKClgXG4gICAgICogLy8gY2FsbCAoaW4gdGhpcyBleGFtcGxlIGl0J3MgdGhlIHF1ZXN0aW9uKSwgYWxvbmcgd2l0aCBhbnkgaW5wdXRzIHBhc3NlZCB0byB0aGUgYC5hc3NpZ24oKWAgbWV0aG9kLlxuICAgICAqIC8vIEluIHRoaXMgY2FzZSwgd2UncmUgcGFzc2luZyB0aGUgc2NoZW1hLlxuICAgICAqIGNvbnN0IHNxbFF1ZXJ5R2VuZXJhdG9yQ2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICAgICAqICAgUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAqICAgICBzY2hlbWE6IGFzeW5jICgpID0+IGRiLmdldFRhYmxlSW5mbygpLFxuICAgICAqICAgfSksXG4gICAgICogICBwcm9tcHQsXG4gICAgICogICBuZXcgQ2hhdE9wZW5BSSh7IG1vZGVsOiBcImdwdC00by1taW5pXCIgfSkud2l0aENvbmZpZyh7IHN0b3A6IFtcIlxcblNRTFJlc3VsdDpcIl0gfSksXG4gICAgICogICBuZXcgU3RyaW5nT3V0cHV0UGFyc2VyKCksXG4gICAgICogXSk7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsUXVlcnlHZW5lcmF0b3JDaGFpbi5pbnZva2Uoe1xuICAgICAqICAgcXVlc3Rpb246IFwiSG93IG1hbnkgZW1wbG95ZWVzIGFyZSB0aGVyZT9cIixcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYXNzaWduKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUFzc2lnbihuZXcgUnVubmFibGVNYXAoeyBzdGVwczogbWFwcGluZyB9KSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/router.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/router.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RouterRunnable: () => (/* binding */ RouterRunnable)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.js\");\n\n\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nclass RouterRunnable extends _base_js__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    static lc_name() {\n        return \"RouterRunnable\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnables = fields.runnables;\n    }\n    async invoke(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.invoke(actualInput, (0,_config_js__WEBPACK_IMPORTED_MODULE_1__.ensureConfig)(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const keys = inputs.map((input) => input.key);\n        const actualInputs = inputs.map((input) => input.input);\n        const missingKey = keys.find((key) => this.runnables[key] === undefined);\n        if (missingKey !== undefined) {\n            throw new Error(`One or more keys do not have a corresponding runnable.`);\n        }\n        const runnables = keys.map((key) => this.runnables[key]);\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < actualInputs.length; i += batchSize) {\n            const batchPromises = actualInputs\n                .slice(i, i + batchSize)\n                .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    async stream(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.stream(actualInput, options);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3JvdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUM7QUFDTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQSxtQ0FBbUMsMENBQTBDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBDQUEwQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2Qiw4Q0FBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0EsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQSw0Q0FBNEMsd0RBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0EsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccnVubmFibGVzXFxyb3V0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUnVubmFibGUgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBlbnN1cmVDb25maWcgfSBmcm9tIFwiLi9jb25maWcuanNcIjtcbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IHJvdXRlcyB0byBhIHNldCBvZiBydW5uYWJsZXMgYmFzZWQgb24gSW5wdXRbJ2tleSddLlxuICogUmV0dXJucyB0aGUgb3V0cHV0IG9mIHRoZSBzZWxlY3RlZCBydW5uYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBSb3V0ZXJSdW5uYWJsZSwgUnVubmFibGVMYW1iZGEgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IHJvdXRlciA9IG5ldyBSb3V0ZXJSdW5uYWJsZSh7XG4gKiAgIHJ1bm5hYmxlczoge1xuICogICAgIHRvVXBwZXJDYXNlOiBSdW5uYWJsZUxhbWJkYS5mcm9tKCh0ZXh0OiBzdHJpbmcpID0+IHRleHQudG9VcHBlckNhc2UoKSksXG4gKiAgICAgcmV2ZXJzZVRleHQ6IFJ1bm5hYmxlTGFtYmRhLmZyb20oKHRleHQ6IHN0cmluZykgPT5cbiAqICAgICAgIHRleHQuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIilcbiAqICAgICApLFxuICogICB9LFxuICogfSk7XG4gKlxuICogLy8gSW52b2tlIHRoZSAncmV2ZXJzZVRleHQnIHJ1bm5hYmxlXG4gKiBjb25zdCByZXN1bHQxID0gcm91dGVyLmludm9rZSh7IGtleTogXCJyZXZlcnNlVGV4dFwiLCBpbnB1dDogXCJIZWxsbyBXb3JsZFwiIH0pO1xuICpcbiAqIC8vIFwiZGxyb1cgb2xsZUhcIlxuICpcbiAqIC8vIEludm9rZSB0aGUgJ3RvVXBwZXJDYXNlJyBydW5uYWJsZVxuICogY29uc3QgcmVzdWx0MiA9IHJvdXRlci5pbnZva2UoeyBrZXk6IFwidG9VcHBlckNhc2VcIiwgaW5wdXQ6IFwiSGVsbG8gV29ybGRcIiB9KTtcbiAqXG4gKiAvLyBcIkhFTExPIFdPUkxEXCJcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUm91dGVyUnVubmFibGUgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJvdXRlclJ1bm5hYmxlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bm5hYmxlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJ1bm5hYmxlcyA9IGZpZWxkcy5ydW5uYWJsZXM7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGtleSwgaW5wdXQ6IGFjdHVhbElucHV0IH0gPSBpbnB1dDtcbiAgICAgICAgY29uc3QgcnVubmFibGUgPSB0aGlzLnJ1bm5hYmxlc1trZXldO1xuICAgICAgICBpZiAocnVubmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW5uYWJsZSBhc3NvY2lhdGVkIHdpdGgga2V5IFwiJHtrZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bm5hYmxlLmludm9rZShhY3R1YWxJbnB1dCwgZW5zdXJlQ29uZmlnKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5rZXkpO1xuICAgICAgICBjb25zdCBhY3R1YWxJbnB1dHMgPSBpbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuaW5wdXQpO1xuICAgICAgICBjb25zdCBtaXNzaW5nS2V5ID0ga2V5cy5maW5kKChrZXkpID0+IHRoaXMucnVubmFibGVzW2tleV0gPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChtaXNzaW5nS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25lIG9yIG1vcmUga2V5cyBkbyBub3QgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgcnVubmFibGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVzID0ga2V5cy5tYXAoKGtleSkgPT4gdGhpcy5ydW5uYWJsZXNba2V5XSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1heENvbmN1cnJlbmN5ID0gb3B0aW9uc0xpc3RbMF0/Lm1heENvbmN1cnJlbmN5ID8/IGJhdGNoT3B0aW9ucz8ubWF4Q29uY3VycmVuY3k7XG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IG1heENvbmN1cnJlbmN5ICYmIG1heENvbmN1cnJlbmN5ID4gMCA/IG1heENvbmN1cnJlbmN5IDogaW5wdXRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0dWFsSW5wdXRzLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUHJvbWlzZXMgPSBhY3R1YWxJbnB1dHNcbiAgICAgICAgICAgICAgICAuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSlcbiAgICAgICAgICAgICAgICAubWFwKChhY3R1YWxJbnB1dCwgaSkgPT4gcnVubmFibGVzW2ldLmludm9rZShhY3R1YWxJbnB1dCwgb3B0aW9uc0xpc3RbaV0pKTtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2hQcm9taXNlcyk7XG4gICAgICAgICAgICBiYXRjaFJlc3VsdHMucHVzaChiYXRjaFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhdGNoUmVzdWx0cy5mbGF0KCk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGtleSwgaW5wdXQ6IGFjdHVhbElucHV0IH0gPSBpbnB1dDtcbiAgICAgICAgY29uc3QgcnVubmFibGUgPSB0aGlzLnJ1bm5hYmxlc1trZXldO1xuICAgICAgICBpZiAocnVubmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW5uYWJsZSBhc3NvY2lhdGVkIHdpdGgga2V5IFwiJHtrZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bm5hYmxlLnN0cmVhbShhY3R1YWxJbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/router.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _RootEventFilter: () => (/* binding */ _RootEventFilter),\n/* harmony export */   isRunnableInterface: () => (/* binding */ isRunnableInterface)\n/* harmony export */ });\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableInterface(thing) {\n    return thing ? thing.lc_runnable : false;\n}\n/**\n * Utility to filter the root event in the streamEvents implementation.\n * This is simply binding the arguments to the namespace to make save on\n * a bit of typing in the streamEvents implementation.\n *\n * TODO: Refactor and remove.\n */\nclass _RootEventFilter {\n    constructor(fields) {\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.includeNames = fields.includeNames;\n        this.includeTypes = fields.includeTypes;\n        this.includeTags = fields.includeTags;\n        this.excludeNames = fields.excludeNames;\n        this.excludeTypes = fields.excludeTypes;\n        this.excludeTags = fields.excludeTags;\n    }\n    includeEvent(event, rootType) {\n        let include = this.includeNames === undefined &&\n            this.includeTypes === undefined &&\n            this.includeTags === undefined;\n        const eventTags = event.tags ?? [];\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(event.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(rootType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include || eventTags.some((tag) => this.includeTags?.includes(tag));\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(event.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(rootType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHJ1bm5hYmxlc1xcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiBpc1J1bm5hYmxlSW50ZXJmYWNlKHRoaW5nKSB7XG4gICAgcmV0dXJuIHRoaW5nID8gdGhpbmcubGNfcnVubmFibGUgOiBmYWxzZTtcbn1cbi8qKlxuICogVXRpbGl0eSB0byBmaWx0ZXIgdGhlIHJvb3QgZXZlbnQgaW4gdGhlIHN0cmVhbUV2ZW50cyBpbXBsZW1lbnRhdGlvbi5cbiAqIFRoaXMgaXMgc2ltcGx5IGJpbmRpbmcgdGhlIGFyZ3VtZW50cyB0byB0aGUgbmFtZXNwYWNlIHRvIG1ha2Ugc2F2ZSBvblxuICogYSBiaXQgb2YgdHlwaW5nIGluIHRoZSBzdHJlYW1FdmVudHMgaW1wbGVtZW50YXRpb24uXG4gKlxuICogVE9ETzogUmVmYWN0b3IgYW5kIHJlbW92ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIF9Sb290RXZlbnRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbmNsdWRlTmFtZXMgPSBmaWVsZHMuaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcy5pbmNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPSBmaWVsZHMuaW5jbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuZXhjbHVkZU5hbWVzID0gZmllbGRzLmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHMuZXhjbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUYWdzID0gZmllbGRzLmV4Y2x1ZGVUYWdzO1xuICAgIH1cbiAgICBpbmNsdWRlRXZlbnQoZXZlbnQsIHJvb3RUeXBlKSB7XG4gICAgICAgIGxldCBpbmNsdWRlID0gdGhpcy5pbmNsdWRlTmFtZXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBldmVudFRhZ3MgPSBldmVudC50YWdzID8/IFtdO1xuICAgICAgICBpZiAodGhpcy5pbmNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlTmFtZXMuaW5jbHVkZXMoZXZlbnQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZVR5cGVzLmluY2x1ZGVzKHJvb3RUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8IGV2ZW50VGFncy5zb21lKCh0YWcpID0+IHRoaXMuaW5jbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMoZXZlbnQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVUeXBlcy5pbmNsdWRlcyhyb290VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSAmJiBldmVudFRhZ3MuZXZlcnkoKHRhZykgPT4gIXRoaXMuZXhjbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/wrappers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToHttpEventStream: () => (/* binding */ convertToHttpEventStream)\n/* harmony export */ });\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.js\");\n\nfunction convertToHttpEventStream(stream) {\n    const encoder = new TextEncoder();\n    const finalStream = new ReadableStream({\n        async start(controller) {\n            for await (const chunk of stream) {\n                controller.enqueue(encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`));\n            }\n            controller.enqueue(encoder.encode(\"event: end\\n\\n\"));\n            controller.close();\n        },\n    });\n    return _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.IterableReadableStream.fromReadableStream(finalStream);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3dyYXBwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTREO0FBQ3JEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usc0JBQXNCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsV0FBVyxvRUFBc0I7QUFDakMiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccnVubmFibGVzXFx3cmFwcGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0h0dHBFdmVudFN0cmVhbShzdHJlYW0pIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZmluYWxTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShgZXZlbnQ6IGRhdGFcXG5kYXRhOiAke0pTT04uc3RyaW5naWZ5KGNodW5rKX1cXG5cXG5gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoXCJldmVudDogZW5kXFxuXFxuXCIpKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0oZmluYWxTdHJlYW0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/context.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/context.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getConfigureHooks: () => (/* binding */ _getConfigureHooks),\n/* harmony export */   getContextVariable: () => (/* binding */ getContextVariable),\n/* harmony export */   registerConfigureHook: () => (/* binding */ registerConfigureHook),\n/* harmony export */   setContextVariable: () => (/* binding */ setContextVariable)\n/* harmony export */ });\n/* harmony import */ var langsmith_run_trees__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith/run_trees */ \"(rsc)/./node_modules/langsmith/run_trees.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js\");\n\n\n/**\n * Set a context variable. Context variables are scoped to any\n * child runnables called by the current runnable, or globally if set outside\n * of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n * @param value The value to set.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setContextVariable(name, value) {\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)();\n    if (asyncLocalStorageInstance === undefined) {\n        throw new Error(`Internal error: Global shared async local storage instance has not been initialized.`);\n    }\n    const runTree = asyncLocalStorageInstance.getStore();\n    const contextVars = { ...runTree?.[_globals_js__WEBPACK_IMPORTED_MODULE_1__._CONTEXT_VARIABLES_KEY] };\n    contextVars[name] = value;\n    let newValue = {};\n    if ((0,langsmith_run_trees__WEBPACK_IMPORTED_MODULE_0__.isRunTree)(runTree)) {\n        newValue = new langsmith_run_trees__WEBPACK_IMPORTED_MODULE_0__.RunTree(runTree);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    newValue[_globals_js__WEBPACK_IMPORTED_MODULE_1__._CONTEXT_VARIABLES_KEY] = contextVars;\n    asyncLocalStorageInstance.enterWith(newValue);\n}\n/**\n * Get the value of a previously set context variable. Context variables\n * are scoped to any child runnables called by the current runnable,\n * or globally if set outside of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getContextVariable(name) {\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)();\n    if (asyncLocalStorageInstance === undefined) {\n        return undefined;\n    }\n    const runTree = asyncLocalStorageInstance.getStore();\n    return runTree?.[_globals_js__WEBPACK_IMPORTED_MODULE_1__._CONTEXT_VARIABLES_KEY]?.[name];\n}\nconst LC_CONFIGURE_HOOKS_KEY = Symbol(\"lc:configure_hooks\");\nconst _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];\n/**\n * Register a callback configure hook to automatically add callback handlers to all runs.\n *\n * There are two ways to use this:\n *\n * 1. Using a context variable:\n *    - Set `contextVar` to specify the variable name\n *    - Use `setContextVariable()` to store your handler instance\n *\n * 2. Using an environment variable:\n *    - Set both `envVar` and `handlerClass`\n *    - The handler will be instantiated when the env var is set to \"true\".\n *\n * @example\n * ```typescript\n * // Method 1: Using context variable\n * import {\n *   registerConfigureHook,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const tracer = new MyCallbackHandler();\n * registerConfigureHook({\n *   contextVar: \"my_tracer\",\n * });\n * setContextVariable(\"my_tracer\", tracer);\n *\n * // ...run code here\n *\n * // Method 2: Using environment variable\n * registerConfigureHook({\n *   handlerClass: MyCallbackHandler,\n *   envVar: \"MY_TRACER_ENABLED\",\n * });\n * process.env.MY_TRACER_ENABLED = \"true\";\n *\n * // ...run code here\n * ```\n *\n * @param config Configuration object for the hook\n * @param config.contextVar Name of the context variable containing the handler instance\n * @param config.inheritable Whether child runs should inherit this handler\n * @param config.handlerClass Optional callback handler class (required if using envVar)\n * @param config.envVar Optional environment variable name to control handler activation\n */\nconst registerConfigureHook = (config) => {\n    if (config.envVar && !config.handlerClass) {\n        throw new Error(\"If envVar is set, handlerClass must also be set to a non-None value.\");\n    }\n    setContextVariable(LC_CONFIGURE_HOOKS_KEY, [..._getConfigureHooks(), config]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9hc3luY19sb2NhbF9zdG9yYWdlL2NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlEO0FBQ2tDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNDQUFzQywrRUFBa0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYSwrREFBc0I7QUFDN0Q7QUFDQTtBQUNBLFFBQVEsOERBQVM7QUFDakIsdUJBQXVCLHdEQUFPO0FBQzlCO0FBQ0E7QUFDQSxhQUFhLCtEQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNDQUFzQywrRUFBa0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQXNCO0FBQzNDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxzaW5nbGV0b25zXFxhc3luY19sb2NhbF9zdG9yYWdlXFxjb250ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUnVuVHJlZSwgUnVuVHJlZSB9IGZyb20gXCJsYW5nc21pdGgvcnVuX3RyZWVzXCI7XG5pbXBvcnQgeyBfQ09OVEVYVF9WQVJJQUJMRVNfS0VZLCBnZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlLCB9IGZyb20gXCIuL2dsb2JhbHMuanNcIjtcbi8qKlxuICogU2V0IGEgY29udGV4dCB2YXJpYWJsZS4gQ29udGV4dCB2YXJpYWJsZXMgYXJlIHNjb3BlZCB0byBhbnlcbiAqIGNoaWxkIHJ1bm5hYmxlcyBjYWxsZWQgYnkgdGhlIGN1cnJlbnQgcnVubmFibGUsIG9yIGdsb2JhbGx5IGlmIHNldCBvdXRzaWRlXG4gKiBvZiBhbnkgcnVubmFibGUuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBBc3luY0xvY2FsU3RvcmFnZSxcbiAqIGluY2x1ZGluZyBOb2RlLmpzLCBEZW5vLCBhbmQgQ2xvdWRmbGFyZSBXb3JrZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUnVubmFibGVMYW1iZGEgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICogaW1wb3J0IHtcbiAqICAgZ2V0Q29udGV4dFZhcmlhYmxlLFxuICogICBzZXRDb250ZXh0VmFyaWFibGVcbiAqIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9jb250ZXh0XCI7XG4gKlxuICogY29uc3QgbmVzdGVkID0gUnVubmFibGVMYW1iZGEuZnJvbSgoKSA9PiB7XG4gKiAgIC8vIFwiYmFyXCIgYmVjYXVzZSBpdCB3YXMgc2V0IGJ5IGEgcGFyZW50XG4gKiAgIGNvbnNvbGUubG9nKGdldENvbnRleHRWYXJpYWJsZShcImZvb1wiKSk7XG4gKlxuICogICAvLyBPdmVycmlkZSB0byBcImJhelwiLCBidXQgb25seSBmb3IgY2hpbGQgcnVubmFibGVzXG4gKiAgIHNldENvbnRleHRWYXJpYWJsZShcImZvb1wiLCBcImJhelwiKTtcbiAqXG4gKiAgIC8vIE5vdyBcImJhelwiLCBidXQgb25seSBmb3IgY2hpbGQgcnVubmFibGVzXG4gKiAgIHJldHVybiBnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIik7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBydW5uYWJsZSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oYXN5bmMgKCkgPT4ge1xuICogICAvLyBTZXQgYSBjb250ZXh0IHZhcmlhYmxlIG5hbWVkIFwiZm9vXCJcbiAqICAgc2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIsIFwiYmFyXCIpO1xuICpcbiAqICAgY29uc3QgcmVzID0gYXdhaXQgbmVzdGVkLmludm9rZSh7fSk7XG4gKlxuICogICAvLyBTdGlsbCBcImJhclwiIHNpbmNlIGNoaWxkIGNoYW5nZXMgZG8gbm90IGFmZmVjdCBwYXJlbnRzXG4gKiAgIGNvbnNvbGUubG9nKGdldENvbnRleHRWYXJpYWJsZShcImZvb1wiKSk7XG4gKlxuICogICByZXR1cm4gcmVzO1xuICogfSk7XG4gKlxuICogLy8gdW5kZWZpbmVkLCBiZWNhdXNlIGNvbnRleHQgdmFyaWFibGUgaGFzIG5vdCBiZWVuIHNldCB5ZXRcbiAqIGNvbnNvbGUubG9nKGdldENvbnRleHRWYXJpYWJsZShcImZvb1wiKSk7XG4gKlxuICogLy8gRmluYWwgcmV0dXJuIHZhbHVlIGlzIFwiYmF6XCJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJ1bm5hYmxlLmludm9rZSh7fSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29udGV4dCB2YXJpYWJsZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIHNldENvbnRleHRWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgIC8vIEF2b2lkIHVzaW5nIGdsb2JhbCBzaW5nbGV0b24gZHVlIHRvIGNpcmN1bHVhciBkZXBlbmRlbmN5IGlzc3Vlc1xuICAgIGNvbnN0IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSBnZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKCk7XG4gICAgaWYgKGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIGVycm9yOiBHbG9iYWwgc2hhcmVkIGFzeW5jIGxvY2FsIHN0b3JhZ2UgaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLmApO1xuICAgIH1cbiAgICBjb25zdCBydW5UcmVlID0gYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZS5nZXRTdG9yZSgpO1xuICAgIGNvbnN0IGNvbnRleHRWYXJzID0geyAuLi5ydW5UcmVlPy5bX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV0gfTtcbiAgICBjb250ZXh0VmFyc1tuYW1lXSA9IHZhbHVlO1xuICAgIGxldCBuZXdWYWx1ZSA9IHt9O1xuICAgIGlmIChpc1J1blRyZWUocnVuVHJlZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXcgUnVuVHJlZShydW5UcmVlKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBuZXdWYWx1ZVtfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSA9IGNvbnRleHRWYXJzO1xuICAgIGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UuZW50ZXJXaXRoKG5ld1ZhbHVlKTtcbn1cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhIHByZXZpb3VzbHkgc2V0IGNvbnRleHQgdmFyaWFibGUuIENvbnRleHQgdmFyaWFibGVzXG4gKiBhcmUgc2NvcGVkIHRvIGFueSBjaGlsZCBydW5uYWJsZXMgY2FsbGVkIGJ5IHRoZSBjdXJyZW50IHJ1bm5hYmxlLFxuICogb3IgZ2xvYmFsbHkgaWYgc2V0IG91dHNpZGUgb2YgYW55IHJ1bm5hYmxlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgQXN5bmNMb2NhbFN0b3JhZ2UsXG4gKiBpbmNsdWRpbmcgTm9kZS5qcywgRGVubywgYW5kIENsb3VkZmxhcmUgV29ya2Vycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFJ1bm5hYmxlTGFtYmRhIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqIGltcG9ydCB7XG4gKiAgIGdldENvbnRleHRWYXJpYWJsZSxcbiAqICAgc2V0Q29udGV4dFZhcmlhYmxlXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvY29udGV4dFwiO1xuICpcbiAqIGNvbnN0IG5lc3RlZCA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oKCkgPT4ge1xuICogICAvLyBcImJhclwiIGJlY2F1c2UgaXQgd2FzIHNldCBieSBhIHBhcmVudFxuICogICBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqICAgLy8gT3ZlcnJpZGUgdG8gXCJiYXpcIiwgYnV0IG9ubHkgZm9yIGNoaWxkIHJ1bm5hYmxlc1xuICogICBzZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIiwgXCJiYXpcIik7XG4gKlxuICogICAvLyBOb3cgXCJiYXpcIiwgYnV0IG9ubHkgZm9yIGNoaWxkIHJ1bm5hYmxlc1xuICogICByZXR1cm4gZ2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIpO1xuICogfSk7XG4gKlxuICogY29uc3QgcnVubmFibGUgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGFzeW5jICgpID0+IHtcbiAqICAgLy8gU2V0IGEgY29udGV4dCB2YXJpYWJsZSBuYW1lZCBcImZvb1wiXG4gKiAgIHNldENvbnRleHRWYXJpYWJsZShcImZvb1wiLCBcImJhclwiKTtcbiAqXG4gKiAgIGNvbnN0IHJlcyA9IGF3YWl0IG5lc3RlZC5pbnZva2Uoe30pO1xuICpcbiAqICAgLy8gU3RpbGwgXCJiYXJcIiBzaW5jZSBjaGlsZCBjaGFuZ2VzIGRvIG5vdCBhZmZlY3QgcGFyZW50c1xuICogICBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqICAgcmV0dXJuIHJlcztcbiAqIH0pO1xuICpcbiAqIC8vIHVuZGVmaW5lZCwgYmVjYXVzZSBjb250ZXh0IHZhcmlhYmxlIGhhcyBub3QgYmVlbiBzZXQgeWV0XG4gKiBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqIC8vIEZpbmFsIHJldHVybiB2YWx1ZSBpcyBcImJhelwiXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBydW5uYWJsZS5pbnZva2Uoe30pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRleHQgdmFyaWFibGUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dFZhcmlhYmxlKG5hbWUpIHtcbiAgICAvLyBBdm9pZCB1c2luZyBnbG9iYWwgc2luZ2xldG9uIGR1ZSB0byBjaXJjdWx1YXIgZGVwZW5kZW5jeSBpc3N1ZXNcbiAgICBjb25zdCBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlID0gZ2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSgpO1xuICAgIGlmIChhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcnVuVHJlZSA9IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UuZ2V0U3RvcmUoKTtcbiAgICByZXR1cm4gcnVuVHJlZT8uW19DT05URVhUX1ZBUklBQkxFU19LRVldPy5bbmFtZV07XG59XG5jb25zdCBMQ19DT05GSUdVUkVfSE9PS1NfS0VZID0gU3ltYm9sKFwibGM6Y29uZmlndXJlX2hvb2tzXCIpO1xuZXhwb3J0IGNvbnN0IF9nZXRDb25maWd1cmVIb29rcyA9ICgpID0+IGdldENvbnRleHRWYXJpYWJsZShMQ19DT05GSUdVUkVfSE9PS1NfS0VZKSB8fCBbXTtcbi8qKlxuICogUmVnaXN0ZXIgYSBjYWxsYmFjayBjb25maWd1cmUgaG9vayB0byBhdXRvbWF0aWNhbGx5IGFkZCBjYWxsYmFjayBoYW5kbGVycyB0byBhbGwgcnVucy5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gdXNlIHRoaXM6XG4gKlxuICogMS4gVXNpbmcgYSBjb250ZXh0IHZhcmlhYmxlOlxuICogICAgLSBTZXQgYGNvbnRleHRWYXJgIHRvIHNwZWNpZnkgdGhlIHZhcmlhYmxlIG5hbWVcbiAqICAgIC0gVXNlIGBzZXRDb250ZXh0VmFyaWFibGUoKWAgdG8gc3RvcmUgeW91ciBoYW5kbGVyIGluc3RhbmNlXG4gKlxuICogMi4gVXNpbmcgYW4gZW52aXJvbm1lbnQgdmFyaWFibGU6XG4gKiAgICAtIFNldCBib3RoIGBlbnZWYXJgIGFuZCBgaGFuZGxlckNsYXNzYFxuICogICAgLSBUaGUgaGFuZGxlciB3aWxsIGJlIGluc3RhbnRpYXRlZCB3aGVuIHRoZSBlbnYgdmFyIGlzIHNldCB0byBcInRydWVcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gTWV0aG9kIDE6IFVzaW5nIGNvbnRleHQgdmFyaWFibGVcbiAqIGltcG9ydCB7XG4gKiAgIHJlZ2lzdGVyQ29uZmlndXJlSG9vayxcbiAqICAgc2V0Q29udGV4dFZhcmlhYmxlXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvY29udGV4dFwiO1xuICpcbiAqIGNvbnN0IHRyYWNlciA9IG5ldyBNeUNhbGxiYWNrSGFuZGxlcigpO1xuICogcmVnaXN0ZXJDb25maWd1cmVIb29rKHtcbiAqICAgY29udGV4dFZhcjogXCJteV90cmFjZXJcIixcbiAqIH0pO1xuICogc2V0Q29udGV4dFZhcmlhYmxlKFwibXlfdHJhY2VyXCIsIHRyYWNlcik7XG4gKlxuICogLy8gLi4ucnVuIGNvZGUgaGVyZVxuICpcbiAqIC8vIE1ldGhvZCAyOiBVc2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogcmVnaXN0ZXJDb25maWd1cmVIb29rKHtcbiAqICAgaGFuZGxlckNsYXNzOiBNeUNhbGxiYWNrSGFuZGxlcixcbiAqICAgZW52VmFyOiBcIk1ZX1RSQUNFUl9FTkFCTEVEXCIsXG4gKiB9KTtcbiAqIHByb2Nlc3MuZW52Lk1ZX1RSQUNFUl9FTkFCTEVEID0gXCJ0cnVlXCI7XG4gKlxuICogLy8gLi4ucnVuIGNvZGUgaGVyZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIGhvb2tcbiAqIEBwYXJhbSBjb25maWcuY29udGV4dFZhciBOYW1lIG9mIHRoZSBjb250ZXh0IHZhcmlhYmxlIGNvbnRhaW5pbmcgdGhlIGhhbmRsZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSBjb25maWcuaW5oZXJpdGFibGUgV2hldGhlciBjaGlsZCBydW5zIHNob3VsZCBpbmhlcml0IHRoaXMgaGFuZGxlclxuICogQHBhcmFtIGNvbmZpZy5oYW5kbGVyQ2xhc3MgT3B0aW9uYWwgY2FsbGJhY2sgaGFuZGxlciBjbGFzcyAocmVxdWlyZWQgaWYgdXNpbmcgZW52VmFyKVxuICogQHBhcmFtIGNvbmZpZy5lbnZWYXIgT3B0aW9uYWwgZW52aXJvbm1lbnQgdmFyaWFibGUgbmFtZSB0byBjb250cm9sIGhhbmRsZXIgYWN0aXZhdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJDb25maWd1cmVIb29rID0gKGNvbmZpZykgPT4ge1xuICAgIGlmIChjb25maWcuZW52VmFyICYmICFjb25maWcuaGFuZGxlckNsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklmIGVudlZhciBpcyBzZXQsIGhhbmRsZXJDbGFzcyBtdXN0IGFsc28gYmUgc2V0IHRvIGEgbm9uLU5vbmUgdmFsdWUuXCIpO1xuICAgIH1cbiAgICBzZXRDb250ZXh0VmFyaWFibGUoTENfQ09ORklHVVJFX0hPT0tTX0tFWSwgWy4uLl9nZXRDb25maWd1cmVIb29rcygpLCBjb25maWddKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/context.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRACING_ALS_KEY: () => (/* binding */ TRACING_ALS_KEY),\n/* harmony export */   _CONTEXT_VARIABLES_KEY: () => (/* binding */ _CONTEXT_VARIABLES_KEY),\n/* harmony export */   getGlobalAsyncLocalStorageInstance: () => (/* binding */ getGlobalAsyncLocalStorageInstance),\n/* harmony export */   setGlobalAsyncLocalStorageInstance: () => (/* binding */ setGlobalAsyncLocalStorageInstance)\n/* harmony export */ });\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst _CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\nconst setGlobalAsyncLocalStorageInstance = (instance) => {\n    globalThis[TRACING_ALS_KEY] = instance;\n};\nconst getGlobalAsyncLocalStorageInstance = () => {\n    return globalThis[TRACING_ALS_KEY];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9hc3luY19sb2NhbF9zdG9yYWdlL2dsb2JhbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFPO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcc2luZ2xldG9uc1xcYXN5bmNfbG9jYWxfc3RvcmFnZVxcZ2xvYmFscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgVFJBQ0lOR19BTFNfS0VZID0gU3ltYm9sLmZvcihcImxzOnRyYWNpbmdfYXN5bmNfbG9jYWxfc3RvcmFnZVwiKTtcbmV4cG9ydCBjb25zdCBfQ09OVEVYVF9WQVJJQUJMRVNfS0VZID0gU3ltYm9sLmZvcihcImxjOmNvbnRleHRfdmFyaWFibGVzXCIpO1xuZXhwb3J0IGNvbnN0IHNldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICBnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPSBpbnN0YW5jZTtcbn07XG5leHBvcnQgY29uc3QgZ2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9ICgpID0+IHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),\n/* harmony export */   MockAsyncLocalStorage: () => (/* binding */ MockAsyncLocalStorage)\n/* harmony export */ });\n/* harmony import */ var langsmith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js\");\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../callbacks/manager.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_store, callback) {\n        return callback();\n    }\n    enterWith(_store) {\n        return undefined;\n    }\n}\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nconst LC_CHILD_KEY = Symbol.for(\"lc:child_config\");\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        return (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)() ?? mockAsyncLocalStorage;\n    }\n    getRunnableConfig() {\n        const storage = this.getInstance();\n        // this has the runnable config\n        // which means that we should also have an instance of a LangChainTracer\n        // with the run map prepopulated\n        return storage.getStore()?.extra?.[LC_CHILD_KEY];\n    }\n    runWithConfig(config, callback, avoidCreatingRootRunTree) {\n        const callbackManager = _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_2__.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n        const storage = this.getInstance();\n        const previousValue = storage.getStore();\n        const parentRunId = callbackManager?.getParentRunId();\n        const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name === \"langchain_tracer\");\n        let runTree;\n        if (langChainTracer && parentRunId) {\n            runTree = langChainTracer.getRunTreeWithTracingConfig(parentRunId);\n        }\n        else if (!avoidCreatingRootRunTree) {\n            runTree = new langsmith__WEBPACK_IMPORTED_MODULE_0__.RunTree({\n                name: \"<runnable_lambda>\",\n                tracingEnabled: false,\n            });\n        }\n        if (runTree) {\n            runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };\n        }\n        if (previousValue !== undefined &&\n            previousValue[_globals_js__WEBPACK_IMPORTED_MODULE_1__._CONTEXT_VARIABLES_KEY] !== undefined) {\n            if (runTree === undefined) {\n                runTree = {};\n            }\n            runTree[_globals_js__WEBPACK_IMPORTED_MODULE_1__._CONTEXT_VARIABLES_KEY] =\n                previousValue[_globals_js__WEBPACK_IMPORTED_MODULE_1__._CONTEXT_VARIABLES_KEY];\n        }\n        return storage.run(runTree, callback);\n    }\n    initializeGlobalInstance(instance) {\n        if ((0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)() === undefined) {\n            (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.setGlobalAsyncLocalStorageInstance)(instance);\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9hc3luY19sb2NhbF9zdG9yYWdlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDb0M7QUFDMkY7QUFDbEU7QUFDdEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrRUFBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtFQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBTztBQUNqQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDBCQUEwQiwrREFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFzQjtBQUMxQyw4QkFBOEIsK0RBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrRUFBa0M7QUFDOUMsWUFBWSwrRUFBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDOEMiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcc2luZ2xldG9uc1xcYXN5bmNfbG9jYWxfc3RvcmFnZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuaW1wb3J0IHsgUnVuVHJlZSB9IGZyb20gXCJsYW5nc21pdGhcIjtcbmltcG9ydCB7IGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UsIHNldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UsIF9DT05URVhUX1ZBUklBQkxFU19LRVksIH0gZnJvbSBcIi4vZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgQ2FsbGJhY2tNYW5hZ2VyIH0gZnJvbSBcIi4uLy4uL2NhbGxiYWNrcy9tYW5hZ2VyLmpzXCI7XG5leHBvcnQgY2xhc3MgTW9ja0FzeW5jTG9jYWxTdG9yYWdlIHtcbiAgICBnZXRTdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcnVuKF9zdG9yZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGVudGVyV2l0aChfc3RvcmUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5jb25zdCBtb2NrQXN5bmNMb2NhbFN0b3JhZ2UgPSBuZXcgTW9ja0FzeW5jTG9jYWxTdG9yYWdlKCk7XG5jb25zdCBMQ19DSElMRF9LRVkgPSBTeW1ib2wuZm9yKFwibGM6Y2hpbGRfY29uZmlnXCIpO1xuY2xhc3MgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlciB7XG4gICAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiBnZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKCkgPz8gbW9ja0FzeW5jTG9jYWxTdG9yYWdlO1xuICAgIH1cbiAgICBnZXRSdW5uYWJsZUNvbmZpZygpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgLy8gdGhpcyBoYXMgdGhlIHJ1bm5hYmxlIGNvbmZpZ1xuICAgICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHdlIHNob3VsZCBhbHNvIGhhdmUgYW4gaW5zdGFuY2Ugb2YgYSBMYW5nQ2hhaW5UcmFjZXJcbiAgICAgICAgLy8gd2l0aCB0aGUgcnVuIG1hcCBwcmVwb3B1bGF0ZWRcbiAgICAgICAgcmV0dXJuIHN0b3JhZ2UuZ2V0U3RvcmUoKT8uZXh0cmE/LltMQ19DSElMRF9LRVldO1xuICAgIH1cbiAgICBydW5XaXRoQ29uZmlnKGNvbmZpZywgY2FsbGJhY2ssIGF2b2lkQ3JlYXRpbmdSb290UnVuVHJlZSkge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXIgPSBDYWxsYmFja01hbmFnZXIuX2NvbmZpZ3VyZVN5bmMoY29uZmlnPy5jYWxsYmFja3MsIHVuZGVmaW5lZCwgY29uZmlnPy50YWdzLCB1bmRlZmluZWQsIGNvbmZpZz8ubWV0YWRhdGEpO1xuICAgICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gc3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgICAgICBjb25zdCBwYXJlbnRSdW5JZCA9IGNhbGxiYWNrTWFuYWdlcj8uZ2V0UGFyZW50UnVuSWQoKTtcbiAgICAgICAgY29uc3QgbGFuZ0NoYWluVHJhY2VyID0gY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVycz8uZmluZCgoaGFuZGxlcikgPT4gaGFuZGxlcj8ubmFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpO1xuICAgICAgICBsZXQgcnVuVHJlZTtcbiAgICAgICAgaWYgKGxhbmdDaGFpblRyYWNlciAmJiBwYXJlbnRSdW5JZCkge1xuICAgICAgICAgICAgcnVuVHJlZSA9IGxhbmdDaGFpblRyYWNlci5nZXRSdW5UcmVlV2l0aFRyYWNpbmdDb25maWcocGFyZW50UnVuSWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhdm9pZENyZWF0aW5nUm9vdFJ1blRyZWUpIHtcbiAgICAgICAgICAgIHJ1blRyZWUgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCI8cnVubmFibGVfbGFtYmRhPlwiLFxuICAgICAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5UcmVlKSB7XG4gICAgICAgICAgICBydW5UcmVlLmV4dHJhID0geyAuLi5ydW5UcmVlLmV4dHJhLCBbTENfQ0hJTERfS0VZXTogY29uZmlnIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZVtfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocnVuVHJlZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcnVuVHJlZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuVHJlZVtfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSA9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZVtfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmFnZS5ydW4ocnVuVHJlZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpbml0aWFsaXplR2xvYmFsSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlcigpO1xuZXhwb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/callbacks.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/callbacks.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   awaitAllCallbacks: () => (/* binding */ awaitAllCallbacks),\n/* harmony export */   consumeCallback: () => (/* binding */ consumeCallback),\n/* harmony export */   getQueue: () => (/* binding */ getQueue)\n/* harmony export */ });\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var _async_local_storage_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./async_local_storage/globals.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js\");\n/* harmony import */ var _tracer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tracer.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\nlet queue;\n/**\n * Creates a queue using the p-queue library. The queue is configured to\n * auto-start and has a concurrency of 1, meaning it will process tasks\n * one at a time.\n */\nfunction createQueue() {\n    const PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_0__[\"default\"] : p_queue__WEBPACK_IMPORTED_MODULE_0__;\n    return new PQueue({\n        autoStart: true,\n        concurrency: 1,\n    });\n}\nfunction getQueue() {\n    if (typeof queue === \"undefined\") {\n        queue = createQueue();\n    }\n    return queue;\n}\n/**\n * Consume a promise, either adding it to the queue or waiting for it to resolve\n * @param promiseFn Promise to consume\n * @param wait Whether to wait for the promise to resolve or resolve immediately\n */\nasync function consumeCallback(promiseFn, wait) {\n    if (wait === true) {\n        // Clear config since callbacks are not part of the root run\n        // Avoid using global singleton due to circuluar dependency issues\n        const asyncLocalStorageInstance = (0,_async_local_storage_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)();\n        if (asyncLocalStorageInstance !== undefined) {\n            await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n        }\n        else {\n            await promiseFn();\n        }\n    }\n    else {\n        queue = getQueue();\n        void queue.add(async () => {\n            const asyncLocalStorageInstance = (0,_async_local_storage_globals_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalAsyncLocalStorageInstance)();\n            if (asyncLocalStorageInstance !== undefined) {\n                await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n            }\n            else {\n                await promiseFn();\n            }\n        });\n    }\n}\n/**\n * Waits for all promises in the queue to resolve. If the queue is\n * undefined, it immediately resolves a promise.\n */\nasync function awaitAllCallbacks() {\n    const defaultClient = (0,_tracer_js__WEBPACK_IMPORTED_MODULE_2__.getDefaultLangChainClientSingleton)();\n    await Promise.allSettled([\n        typeof queue !== \"undefined\" ? queue.onIdle() : Promise.resolve(),\n        defaultClient.awaitPendingTraceBatches(),\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9jYWxsYmFja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDZ0M7QUFDc0Q7QUFDckI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBc0IsR0FBRywrQ0FBaUIsR0FBRyxvQ0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUdBQWtDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1HQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwwQkFBMEIsOEVBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcc2luZ2xldG9uc1xcY2FsbGJhY2tzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCBQUXVldWVNb2QgZnJvbSBcInAtcXVldWVcIjtcbmltcG9ydCB7IGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgfSBmcm9tIFwiLi9hc3luY19sb2NhbF9zdG9yYWdlL2dsb2JhbHMuanNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRMYW5nQ2hhaW5DbGllbnRTaW5nbGV0b24gfSBmcm9tIFwiLi90cmFjZXIuanNcIjtcbmxldCBxdWV1ZTtcbi8qKlxuICogQ3JlYXRlcyBhIHF1ZXVlIHVzaW5nIHRoZSBwLXF1ZXVlIGxpYnJhcnkuIFRoZSBxdWV1ZSBpcyBjb25maWd1cmVkIHRvXG4gKiBhdXRvLXN0YXJ0IGFuZCBoYXMgYSBjb25jdXJyZW5jeSBvZiAxLCBtZWFuaW5nIGl0IHdpbGwgcHJvY2VzcyB0YXNrc1xuICogb25lIGF0IGEgdGltZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUXVldWUoKSB7XG4gICAgY29uc3QgUFF1ZXVlID0gXCJkZWZhdWx0XCIgaW4gUFF1ZXVlTW9kID8gUFF1ZXVlTW9kLmRlZmF1bHQgOiBQUXVldWVNb2Q7XG4gICAgcmV0dXJuIG5ldyBQUXVldWUoe1xuICAgICAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgICAgIGNvbmN1cnJlbmN5OiAxLFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFF1ZXVlKCkge1xuICAgIGlmICh0eXBlb2YgcXVldWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcXVldWUgPSBjcmVhdGVRdWV1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcXVldWU7XG59XG4vKipcbiAqIENvbnN1bWUgYSBwcm9taXNlLCBlaXRoZXIgYWRkaW5nIGl0IHRvIHRoZSBxdWV1ZSBvciB3YWl0aW5nIGZvciBpdCB0byByZXNvbHZlXG4gKiBAcGFyYW0gcHJvbWlzZUZuIFByb21pc2UgdG8gY29uc3VtZVxuICogQHBhcmFtIHdhaXQgV2hldGhlciB0byB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIG9yIHJlc29sdmUgaW1tZWRpYXRlbHlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVDYWxsYmFjayhwcm9taXNlRm4sIHdhaXQpIHtcbiAgICBpZiAod2FpdCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBDbGVhciBjb25maWcgc2luY2UgY2FsbGJhY2tzIGFyZSBub3QgcGFydCBvZiB0aGUgcm9vdCBydW5cbiAgICAgICAgLy8gQXZvaWQgdXNpbmcgZ2xvYmFsIHNpbmdsZXRvbiBkdWUgdG8gY2lyY3VsdWFyIGRlcGVuZGVuY3kgaXNzdWVzXG4gICAgICAgIGNvbnN0IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSBnZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKCk7XG4gICAgICAgIGlmIChhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UucnVuKHVuZGVmaW5lZCwgYXN5bmMgKCkgPT4gcHJvbWlzZUZuKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZUZuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHF1ZXVlID0gZ2V0UXVldWUoKTtcbiAgICAgICAgdm9pZCBxdWV1ZS5hZGQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9IGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGlmIChhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlLnJ1bih1bmRlZmluZWQsIGFzeW5jICgpID0+IHByb21pc2VGbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHByb21pc2VGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFdhaXRzIGZvciBhbGwgcHJvbWlzZXMgaW4gdGhlIHF1ZXVlIHRvIHJlc29sdmUuIElmIHRoZSBxdWV1ZSBpc1xuICogdW5kZWZpbmVkLCBpdCBpbW1lZGlhdGVseSByZXNvbHZlcyBhIHByb21pc2UuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhd2FpdEFsbENhbGxiYWNrcygpIHtcbiAgICBjb25zdCBkZWZhdWx0Q2xpZW50ID0gZ2V0RGVmYXVsdExhbmdDaGFpbkNsaWVudFNpbmdsZXRvbigpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbXG4gICAgICAgIHR5cGVvZiBxdWV1ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHF1ZXVlLm9uSWRsZSgpIDogUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICAgIGRlZmF1bHRDbGllbnQuYXdhaXRQZW5kaW5nVHJhY2VCYXRjaGVzKCksXG4gICAgXSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/callbacks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _async_local_storage_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),\n/* harmony export */   MockAsyncLocalStorage: () => (/* reexport safe */ _async_local_storage_index_js__WEBPACK_IMPORTED_MODULE_0__.MockAsyncLocalStorage),\n/* harmony export */   _CONTEXT_VARIABLES_KEY: () => (/* reexport safe */ _async_local_storage_globals_js__WEBPACK_IMPORTED_MODULE_1__._CONTEXT_VARIABLES_KEY)\n/* harmony export */ });\n/* harmony import */ var _async_local_storage_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async_local_storage/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/index.js\");\n/* harmony import */ var _async_local_storage_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./async_local_storage/globals.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js\");\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0RztBQUNsQztBQUNKO0FBQ3BDIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHNpbmdsZXRvbnNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24sIE1vY2tBc3luY0xvY2FsU3RvcmFnZSwgfSBmcm9tIFwiLi9hc3luY19sb2NhbF9zdG9yYWdlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIH0gZnJvbSBcIi4vYXN5bmNfbG9jYWxfc3RvcmFnZS9nbG9iYWxzLmpzXCI7XG5leHBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLCBNb2NrQXN5bmNMb2NhbFN0b3JhZ2UsIH07XG5leHBvcnQgeyBfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/tracer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultLangChainClientSingleton: () => (/* binding */ getDefaultLangChainClientSingleton),\n/* harmony export */   setDefaultLangChainClientSingleton: () => (/* binding */ setDefaultLangChainClientSingleton)\n/* harmony export */ });\n/* harmony import */ var langsmith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.js\");\n\n\nlet client;\nconst getDefaultLangChainClientSingleton = () => {\n    if (client === undefined) {\n        const clientParams = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n            ? {\n                // LangSmith has its own backgrounding system\n                blockOnRootRunFinalization: true,\n            }\n            : {};\n        client = new langsmith__WEBPACK_IMPORTED_MODULE_0__.Client(clientParams);\n    }\n    return client;\n};\nconst setDefaultLangChainClientSingleton = (newClient) => {\n    client = newClient;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy90cmFjZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtQztBQUNzQjtBQUN6RDtBQUNPO0FBQ1A7QUFDQSw2QkFBNkIscUVBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHNpbmdsZXRvbnNcXHRyYWNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwibGFuZ3NtaXRoXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4uL3V0aWxzL2Vudi5qc1wiO1xubGV0IGNsaWVudDtcbmV4cG9ydCBjb25zdCBnZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uID0gKCkgPT4ge1xuICAgIGlmIChjbGllbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBjbGllbnRQYXJhbXMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0NBTExCQUNLU19CQUNLR1JPVU5EXCIpID09PSBcImZhbHNlXCJcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIC8vIExhbmdTbWl0aCBoYXMgaXRzIG93biBiYWNrZ3JvdW5kaW5nIHN5c3RlbVxuICAgICAgICAgICAgICAgIGJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgY2xpZW50ID0gbmV3IENsaWVudChjbGllbnRQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2xpZW50O1xufTtcbmV4cG9ydCBjb25zdCBzZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uID0gKG5ld0NsaWVudCkgPT4ge1xuICAgIGNsaWVudCA9IG5ld0NsaWVudDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/stores.js":
/*!*****************************************************!*\
  !*** ./node_modules/@langchain/core/dist/stores.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseStore: () => (/* binding */ BaseStore),\n/* harmony export */   InMemoryStore: () => (/* binding */ InMemoryStore)\n/* harmony export */ });\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./load/serializable.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\");\n\n/**\n * Abstract interface for a key-value store.\n */\nclass BaseStore extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable {\n}\n/**\n * In-memory implementation of the BaseStore using a dictionary. Used for\n * storing key-value pairs in memory.\n * @example\n * ```typescript\n * const store = new InMemoryStore<BaseMessage>();\n * await store.mset(\n *   Array.from({ length: 5 }).map((_, index) => [\n *     `message:id:${index}`,\n *     index % 2 === 0\n *       ? new AIMessage(\"ai stuff...\")\n *       : new HumanMessage(\"human stuff...\"),\n *   ]),\n * );\n *\n * const retrievedMessages = await store.mget([\"message:id:0\", \"message:id:1\"]);\n * await store.mdelete(await store.yieldKeys(\"message:id:\").toArray());\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass InMemoryStore extends BaseStore {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"storage\"]\n        });\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n    }\n    /**\n     * Retrieves the values associated with the given keys from the store.\n     * @param keys Keys to retrieve values for.\n     * @returns Array of values associated with the given keys.\n     */\n    async mget(keys) {\n        return keys.map((key) => this.store[key]);\n    }\n    /**\n     * Sets the values for the given keys in the store.\n     * @param keyValuePairs Array of key-value pairs to set in the store.\n     * @returns Promise that resolves when all key-value pairs have been set.\n     */\n    async mset(keyValuePairs) {\n        for (const [key, value] of keyValuePairs) {\n            this.store[key] = value;\n        }\n    }\n    /**\n     * Deletes the given keys and their associated values from the store.\n     * @param keys Keys to delete from the store.\n     * @returns Promise that resolves when all keys have been deleted.\n     */\n    async mdelete(keys) {\n        for (const key of keys) {\n            delete this.store[key];\n        }\n    }\n    /**\n     * Asynchronous generator that yields keys from the store. If a prefix is\n     * provided, it only yields keys that start with the prefix.\n     * @param prefix Optional prefix to filter keys.\n     * @returns AsyncGenerator that yields keys from the store.\n     */\n    async *yieldKeys(prefix) {\n        const keys = Object.keys(this.store);\n        for (const key of keys) {\n            if (prefix === undefined || key.startsWith(prefix)) {\n                yield key;\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc3RvcmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsK0RBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxzdG9yZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2VyaWFsaXphYmxlIH0gZnJvbSBcIi4vbG9hZC9zZXJpYWxpemFibGUuanNcIjtcbi8qKlxuICogQWJzdHJhY3QgaW50ZXJmYWNlIGZvciBhIGtleS12YWx1ZSBzdG9yZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VTdG9yZSBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XG59XG4vKipcbiAqIEluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQmFzZVN0b3JlIHVzaW5nIGEgZGljdGlvbmFyeS4gVXNlZCBmb3JcbiAqIHN0b3Jpbmcga2V5LXZhbHVlIHBhaXJzIGluIG1lbW9yeS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBzdG9yZSA9IG5ldyBJbk1lbW9yeVN0b3JlPEJhc2VNZXNzYWdlPigpO1xuICogYXdhaXQgc3RvcmUubXNldChcbiAqICAgQXJyYXkuZnJvbSh7IGxlbmd0aDogNSB9KS5tYXAoKF8sIGluZGV4KSA9PiBbXG4gKiAgICAgYG1lc3NhZ2U6aWQ6JHtpbmRleH1gLFxuICogICAgIGluZGV4ICUgMiA9PT0gMFxuICogICAgICAgPyBuZXcgQUlNZXNzYWdlKFwiYWkgc3R1ZmYuLi5cIilcbiAqICAgICAgIDogbmV3IEh1bWFuTWVzc2FnZShcImh1bWFuIHN0dWZmLi4uXCIpLFxuICogICBdKSxcbiAqICk7XG4gKlxuICogY29uc3QgcmV0cmlldmVkTWVzc2FnZXMgPSBhd2FpdCBzdG9yZS5tZ2V0KFtcIm1lc3NhZ2U6aWQ6MFwiLCBcIm1lc3NhZ2U6aWQ6MVwiXSk7XG4gKiBhd2FpdCBzdG9yZS5tZGVsZXRlKGF3YWl0IHN0b3JlLnlpZWxkS2V5cyhcIm1lc3NhZ2U6aWQ6XCIpLnRvQXJyYXkoKSk7XG4gKiBgYGBcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBjbGFzcyBJbk1lbW9yeVN0b3JlIGV4dGVuZHMgQmFzZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJzdG9yYWdlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5cyBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0ga2V5cyBLZXlzIHRvIHJldHJpZXZlIHZhbHVlcyBmb3IuXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5cy5cbiAgICAgKi9cbiAgICBhc3luYyBtZ2V0KGtleXMpIHtcbiAgICAgICAgcmV0dXJuIGtleXMubWFwKChrZXkpID0+IHRoaXMuc3RvcmVba2V5XSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleXMgaW4gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSBrZXlWYWx1ZVBhaXJzIEFycmF5IG9mIGtleS12YWx1ZSBwYWlycyB0byBzZXQgaW4gdGhlIHN0b3JlLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBrZXktdmFsdWUgcGFpcnMgaGF2ZSBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBhc3luYyBtc2V0KGtleVZhbHVlUGFpcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVQYWlycykge1xuICAgICAgICAgICAgdGhpcy5zdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgZ2l2ZW4ga2V5cyBhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMgZnJvbSB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIGtleXMgS2V5cyB0byBkZWxldGUgZnJvbSB0aGUgc3RvcmUuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGtleXMgaGF2ZSBiZWVuIGRlbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgbWRlbGV0ZShrZXlzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzIGdlbmVyYXRvciB0aGF0IHlpZWxkcyBrZXlzIGZyb20gdGhlIHN0b3JlLiBJZiBhIHByZWZpeCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBvbmx5IHlpZWxkcyBrZXlzIHRoYXQgc3RhcnQgd2l0aCB0aGUgcHJlZml4LlxuICAgICAqIEBwYXJhbSBwcmVmaXggT3B0aW9uYWwgcHJlZml4IHRvIGZpbHRlciBrZXlzLlxuICAgICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHRoYXQgeWllbGRzIGtleXMgZnJvbSB0aGUgc3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgKnlpZWxkS2V5cyhwcmVmaXgpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuc3RvcmUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQgfHwga2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/stores.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseToolkit: () => (/* binding */ BaseToolkit),\n/* harmony export */   DynamicStructuredTool: () => (/* binding */ DynamicStructuredTool),\n/* harmony export */   DynamicTool: () => (/* binding */ DynamicTool),\n/* harmony export */   StructuredTool: () => (/* binding */ StructuredTool),\n/* harmony export */   Tool: () => (/* binding */ Tool),\n/* harmony export */   ToolInputParsingException: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.ToolInputParsingException),\n/* harmony export */   isLangChainTool: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_9__.isLangChainTool),\n/* harmony export */   isRunnableToolLike: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_9__.isRunnableToolLike),\n/* harmony export */   isStructuredTool: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_9__.isStructuredTool),\n/* harmony export */   isStructuredToolParams: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_9__.isStructuredToolParams),\n/* harmony export */   tool: () => (/* binding */ tool)\n/* harmony export */ });\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _cfworker_json_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/esm/index.js\");\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../callbacks/manager.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* harmony import */ var _language_models_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../language_models/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.js\");\n/* harmony import */ var _runnables_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../runnables/config.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.js\");\n/* harmony import */ var _messages_tool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../messages/tool.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.js\");\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../singletons/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.js\");\n/* harmony import */ var _utils_types_zod_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/types/zod.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.js\");\n/* harmony import */ var _utils_json_schema_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/json_schema.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/@langchain/core/dist/tools/types.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nclass StructuredTool extends _language_models_base_js__WEBPACK_IMPORTED_MODULE_2__.BaseLangChain {\n    get lc_namespace() {\n        return [\"langchain\", \"tools\"];\n    }\n    constructor(fields) {\n        super(fields ?? {});\n        /**\n         * Whether to return the tool's output directly.\n         *\n         * Setting this to true means that after the tool is called,\n         * an agent should stop looping.\n         */\n        Object.defineProperty(this, \"returnDirect\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"verboseParsingErrors\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /**\n         * The tool response format.\n         *\n         * If \"content\" then the output of the tool is interpreted as the contents of a\n         * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n         * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n         *\n         * @default \"content\"\n         */\n        Object.defineProperty(this, \"responseFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"content\"\n        });\n        /**\n         * Default config object for the tool runnable.\n         */\n        Object.defineProperty(this, \"defaultConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.verboseParsingErrors =\n            fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n        this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n        this.defaultConfig = fields?.defaultConfig ?? this.defaultConfig;\n        this.metadata = fields?.metadata ?? this.metadata;\n    }\n    /**\n     * Invokes the tool with the provided input and configuration.\n     * @param input The input for the tool.\n     * @param config Optional configuration for the tool.\n     * @returns A Promise that resolves with the tool's output.\n     */\n    async invoke(input, config) {\n        let toolInput;\n        let enrichedConfig = (0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_3__.ensureConfig)((0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_3__.mergeConfigs)(this.defaultConfig, config));\n        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__._isToolCall)(input)) {\n            toolInput = input.args;\n            enrichedConfig = {\n                ...enrichedConfig,\n                toolCall: input,\n            };\n        }\n        else {\n            toolInput = input;\n        }\n        return this.call(toolInput, enrichedConfig);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument, configuration, and tags. It\n     * parses the input according to the schema, handles any errors, and\n     * manages callbacks.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration or callbacks for the tool.\n     * @param tags Optional tags for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        // Determine the actual input that needs parsing/validation.\n        // If arg is a ToolCall, use its args; otherwise, use arg directly.\n        const inputForValidation = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__._isToolCall)(arg) ? arg.args : arg;\n        let parsed; // This will hold the successfully parsed input of the expected output type.\n        if ((0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_7__.isInteropZodSchema)(this.schema)) {\n            try {\n                // Validate the inputForValidation - TS needs help here as it can't exclude ToolCall based on the check\n                parsed = await (0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_7__.interopParseAsync)(this.schema, inputForValidation);\n            }\n            catch (e) {\n                let message = `Received tool input did not match expected schema`;\n                if (this.verboseParsingErrors) {\n                    message = `${message}\\nDetails: ${e.message}`;\n                }\n                // Pass the original raw input arg to the exception\n                throw new _utils_js__WEBPACK_IMPORTED_MODULE_6__.ToolInputParsingException(message, JSON.stringify(arg));\n            }\n        }\n        else {\n            const result = (0,_cfworker_json_schema__WEBPACK_IMPORTED_MODULE_0__.validate)(inputForValidation, this.schema);\n            if (!result.valid) {\n                let message = `Received tool input did not match expected schema`;\n                if (this.verboseParsingErrors) {\n                    message = `${message}\\nDetails: ${result.errors\n                        .map((e) => `${e.keywordLocation}: ${e.error}`)\n                        .join(\"\\n\")}`;\n                }\n                // Pass the original raw input arg to the exception\n                throw new _utils_js__WEBPACK_IMPORTED_MODULE_6__.ToolInputParsingException(message, JSON.stringify(arg));\n            }\n            // Assign the validated input to parsed\n            // We cast here because validate() doesn't narrow the type sufficiently for TS, but we know it's valid.\n            parsed = inputForValidation;\n        }\n        const config = (0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_1__.parseCallbackConfigArg)(configArg);\n        const callbackManager_ = _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_1__.CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleToolStart(this.toJSON(), \n        // Log the original raw input arg\n        typeof arg === \"string\" ? arg : JSON.stringify(arg), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        let result;\n        try {\n            // Pass the correctly typed parsed input to _call\n            result = await this._call(parsed, runManager, config);\n        }\n        catch (e) {\n            await runManager?.handleToolError(e);\n            throw e;\n        }\n        let content;\n        let artifact;\n        if (this.responseFormat === \"content_and_artifact\") {\n            if (Array.isArray(result) && result.length === 2) {\n                [content, artifact] = result;\n            }\n            else {\n                throw new Error(`Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(result)}`);\n            }\n        }\n        else {\n            content = result;\n        }\n        let toolCallId;\n        // Extract toolCallId ONLY if the original arg was a ToolCall\n        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__._isToolCall)(arg)) {\n            toolCallId = arg.id;\n        }\n        // Or if it was provided in the config's toolCall property\n        if (!toolCallId && (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__._configHasToolCallId)(config)) {\n            toolCallId = config.toolCall.id;\n        }\n        const formattedOutput = _formatToolOutput({\n            content,\n            artifact,\n            toolCallId,\n            name: this.name,\n            metadata: this.metadata,\n        });\n        await runManager?.handleToolEnd(formattedOutput);\n        return formattedOutput;\n    }\n}\n/**\n * Base class for Tools that accept input as a string.\n */\nclass Tool extends StructuredTool {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: zod_v3__WEBPACK_IMPORTED_MODULE_10__.object({ input: zod_v3__WEBPACK_IMPORTED_MODULE_10__.string().optional() })\n                .transform((obj) => obj.input)\n        });\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument and callbacks. It handles\n     * string inputs specifically.\n     * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n     * @param callbacks Optional callbacks for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    // Match the base class signature including the generics and conditional return type\n    call(arg, callbacks) {\n        // Prepare the input for the base class call method.\n        // If arg is string or undefined, wrap it; otherwise, pass ToolCall or { input: ... } directly.\n        const structuredArg = typeof arg === \"string\" || arg == null ? { input: arg } : arg;\n        // Ensure TConfig is passed to super.call\n        return super.call(structuredArg, callbacks);\n    }\n}\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nclass DynamicTool extends Tool {\n    static lc_name() {\n        return \"DynamicTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    async call(arg, configArg) {\n        const config = (0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_1__.parseCallbackConfigArg)(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        // Call the Tool class's call method, passing generics through\n        // Cast config to TConfig to satisfy the super.call signature\n        return super.call(arg, config);\n    }\n    /** @ignore */\n    async _call(input, // DynamicTool's _call specifically expects a string after schema transformation\n    runManager, parentConfig) {\n        return this.func(input, runManager, parentConfig);\n    }\n}\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n */\nclass DynamicStructuredTool extends StructuredTool {\n    static lc_name() {\n        return \"DynamicStructuredTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n        this.schema = fields.schema;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    // Match the base class signature\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        const config = (0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_1__.parseCallbackConfigArg)(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        // Call the base class method, passing generics through\n        // Cast config to TConfig to satisfy the super.call signature\n        return super.call(arg, config, tags);\n    }\n    _call(arg, runManager, parentConfig) {\n        return this.func(arg, runManager, parentConfig);\n    }\n}\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nclass BaseToolkit {\n    getTools() {\n        return this.tools;\n    }\n}\nfunction tool(func, fields) {\n    const isSimpleStringSchema = (0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_7__.isSimpleStringZodSchema)(fields.schema);\n    const isStringJSONSchema = (0,_utils_json_schema_js__WEBPACK_IMPORTED_MODULE_8__.validatesOnlyStrings)(fields.schema);\n    // If the schema is not provided, or it's a simple string schema, create a DynamicTool\n    if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) {\n        return new DynamicTool({\n            ...fields,\n            description: fields.description ??\n                (fields.schema && (0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_7__.getSchemaDescription)(fields.schema)) ??\n                `${fields.name} tool`,\n            func: async (input, runManager, config) => {\n                return new Promise((resolve, reject) => {\n                    const childConfig = (0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_3__.patchConfig)(config, {\n                        callbacks: runManager?.getChild(),\n                    });\n                    void _singletons_index_js__WEBPACK_IMPORTED_MODULE_5__.AsyncLocalStorageProviderSingleton.runWithConfig((0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_3__.pickRunnableConfigKeys)(childConfig), async () => {\n                        try {\n                            // TS doesn't restrict the type here based on the guard above\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            resolve(func(input, childConfig));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            },\n        });\n    }\n    const schema = fields.schema;\n    const description = fields.description ??\n        fields.schema.description ??\n        `${fields.name} tool`;\n    return new DynamicStructuredTool({\n        ...fields,\n        description,\n        schema,\n        func: async (input, runManager, config) => {\n            return new Promise((resolve, reject) => {\n                const childConfig = (0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_3__.patchConfig)(config, {\n                    callbacks: runManager?.getChild(),\n                });\n                void _singletons_index_js__WEBPACK_IMPORTED_MODULE_5__.AsyncLocalStorageProviderSingleton.runWithConfig((0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_3__.pickRunnableConfigKeys)(childConfig), async () => {\n                    try {\n                        resolve(func(input, childConfig));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n            });\n        },\n    });\n}\nfunction _formatToolOutput(params) {\n    const { content, artifact, toolCallId, metadata } = params;\n    if (toolCallId && !(0,_messages_tool_js__WEBPACK_IMPORTED_MODULE_4__.isDirectToolOutput)(content)) {\n        if (typeof content === \"string\" ||\n            (Array.isArray(content) &&\n                content.every((item) => typeof item === \"object\"))) {\n            return new _messages_tool_js__WEBPACK_IMPORTED_MODULE_4__.ToolMessage({\n                status: \"success\",\n                content,\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n                metadata,\n            });\n        }\n        else {\n            return new _messages_tool_js__WEBPACK_IMPORTED_MODULE_4__.ToolMessage({\n                status: \"success\",\n                content: _stringify(content),\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n                metadata,\n            });\n        }\n    }\n    else {\n        return content;\n    }\n}\nfunction _stringify(content) {\n    try {\n        return JSON.stringify(content, null, 2) ?? \"\";\n    }\n    catch (_noOp) {\n        return `${content}`;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQjtBQUN1QjtBQUNpQztBQUN4QjtBQUMrQztBQUNwQztBQUNNO0FBQ2U7QUFDbUM7QUFDL0Q7QUFDNkM7QUFDdkU7QUFDckM7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLG1FQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrRUFBWSxDQUFDLGtFQUFZO0FBQ3RELFlBQVksc0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxtQ0FBbUMsc0RBQVc7QUFDOUMsb0JBQW9CO0FBQ3BCLFlBQVksdUVBQWtCO0FBQzlCO0FBQ0E7QUFDQSwrQkFBK0Isc0VBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsYUFBYSxVQUFVO0FBQ2hFO0FBQ0E7QUFDQSwwQkFBMEIsZ0VBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUSxhQUFhO0FBQ3RELHVDQUF1QyxrQkFBa0IsSUFBSSxRQUFRO0FBQ3JFLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsMEJBQTBCLGdFQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZFQUFzQjtBQUM3QyxpQ0FBaUMsa0VBQWUsK0dBQStHLHVCQUF1QjtBQUN0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStILHVCQUF1QjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtEQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkNBQ0ksR0FBRyxPQUFPLDJDQUFRLGVBQWU7QUFDeEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOEJBQThCLGFBQWE7QUFDOUYseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkVBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2RUFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsNEVBQXVCO0FBQ3hELCtCQUErQiwyRUFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5RUFBb0I7QUFDdEQsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBLHdDQUF3QyxpRUFBVztBQUNuRDtBQUNBLHFCQUFxQjtBQUNyQix5QkFBeUIsb0ZBQWtDLGVBQWUsNEVBQXNCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlFQUFXO0FBQy9DO0FBQ0EsaUJBQWlCO0FBQ2pCLHFCQUFxQixvRkFBa0MsZUFBZSw0RUFBc0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDBDQUEwQztBQUN0RCx1QkFBdUIscUVBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QiwwREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdG9vbHNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHogfSBmcm9tIFwiem9kL3YzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZSwgfSBmcm9tIFwiQGNmd29ya2VyL2pzb24tc2NoZW1hXCI7XG5pbXBvcnQgeyBDYWxsYmFja01hbmFnZXIsIHBhcnNlQ2FsbGJhY2tDb25maWdBcmcsIH0gZnJvbSBcIi4uL2NhbGxiYWNrcy9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBCYXNlTGFuZ0NoYWluIH0gZnJvbSBcIi4uL2xhbmd1YWdlX21vZGVscy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBtZXJnZUNvbmZpZ3MsIGVuc3VyZUNvbmZpZywgcGF0Y2hDb25maWcsIHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMsIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9jb25maWcuanNcIjtcbmltcG9ydCB7IGlzRGlyZWN0VG9vbE91dHB1dCwgVG9vbE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZXMvdG9vbC5qc1wiO1xuaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBfY29uZmlnSGFzVG9vbENhbGxJZCwgX2lzVG9vbENhbGwsIFRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24sIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IGludGVyb3BQYXJzZUFzeW5jLCBpc1NpbXBsZVN0cmluZ1pvZFNjaGVtYSwgaXNJbnRlcm9wWm9kU2NoZW1hLCBnZXRTY2hlbWFEZXNjcmlwdGlvbiwgfSBmcm9tIFwiLi4vdXRpbHMvdHlwZXMvem9kLmpzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZXNPbmx5U3RyaW5ncyB9IGZyb20gXCIuLi91dGlscy9qc29uX3NjaGVtYS5qc1wiO1xuZXhwb3J0IHsgaXNMYW5nQ2hhaW5Ub29sLCBpc1J1bm5hYmxlVG9vbExpa2UsIGlzU3RydWN0dXJlZFRvb2wsIGlzU3RydWN0dXJlZFRvb2xQYXJhbXMsIH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcbmV4cG9ydCB7IFRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24gfTtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgVG9vbHMgdGhhdCBhY2NlcHQgaW5wdXQgb2YgYW55IHNoYXBlIGRlZmluZWQgYnkgYSBab2Qgc2NoZW1hLlxuICovXG5leHBvcnQgY2xhc3MgU3RydWN0dXJlZFRvb2wgZXh0ZW5kcyBCYXNlTGFuZ0NoYWluIHtcbiAgICBnZXQgbGNfbmFtZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gW1wibGFuZ2NoYWluXCIsIFwidG9vbHNcIl07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMgPz8ge30pO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byByZXR1cm4gdGhlIHRvb2wncyBvdXRwdXQgZGlyZWN0bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNldHRpbmcgdGhpcyB0byB0cnVlIG1lYW5zIHRoYXQgYWZ0ZXIgdGhlIHRvb2wgaXMgY2FsbGVkLFxuICAgICAgICAgKiBhbiBhZ2VudCBzaG91bGQgc3RvcCBsb29waW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmV0dXJuRGlyZWN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyYm9zZVBhcnNpbmdFcnJvcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvb2wgcmVzcG9uc2UgZm9ybWF0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBcImNvbnRlbnRcIiB0aGVuIHRoZSBvdXRwdXQgb2YgdGhlIHRvb2wgaXMgaW50ZXJwcmV0ZWQgYXMgdGhlIGNvbnRlbnRzIG9mIGFcbiAgICAgICAgICogVG9vbE1lc3NhZ2UuIElmIFwiY29udGVudF9hbmRfYXJ0aWZhY3RcIiB0aGVuIHRoZSBvdXRwdXQgaXMgZXhwZWN0ZWQgdG8gYmUgYVxuICAgICAgICAgKiB0d28tdHVwbGUgY29ycmVzcG9uZGluZyB0byB0aGUgKGNvbnRlbnQsIGFydGlmYWN0KSBvZiBhIFRvb2xNZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBcImNvbnRlbnRcIlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VGb3JtYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiY29udGVudFwiXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBjb25maWcgb2JqZWN0IGZvciB0aGUgdG9vbCBydW5uYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRDb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52ZXJib3NlUGFyc2luZ0Vycm9ycyA9XG4gICAgICAgICAgICBmaWVsZHM/LnZlcmJvc2VQYXJzaW5nRXJyb3JzID8/IHRoaXMudmVyYm9zZVBhcnNpbmdFcnJvcnM7XG4gICAgICAgIHRoaXMucmVzcG9uc2VGb3JtYXQgPSBmaWVsZHM/LnJlc3BvbnNlRm9ybWF0ID8/IHRoaXMucmVzcG9uc2VGb3JtYXQ7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IGZpZWxkcz8uZGVmYXVsdENvbmZpZyA/PyB0aGlzLmRlZmF1bHRDb25maWc7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBmaWVsZHM/Lm1ldGFkYXRhID8/IHRoaXMubWV0YWRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIHRvb2wgd2l0aCB0aGUgcHJvdmlkZWQgaW5wdXQgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBmb3IgdGhlIHRvb2wuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgdG9vbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0b29sJ3Mgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGxldCB0b29sSW5wdXQ7XG4gICAgICAgIGxldCBlbnJpY2hlZENvbmZpZyA9IGVuc3VyZUNvbmZpZyhtZXJnZUNvbmZpZ3ModGhpcy5kZWZhdWx0Q29uZmlnLCBjb25maWcpKTtcbiAgICAgICAgaWYgKF9pc1Rvb2xDYWxsKGlucHV0KSkge1xuICAgICAgICAgICAgdG9vbElucHV0ID0gaW5wdXQuYXJncztcbiAgICAgICAgICAgIGVucmljaGVkQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIC4uLmVucmljaGVkQ29uZmlnLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsOiBpbnB1dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b29sSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKHRvb2xJbnB1dCwgZW5yaWNoZWRDb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjMuMC5cbiAgICAgKlxuICAgICAqIENhbGxzIHRoZSB0b29sIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50LCBjb25maWd1cmF0aW9uLCBhbmQgdGFncy4gSXRcbiAgICAgKiBwYXJzZXMgdGhlIGlucHV0IGFjY29yZGluZyB0byB0aGUgc2NoZW1hLCBoYW5kbGVzIGFueSBlcnJvcnMsIGFuZFxuICAgICAqIG1hbmFnZXMgY2FsbGJhY2tzLlxuICAgICAqIEBwYXJhbSBhcmcgVGhlIGlucHV0IGFyZ3VtZW50IGZvciB0aGUgdG9vbC5cbiAgICAgKiBAcGFyYW0gY29uZmlnQXJnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3IgY2FsbGJhY2tzIGZvciB0aGUgdG9vbC5cbiAgICAgKiBAcGFyYW0gdGFncyBPcHRpb25hbCB0YWdzIGZvciB0aGUgdG9vbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGwoYXJnLCBjb25maWdBcmcsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHRhZ3MpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBhY3R1YWwgaW5wdXQgdGhhdCBuZWVkcyBwYXJzaW5nL3ZhbGlkYXRpb24uXG4gICAgICAgIC8vIElmIGFyZyBpcyBhIFRvb2xDYWxsLCB1c2UgaXRzIGFyZ3M7IG90aGVyd2lzZSwgdXNlIGFyZyBkaXJlY3RseS5cbiAgICAgICAgY29uc3QgaW5wdXRGb3JWYWxpZGF0aW9uID0gX2lzVG9vbENhbGwoYXJnKSA/IGFyZy5hcmdzIDogYXJnO1xuICAgICAgICBsZXQgcGFyc2VkOyAvLyBUaGlzIHdpbGwgaG9sZCB0aGUgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBpbnB1dCBvZiB0aGUgZXhwZWN0ZWQgb3V0cHV0IHR5cGUuXG4gICAgICAgIGlmIChpc0ludGVyb3Bab2RTY2hlbWEodGhpcy5zY2hlbWEpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBpbnB1dEZvclZhbGlkYXRpb24gLSBUUyBuZWVkcyBoZWxwIGhlcmUgYXMgaXQgY2FuJ3QgZXhjbHVkZSBUb29sQ2FsbCBiYXNlZCBvbiB0aGUgY2hlY2tcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBhd2FpdCBpbnRlcm9wUGFyc2VBc3luYyh0aGlzLnNjaGVtYSwgaW5wdXRGb3JWYWxpZGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBgUmVjZWl2ZWQgdG9vbCBpbnB1dCBkaWQgbm90IG1hdGNoIGV4cGVjdGVkIHNjaGVtYWA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmVyYm9zZVBhcnNpbmdFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuRGV0YWlsczogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFzcyB0aGUgb3JpZ2luYWwgcmF3IGlucHV0IGFyZyB0byB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24obWVzc2FnZSwgSlNPTi5zdHJpbmdpZnkoYXJnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZShpbnB1dEZvclZhbGlkYXRpb24sIHRoaXMuc2NoZW1hKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBgUmVjZWl2ZWQgdG9vbCBpbnB1dCBkaWQgbm90IG1hdGNoIGV4cGVjdGVkIHNjaGVtYWA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmVyYm9zZVBhcnNpbmdFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuRGV0YWlsczogJHtyZXN1bHQuZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChlKSA9PiBgJHtlLmtleXdvcmRMb2NhdGlvbn06ICR7ZS5lcnJvcn1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCJcXG5cIil9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFzcyB0aGUgb3JpZ2luYWwgcmF3IGlucHV0IGFyZyB0byB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24obWVzc2FnZSwgSlNPTi5zdHJpbmdpZnkoYXJnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBc3NpZ24gdGhlIHZhbGlkYXRlZCBpbnB1dCB0byBwYXJzZWRcbiAgICAgICAgICAgIC8vIFdlIGNhc3QgaGVyZSBiZWNhdXNlIHZhbGlkYXRlKCkgZG9lc24ndCBuYXJyb3cgdGhlIHR5cGUgc3VmZmljaWVudGx5IGZvciBUUywgYnV0IHdlIGtub3cgaXQncyB2YWxpZC5cbiAgICAgICAgICAgIHBhcnNlZCA9IGlucHV0Rm9yVmFsaWRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSBwYXJzZUNhbGxiYWNrQ29uZmlnQXJnKGNvbmZpZ0FyZyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBDYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGNvbmZpZy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBjb25maWcudGFncyB8fCB0YWdzLCB0aGlzLnRhZ3MsIGNvbmZpZy5tZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVUb29sU3RhcnQodGhpcy50b0pTT04oKSwgXG4gICAgICAgIC8vIExvZyB0aGUgb3JpZ2luYWwgcmF3IGlucHV0IGFyZ1xuICAgICAgICB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiID8gYXJnIDogSlNPTi5zdHJpbmdpZnkoYXJnKSwgY29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWcucnVuTmFtZSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQYXNzIHRoZSBjb3JyZWN0bHkgdHlwZWQgcGFyc2VkIGlucHV0IHRvIF9jYWxsXG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLl9jYWxsKHBhcnNlZCwgcnVuTWFuYWdlciwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlVG9vbEVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgbGV0IGFydGlmYWN0O1xuICAgICAgICBpZiAodGhpcy5yZXNwb25zZUZvcm1hdCA9PT0gXCJjb250ZW50X2FuZF9hcnRpZmFjdFwiKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBbY29udGVudCwgYXJ0aWZhY3RdID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb29sIHJlc3BvbnNlIGZvcm1hdCBpcyBcImNvbnRlbnRfYW5kX2FydGlmYWN0XCIgYnV0IHRoZSBvdXRwdXQgd2FzIG5vdCBhIHR3by10dXBsZS5cXG5SZXN1bHQ6ICR7SlNPTi5zdHJpbmdpZnkocmVzdWx0KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvb2xDYWxsSWQ7XG4gICAgICAgIC8vIEV4dHJhY3QgdG9vbENhbGxJZCBPTkxZIGlmIHRoZSBvcmlnaW5hbCBhcmcgd2FzIGEgVG9vbENhbGxcbiAgICAgICAgaWYgKF9pc1Rvb2xDYWxsKGFyZykpIHtcbiAgICAgICAgICAgIHRvb2xDYWxsSWQgPSBhcmcuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3IgaWYgaXQgd2FzIHByb3ZpZGVkIGluIHRoZSBjb25maWcncyB0b29sQ2FsbCBwcm9wZXJ0eVxuICAgICAgICBpZiAoIXRvb2xDYWxsSWQgJiYgX2NvbmZpZ0hhc1Rvb2xDYWxsSWQoY29uZmlnKSkge1xuICAgICAgICAgICAgdG9vbENhbGxJZCA9IGNvbmZpZy50b29sQ2FsbC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRPdXRwdXQgPSBfZm9ybWF0VG9vbE91dHB1dCh7XG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgYXJ0aWZhY3QsXG4gICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVUb29sRW5kKGZvcm1hdHRlZE91dHB1dCk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRPdXRwdXQ7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBUb29scyB0aGF0IGFjY2VwdCBpbnB1dCBhcyBhIHN0cmluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRvb2wgZXh0ZW5kcyBTdHJ1Y3R1cmVkVG9vbCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogelxuICAgICAgICAgICAgICAgIC5vYmplY3QoeyBpbnB1dDogei5zdHJpbmcoKS5vcHRpb25hbCgpIH0pXG4gICAgICAgICAgICAgICAgLnRyYW5zZm9ybSgob2JqKSA9PiBvYmouaW5wdXQpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjMuMC5cbiAgICAgKlxuICAgICAqIENhbGxzIHRoZSB0b29sIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50IGFuZCBjYWxsYmFja3MuIEl0IGhhbmRsZXNcbiAgICAgKiBzdHJpbmcgaW5wdXRzIHNwZWNpZmljYWxseS5cbiAgICAgKiBAcGFyYW0gYXJnIFRoZSBpbnB1dCBhcmd1bWVudCBmb3IgdGhlIHRvb2wsIHdoaWNoIGNhbiBiZSBhIHN0cmluZywgdW5kZWZpbmVkLCBvciBhbiBpbnB1dCBvZiB0aGUgdG9vbCdzIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIE9wdGlvbmFsIGNhbGxiYWNrcyBmb3IgdGhlIHRvb2wuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHN0cmluZy5cbiAgICAgKi9cbiAgICAvLyBNYXRjaCB0aGUgYmFzZSBjbGFzcyBzaWduYXR1cmUgaW5jbHVkaW5nIHRoZSBnZW5lcmljcyBhbmQgY29uZGl0aW9uYWwgcmV0dXJuIHR5cGVcbiAgICBjYWxsKGFyZywgY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIGlucHV0IGZvciB0aGUgYmFzZSBjbGFzcyBjYWxsIG1ldGhvZC5cbiAgICAgICAgLy8gSWYgYXJnIGlzIHN0cmluZyBvciB1bmRlZmluZWQsIHdyYXAgaXQ7IG90aGVyd2lzZSwgcGFzcyBUb29sQ2FsbCBvciB7IGlucHV0OiAuLi4gfSBkaXJlY3RseS5cbiAgICAgICAgY29uc3Qgc3RydWN0dXJlZEFyZyA9IHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgfHwgYXJnID09IG51bGwgPyB7IGlucHV0OiBhcmcgfSA6IGFyZztcbiAgICAgICAgLy8gRW5zdXJlIFRDb25maWcgaXMgcGFzc2VkIHRvIHN1cGVyLmNhbGxcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhbGwoc3RydWN0dXJlZEFyZywgY2FsbGJhY2tzKTtcbiAgICB9XG59XG4vKipcbiAqIEEgdG9vbCB0aGF0IGNhbiBiZSBjcmVhdGVkIGR5bmFtaWNhbGx5IGZyb20gYSBmdW5jdGlvbiwgbmFtZSwgYW5kIGRlc2NyaXB0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRHluYW1pY1Rvb2wgZXh0ZW5kcyBUb29sIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiRHluYW1pY1Rvb2xcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5mdW5jID0gZmllbGRzLmZ1bmM7XG4gICAgICAgIHRoaXMucmV0dXJuRGlyZWN0ID0gZmllbGRzLnJldHVybkRpcmVjdCA/PyB0aGlzLnJldHVybkRpcmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4zLjAuXG4gICAgICovXG4gICAgYXN5bmMgY2FsbChhcmcsIGNvbmZpZ0FyZykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBwYXJzZUNhbGxiYWNrQ29uZmlnQXJnKGNvbmZpZ0FyZyk7XG4gICAgICAgIGlmIChjb25maWcucnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcucnVuTmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHRoZSBUb29sIGNsYXNzJ3MgY2FsbCBtZXRob2QsIHBhc3NpbmcgZ2VuZXJpY3MgdGhyb3VnaFxuICAgICAgICAvLyBDYXN0IGNvbmZpZyB0byBUQ29uZmlnIHRvIHNhdGlzZnkgdGhlIHN1cGVyLmNhbGwgc2lnbmF0dXJlXG4gICAgICAgIHJldHVybiBzdXBlci5jYWxsKGFyZywgY29uZmlnKTtcbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhc3luYyBfY2FsbChpbnB1dCwgLy8gRHluYW1pY1Rvb2wncyBfY2FsbCBzcGVjaWZpY2FsbHkgZXhwZWN0cyBhIHN0cmluZyBhZnRlciBzY2hlbWEgdHJhbnNmb3JtYXRpb25cbiAgICBydW5NYW5hZ2VyLCBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhpbnB1dCwgcnVuTWFuYWdlciwgcGFyZW50Q29uZmlnKTtcbiAgICB9XG59XG4vKipcbiAqIEEgdG9vbCB0aGF0IGNhbiBiZSBjcmVhdGVkIGR5bmFtaWNhbGx5IGZyb20gYSBmdW5jdGlvbiwgbmFtZSwgYW5kXG4gKiBkZXNjcmlwdGlvbiwgZGVzaWduZWQgdG8gd29yayB3aXRoIHN0cnVjdHVyZWQgZGF0YS4gSXQgZXh0ZW5kcyB0aGVcbiAqIFN0cnVjdHVyZWRUb29sIGNsYXNzIGFuZCBvdmVycmlkZXMgdGhlIF9jYWxsIG1ldGhvZCB0byBleGVjdXRlIHRoZVxuICogcHJvdmlkZWQgZnVuY3Rpb24gd2hlbiB0aGUgdG9vbCBpcyBjYWxsZWQuXG4gKlxuICogU2NoZW1hIGNhbiBiZSBwYXNzZWQgYXMgWm9kIG9yIEpTT04gc2NoZW1hLiBUaGUgdG9vbCB3aWxsIG5vdCB2YWxpZGF0ZVxuICogaW5wdXQgaWYgSlNPTiBzY2hlbWEgaXMgcGFzc2VkLlxuICovXG5leHBvcnQgY2xhc3MgRHluYW1pY1N0cnVjdHVyZWRUb29sIGV4dGVuZHMgU3RydWN0dXJlZFRvb2wge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJEeW5hbWljU3RydWN0dXJlZFRvb2xcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2hlbWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgICAgICB0aGlzLnJldHVybkRpcmVjdCA9IGZpZWxkcy5yZXR1cm5EaXJlY3QgPz8gdGhpcy5yZXR1cm5EaXJlY3Q7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZmllbGRzLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4zLjAuXG4gICAgICovXG4gICAgLy8gTWF0Y2ggdGhlIGJhc2UgY2xhc3Mgc2lnbmF0dXJlXG4gICAgYXN5bmMgY2FsbChhcmcsIGNvbmZpZ0FyZywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgdGFncykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBwYXJzZUNhbGxiYWNrQ29uZmlnQXJnKGNvbmZpZ0FyZyk7XG4gICAgICAgIGlmIChjb25maWcucnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcucnVuTmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHRoZSBiYXNlIGNsYXNzIG1ldGhvZCwgcGFzc2luZyBnZW5lcmljcyB0aHJvdWdoXG4gICAgICAgIC8vIENhc3QgY29uZmlnIHRvIFRDb25maWcgdG8gc2F0aXNmeSB0aGUgc3VwZXIuY2FsbCBzaWduYXR1cmVcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhbGwoYXJnLCBjb25maWcsIHRhZ3MpO1xuICAgIH1cbiAgICBfY2FsbChhcmcsIHJ1bk1hbmFnZXIsIHBhcmVudENvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGFyZywgcnVuTWFuYWdlciwgcGFyZW50Q29uZmlnKTtcbiAgICB9XG59XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHRvb2xraXRzIGluIExhbmdDaGFpbi4gVG9vbGtpdHMgYXJlIGNvbGxlY3Rpb25zXG4gKiBvZiB0b29scyB0aGF0IGFnZW50cyBjYW4gdXNlLiBTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoZSBgdG9vbHNgXG4gKiBwcm9wZXJ0eSB0byBwcm92aWRlIHRoZSBzcGVjaWZpYyB0b29scyBmb3IgdGhlIHRvb2xraXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlVG9vbGtpdCB7XG4gICAgZ2V0VG9vbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvb2xzO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB0b29sKGZ1bmMsIGZpZWxkcykge1xuICAgIGNvbnN0IGlzU2ltcGxlU3RyaW5nU2NoZW1hID0gaXNTaW1wbGVTdHJpbmdab2RTY2hlbWEoZmllbGRzLnNjaGVtYSk7XG4gICAgY29uc3QgaXNTdHJpbmdKU09OU2NoZW1hID0gdmFsaWRhdGVzT25seVN0cmluZ3MoZmllbGRzLnNjaGVtYSk7XG4gICAgLy8gSWYgdGhlIHNjaGVtYSBpcyBub3QgcHJvdmlkZWQsIG9yIGl0J3MgYSBzaW1wbGUgc3RyaW5nIHNjaGVtYSwgY3JlYXRlIGEgRHluYW1pY1Rvb2xcbiAgICBpZiAoIWZpZWxkcy5zY2hlbWEgfHwgaXNTaW1wbGVTdHJpbmdTY2hlbWEgfHwgaXNTdHJpbmdKU09OU2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgRHluYW1pY1Rvb2woe1xuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGZpZWxkcy5kZXNjcmlwdGlvbiA/P1xuICAgICAgICAgICAgICAgIChmaWVsZHMuc2NoZW1hICYmIGdldFNjaGVtYURlc2NyaXB0aW9uKGZpZWxkcy5zY2hlbWEpKSA/P1xuICAgICAgICAgICAgICAgIGAke2ZpZWxkcy5uYW1lfSB0b29sYCxcbiAgICAgICAgICAgIGZ1bmM6IGFzeW5jIChpbnB1dCwgcnVuTWFuYWdlciwgY29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMoY2hpbGRDb25maWcpLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRTIGRvZXNuJ3QgcmVzdHJpY3QgdGhlIHR5cGUgaGVyZSBiYXNlZCBvbiB0aGUgZ3VhcmQgYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZnVuYyhpbnB1dCwgY2hpbGRDb25maWcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzY2hlbWEgPSBmaWVsZHMuc2NoZW1hO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZmllbGRzLmRlc2NyaXB0aW9uID8/XG4gICAgICAgIGZpZWxkcy5zY2hlbWEuZGVzY3JpcHRpb24gPz9cbiAgICAgICAgYCR7ZmllbGRzLm5hbWV9IHRvb2xgO1xuICAgIHJldHVybiBuZXcgRHluYW1pY1N0cnVjdHVyZWRUb29sKHtcbiAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBmdW5jOiBhc3luYyAoaW5wdXQsIHJ1bk1hbmFnZXIsIGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZENvbmZpZyA9IHBhdGNoQ29uZmlnKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdm9pZCBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcocGlja1J1bm5hYmxlQ29uZmlnS2V5cyhjaGlsZENvbmZpZyksIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZnVuYyhpbnB1dCwgY2hpbGRDb25maWcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9mb3JtYXRUb29sT3V0cHV0KHBhcmFtcykge1xuICAgIGNvbnN0IHsgY29udGVudCwgYXJ0aWZhY3QsIHRvb2xDYWxsSWQsIG1ldGFkYXRhIH0gPSBwYXJhbXM7XG4gICAgaWYgKHRvb2xDYWxsSWQgJiYgIWlzRGlyZWN0VG9vbE91dHB1dChjb250ZW50KSkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvbnRlbnQpICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUb29sTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgIGFydGlmYWN0LFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUb29sTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBfc3RyaW5naWZ5KGNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIGFydGlmYWN0LFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG59XG5mdW5jdGlvbiBfc3RyaW5naWZ5KGNvbnRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY29udGVudCwgbnVsbCwgMikgPz8gXCJcIjtcbiAgICB9XG4gICAgY2F0Y2ggKF9ub09wKSB7XG4gICAgICAgIHJldHVybiBgJHtjb250ZW50fWA7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/types.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isLangChainTool: () => (/* binding */ isLangChainTool),\n/* harmony export */   isRunnableToolLike: () => (/* binding */ isRunnableToolLike),\n/* harmony export */   isStructuredTool: () => (/* binding */ isStructuredTool),\n/* harmony export */   isStructuredToolParams: () => (/* binding */ isStructuredToolParams)\n/* harmony export */ });\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _utils_types_zod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/types/zod.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.js\");\n\n\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nfunction isStructuredTool(tool) {\n    return (tool !== undefined &&\n        Array.isArray(tool.lc_namespace));\n}\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nfunction isRunnableToolLike(tool) {\n    return (tool !== undefined &&\n        _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(tool) &&\n        \"lc_name\" in tool.constructor &&\n        typeof tool.constructor.lc_name === \"function\" &&\n        tool.constructor.lc_name() === \"RunnableToolLike\");\n}\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nfunction isStructuredToolParams(tool) {\n    return (!!tool &&\n        typeof tool === \"object\" &&\n        \"name\" in tool &&\n        \"schema\" in tool &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ((0,_utils_types_zod_js__WEBPACK_IMPORTED_MODULE_1__.isInteropZodSchema)(tool.schema) ||\n            (tool.schema != null &&\n                typeof tool.schema === \"object\" &&\n                \"type\" in tool.schema &&\n                typeof tool.schema.type === \"string\" &&\n                [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"].includes(tool.schema.type))));\n}\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nfunction isLangChainTool(tool) {\n    return (isStructuredToolParams(tool) ||\n        isRunnableToolLike(tool) ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        isStructuredTool(tool));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlEO0FBQ1c7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrREFBa0Q7QUFDN0QsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ087QUFDUDtBQUNBLFFBQVEsd0RBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLDhCQUE4QjtBQUMzQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdUVBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLDhCQUE4QjtBQUMzQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx0b29sc1xcdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUnVubmFibGUsIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBpc0ludGVyb3Bab2RTY2hlbWEsIH0gZnJvbSBcIi4uL3V0aWxzL3R5cGVzL3pvZC5qc1wiO1xuLyoqXG4gKiBDb25maXJtIHdoZXRoZXIgdGhlIGlucHV0dGVkIHRvb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYFN0cnVjdHVyZWRUb29sSW50ZXJmYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdHVyZWRUb29sSW50ZXJmYWNlIHwgSlNPTlNjaGVtYSB8IHVuZGVmaW5lZH0gdG9vbCBUaGUgdG9vbCB0byBjaGVjayBpZiBpdCBpcyBhbiBpbnN0YW5jZSBvZiBgU3RydWN0dXJlZFRvb2xJbnRlcmZhY2VgLlxuICogQHJldHVybnMge3Rvb2wgaXMgU3RydWN0dXJlZFRvb2xJbnRlcmZhY2V9IFdoZXRoZXIgdGhlIGlucHV0dGVkIHRvb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYFN0cnVjdHVyZWRUb29sSW50ZXJmYWNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RydWN0dXJlZFRvb2wodG9vbCkge1xuICAgIHJldHVybiAodG9vbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodG9vbC5sY19uYW1lc3BhY2UpKTtcbn1cbi8qKlxuICogQ29uZmlybSB3aGV0aGVyIHRoZSBpbnB1dHRlZCB0b29sIGlzIGFuIGluc3RhbmNlIG9mIGBSdW5uYWJsZVRvb2xMaWtlYC5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd24gfCB1bmRlZmluZWR9IHRvb2wgVGhlIHRvb2wgdG8gY2hlY2sgaWYgaXQgaXMgYW4gaW5zdGFuY2Ugb2YgYFJ1bm5hYmxlVG9vbExpa2VgLlxuICogQHJldHVybnMge3Rvb2wgaXMgUnVubmFibGVUb29sTGlrZX0gV2hldGhlciB0aGUgaW5wdXR0ZWQgdG9vbCBpcyBhbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1J1bm5hYmxlVG9vbExpa2UodG9vbCkge1xuICAgIHJldHVybiAodG9vbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIFJ1bm5hYmxlLmlzUnVubmFibGUodG9vbCkgJiZcbiAgICAgICAgXCJsY19uYW1lXCIgaW4gdG9vbC5jb25zdHJ1Y3RvciAmJlxuICAgICAgICB0eXBlb2YgdG9vbC5jb25zdHJ1Y3Rvci5sY19uYW1lID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdG9vbC5jb25zdHJ1Y3Rvci5sY19uYW1lKCkgPT09IFwiUnVubmFibGVUb29sTGlrZVwiKTtcbn1cbi8qKlxuICogQ29uZmlybSB3aGV0aGVyIG9yIG5vdCB0aGUgdG9vbCBjb250YWlucyB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXMgdG8gYmUgY29uc2lkZXJlZCBhIGBTdHJ1Y3R1cmVkVG9vbFBhcmFtc2AuXG4gKlxuICogQHBhcmFtIHt1bmtub3duIHwgdW5kZWZpbmVkfSB0b29sIFRoZSBvYmplY3QgdG8gY2hlY2sgaWYgaXQgaXMgYSBgU3RydWN0dXJlZFRvb2xQYXJhbXNgLlxuICogQHJldHVybnMge3Rvb2wgaXMgU3RydWN0dXJlZFRvb2xQYXJhbXN9IFdoZXRoZXIgdGhlIGlucHV0dGVkIG9iamVjdCBpcyBhIGBTdHJ1Y3R1cmVkVG9vbFBhcmFtc2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cnVjdHVyZWRUb29sUGFyYW1zKHRvb2wpIHtcbiAgICByZXR1cm4gKCEhdG9vbCAmJlxuICAgICAgICB0eXBlb2YgdG9vbCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcIm5hbWVcIiBpbiB0b29sICYmXG4gICAgICAgIFwic2NoZW1hXCIgaW4gdG9vbCAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAoaXNJbnRlcm9wWm9kU2NoZW1hKHRvb2wuc2NoZW1hKSB8fFxuICAgICAgICAgICAgKHRvb2wuc2NoZW1hICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdG9vbC5zY2hlbWEgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBcInR5cGVcIiBpbiB0b29sLnNjaGVtYSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0b29sLnNjaGVtYS50eXBlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgW1wibnVsbFwiLCBcImJvb2xlYW5cIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcIm51bWJlclwiLCBcInN0cmluZ1wiXS5pbmNsdWRlcyh0b29sLnNjaGVtYS50eXBlKSkpKTtcbn1cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHRvb2wgaXMgb25lIG9mIFN0cnVjdHVyZWRUb29sLCBSdW5uYWJsZVRvb2wgb3IgU3RydWN0dXJlZFRvb2xQYXJhbXMuXG4gKiBJdCByZXR1cm5zIGBpcyBTdHJ1Y3R1cmVkVG9vbFBhcmFtc2Agc2luY2UgdGhhdCBpcyB0aGUgbW9zdCBtaW5pbWFsIGludGVyZmFjZSBvZiB0aGUgdGhyZWUsXG4gKiB3aGlsZSBzdGlsbCBjb250YWluaW5nIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllcyB0byBiZSBwYXNzZWQgdG8gYSBMTE0gZm9yIHRvb2wgY2FsbGluZy5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd24gfCB1bmRlZmluZWR9IHRvb2wgVGhlIHRvb2wgdG8gY2hlY2sgaWYgaXQgaXMgYSBMYW5nQ2hhaW4gdG9vbC5cbiAqIEByZXR1cm5zIHt0b29sIGlzIFN0cnVjdHVyZWRUb29sUGFyYW1zfSBXaGV0aGVyIHRoZSBpbnB1dHRlZCB0b29sIGlzIGEgTGFuZ0NoYWluIHRvb2wuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xhbmdDaGFpblRvb2wodG9vbCkge1xuICAgIHJldHVybiAoaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtcyh0b29sKSB8fFxuICAgICAgICBpc1J1bm5hYmxlVG9vbExpa2UodG9vbCkgfHxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgaXNTdHJ1Y3R1cmVkVG9vbCh0b29sKSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToolInputParsingException: () => (/* binding */ ToolInputParsingException),\n/* harmony export */   _configHasToolCallId: () => (/* binding */ _configHasToolCallId),\n/* harmony export */   _isToolCall: () => (/* binding */ _isToolCall)\n/* harmony export */ });\nfunction _isToolCall(toolCall) {\n    return !!(toolCall &&\n        typeof toolCall === \"object\" &&\n        \"type\" in toolCall &&\n        toolCall.type === \"tool_call\");\n}\nfunction _configHasToolCallId(config) {\n    return !!(config &&\n        typeof config === \"object\" &&\n        \"toolCall\" in config &&\n        config.toolCall != null &&\n        typeof config.toolCall === \"object\" &&\n        \"id\" in config.toolCall &&\n        typeof config.toolCall.id === \"string\");\n}\n/**\n * Custom error class used to handle exceptions related to tool input parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nclass ToolInputParsingException extends Error {\n    constructor(message, output) {\n        super(message);\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.output = output;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHRvb2xzXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gX2lzVG9vbENhbGwodG9vbENhbGwpIHtcbiAgICByZXR1cm4gISEodG9vbENhbGwgJiZcbiAgICAgICAgdHlwZW9mIHRvb2xDYWxsID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIFwidHlwZVwiIGluIHRvb2xDYWxsICYmXG4gICAgICAgIHRvb2xDYWxsLnR5cGUgPT09IFwidG9vbF9jYWxsXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9jb25maWdIYXNUb29sQ2FsbElkKGNvbmZpZykge1xuICAgIHJldHVybiAhIShjb25maWcgJiZcbiAgICAgICAgdHlwZW9mIGNvbmZpZyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcInRvb2xDYWxsXCIgaW4gY29uZmlnICYmXG4gICAgICAgIGNvbmZpZy50b29sQ2FsbCAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBjb25maWcudG9vbENhbGwgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgXCJpZFwiIGluIGNvbmZpZy50b29sQ2FsbCAmJlxuICAgICAgICB0eXBlb2YgY29uZmlnLnRvb2xDYWxsLmlkID09PSBcInN0cmluZ1wiKTtcbn1cbi8qKlxuICogQ3VzdG9tIGVycm9yIGNsYXNzIHVzZWQgdG8gaGFuZGxlIGV4Y2VwdGlvbnMgcmVsYXRlZCB0byB0b29sIGlucHV0IHBhcnNpbmcuXG4gKiBJdCBleHRlbmRzIHRoZSBidWlsdC1pbiBgRXJyb3JgIGNsYXNzIGFuZCBhZGRzIGFuIG9wdGlvbmFsIGBvdXRwdXRgXG4gKiBwcm9wZXJ0eSB0aGF0IGNhbiBob2xkIHRoZSBvdXRwdXQgdGhhdCBjYXVzZWQgdGhlIGV4Y2VwdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3V0cHV0KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/base.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/base.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseTracer: () => (/* binding */ BaseTracer),\n/* harmony export */   isBaseTracer: () => (/* binding */ isBaseTracer)\n/* harmony export */ });\n/* harmony import */ var langsmith_run_trees__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith/run_trees */ \"(rsc)/./node_modules/langsmith/run_trees.js\");\n/* harmony import */ var _callbacks_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../callbacks/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.js\");\n\n\n\n// TODO: Remove and just use base LangSmith Run type\nconst convertRunTreeToRun = (runTree) => {\n    if (!runTree) {\n        return undefined;\n    }\n    // Important that we return the raw run tree object since the reference\n    // is mutated in other places.\n    // TODO: Remove places where this is being done.\n    // eslint-disable-next-line no-param-reassign\n    runTree.events = runTree.events ?? [];\n    // eslint-disable-next-line no-param-reassign\n    runTree.child_runs = runTree.child_runs ?? [];\n    // TODO: Remove this cast and just use the LangSmith RunTree type.\n    return runTree;\n};\nfunction convertRunToRunTree(run, parentRun) {\n    if (!run) {\n        return undefined;\n    }\n    return new langsmith_run_trees__WEBPACK_IMPORTED_MODULE_0__.RunTree({\n        ...run,\n        start_time: run._serialized_start_time ?? run.start_time,\n        parent_run: convertRunToRunTree(parentRun),\n        child_runs: run.child_runs\n            .map((r) => convertRunToRunTree(r))\n            .filter((r) => r !== undefined),\n        extra: {\n            ...run.extra,\n            runtime: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentSync)(),\n        },\n        tracingEnabled: false,\n    });\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nfunction isBaseTracer(x) {\n    return typeof x._addRunToRunMap === \"function\";\n}\nclass BaseTracer extends _callbacks_base_js__WEBPACK_IMPORTED_MODULE_1__.BaseCallbackHandler {\n    constructor(_fields) {\n        super(...arguments);\n        /** @deprecated Use `runTreeMap` instead. */\n        Object.defineProperty(this, \"runMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"runTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"usesRunTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    copy() {\n        return this;\n    }\n    getRunById(runId) {\n        if (runId === undefined) {\n            return undefined;\n        }\n        return this.usesRunTreeMap\n            ? convertRunTreeToRun(this.runTreeMap.get(runId))\n            : this.runMap.get(runId);\n    }\n    stringifyError(error) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (error instanceof Error) {\n            return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n        }\n        if (typeof error === \"string\") {\n            return error;\n        }\n        return `${error}`;\n    }\n    _addChildRun(parentRun, childRun) {\n        parentRun.child_runs.push(childRun);\n    }\n    _addRunToRunMap(run) {\n        const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } = (0,langsmith_run_trees__WEBPACK_IMPORTED_MODULE_0__.convertToDottedOrderFormat)(new Date(run.start_time).getTime(), run.id, run.execution_order);\n        const storedRun = { ...run };\n        const parentRun = this.getRunById(storedRun.parent_run_id);\n        if (storedRun.parent_run_id !== undefined) {\n            if (parentRun) {\n                this._addChildRun(parentRun, storedRun);\n                parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n                storedRun.trace_id = parentRun.trace_id;\n                if (parentRun.dotted_order !== undefined) {\n                    storedRun.dotted_order = [\n                        parentRun.dotted_order,\n                        currentDottedOrder,\n                    ].join(\".\");\n                    storedRun._serialized_start_time = microsecondPrecisionDatestring;\n                }\n                else {\n                    // This can happen naturally for callbacks added within a run\n                    // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n                }\n            }\n            else {\n                // This can happen naturally for callbacks added within a run\n                // console.debug(\n                //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n                // );\n            }\n        }\n        else {\n            storedRun.trace_id = storedRun.id;\n            storedRun.dotted_order = currentDottedOrder;\n            storedRun._serialized_start_time = microsecondPrecisionDatestring;\n        }\n        if (this.usesRunTreeMap) {\n            const runTree = convertRunToRunTree(storedRun, parentRun);\n            if (runTree !== undefined) {\n                this.runTreeMap.set(storedRun.id, runTree);\n            }\n        }\n        else {\n            this.runMap.set(storedRun.id, storedRun);\n        }\n        return storedRun;\n    }\n    async _endTrace(run) {\n        const parentRun = run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);\n        if (parentRun) {\n            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n        }\n        else {\n            await this.persistRun(run);\n        }\n        await this.onRunUpdate?.(run);\n        if (this.usesRunTreeMap) {\n            this.runTreeMap.delete(run.id);\n        }\n        else {\n            this.runMap.delete(run.id);\n        }\n    }\n    _getExecutionOrder(parentRunId) {\n        const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);\n        // If a run has no parent then execution order is 1\n        if (!parentRun) {\n            return 1;\n        }\n        return parentRun.child_execution_order + 1;\n    }\n    /**\n     * Create and add a run to the run map for LLM start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { prompts },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chat model start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { messages },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = output;\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        run.extra = { ...run.extra, ...extraParams };\n        await this.onLLMEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        run.extra = { ...run.extra, ...extraParams };\n        await this.onLLMError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chain start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? chain.id[chain.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: chain,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs,\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: runType ?? \"chain\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);\n        await this.onRunCreate?.(run);\n        await this.onChainStart?.(run);\n        return run;\n    }\n    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n        const run = this.getRunById(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = _coerceToDict(outputs, \"output\");\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n        const run = this.getRunById(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for tool start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? tool.id[tool.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: tool,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { input },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"tool\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onToolStart?.(run);\n        return run;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { output };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleToolError(error, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleAgentAction(action, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        const agentRun = run;\n        agentRun.actions = agentRun.actions || [];\n        agentRun.actions.push(action);\n        agentRun.events.push({\n            name: \"agent_action\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentAction?.(run);\n    }\n    async handleAgentEnd(action, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"agent_end\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentEnd?.(run);\n    }\n    /**\n     * Create and add a run to the run map for retriever start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? retriever.id[retriever.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: retriever,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { query },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"retriever\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onRetrieverStart?.(run);\n        return run;\n    }\n    async handleRetrieverEnd(documents, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { documents };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleRetrieverError(error, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleText(text, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"text\",\n            time: new Date().toISOString(),\n            kwargs: { text },\n        });\n        await this.onText?.(run);\n    }\n    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(`Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`);\n        }\n        run.events.push({\n            name: \"new_token\",\n            time: new Date().toISOString(),\n            kwargs: { token, idx, chunk: fields?.chunk },\n        });\n        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n        return run;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBFO0FBQ2Q7QUFDQTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3RUFBeUI7QUFDOUMsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDTyx5QkFBeUIsbUVBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxZQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBa0UsRUFBRSwrRUFBMEI7QUFDOUcsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5QkFBeUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx5QkFBeUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hELFNBQVM7QUFDVCxpREFBaUQsc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx0cmFjZXJzXFxiYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJ1blRyZWUsIGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0IH0gZnJvbSBcImxhbmdzbWl0aC9ydW5fdHJlZXNcIjtcbmltcG9ydCB7IEJhc2VDYWxsYmFja0hhbmRsZXIsIH0gZnJvbSBcIi4uL2NhbGxiYWNrcy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBnZXRSdW50aW1lRW52aXJvbm1lbnRTeW5jIH0gZnJvbSBcIi4uL3V0aWxzL2Vudi5qc1wiO1xuLy8gVE9ETzogUmVtb3ZlIGFuZCBqdXN0IHVzZSBiYXNlIExhbmdTbWl0aCBSdW4gdHlwZVxuY29uc3QgY29udmVydFJ1blRyZWVUb1J1biA9IChydW5UcmVlKSA9PiB7XG4gICAgaWYgKCFydW5UcmVlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEltcG9ydGFudCB0aGF0IHdlIHJldHVybiB0aGUgcmF3IHJ1biB0cmVlIG9iamVjdCBzaW5jZSB0aGUgcmVmZXJlbmNlXG4gICAgLy8gaXMgbXV0YXRlZCBpbiBvdGhlciBwbGFjZXMuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHBsYWNlcyB3aGVyZSB0aGlzIGlzIGJlaW5nIGRvbmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcnVuVHJlZS5ldmVudHMgPSBydW5UcmVlLmV2ZW50cyA/PyBbXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBydW5UcmVlLmNoaWxkX3J1bnMgPSBydW5UcmVlLmNoaWxkX3J1bnMgPz8gW107XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgY2FzdCBhbmQganVzdCB1c2UgdGhlIExhbmdTbWl0aCBSdW5UcmVlIHR5cGUuXG4gICAgcmV0dXJuIHJ1blRyZWU7XG59O1xuZnVuY3Rpb24gY29udmVydFJ1blRvUnVuVHJlZShydW4sIHBhcmVudFJ1bikge1xuICAgIGlmICghcnVuKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUnVuVHJlZSh7XG4gICAgICAgIC4uLnJ1bixcbiAgICAgICAgc3RhcnRfdGltZTogcnVuLl9zZXJpYWxpemVkX3N0YXJ0X3RpbWUgPz8gcnVuLnN0YXJ0X3RpbWUsXG4gICAgICAgIHBhcmVudF9ydW46IGNvbnZlcnRSdW5Ub1J1blRyZWUocGFyZW50UnVuKSxcbiAgICAgICAgY2hpbGRfcnVuczogcnVuLmNoaWxkX3J1bnNcbiAgICAgICAgICAgIC5tYXAoKHIpID0+IGNvbnZlcnRSdW5Ub1J1blRyZWUocikpXG4gICAgICAgICAgICAuZmlsdGVyKChyKSA9PiByICE9PSB1bmRlZmluZWQpLFxuICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgLi4ucnVuLmV4dHJhLFxuICAgICAgICAgICAgcnVudGltZTogZ2V0UnVudGltZUVudmlyb25tZW50U3luYygpLFxuICAgICAgICB9LFxuICAgICAgICB0cmFjaW5nRW5hYmxlZDogZmFsc2UsXG4gICAgfSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gX2NvZXJjZVRvRGljdCh2YWx1ZSwgZGVmYXVsdEtleSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiB7IFtkZWZhdWx0S2V5XTogdmFsdWUgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2VUcmFjZXIoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeC5fYWRkUnVuVG9SdW5NYXAgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydCBjbGFzcyBCYXNlVHJhY2VyIGV4dGVuZHMgQmFzZUNhbGxiYWNrSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoX2ZpZWxkcykge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGBydW5UcmVlTWFwYCBpbnN0ZWFkLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5NYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuVHJlZU1hcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1c2VzUnVuVHJlZU1hcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRSdW5CeUlkKHJ1bklkKSB7XG4gICAgICAgIGlmIChydW5JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXNSdW5UcmVlTWFwXG4gICAgICAgICAgICA/IGNvbnZlcnRSdW5UcmVlVG9SdW4odGhpcy5ydW5UcmVlTWFwLmdldChydW5JZCkpXG4gICAgICAgICAgICA6IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgfVxuICAgIHN0cmluZ2lmeUVycm9yKGVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlICsgKGVycm9yPy5zdGFjayA/IGBcXG5cXG4ke2Vycm9yLnN0YWNrfWAgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2Vycm9yfWA7XG4gICAgfVxuICAgIF9hZGRDaGlsZFJ1bihwYXJlbnRSdW4sIGNoaWxkUnVuKSB7XG4gICAgICAgIHBhcmVudFJ1bi5jaGlsZF9ydW5zLnB1c2goY2hpbGRSdW4pO1xuICAgIH1cbiAgICBfYWRkUnVuVG9SdW5NYXAocnVuKSB7XG4gICAgICAgIGNvbnN0IHsgZG90dGVkT3JkZXI6IGN1cnJlbnREb3R0ZWRPcmRlciwgbWljcm9zZWNvbmRQcmVjaXNpb25EYXRlc3RyaW5nIH0gPSBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChuZXcgRGF0ZShydW4uc3RhcnRfdGltZSkuZ2V0VGltZSgpLCBydW4uaWQsIHJ1bi5leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICBjb25zdCBzdG9yZWRSdW4gPSB7IC4uLnJ1biB9O1xuICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSB0aGlzLmdldFJ1bkJ5SWQoc3RvcmVkUnVuLnBhcmVudF9ydW5faWQpO1xuICAgICAgICBpZiAoc3RvcmVkUnVuLnBhcmVudF9ydW5faWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudFJ1bikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkUnVuKHBhcmVudFJ1biwgc3RvcmVkUnVuKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyID0gTWF0aC5tYXgocGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciwgc3RvcmVkUnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgICAgICAgICAgc3RvcmVkUnVuLnRyYWNlX2lkID0gcGFyZW50UnVuLnRyYWNlX2lkO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRSdW4uZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUnVuLmRvdHRlZF9vcmRlciA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RG90dGVkT3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbihcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZFJ1bi5fc2VyaWFsaXplZF9zdGFydF90aW1lID0gbWljcm9zZWNvbmRQcmVjaXNpb25EYXRlc3RyaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIG5hdHVyYWxseSBmb3IgY2FsbGJhY2tzIGFkZGVkIHdpdGhpbiBhIHJ1blxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKGBQYXJlbnQgcnVuIHdpdGggVVVJRCAke3N0b3JlZFJ1bi5wYXJlbnRfcnVuX2lkfSBoYXMgbm8gZG90dGVkIG9yZGVyLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBuYXR1cmFsbHkgZm9yIGNhbGxiYWNrcyBhZGRlZCB3aXRoaW4gYSBydW5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgICAgIC8vICAgYFBhcmVudCBydW4gd2l0aCBVVUlEICR7c3RvcmVkUnVuLnBhcmVudF9ydW5faWR9IG5vdCBmb3VuZC5gXG4gICAgICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3JlZFJ1bi50cmFjZV9pZCA9IHN0b3JlZFJ1bi5pZDtcbiAgICAgICAgICAgIHN0b3JlZFJ1bi5kb3R0ZWRfb3JkZXIgPSBjdXJyZW50RG90dGVkT3JkZXI7XG4gICAgICAgICAgICBzdG9yZWRSdW4uX3NlcmlhbGl6ZWRfc3RhcnRfdGltZSA9IG1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2VzUnVuVHJlZU1hcCkge1xuICAgICAgICAgICAgY29uc3QgcnVuVHJlZSA9IGNvbnZlcnRSdW5Ub1J1blRyZWUoc3RvcmVkUnVuLCBwYXJlbnRSdW4pO1xuICAgICAgICAgICAgaWYgKHJ1blRyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVHJlZU1hcC5zZXQoc3RvcmVkUnVuLmlkLCBydW5UcmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucnVuTWFwLnNldChzdG9yZWRSdW4uaWQsIHN0b3JlZFJ1bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlZFJ1bjtcbiAgICB9XG4gICAgYXN5bmMgX2VuZFRyYWNlKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSBydW4ucGFyZW50X3J1bl9pZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0UnVuQnlJZChydW4ucGFyZW50X3J1bl9pZCk7XG4gICAgICAgIGlmIChwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgIHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIgPSBNYXRoLm1heChwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBydW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdFJ1bihydW4pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5VcGRhdGU/LihydW4pO1xuICAgICAgICBpZiAodGhpcy51c2VzUnVuVHJlZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5ydW5UcmVlTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ydW5NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1biA9IHBhcmVudFJ1bklkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRSdW5CeUlkKHBhcmVudFJ1bklkKTtcbiAgICAgICAgLy8gSWYgYSBydW4gaGFzIG5vIHBhcmVudCB0aGVuIGV4ZWN1dGlvbiBvcmRlciBpcyAxXG4gICAgICAgIGlmICghcGFyZW50UnVuKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgYWRkIGEgcnVuIHRvIHRoZSBydW4gbWFwIGZvciBMTE0gc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JMTE1TdGFydChsbG0sIHByb21wdHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGZpbmFsRXh0cmFQYXJhbXMgPSBtZXRhZGF0YVxuICAgICAgICAgICAgPyB7IC4uLmV4dHJhUGFyYW1zLCBtZXRhZGF0YSB9XG4gICAgICAgICAgICA6IGV4dHJhUGFyYW1zO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IGxsbS5pZFtsbG0uaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBsbG0sXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0czogeyBwcm9tcHRzIH0sXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwibGxtXCIsXG4gICAgICAgICAgICBleHRyYTogZmluYWxFeHRyYVBhcmFtcyA/PyB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW5Ub1J1bk1hcChydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1TdGFydChsbG0sIHByb21wdHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvckxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuQ3JlYXRlPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTVN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIGNoYXQgbW9kZWwgc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBmaW5hbEV4dHJhUGFyYW1zID0gbWV0YWRhdGFcbiAgICAgICAgICAgID8geyAuLi5leHRyYVBhcmFtcywgbWV0YWRhdGEgfVxuICAgICAgICAgICAgOiBleHRyYVBhcmFtcztcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBsbG0uaWRbbGxtLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogbGxtLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgbWVzc2FnZXMgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgICAgICAgIGV4dHJhOiBmaW5hbEV4dHJhUGFyYW1zID8/IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYXRNb2RlbFN0YXJ0KGxsbSwgbWVzc2FnZXMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvckNoYXRNb2RlbFN0YXJ0KGxsbSwgbWVzc2FnZXMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1bkNyZWF0ZT8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVuZChvdXRwdXQsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBleHRyYVBhcmFtcykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBMTE0gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSBvdXRwdXQ7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgcnVuLmV4dHJhID0geyAuLi5ydW4uZXh0cmEsIC4uLmV4dHJhUGFyYW1zIH07XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1FbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FcnJvcihlcnJvciwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGV4dHJhUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIExMTSBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bi5leHRyYSA9IHsgLi4ucnVuLmV4dHJhLCAuLi5leHRyYVBhcmFtcyB9O1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHJ1biB0byB0aGUgcnVuIG1hcCBmb3IgY2hhaW4gc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIHJ1blR5cGUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBjaGFpbi5pZFtjaGFpbi5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGNoYWluLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlID8/IFwiY2hhaW5cIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuVG9SdW5NYXAocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBydW5UeXBlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvckNoYWluU3RhcnQoY2hhaW4sIGlucHV0cywgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgcnVuVHlwZSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRW5kKG91dHB1dHMsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoYWluIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0gX2NvZXJjZVRvRGljdChvdXRwdXRzLCBcIm91dHB1dFwiKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa3dhcmdzPy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuLmlucHV0cyA9IF9jb2VyY2VUb0RpY3Qoa3dhcmdzLmlucHV0cywgXCJpbnB1dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5FbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVycm9yKGVycm9yLCBydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGFpbiBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrd2FyZ3M/LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gX2NvZXJjZVRvRGljdChrd2FyZ3MuaW5wdXRzLCBcImlucHV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMub25DaGFpbkVycm9yPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIHRvb2wgc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyB0b29sLmlkW3Rvb2wuaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB0b29sLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgaW5wdXQgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW5Ub1J1bk1hcChydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yVG9vbFN0YXJ0KHRvb2wsIGlucHV0LCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1bkNyZWF0ZT8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInRvb2xcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0geyBvdXRwdXQgfTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uVG9vbEVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnJvciwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRvb2wgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50UnVuID0gcnVuO1xuICAgICAgICBhZ2VudFJ1bi5hY3Rpb25zID0gYWdlbnRSdW4uYWN0aW9ucyB8fCBbXTtcbiAgICAgICAgYWdlbnRSdW4uYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIGFnZW50UnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWdlbnRfYWN0aW9uXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgYWN0aW9uIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQWdlbnRBY3Rpb24/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEVuZChhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImFnZW50X2VuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IGFjdGlvbiB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkFnZW50RW5kPy4ocnVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIHJldHJpZXZlciBzdGFydCBldmVudHMuXG4gICAgICogVGhpcyBtdXN0IHNvbWV0aW1lcyBiZSBkb25lIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICogd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZCwgc28gd2UgZXhwb3NlIGl0IGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmUuXG4gICAgICovXG4gICAgX2NyZWF0ZVJ1bkZvclJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyByZXRyaWV2ZXIuaWRbcmV0cmlldmVyLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogcmV0cmlldmVyLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgcXVlcnkgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwicmV0cmlldmVyXCIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGV4dHJhOiBtZXRhZGF0YSA/IHsgbWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUmV0cmlldmVyU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFbmQoZG9jdW1lbnRzLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInJldHJpZXZlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXRyaWV2ZXIgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4ub3V0cHV0cyA9IHsgZG9jdW1lbnRzIH07XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJldHJpZXZlckVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVycm9yKGVycm9yLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInJldHJpZXZlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXRyaWV2ZXIgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SZXRyaWV2ZXJFcnJvcj8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRleHQodGV4dCwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IHRleHQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25UZXh0Py4ocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNTmV3VG9rZW4odG9rZW4sIGlkeCwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGZpZWxkcykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJydW5JZFwiIHByb3ZpZGVkIHRvIFwiaGFuZGxlTExNTmV3VG9rZW5cIiBjYWxsYmFjay5gKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJuZXdfdG9rZW5cIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGt3YXJnczogeyB0b2tlbiwgaWR4LCBjaHVuazogZmllbGRzPy5jaHVuayB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTU5ld1Rva2VuPy4ocnVuLCB0b2tlbiwgeyBjaHVuazogZmllbGRzPy5jaHVuayB9KTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/console.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/console.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsoleCallbackHandler: () => (/* binding */ ConsoleCallbackHandler)\n/* harmony export */ });\n/* harmony import */ var ansi_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ansi-styles */ \"(rsc)/./node_modules/ansi-styles/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\");\n\n\nfunction wrap(style, text) {\n    return `${style.open}${text}${style.close}`;\n}\nfunction tryJsonStringify(obj, fallback) {\n    try {\n        return JSON.stringify(obj, null, 2);\n    }\n    catch (err) {\n        return fallback;\n    }\n}\nfunction formatKVMapItem(value) {\n    if (typeof value === \"string\") {\n        return value.trim();\n    }\n    if (value === null || value === undefined) {\n        return value;\n    }\n    return tryJsonStringify(value, value.toString());\n}\nfunction elapsed(run) {\n    if (!run.end_time)\n        return \"\";\n    const elapsed = run.end_time - run.start_time;\n    if (elapsed < 1000) {\n        return `${elapsed}ms`;\n    }\n    return `${(elapsed / 1000).toFixed(2)}s`;\n}\nconst { color } = ansi_styles__WEBPACK_IMPORTED_MODULE_0__;\n/**\n * A tracer that logs all events to the console. It extends from the\n * `BaseTracer` class and overrides its methods to provide custom logging\n * functionality.\n * @example\n * ```typescript\n *\n * const llm = new ChatAnthropic({\n *   temperature: 0,\n *   tags: [\"example\", \"callbacks\", \"constructor\"],\n *   callbacks: [new ConsoleCallbackHandler()],\n * });\n *\n * ```\n */\nclass ConsoleCallbackHandler extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseTracer {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"console_callback_handler\"\n        });\n    }\n    /**\n     * Method used to persist the run. In this case, it simply returns a\n     * resolved promise as there's no persistence logic.\n     * @param _run The run to persist.\n     * @returns A resolved promise.\n     */\n    persistRun(_run) {\n        return Promise.resolve();\n    }\n    // utility methods\n    /**\n     * Method used to get all the parent runs of a given run.\n     * @param run The run whose parents are to be retrieved.\n     * @returns An array of parent runs.\n     */\n    getParents(run) {\n        const parents = [];\n        let currentRun = run;\n        while (currentRun.parent_run_id) {\n            const parent = this.runMap.get(currentRun.parent_run_id);\n            if (parent) {\n                parents.push(parent);\n                currentRun = parent;\n            }\n            else {\n                break;\n            }\n        }\n        return parents;\n    }\n    /**\n     * Method used to get a string representation of the run's lineage, which\n     * is used in logging.\n     * @param run The run whose lineage is to be retrieved.\n     * @returns A string representation of the run's lineage.\n     */\n    getBreadcrumbs(run) {\n        const parents = this.getParents(run).reverse();\n        const string = [...parents, run]\n            .map((parent, i, arr) => {\n            const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;\n            return i === arr.length - 1 ? wrap(ansi_styles__WEBPACK_IMPORTED_MODULE_0__.bold, name) : name;\n        })\n            .join(\" > \");\n        return wrap(color.grey, string);\n    }\n    // logging methods\n    /**\n     * Method used to log the start of a chain run.\n     * @param run The chain run that has started.\n     * @returns void\n     */\n    onChainStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[chain/start]\")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a chain run.\n     * @param run The chain run that has ended.\n     * @returns void\n     */\n    onChainEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[chain/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a chain run.\n     * @param run The chain run that has errored.\n     * @returns void\n     */\n    onChainError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[chain/error]\")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of an LLM run.\n     * @param run The LLM run that has started.\n     * @returns void\n     */\n    onLLMStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        const inputs = \"prompts\" in run.inputs\n            ? { prompts: run.inputs.prompts.map((p) => p.trim()) }\n            : run.inputs;\n        console.log(`${wrap(color.green, \"[llm/start]\")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of an LLM run.\n     * @param run The LLM run that has ended.\n     * @returns void\n     */\n    onLLMEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[llm/end]\")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, \"[response]\")}`);\n    }\n    /**\n     * Method used to log any errors of an LLM run.\n     * @param run The LLM run that has errored.\n     * @returns void\n     */\n    onLLMError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[llm/error]\")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a tool run.\n     * @param run The tool run that has started.\n     * @returns void\n     */\n    onToolStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[tool/start]\")} [${crumbs}] Entering Tool run with input: \"${formatKVMapItem(run.inputs.input)}\"`);\n    }\n    /**\n     * Method used to log the end of a tool run.\n     * @param run The tool run that has ended.\n     * @returns void\n     */\n    onToolEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[tool/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: \"${formatKVMapItem(run.outputs?.output)}\"`);\n    }\n    /**\n     * Method used to log any errors of a tool run.\n     * @param run The tool run that has errored.\n     * @returns void\n     */\n    onToolError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[tool/error]\")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a retriever run.\n     * @param run The retriever run that has started.\n     * @returns void\n     */\n    onRetrieverStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[retriever/start]\")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a retriever run.\n     * @param run The retriever run that has ended.\n     * @returns void\n     */\n    onRetrieverEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[retriever/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a retriever run.\n     * @param run The retriever run that has errored.\n     * @returns void\n     */\n    onRetrieverError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[retriever/error]\")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the action selected by the agent.\n     * @param run The run in which the agent action occurred.\n     * @returns void\n     */\n    onAgentAction(run) {\n        const agentRun = run;\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.blue, \"[agent/action]\")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], \"[action]\")}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9jb25zb2xlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNNO0FBQ3ZDO0FBQ0EsY0FBYyxXQUFXLEVBQUUsS0FBSyxFQUFFLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQSxRQUFRLFFBQVEsRUFBRSx3Q0FBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQyxnREFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QixHQUFHLGdCQUFnQixHQUFHLFlBQVk7QUFDckYsK0NBQStDLDZDQUFXO0FBQzFELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9DQUFvQyxHQUFHLE9BQU8sbUNBQW1DLHlDQUF5QztBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQyxHQUFHLE9BQU8sS0FBSyxhQUFhLG1DQUFtQywyQ0FBMkM7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQ0FBa0MsR0FBRyxPQUFPLEtBQUssYUFBYSxrQ0FBa0MsdUNBQXVDO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLHVCQUF1QixrQ0FBa0MsR0FBRyxPQUFPLGlDQUFpQyxxQ0FBcUM7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0IsR0FBRyxPQUFPLEtBQUssYUFBYSxpQ0FBaUMsNENBQTRDO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDLEdBQUcsT0FBTyxLQUFLLGFBQWEsZ0NBQWdDLHVDQUF1QztBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1DQUFtQyxHQUFHLE9BQU8sbUNBQW1DLGtDQUFrQztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQyxHQUFHLE9BQU8sS0FBSyxhQUFhLG1DQUFtQyxxQ0FBcUM7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUMsR0FBRyxPQUFPLEtBQUssYUFBYSxpQ0FBaUMsdUNBQXVDO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0NBQXdDLEdBQUcsT0FBTyx1Q0FBdUMseUNBQXlDO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUNBQXFDLEdBQUcsT0FBTyxLQUFLLGFBQWEsdUNBQXVDLDJDQUEyQztBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFzQyxHQUFHLE9BQU8sS0FBSyxhQUFhLHNDQUFzQyx1Q0FBdUM7QUFDdEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9DQUFvQyxHQUFHLE9BQU8sMkJBQTJCLDRFQUE0RTtBQUM1SztBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHRyYWNlcnNcXGNvbnNvbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0eWxlcyBmcm9tIFwiYW5zaS1zdHlsZXNcIjtcbmltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5mdW5jdGlvbiB3cmFwKHN0eWxlLCB0ZXh0KSB7XG4gICAgcmV0dXJuIGAke3N0eWxlLm9wZW59JHt0ZXh0fSR7c3R5bGUuY2xvc2V9YDtcbn1cbmZ1bmN0aW9uIHRyeUpzb25TdHJpbmdpZnkob2JqLCBmYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JtYXRLVk1hcEl0ZW0odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyeUpzb25TdHJpbmdpZnkodmFsdWUsIHZhbHVlLnRvU3RyaW5nKCkpO1xufVxuZnVuY3Rpb24gZWxhcHNlZChydW4pIHtcbiAgICBpZiAoIXJ1bi5lbmRfdGltZSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgY29uc3QgZWxhcHNlZCA9IHJ1bi5lbmRfdGltZSAtIHJ1bi5zdGFydF90aW1lO1xuICAgIGlmIChlbGFwc2VkIDwgMTAwMCkge1xuICAgICAgICByZXR1cm4gYCR7ZWxhcHNlZH1tc2A7XG4gICAgfVxuICAgIHJldHVybiBgJHsoZWxhcHNlZCAvIDEwMDApLnRvRml4ZWQoMil9c2A7XG59XG5jb25zdCB7IGNvbG9yIH0gPSBzdHlsZXM7XG4vKipcbiAqIEEgdHJhY2VyIHRoYXQgbG9ncyBhbGwgZXZlbnRzIHRvIHRoZSBjb25zb2xlLiBJdCBleHRlbmRzIGZyb20gdGhlXG4gKiBgQmFzZVRyYWNlcmAgY2xhc3MgYW5kIG92ZXJyaWRlcyBpdHMgbWV0aG9kcyB0byBwcm92aWRlIGN1c3RvbSBsb2dnaW5nXG4gKiBmdW5jdGlvbmFsaXR5LlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqXG4gKiBjb25zdCBsbG0gPSBuZXcgQ2hhdEFudGhyb3BpYyh7XG4gKiAgIHRlbXBlcmF0dXJlOiAwLFxuICogICB0YWdzOiBbXCJleGFtcGxlXCIsIFwiY2FsbGJhY2tzXCIsIFwiY29uc3RydWN0b3JcIl0sXG4gKiAgIGNhbGxiYWNrczogW25ldyBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyKCldLFxuICogfSk7XG4gKlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiY29uc29sZV9jYWxsYmFja19oYW5kbGVyXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHBlcnNpc3QgdGhlIHJ1bi4gSW4gdGhpcyBjYXNlLCBpdCBzaW1wbHkgcmV0dXJucyBhXG4gICAgICogcmVzb2x2ZWQgcHJvbWlzZSBhcyB0aGVyZSdzIG5vIHBlcnNpc3RlbmNlIGxvZ2ljLlxuICAgICAqIEBwYXJhbSBfcnVuIFRoZSBydW4gdG8gcGVyc2lzdC5cbiAgICAgKiBAcmV0dXJucyBBIHJlc29sdmVkIHByb21pc2UuXG4gICAgICovXG4gICAgcGVyc2lzdFJ1bihfcnVuKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLy8gdXRpbGl0eSBtZXRob2RzXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IGFsbCB0aGUgcGFyZW50IHJ1bnMgb2YgYSBnaXZlbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcnVuIHdob3NlIHBhcmVudHMgYXJlIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBwYXJlbnQgcnVucy5cbiAgICAgKi9cbiAgICBnZXRQYXJlbnRzKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50UnVuID0gcnVuO1xuICAgICAgICB3aGlsZSAoY3VycmVudFJ1bi5wYXJlbnRfcnVuX2lkKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnJ1bk1hcC5nZXQoY3VycmVudFJ1bi5wYXJlbnRfcnVuX2lkKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UnVuID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVuJ3MgbGluZWFnZSwgd2hpY2hcbiAgICAgKiBpcyB1c2VkIGluIGxvZ2dpbmcuXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcnVuIHdob3NlIGxpbmVhZ2UgaXMgdG8gYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydW4ncyBsaW5lYWdlLlxuICAgICAqL1xuICAgIGdldEJyZWFkY3J1bWJzKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gdGhpcy5nZXRQYXJlbnRzKHJ1bikucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBbLi4ucGFyZW50cywgcnVuXVxuICAgICAgICAgICAgLm1hcCgocGFyZW50LCBpLCBhcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBgJHtwYXJlbnQuZXhlY3V0aW9uX29yZGVyfToke3BhcmVudC5ydW5fdHlwZX06JHtwYXJlbnQubmFtZX1gO1xuICAgICAgICAgICAgcmV0dXJuIGkgPT09IGFyci5sZW5ndGggLSAxID8gd3JhcChzdHlsZXMuYm9sZCwgbmFtZSkgOiBuYW1lO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCIgPiBcIik7XG4gICAgICAgIHJldHVybiB3cmFwKGNvbG9yLmdyZXksIHN0cmluZyk7XG4gICAgfVxuICAgIC8vIGxvZ2dpbmcgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYSBjaGFpbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgY2hhaW4gcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQ2hhaW5TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIltjaGFpbi9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIENoYWluIHJ1biB3aXRoIGlucHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmlucHV0cywgXCJbaW5wdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYSBjaGFpbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgY2hhaW4gcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkNoYWluRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbY2hhaW4vZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBDaGFpbiBydW4gd2l0aCBvdXRwdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4ub3V0cHV0cywgXCJbb3V0cHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGEgY2hhaW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIGNoYWluIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkNoYWluRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW2NoYWluL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gQ2hhaW4gcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGFuIExMTSBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgTExNIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkxMTVN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IFwicHJvbXB0c1wiIGluIHJ1bi5pbnB1dHNcbiAgICAgICAgICAgID8geyBwcm9tcHRzOiBydW4uaW5wdXRzLnByb21wdHMubWFwKChwKSA9PiBwLnRyaW0oKSkgfVxuICAgICAgICAgICAgOiBydW4uaW5wdXRzO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIltsbG0vc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBMTE0gcnVuIHdpdGggaW5wdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShpbnB1dHMsIFwiW2lucHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGFuIExMTSBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgTExNIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25MTE1FbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIltsbG0vZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBMTE0gcnVuIHdpdGggb3V0cHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLm91dHB1dHMsIFwiW3Jlc3BvbnNlXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYW4gTExNIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBMTE0gcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uTExNRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW2xsbS9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIExMTSBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYSB0b29sIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSB0b29sIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblRvb2xTdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIlt0b29sL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgVG9vbCBydW4gd2l0aCBpbnB1dDogXCIke2Zvcm1hdEtWTWFwSXRlbShydW4uaW5wdXRzLmlucHV0KX1cImApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhIHRvb2wgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHRvb2wgcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblRvb2xFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIlt0b29sL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgVG9vbCBydW4gd2l0aCBvdXRwdXQ6IFwiJHtmb3JtYXRLVk1hcEl0ZW0ocnVuLm91dHB1dHM/Lm91dHB1dCl9XCJgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYSB0b29sIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSB0b29sIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblRvb2xFcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbdG9vbC9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIFRvb2wgcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGEgcmV0cmlldmVyIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSByZXRyaWV2ZXIgcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uUmV0cmlldmVyU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbcmV0cmlldmVyL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgUmV0cmlldmVyIHJ1biB3aXRoIGlucHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmlucHV0cywgXCJbaW5wdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYSByZXRyaWV2ZXIgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJldHJpZXZlciBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uUmV0cmlldmVyRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbcmV0cmlldmVyL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgUmV0cmlldmVyIHJ1biB3aXRoIG91dHB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5vdXRwdXRzLCBcIltvdXRwdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYSByZXRyaWV2ZXIgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJldHJpZXZlciBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25SZXRyaWV2ZXJFcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbcmV0cmlldmVyL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gUmV0cmlldmVyIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBhY3Rpb24gc2VsZWN0ZWQgYnkgdGhlIGFnZW50LlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJ1biBpbiB3aGljaCB0aGUgYWdlbnQgYWN0aW9uIG9jY3VycmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkFnZW50QWN0aW9uKHJ1bikge1xuICAgICAgICBjb25zdCBhZ2VudFJ1biA9IHJ1bjtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmJsdWUsIFwiW2FnZW50L2FjdGlvbl1cIil9IFske2NydW1ic31dIEFnZW50IHNlbGVjdGVkIGFjdGlvbjogJHt0cnlKc29uU3RyaW5naWZ5KGFnZW50UnVuLmFjdGlvbnNbYWdlbnRSdW4uYWN0aW9ucy5sZW5ndGggLSAxXSwgXCJbYWN0aW9uXVwiKX1gKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/console.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/event_stream.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventStreamCallbackHandler: () => (/* binding */ EventStreamCallbackHandler),\n/* harmony export */   isStreamEventsHandler: () => (/* binding */ isStreamEventsHandler)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _messages_ai_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../messages/ai.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.js\");\n/* harmony import */ var _outputs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../outputs.js */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.js\");\n\n\n\n\nfunction assignName({ name, serialized, }) {\n    if (name !== undefined) {\n        return name;\n    }\n    if (serialized?.name !== undefined) {\n        return serialized.name;\n    }\n    else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n        return serialized.id[serialized.id.length - 1];\n    }\n    return \"Unnamed\";\n}\nconst isStreamEventsHandler = (handler) => handler.name === \"event_stream_tracer\";\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass EventStreamCallbackHandler extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"runInfoMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"tappedPromises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"event_stream_tracer\"\n        });\n        Object.defineProperty(this, \"lc_prefer_streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = _utils_stream_js__WEBPACK_IMPORTED_MODULE_1__.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.runType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.runType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, outputStream) {\n        const firstChunk = await outputStream.next();\n        if (firstChunk.done) {\n            return;\n        }\n        const runInfo = this.runInfoMap.get(runId);\n        // Run has finished, don't issue any stream events.\n        // An example of this is for runnables that use the default\n        // implementation of .stream(), which delegates to .invoke()\n        // and calls .onChainEnd() before passing it to the iterator.\n        if (runInfo === undefined) {\n            yield firstChunk.value;\n            return;\n        }\n        // Match format from handlers below\n        function _formatOutputChunk(eventType, data) {\n            if (eventType === \"llm\" && typeof data === \"string\") {\n                return new _outputs_js__WEBPACK_IMPORTED_MODULE_3__.GenerationChunk({ text: data });\n            }\n            return data;\n        }\n        let tappedPromise = this.tappedPromises.get(runId);\n        // if we are the first to tap, issue stream events\n        if (tappedPromise === undefined) {\n            let tappedPromiseResolver;\n            tappedPromise = new Promise((resolve) => {\n                tappedPromiseResolver = resolve;\n            });\n            this.tappedPromises.set(runId, tappedPromise);\n            try {\n                const event = {\n                    event: `on_${runInfo.runType}_stream`,\n                    run_id: runId,\n                    name: runInfo.name,\n                    tags: runInfo.tags,\n                    metadata: runInfo.metadata,\n                    data: {},\n                };\n                await this.send({\n                    ...event,\n                    data: {\n                        chunk: _formatOutputChunk(runInfo.runType, firstChunk.value),\n                    },\n                }, runInfo);\n                yield firstChunk.value;\n                for await (const chunk of outputStream) {\n                    // Don't yield tool and retriever stream events\n                    if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n                        await this.send({\n                            ...event,\n                            data: {\n                                chunk: _formatOutputChunk(runInfo.runType, chunk),\n                            },\n                        }, runInfo);\n                    }\n                    yield chunk;\n                }\n            }\n            finally {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tappedPromiseResolver();\n                // Don't delete from the promises map to keep track of which runs have been tapped.\n            }\n        }\n        else {\n            // otherwise just pass through\n            yield firstChunk.value;\n            for await (const chunk of outputStream) {\n                yield chunk;\n            }\n        }\n    }\n    async send(payload, run) {\n        if (this._includeRun(run)) {\n            await this.writer.write(payload);\n        }\n    }\n    async sendEndEvent(payload, run) {\n        const tappedPromise = this.tappedPromises.get(payload.run_id);\n        if (tappedPromise !== undefined) {\n            void tappedPromise.then(() => {\n                void this.send(payload, run);\n            });\n        }\n        else {\n            await this.send(payload, run);\n        }\n    }\n    async onLLMStart(run) {\n        const runName = assignName(run);\n        const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: run.inputs,\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        const eventName = `on_${runType}_start`;\n        await this.send({\n            event: eventName,\n            data: {\n                input: run.inputs,\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onLLMNewToken(run, token, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs) {\n        const runInfo = this.runInfoMap.get(run.id);\n        let chunk;\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n        }\n        // Top-level streaming events are covered by tapOutputIterable\n        if (this.runInfoMap.size === 1) {\n            return;\n        }\n        if (runInfo.runType === \"chat_model\") {\n            eventName = \"on_chat_model_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new _messages_ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessageChunk({ content: token, id: `run-${run.id}` });\n            }\n            else {\n                chunk = kwargs.chunk.message;\n            }\n        }\n        else if (runInfo.runType === \"llm\") {\n            eventName = \"on_llm_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new _outputs_js__WEBPACK_IMPORTED_MODULE_3__.GenerationChunk({ text: token });\n            }\n            else {\n                chunk = kwargs.chunk;\n            }\n        }\n        else {\n            throw new Error(`Unexpected run type ${runInfo.runType}`);\n        }\n        await this.send({\n            event: eventName,\n            data: {\n                chunk,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onLLMEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const generations = run.outputs?.generations;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let output;\n        if (runInfo.runType === \"chat_model\") {\n            for (const generation of generations ?? []) {\n                if (output !== undefined) {\n                    break;\n                }\n                output = generation[0]?.message;\n            }\n            eventName = \"on_chat_model_end\";\n        }\n        else if (runInfo.runType === \"llm\") {\n            output = {\n                generations: generations?.map((generation) => {\n                    return generation.map((chunk) => {\n                        return {\n                            text: chunk.text,\n                            generationInfo: chunk.generationInfo,\n                        };\n                    });\n                }),\n                llmOutput: run.outputs?.llmOutput ?? {},\n            };\n            eventName = \"on_llm_end\";\n        }\n        else {\n            throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onChainStart(run) {\n        const runName = assignName(run);\n        const runType = run.run_type ?? \"chain\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: run.run_type,\n        };\n        let eventData = {};\n        // Workaround Runnable core code not sending input when transform streaming.\n        if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n            eventData = {};\n            runInfo.inputs = {};\n        }\n        else if (run.inputs.input !== undefined) {\n            eventData.input = run.inputs.input;\n            runInfo.inputs = run.inputs.input;\n        }\n        else {\n            eventData.input = run.inputs;\n            runInfo.inputs = run.inputs;\n        }\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: `on_${runType}_start`,\n            data: eventData,\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onChainEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const eventName = `on_${run.run_type}_end`;\n        const inputs = run.inputs ?? runInfo.inputs ?? {};\n        const outputs = run.outputs?.output ?? run.outputs;\n        const data = {\n            output: outputs,\n            input: inputs,\n        };\n        if (inputs.input && Object.keys(inputs).length === 1) {\n            data.input = inputs.input;\n            runInfo.inputs = inputs.input;\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data,\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolStart(run) {\n        const runName = assignName(run);\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: \"tool\",\n            inputs: run.inputs ?? {},\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_tool_start\",\n            data: {\n                input: run.inputs ?? {},\n            },\n            name: runName,\n            run_id: run.id,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n        }\n        if (runInfo.inputs === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);\n        }\n        const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n        await this.sendEndEvent({\n            event: \"on_tool_end\",\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onRetrieverStart(run) {\n        const runName = assignName(run);\n        const runType = \"retriever\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: {\n                query: run.inputs.query,\n            },\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_retriever_start\",\n            data: {\n                input: {\n                    query: run.inputs.query,\n                },\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onRetrieverEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n        }\n        await this.sendEndEvent({\n            event: \"on_retriever_end\",\n            data: {\n                output: run.outputs?.documents ?? run.outputs,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleCustomEvent(eventName, data, runId) {\n        const runInfo = this.runInfoMap.get(runId);\n        if (runInfo === undefined) {\n            throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);\n        }\n        await this.send({\n            event: \"on_custom_event\",\n            run_id: runId,\n            name: eventName,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n            data,\n        }, runInfo);\n    }\n    async finish() {\n        const pendingPromises = [...this.tappedPromises.values()];\n        void Promise.all(pendingPromises).finally(() => {\n            void this.writer.close();\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9ldmVudF9zdHJlYW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXVDO0FBQ3FCO0FBQ1Q7QUFDSDtBQUNoRCxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QyxnREFBVTtBQUMxRDtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvRUFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBZSxHQUFHLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkRBQWMsR0FBRywyQkFBMkIsT0FBTyxHQUFHO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0RBQWUsR0FBRyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xcZXZlbnRfc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgQUlNZXNzYWdlQ2h1bmsgfSBmcm9tIFwiLi4vbWVzc2FnZXMvYWkuanNcIjtcbmltcG9ydCB7IEdlbmVyYXRpb25DaHVuayB9IGZyb20gXCIuLi9vdXRwdXRzLmpzXCI7XG5mdW5jdGlvbiBhc3NpZ25OYW1lKHsgbmFtZSwgc2VyaWFsaXplZCwgfSkge1xuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemVkPy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VyaWFsaXplZD8uaWQgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWQ/LmlkKSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZC5pZFtzZXJpYWxpemVkLmlkLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gXCJVbm5hbWVkXCI7XG59XG5leHBvcnQgY29uc3QgaXNTdHJlYW1FdmVudHNIYW5kbGVyID0gKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJldmVudF9zdHJlYW1fdHJhY2VyXCI7XG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyB0aGUgYEJhc2VUcmFjZXJgIGNsYXNzIGZyb20gdGhlXG4gKiBgbGFuZ2NoYWluLmNhbGxiYWNrcy50cmFjZXJzLmJhc2VgIG1vZHVsZS4gSXQgcmVwcmVzZW50cyBhIGNhbGxiYWNrXG4gKiBoYW5kbGVyIHRoYXQgbG9ncyB0aGUgZXhlY3V0aW9uIG9mIHJ1bnMgYW5kIGVtaXRzIGBSdW5Mb2dgIGluc3RhbmNlcyB0byBhXG4gKiBgUnVuTG9nU3RyZWFtYC5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50U3RyZWFtQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKHsgX2F3YWl0SGFuZGxlcjogdHJ1ZSwgLi4uZmllbGRzIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQ2xvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5JbmZvTWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcHBlZFByb21pc2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zZm9ybVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVjZWl2ZVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImV2ZW50X3N0cmVhbV90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfcHJlZmVyX3N0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPSBmaWVsZHM/LmF1dG9DbG9zZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lcyA9IGZpZWxkcz8uaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcz8uaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzPy5pbmNsdWRlVGFncztcbiAgICAgICAgdGhpcy5leGNsdWRlTmFtZXMgPSBmaWVsZHM/LmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHM/LmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcz8uZXhjbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICB0aGlzLndyaXRlciA9IHRoaXMudHJhbnNmb3JtU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVTdHJlYW0gPSBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbSh0aGlzLnRyYW5zZm9ybVN0cmVhbS5yZWFkYWJsZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVTdHJlYW07XG4gICAgfVxuICAgIGFzeW5jIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgICAgLy8gYW5kIGlzIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICB9XG4gICAgX2luY2x1ZGVSdW4ocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blRhZ3MgPSBydW4udGFncyA/PyBbXTtcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0aGlzLmluY2x1ZGVOYW1lcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhydW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ1blRhZ3MuZmluZCgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1blR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgJiYgcnVuVGFncy5ldmVyeSgodGFnKSA9PiAhdGhpcy5leGNsdWRlVGFncz8uaW5jbHVkZXModGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfVxuICAgIGFzeW5jICp0YXBPdXRwdXRJdGVyYWJsZShydW5JZCwgb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBhd2FpdCBvdXRwdXRTdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoZmlyc3RDaHVuay5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuSWQpO1xuICAgICAgICAvLyBSdW4gaGFzIGZpbmlzaGVkLCBkb24ndCBpc3N1ZSBhbnkgc3RyZWFtIGV2ZW50cy5cbiAgICAgICAgLy8gQW4gZXhhbXBsZSBvZiB0aGlzIGlzIGZvciBydW5uYWJsZXMgdGhhdCB1c2UgdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gb2YgLnN0cmVhbSgpLCB3aGljaCBkZWxlZ2F0ZXMgdG8gLmludm9rZSgpXG4gICAgICAgIC8vIGFuZCBjYWxscyAub25DaGFpbkVuZCgpIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSBpdGVyYXRvci5cbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeWllbGQgZmlyc3RDaHVuay52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXRjaCBmb3JtYXQgZnJvbSBoYW5kbGVycyBiZWxvd1xuICAgICAgICBmdW5jdGlvbiBfZm9ybWF0T3V0cHV0Q2h1bmsoZXZlbnRUeXBlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcImxsbVwiICYmIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0aW9uQ2h1bmsoeyB0ZXh0OiBkYXRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcHBlZFByb21pc2UgPSB0aGlzLnRhcHBlZFByb21pc2VzLmdldChydW5JZCk7XG4gICAgICAgIC8vIGlmIHdlIGFyZSB0aGUgZmlyc3QgdG8gdGFwLCBpc3N1ZSBzdHJlYW0gZXZlbnRzXG4gICAgICAgIGlmICh0YXBwZWRQcm9taXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCB0YXBwZWRQcm9taXNlUmVzb2x2ZXI7XG4gICAgICAgICAgICB0YXBwZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0YXBwZWRQcm9taXNlUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRhcHBlZFByb21pc2VzLnNldChydW5JZCwgdGFwcGVkUHJvbWlzZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7cnVuSW5mby5ydW5UeXBlfV9zdHJlYW1gLFxuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBfZm9ybWF0T3V0cHV0Q2h1bmsocnVuSW5mby5ydW5UeXBlLCBmaXJzdENodW5rLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCBydW5JbmZvKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBmaXJzdENodW5rLnZhbHVlO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHlpZWxkIHRvb2wgYW5kIHJldHJpZXZlciBzdHJlYW0gZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5JbmZvLnJ1blR5cGUgIT09IFwidG9vbFwiICYmIHJ1bkluZm8ucnVuVHlwZSAhPT0gXCJyZXRyaWV2ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBfZm9ybWF0T3V0cHV0Q2h1bmsocnVuSW5mby5ydW5UeXBlLCBjaHVuayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJ1bkluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgdGFwcGVkUHJvbWlzZVJlc29sdmVyKCk7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgZGVsZXRlIGZyb20gdGhlIHByb21pc2VzIG1hcCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIHJ1bnMgaGF2ZSBiZWVuIHRhcHBlZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHBhc3MgdGhyb3VnaFxuICAgICAgICAgICAgeWllbGQgZmlyc3RDaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZChwYXlsb2FkLCBydW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2luY2x1ZGVSdW4ocnVuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZEVuZEV2ZW50KHBheWxvYWQsIHJ1bikge1xuICAgICAgICBjb25zdCB0YXBwZWRQcm9taXNlID0gdGhpcy50YXBwZWRQcm9taXNlcy5nZXQocGF5bG9hZC5ydW5faWQpO1xuICAgICAgICBpZiAodGFwcGVkUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2b2lkIHRhcHBlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLnNlbmQocGF5bG9hZCwgcnVuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHBheWxvYWQsIHJ1bik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25MTE1TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IGFzc2lnbk5hbWUocnVuKTtcbiAgICAgICAgY29uc3QgcnVuVHlwZSA9IHJ1bi5pbnB1dHMubWVzc2FnZXMgIT09IHVuZGVmaW5lZCA/IFwiY2hhdF9tb2RlbFwiIDogXCJsbG1cIjtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHtcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgcnVuVHlwZSxcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBgb25fJHtydW5UeXBlfV9zdGFydGA7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlucHV0OiBydW4uaW5wdXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkxMTU5ld1Rva2VuKHJ1biwgdG9rZW4sIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgbGV0IGV2ZW50TmFtZTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvbkxMTU5ld1Rva2VuOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvcC1sZXZlbCBzdHJlYW1pbmcgZXZlbnRzIGFyZSBjb3ZlcmVkIGJ5IHRhcE91dHB1dEl0ZXJhYmxlXG4gICAgICAgIGlmICh0aGlzLnJ1bkluZm9NYXAuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5JbmZvLnJ1blR5cGUgPT09IFwiY2hhdF9tb2RlbFwiKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uX2NoYXRfbW9kZWxfc3RyZWFtXCI7XG4gICAgICAgICAgICBpZiAoa3dhcmdzPy5jaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgQUlNZXNzYWdlQ2h1bmsoeyBjb250ZW50OiB0b2tlbiwgaWQ6IGBydW4tJHtydW4uaWR9YCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rID0ga3dhcmdzLmNodW5rLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuSW5mby5ydW5UeXBlID09PSBcImxsbVwiKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uX2xsbV9zdHJlYW1cIjtcbiAgICAgICAgICAgIGlmIChrd2FyZ3M/LmNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBHZW5lcmF0aW9uQ2h1bmsoeyB0ZXh0OiB0b2tlbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rID0ga3dhcmdzLmNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHJ1biB0eXBlICR7cnVuSW5mby5ydW5UeXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkxMTUVuZChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBsZXQgZXZlbnROYW1lO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uTExNRW5kOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gcnVuLm91dHB1dHM/LmdlbmVyYXRpb25zO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICBpZiAocnVuSW5mby5ydW5UeXBlID09PSBcImNoYXRfbW9kZWxcIikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0aW9uIG9mIGdlbmVyYXRpb25zID8/IFtdKSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBnZW5lcmF0aW9uWzBdPy5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbl9jaGF0X21vZGVsX2VuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bkluZm8ucnVuVHlwZSA9PT0gXCJsbG1cIikge1xuICAgICAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBnZW5lcmF0aW9ucz8ubWFwKChnZW5lcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0aW9uLm1hcCgoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzogY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBsbG1PdXRwdXQ6IHJ1bi5vdXRwdXRzPy5sbG1PdXRwdXQgPz8ge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbl9sbG1fZW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uTExNRW5kOiBVbmV4cGVjdGVkIHJ1biB0eXBlOiAke3J1bkluZm8ucnVuVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFbmRFdmVudCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuSW5mby5pbnB1dHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uQ2hhaW5TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IGFzc2lnbk5hbWUocnVuKTtcbiAgICAgICAgY29uc3QgcnVuVHlwZSA9IHJ1bi5ydW5fdHlwZSA/PyBcImNoYWluXCI7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB7XG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHJ1blR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGV2ZW50RGF0YSA9IHt9O1xuICAgICAgICAvLyBXb3JrYXJvdW5kIFJ1bm5hYmxlIGNvcmUgY29kZSBub3Qgc2VuZGluZyBpbnB1dCB3aGVuIHRyYW5zZm9ybSBzdHJlYW1pbmcuXG4gICAgICAgIGlmIChydW4uaW5wdXRzLmlucHV0ID09PSBcIlwiICYmIE9iamVjdC5rZXlzKHJ1bi5pbnB1dHMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZXZlbnREYXRhID0ge307XG4gICAgICAgICAgICBydW5JbmZvLmlucHV0cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bi5pbnB1dHMuaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXZlbnREYXRhLmlucHV0ID0gcnVuLmlucHV0cy5pbnB1dDtcbiAgICAgICAgICAgIHJ1bkluZm8uaW5wdXRzID0gcnVuLmlucHV0cy5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YS5pbnB1dCA9IHJ1bi5pbnB1dHM7XG4gICAgICAgICAgICBydW5JbmZvLmlucHV0cyA9IHJ1bi5pbnB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3J1blR5cGV9X3N0YXJ0YCxcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50RGF0YSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkNoYWluRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBydW5JbmZvID0gdGhpcy5ydW5JbmZvTWFwLmdldChydW4uaWQpO1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIGlmIChydW5JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25DaGFpbkVuZDogUnVuIElEICR7cnVuLmlkfSBub3QgZm91bmQgaW4gcnVuIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBgb25fJHtydW4ucnVuX3R5cGV9X2VuZGA7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHJ1bi5pbnB1dHMgPz8gcnVuSW5mby5pbnB1dHMgPz8ge307XG4gICAgICAgIGNvbnN0IG91dHB1dHMgPSBydW4ub3V0cHV0cz8ub3V0cHV0ID8/IHJ1bi5vdXRwdXRzO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXRzLFxuICAgICAgICAgICAgaW5wdXQ6IGlucHV0cyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlucHV0cy5pbnB1dCAmJiBPYmplY3Qua2V5cyhpbnB1dHMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZGF0YS5pbnB1dCA9IGlucHV0cy5pbnB1dDtcbiAgICAgICAgICAgIHJ1bkluZm8uaW5wdXRzID0gaW5wdXRzLmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVuZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uVG9vbFN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gYXNzaWduTmFtZShydW4pO1xuICAgICAgICBjb25zdCBydW5JbmZvID0ge1xuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5UeXBlOiBcInRvb2xcIixcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyA/PyB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwib25fdG9vbF9zdGFydFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlucHV0OiBydW4uaW5wdXRzID8/IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvblRvb2xFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5kZWxldGUocnVuLmlkKTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvblRvb2xFbmQ6IFJ1biBJRCAke3J1bi5pZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bkluZm8uaW5wdXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25Ub29sRW5kOiBSdW4gSUQgJHtydW4uaWR9IGlzIGEgdG9vbCBjYWxsLCBhbmQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0cmFjZWQgaW5wdXRzLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHJ1bi5vdXRwdXRzPy5vdXRwdXQgPT09IHVuZGVmaW5lZCA/IHJ1bi5vdXRwdXRzIDogcnVuLm91dHB1dHMub3V0cHV0O1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFbmRFdmVudCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl90b29sX2VuZFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuSW5mby5pbnB1dHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uUmV0cmlldmVyU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bk5hbWUgPSBhc3NpZ25OYW1lKHJ1bik7XG4gICAgICAgIGNvbnN0IHJ1blR5cGUgPSBcInJldHJpZXZlclwiO1xuICAgICAgICBjb25zdCBydW5JbmZvID0ge1xuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5UeXBlLFxuICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHJ1bi5pbnB1dHMucXVlcnksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuc2V0KHJ1bi5pZCwgcnVuSW5mbyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl9yZXRyaWV2ZXJfc3RhcnRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeTogcnVuLmlucHV0cy5xdWVyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvblJldHJpZXZlckVuZChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uUmV0cmlldmVyRW5kOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVuZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX3JldHJpZXZlcl9lbmRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJ1bi5vdXRwdXRzPy5kb2N1bWVudHMgPz8gcnVuLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHJ1bkluZm8uaW5wdXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIGhhbmRsZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGF0YSwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhbmRsZUN1c3RvbUV2ZW50OiBSdW4gSUQgJHtydW5JZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX2N1c3RvbV9ldmVudFwiLFxuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW5JbmZvLm1ldGFkYXRhLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmlzaCgpIHtcbiAgICAgICAgY29uc3QgcGVuZGluZ1Byb21pc2VzID0gWy4uLnRoaXMudGFwcGVkUHJvbWlzZXMudmFsdWVzKCldO1xuICAgICAgICB2b2lkIFByb21pc2UuYWxsKHBlbmRpbmdQcm9taXNlcykuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICB2b2lkIHRoaXMud3JpdGVyLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/initialize.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/initialize.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTracingCallbackHandler: () => (/* binding */ getTracingCallbackHandler),\n/* harmony export */   getTracingV2CallbackHandler: () => (/* binding */ getTracingV2CallbackHandler)\n/* harmony export */ });\n/* harmony import */ var _tracer_langchain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tracer_langchain.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.js\");\n/* harmony import */ var _tracer_langchain_v1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracer_langchain_v1.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain_v1.js\");\n\n\n/**\n * @deprecated Use the V2 handler instead.\n *\n * Function that returns an instance of `LangChainTracerV1`. If a session\n * is provided, it loads that session into the tracer; otherwise, it loads\n * a default session.\n * @param session Optional session to load into the tracer.\n * @returns An instance of `LangChainTracerV1`.\n */\nasync function getTracingCallbackHandler(session) {\n    const tracer = new _tracer_langchain_v1_js__WEBPACK_IMPORTED_MODULE_1__.LangChainTracerV1();\n    if (session) {\n        await tracer.loadSession(session);\n    }\n    else {\n        await tracer.loadDefaultSession();\n    }\n    return tracer;\n}\n/**\n * @deprecated Instantiate directly using the LangChainTracer constructor.\n *\n * Function that returns an instance of `LangChainTracer`. It does not\n * load any session data.\n * @returns An instance of `LangChainTracer`.\n */\nasync function getTracingV2CallbackHandler() {\n    return new _tracer_langchain_js__WEBPACK_IMPORTED_MODULE_0__.LangChainTracer();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9pbml0aWFsaXplLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0Q7QUFDSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUJBQXVCLHNFQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWUsaUVBQWU7QUFDOUIiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xcaW5pdGlhbGl6ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5nQ2hhaW5UcmFjZXIgfSBmcm9tIFwiLi90cmFjZXJfbGFuZ2NoYWluLmpzXCI7XG5pbXBvcnQgeyBMYW5nQ2hhaW5UcmFjZXJWMSB9IGZyb20gXCIuL3RyYWNlcl9sYW5nY2hhaW5fdjEuanNcIjtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBWMiBoYW5kbGVyIGluc3RlYWQuXG4gKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBMYW5nQ2hhaW5UcmFjZXJWMWAuIElmIGEgc2Vzc2lvblxuICogaXMgcHJvdmlkZWQsIGl0IGxvYWRzIHRoYXQgc2Vzc2lvbiBpbnRvIHRoZSB0cmFjZXI7IG90aGVyd2lzZSwgaXQgbG9hZHNcbiAqIGEgZGVmYXVsdCBzZXNzaW9uLlxuICogQHBhcmFtIHNlc3Npb24gT3B0aW9uYWwgc2Vzc2lvbiB0byBsb2FkIGludG8gdGhlIHRyYWNlci5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBMYW5nQ2hhaW5UcmFjZXJWMWAuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUcmFjaW5nQ2FsbGJhY2tIYW5kbGVyKHNlc3Npb24pIHtcbiAgICBjb25zdCB0cmFjZXIgPSBuZXcgTGFuZ0NoYWluVHJhY2VyVjEoKTtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0cmFjZXIubG9hZFNlc3Npb24oc2Vzc2lvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhd2FpdCB0cmFjZXIubG9hZERlZmF1bHRTZXNzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0cmFjZXI7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIEluc3RhbnRpYXRlIGRpcmVjdGx5IHVzaW5nIHRoZSBMYW5nQ2hhaW5UcmFjZXIgY29uc3RydWN0b3IuXG4gKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBMYW5nQ2hhaW5UcmFjZXJgLiBJdCBkb2VzIG5vdFxuICogbG9hZCBhbnkgc2Vzc2lvbiBkYXRhLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYExhbmdDaGFpblRyYWNlcmAuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUcmFjaW5nVjJDYWxsYmFja0hhbmRsZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBMYW5nQ2hhaW5UcmFjZXIoKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/initialize.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/log_stream.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogStreamCallbackHandler: () => (/* binding */ LogStreamCallbackHandler),\n/* harmony export */   RunLog: () => (/* binding */ RunLog),\n/* harmony export */   RunLogPatch: () => (/* binding */ RunLogPatch),\n/* harmony export */   isLogStreamHandler: () => (/* binding */ isLogStreamHandler)\n/* harmony export */ });\n/* harmony import */ var _utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/fast-json-patch/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/stream.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _messages_ai_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../messages/ai.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.js\");\n\n\n\n\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nclass RunLogPatch {\n    constructor(fields) {\n        Object.defineProperty(this, \"ops\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.ops = fields.ops ?? [];\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)({}, ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nclass RunLog extends RunLogPatch {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"state\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.state = fields.state;\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)(this.state, other.ops);\n        return new RunLog({ ops, state: states[states.length - 1].newDocument });\n    }\n    static fromRunLogPatch(patch) {\n        const states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)({}, patch.ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops: patch.ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nconst isLogStreamHandler = (handler) => handler.name === \"log_stream_tracer\";\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run, schemaFormat) {\n    if (schemaFormat === \"original\") {\n        throw new Error(\"Do not assign inputs with original schema drop the key for now. \" +\n            \"When inputs are added to streamLog they should be added with \" +\n            \"standardized schema for streaming events.\");\n    }\n    const { inputs } = run;\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return inputs;\n    }\n    if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n        return undefined;\n    }\n    // new style chains\n    // These nest an additional 'input' key inside the 'inputs' to make sure\n    // the input is always a dict. We need to unpack and user the inner value.\n    // We should try to fix this in Runnables and callbacks/tracers\n    // Runnables should be using a null type here not a placeholder\n    // dict.\n    return inputs.input;\n}\nasync function _getStandardizedOutputs(run, schemaFormat) {\n    const { outputs } = run;\n    if (schemaFormat === \"original\") {\n        // Return the old schema, without standardizing anything\n        return outputs;\n    }\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return outputs;\n    }\n    // TODO: Remove this hacky check\n    if (outputs !== undefined &&\n        Object.keys(outputs).length === 1 &&\n        outputs?.output !== undefined) {\n        return outputs.output;\n    }\n    return outputs;\n}\nfunction isChatGenerationChunk(x) {\n    return x !== undefined && x.message !== undefined;\n}\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass LogStreamCallbackHandler extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_schemaFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"original\"\n        });\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"keyMapByRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"counterMapByRunName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"log_stream_tracer\"\n        });\n        Object.defineProperty(this, \"lc_prefer_streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        if (run.id === this.rootId) {\n            return false;\n        }\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.run_type);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.run_type);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, output) {\n        // Tap an output async iterator to stream its values to the log.\n        for await (const chunk of output) {\n            // root run is handled in .streamLog()\n            if (runId !== this.rootId) {\n                // if we can't find the run silently ignore\n                // eg. because this run wasn't included in the log\n                const key = this.keyMapByRunId[runId];\n                if (key) {\n                    await this.writer.write(new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: `/logs/${key}/streamed_output/-`,\n                                value: chunk,\n                            },\n                        ],\n                    }));\n                }\n            }\n            yield chunk;\n        }\n    }\n    async onRunCreate(run) {\n        if (this.rootId === undefined) {\n            this.rootId = run.id;\n            await this.writer.write(new RunLogPatch({\n                ops: [\n                    {\n                        op: \"replace\",\n                        path: \"\",\n                        value: {\n                            id: run.id,\n                            name: run.name,\n                            type: run.run_type,\n                            streamed_output: [],\n                            final_output: undefined,\n                            logs: {},\n                        },\n                    },\n                ],\n            }));\n        }\n        if (!this._includeRun(run)) {\n            return;\n        }\n        if (this.counterMapByRunName[run.name] === undefined) {\n            this.counterMapByRunName[run.name] = 0;\n        }\n        this.counterMapByRunName[run.name] += 1;\n        const count = this.counterMapByRunName[run.name];\n        this.keyMapByRunId[run.id] =\n            count === 1 ? run.name : `${run.name}:${count}`;\n        const logEntry = {\n            id: run.id,\n            name: run.name,\n            type: run.run_type,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            start_time: new Date(run.start_time).toISOString(),\n            streamed_output: [],\n            streamed_output_str: [],\n            final_output: undefined,\n            end_time: undefined,\n        };\n        if (this._schemaFormat === \"streaming_events\") {\n            logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n        }\n        await this.writer.write(new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${this.keyMapByRunId[run.id]}`,\n                    value: logEntry,\n                },\n            ],\n        }));\n    }\n    async onRunUpdate(run) {\n        try {\n            const runName = this.keyMapByRunId[run.id];\n            if (runName === undefined) {\n                return;\n            }\n            const ops = [];\n            if (this._schemaFormat === \"streaming_events\") {\n                ops.push({\n                    op: \"replace\",\n                    path: `/logs/${runName}/inputs`,\n                    value: await _getStandardizedInputs(run, this._schemaFormat),\n                });\n            }\n            ops.push({\n                op: \"add\",\n                path: `/logs/${runName}/final_output`,\n                value: await _getStandardizedOutputs(run, this._schemaFormat),\n            });\n            if (run.end_time !== undefined) {\n                ops.push({\n                    op: \"add\",\n                    path: `/logs/${runName}/end_time`,\n                    value: new Date(run.end_time).toISOString(),\n                });\n            }\n            const patch = new RunLogPatch({ ops });\n            await this.writer.write(patch);\n        }\n        finally {\n            if (run.id === this.rootId) {\n                const patch = new RunLogPatch({\n                    ops: [\n                        {\n                            op: \"replace\",\n                            path: \"/final_output\",\n                            value: await _getStandardizedOutputs(run, this._schemaFormat),\n                        },\n                    ],\n                });\n                await this.writer.write(patch);\n                if (this.autoClose) {\n                    await this.writer.close();\n                }\n            }\n        }\n    }\n    async onLLMNewToken(run, token, kwargs) {\n        const runName = this.keyMapByRunId[run.id];\n        if (runName === undefined) {\n            return;\n        }\n        // TODO: Remove hack\n        const isChatModel = run.inputs.messages !== undefined;\n        let streamedOutputValue;\n        if (isChatModel) {\n            if (isChatGenerationChunk(kwargs?.chunk)) {\n                streamedOutputValue = kwargs?.chunk;\n            }\n            else {\n                streamedOutputValue = new _messages_ai_js__WEBPACK_IMPORTED_MODULE_3__.AIMessageChunk({\n                    id: `run-${run.id}`,\n                    content: token,\n                });\n            }\n        }\n        else {\n            streamedOutputValue = token;\n        }\n        const patch = new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output_str/-`,\n                    value: token,\n                },\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output/-`,\n                    value: streamedOutputValue,\n                },\n            ],\n        });\n        await this.writer.write(patch);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9sb2dfc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdFO0FBQ3pCO0FBQ3FCO0FBQ1Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyRUFBVSxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJFQUFVO0FBQ2pDLDRCQUE0QixtREFBbUQ7QUFDL0U7QUFDQTtBQUNBLHVCQUF1QiwyRUFBVSxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDLGdEQUFVO0FBQ3hEO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9FQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUyxHQUFHLE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyREFBYztBQUN4RCwrQkFBK0IsT0FBTztBQUN0QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHRyYWNlcnNcXGxvZ19zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwbHlQYXRjaCwgfSBmcm9tIFwiLi4vdXRpbHMvZmFzdC1qc29uLXBhdGNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSB9IGZyb20gXCIuLi91dGlscy9zdHJlYW0uanNcIjtcbmltcG9ydCB7IEFJTWVzc2FnZUNodW5rIH0gZnJvbSBcIi4uL21lc3NhZ2VzL2FpLmpzXCI7XG4vKipcbiAqIExpc3Qgb2YganNvbnBhdGNoIEpTT05QYXRjaE9wZXJhdGlvbnMsIHdoaWNoIGRlc2NyaWJlIGhvdyB0byBjcmVhdGUgdGhlIHJ1biBzdGF0ZVxuICogZnJvbSBhbiBlbXB0eSBkaWN0LiBUaGlzIGlzIHRoZSBtaW5pbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsb2csIGRlc2lnbmVkIHRvXG4gKiBiZSBzZXJpYWxpemVkIGFzIEpTT04gYW5kIHNlbnQgb3ZlciB0aGUgd2lyZSB0byByZWNvbnN0cnVjdCB0aGUgbG9nIG9uIHRoZSBvdGhlclxuICogc2lkZS4gUmVjb25zdHJ1Y3Rpb24gb2YgdGhlIHN0YXRlIGNhbiBiZSBkb25lIHdpdGggYW55IGpzb25wYXRjaC1jb21wbGlhbnQgbGlicmFyeSxcbiAqIHNlZSBodHRwczovL2pzb25wYXRjaC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5Mb2dQYXRjaCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wcyA9IGZpZWxkcy5vcHMgPz8gW107XG4gICAgfVxuICAgIGNvbmNhdChvdGhlcikge1xuICAgICAgICBjb25zdCBvcHMgPSB0aGlzLm9wcy5jb25jYXQob3RoZXIub3BzKTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gYXBwbHlQYXRjaCh7fSwgb3BzKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bkxvZyh7XG4gICAgICAgICAgICBvcHMsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1bkxvZyBleHRlbmRzIFJ1bkxvZ1BhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGZpZWxkcy5zdGF0ZTtcbiAgICB9XG4gICAgY29uY2F0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMub3BzLmNvbmNhdChvdGhlci5vcHMpO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBhcHBseVBhdGNoKHRoaXMuc3RhdGUsIG90aGVyLm9wcyk7XG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHsgb3BzLCBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SdW5Mb2dQYXRjaChwYXRjaCkge1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBhcHBseVBhdGNoKHt9LCBwYXRjaC5vcHMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHtcbiAgICAgICAgICAgIG9wczogcGF0Y2gub3BzLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlc1tzdGF0ZXMubGVuZ3RoIC0gMV0ubmV3RG9jdW1lbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBpc0xvZ1N0cmVhbUhhbmRsZXIgPSAoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBcImxvZ19zdHJlYW1fdHJhY2VyXCI7XG4vKipcbiAqIEV4dHJhY3Qgc3RhbmRhcmRpemVkIGlucHV0cyBmcm9tIGEgcnVuLlxuICpcbiAqIFN0YW5kYXJkaXplcyB0aGUgaW5wdXRzIGJhc2VkIG9uIHRoZSB0eXBlIG9mIHRoZSBydW5uYWJsZSB1c2VkLlxuICpcbiAqIEBwYXJhbSBydW4gLSBSdW4gb2JqZWN0XG4gKiBAcGFyYW0gc2NoZW1hRm9ybWF0IC0gVGhlIHNjaGVtYSBmb3JtYXQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm5zIFZhbGlkIGlucHV0cyBhcmUgb25seSBkaWN0LiBCeSBjb252ZW50aW9ucywgaW5wdXRzIGFsd2F5cyByZXByZXNlbnRlZFxuICogaW52b2NhdGlvbiB1c2luZyBuYW1lZCBhcmd1bWVudHMuXG4gKiBBIG51bGwgbWVhbnMgdGhhdCB0aGUgaW5wdXQgaXMgbm90IHlldCBrbm93biFcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2dldFN0YW5kYXJkaXplZElucHV0cyhydW4sIHNjaGVtYUZvcm1hdCkge1xuICAgIGlmIChzY2hlbWFGb3JtYXQgPT09IFwib3JpZ2luYWxcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEbyBub3QgYXNzaWduIGlucHV0cyB3aXRoIG9yaWdpbmFsIHNjaGVtYSBkcm9wIHRoZSBrZXkgZm9yIG5vdy4gXCIgK1xuICAgICAgICAgICAgXCJXaGVuIGlucHV0cyBhcmUgYWRkZWQgdG8gc3RyZWFtTG9nIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHdpdGggXCIgK1xuICAgICAgICAgICAgXCJzdGFuZGFyZGl6ZWQgc2NoZW1hIGZvciBzdHJlYW1pbmcgZXZlbnRzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpbnB1dHMgfSA9IHJ1bjtcbiAgICBpZiAoW1wicmV0cmlldmVyXCIsIFwibGxtXCIsIFwicHJvbXB0XCJdLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKGlucHV0cykubGVuZ3RoID09PSAxICYmIGlucHV0cz8uaW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gbmV3IHN0eWxlIGNoYWluc1xuICAgIC8vIFRoZXNlIG5lc3QgYW4gYWRkaXRpb25hbCAnaW5wdXQnIGtleSBpbnNpZGUgdGhlICdpbnB1dHMnIHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoZSBpbnB1dCBpcyBhbHdheXMgYSBkaWN0LiBXZSBuZWVkIHRvIHVucGFjayBhbmQgdXNlciB0aGUgaW5uZXIgdmFsdWUuXG4gICAgLy8gV2Ugc2hvdWxkIHRyeSB0byBmaXggdGhpcyBpbiBSdW5uYWJsZXMgYW5kIGNhbGxiYWNrcy90cmFjZXJzXG4gICAgLy8gUnVubmFibGVzIHNob3VsZCBiZSB1c2luZyBhIG51bGwgdHlwZSBoZXJlIG5vdCBhIHBsYWNlaG9sZGVyXG4gICAgLy8gZGljdC5cbiAgICByZXR1cm4gaW5wdXRzLmlucHV0O1xufVxuYXN5bmMgZnVuY3Rpb24gX2dldFN0YW5kYXJkaXplZE91dHB1dHMocnVuLCBzY2hlbWFGb3JtYXQpIHtcbiAgICBjb25zdCB7IG91dHB1dHMgfSA9IHJ1bjtcbiAgICBpZiAoc2NoZW1hRm9ybWF0ID09PSBcIm9yaWdpbmFsXCIpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBvbGQgc2NoZW1hLCB3aXRob3V0IHN0YW5kYXJkaXppbmcgYW55dGhpbmdcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIGlmIChbXCJyZXRyaWV2ZXJcIiwgXCJsbG1cIiwgXCJwcm9tcHRcIl0uaW5jbHVkZXMocnVuLnJ1bl90eXBlKSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgaGFja3kgY2hlY2tcbiAgICBpZiAob3V0cHV0cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG91dHB1dHMpLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBvdXRwdXRzPy5vdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb3V0cHV0cy5vdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRzO1xufVxuZnVuY3Rpb24gaXNDaGF0R2VuZXJhdGlvbkNodW5rKHgpIHtcbiAgICByZXR1cm4geCAhPT0gdW5kZWZpbmVkICYmIHgubWVzc2FnZSAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBDbGFzcyB0aGF0IGV4dGVuZHMgdGhlIGBCYXNlVHJhY2VyYCBjbGFzcyBmcm9tIHRoZVxuICogYGxhbmdjaGFpbi5jYWxsYmFja3MudHJhY2Vycy5iYXNlYCBtb2R1bGUuIEl0IHJlcHJlc2VudHMgYSBjYWxsYmFja1xuICogaGFuZGxlciB0aGF0IGxvZ3MgdGhlIGV4ZWN1dGlvbiBvZiBydW5zIGFuZCBlbWl0cyBgUnVuTG9nYCBpbnN0YW5jZXMgdG8gYVxuICogYFJ1bkxvZ1N0cmVhbWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoeyBfYXdhaXRIYW5kbGVyOiB0cnVlLCAuLi5maWVsZHMgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9DbG9zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zY2hlbWFGb3JtYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwib3JpZ2luYWxcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9vdElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleU1hcEJ5UnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb3VudGVyTWFwQnlSdW5OYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNmb3JtU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndyaXRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWNlaXZlU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwibG9nX3N0cmVhbV90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfcHJlZmVyX3N0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPSBmaWVsZHM/LmF1dG9DbG9zZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lcyA9IGZpZWxkcz8uaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcz8uaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzPy5pbmNsdWRlVGFncztcbiAgICAgICAgdGhpcy5leGNsdWRlTmFtZXMgPSBmaWVsZHM/LmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHM/LmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcz8uZXhjbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuX3NjaGVtYUZvcm1hdCA9IGZpZWxkcz8uX3NjaGVtYUZvcm1hdCA/PyB0aGlzLl9zY2hlbWFGb3JtYXQ7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICB0aGlzLndyaXRlciA9IHRoaXMudHJhbnNmb3JtU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVTdHJlYW0gPSBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbSh0aGlzLnRyYW5zZm9ybVN0cmVhbS5yZWFkYWJsZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVTdHJlYW07XG4gICAgfVxuICAgIGFzeW5jIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgICAgLy8gYW5kIGlzIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICB9XG4gICAgX2luY2x1ZGVSdW4ocnVuKSB7XG4gICAgICAgIGlmIChydW4uaWQgPT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVuVGFncyA9IHJ1bi50YWdzID8/IFtdO1xuICAgICAgICBsZXQgaW5jbHVkZSA9IHRoaXMuaW5jbHVkZU5hbWVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKHJ1bi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1bl90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ1blRhZ3MuZmluZCgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1bl90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlICYmIHJ1blRhZ3MuZXZlcnkoKHRhZykgPT4gIXRoaXMuZXhjbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH1cbiAgICBhc3luYyAqdGFwT3V0cHV0SXRlcmFibGUocnVuSWQsIG91dHB1dCkge1xuICAgICAgICAvLyBUYXAgYW4gb3V0cHV0IGFzeW5jIGl0ZXJhdG9yIHRvIHN0cmVhbSBpdHMgdmFsdWVzIHRvIHRoZSBsb2cuXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0KSB7XG4gICAgICAgICAgICAvLyByb290IHJ1biBpcyBoYW5kbGVkIGluIC5zdHJlYW1Mb2coKVxuICAgICAgICAgICAgaWYgKHJ1bklkICE9PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZpbmQgdGhlIHJ1biBzaWxlbnRseSBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBlZy4gYmVjYXVzZSB0aGlzIHJ1biB3YXNuJ3QgaW5jbHVkZWQgaW4gdGhlIGxvZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5TWFwQnlSdW5JZFtydW5JZF07XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7a2V5fS9zdHJlYW1lZF9vdXRwdXQvLWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuQ3JlYXRlKHJ1bikge1xuICAgICAgICBpZiAodGhpcy5yb290SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yb290SWQgPSBydW4uaWQ7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1lZF9vdXRwdXQ6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsX291dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3M6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5jbHVkZVJ1bihydW4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSArPSAxO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV07XG4gICAgICAgIHRoaXMua2V5TWFwQnlSdW5JZFtydW4uaWRdID1cbiAgICAgICAgICAgIGNvdW50ID09PSAxID8gcnVuLm5hbWUgOiBgJHtydW4ubmFtZX06JHtjb3VudH1gO1xuICAgICAgICBjb25zdCBsb2dFbnRyeSA9IHtcbiAgICAgICAgICAgIGlkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW4ubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBuZXcgRGF0ZShydW4uc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0cmVhbWVkX291dHB1dDogW10sXG4gICAgICAgICAgICBzdHJlYW1lZF9vdXRwdXRfc3RyOiBbXSxcbiAgICAgICAgICAgIGZpbmFsX291dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kX3RpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NjaGVtYUZvcm1hdCA9PT0gXCJzdHJlYW1pbmdfZXZlbnRzXCIpIHtcbiAgICAgICAgICAgIGxvZ0VudHJ5LmlucHV0cyA9IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRJbnB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHt0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXX1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbG9nRW50cnksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydW5OYW1lID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF07XG4gICAgICAgICAgICBpZiAocnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5fc2NoZW1hRm9ybWF0ID09PSBcInN0cmVhbWluZ19ldmVudHNcIikge1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9pbnB1dHNgLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgX2dldFN0YW5kYXJkaXplZElucHV0cyhydW4sIHRoaXMuX3NjaGVtYUZvcm1hdCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vZmluYWxfb3V0cHV0YCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgX2dldFN0YW5kYXJkaXplZE91dHB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9lbmRfdGltZWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBSdW5Mb2dQYXRjaCh7IG9wcyB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChydW4uaWQgPT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCIvZmluYWxfb3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRPdXRwdXRzKHJ1biwgdGhpcy5fc2NoZW1hRm9ybWF0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkxMTU5ld1Rva2VuKHJ1biwgdG9rZW4sIGt3YXJncykge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF07XG4gICAgICAgIGlmIChydW5OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgaGFja1xuICAgICAgICBjb25zdCBpc0NoYXRNb2RlbCA9IHJ1bi5pbnB1dHMubWVzc2FnZXMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHN0cmVhbWVkT3V0cHV0VmFsdWU7XG4gICAgICAgIGlmIChpc0NoYXRNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGlzQ2hhdEdlbmVyYXRpb25DaHVuayhrd2FyZ3M/LmNodW5rKSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbWVkT3V0cHV0VmFsdWUgPSBrd2FyZ3M/LmNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtZWRPdXRwdXRWYWx1ZSA9IG5ldyBBSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBgcnVuLSR7cnVuLmlkfWAsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtZWRPdXRwdXRWYWx1ZSA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L3N0cmVhbWVkX291dHB1dF9zdHIvLWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b2tlbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L3N0cmVhbWVkX291dHB1dC8tYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbWVkT3V0cHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/root_listener.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RootListenersTracer: () => (/* binding */ RootListenersTracer)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\");\n\nclass RootListenersTracer extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseTracer {\n    constructor({ config, onStart, onEnd, onError, }) {\n        super({ _awaitHandler: true });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"RootListenersTracer\"\n        });\n        /** The Run's ID. Type UUID */\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnStart\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnEnd\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.config = config;\n        this.argOnStart = onStart;\n        this.argOnEnd = onEnd;\n        this.argOnError = onError;\n    }\n    /**\n     * This is a legacy method only called once for an entire run tree\n     * therefore not useful here\n     * @param {Run} _ Not used\n     */\n    persistRun(_) {\n        return Promise.resolve();\n    }\n    async onRunCreate(run) {\n        if (this.rootId) {\n            return;\n        }\n        this.rootId = run.id;\n        if (this.argOnStart) {\n            await this.argOnStart(run, this.config);\n        }\n    }\n    async onRunUpdate(run) {\n        if (run.id !== this.rootId) {\n            return;\n        }\n        if (!run.error) {\n            if (this.argOnEnd) {\n                await this.argOnEnd(run, this.config);\n            }\n        }\n        else if (this.argOnError) {\n            await this.argOnError(run, this.config);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9yb290X2xpc3RlbmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDO0FBQ2hDLGtDQUFrQyxnREFBVTtBQUNuRCxrQkFBa0Isa0NBQWtDO0FBQ3BELGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx0cmFjZXJzXFxyb290X2xpc3RlbmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgY2xhc3MgUm9vdExpc3RlbmVyc1RyYWNlciBleHRlbmRzIEJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgY29uZmlnLCBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciwgfSkge1xuICAgICAgICBzdXBlcih7IF9hd2FpdEhhbmRsZXI6IHRydWUgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiUm9vdExpc3RlbmVyc1RyYWNlclwiXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogVGhlIFJ1bidzIElELiBUeXBlIFVVSUQgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9vdElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcmdPblN0YXJ0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFyZ09uRW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFyZ09uRXJyb3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuYXJnT25TdGFydCA9IG9uU3RhcnQ7XG4gICAgICAgIHRoaXMuYXJnT25FbmQgPSBvbkVuZDtcbiAgICAgICAgdGhpcy5hcmdPbkVycm9yID0gb25FcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGxlZ2FjeSBtZXRob2Qgb25seSBjYWxsZWQgb25jZSBmb3IgYW4gZW50aXJlIHJ1biB0cmVlXG4gICAgICogdGhlcmVmb3JlIG5vdCB1c2VmdWwgaGVyZVxuICAgICAqIEBwYXJhbSB7UnVufSBfIE5vdCB1c2VkXG4gICAgICovXG4gICAgcGVyc2lzdFJ1bihfKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5DcmVhdGUocnVuKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdElkID0gcnVuLmlkO1xuICAgICAgICBpZiAodGhpcy5hcmdPblN0YXJ0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uU3RhcnQocnVuLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIGlmIChydW4uaWQgIT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFydW4uZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZ09uRW5kKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdPbkVuZChydW4sIHRoaXMuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFyZ09uRXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJnT25FcnJvcihydW4sIHRoaXMuY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/run_collector.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/run_collector.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunCollectorCallbackHandler: () => (/* binding */ RunCollectorCallbackHandler)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\");\n\n/**\n * A callback handler that collects traced runs and makes it easy to fetch the traced run object from calls through any langchain object.\n * For instance, it makes it easy to fetch the run ID and then do things with that, such as log feedback.\n */\nclass RunCollectorCallbackHandler extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseTracer {\n    /**\n     * Creates a new instance of the RunCollectorCallbackHandler class.\n     * @param exampleId The ID of the example.\n     */\n    constructor({ exampleId } = {}) {\n        super({ _awaitHandler: true });\n        /** The name of the callback handler. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"run_collector\"\n        });\n        /** The ID of the example. */\n        Object.defineProperty(this, \"exampleId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** An array of traced runs. */\n        Object.defineProperty(this, \"tracedRuns\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.exampleId = exampleId;\n        this.tracedRuns = [];\n    }\n    /**\n     * Persists the given run object.\n     * @param run The run object to persist.\n     */\n    async persistRun(run) {\n        const run_ = { ...run };\n        run_.reference_example_id = this.exampleId;\n        this.tracedRuns.push(run_);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9ydW5fY29sbGVjdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLGdEQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVksSUFBSTtBQUNsQyxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xccnVuX2NvbGxlY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBjb2xsZWN0cyB0cmFjZWQgcnVucyBhbmQgbWFrZXMgaXQgZWFzeSB0byBmZXRjaCB0aGUgdHJhY2VkIHJ1biBvYmplY3QgZnJvbSBjYWxscyB0aHJvdWdoIGFueSBsYW5nY2hhaW4gb2JqZWN0LlxuICogRm9yIGluc3RhbmNlLCBpdCBtYWtlcyBpdCBlYXN5IHRvIGZldGNoIHRoZSBydW4gSUQgYW5kIHRoZW4gZG8gdGhpbmdzIHdpdGggdGhhdCwgc3VjaCBhcyBsb2cgZmVlZGJhY2suXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5Db2xsZWN0b3JDYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBSdW5Db2xsZWN0b3JDYWxsYmFja0hhbmRsZXIgY2xhc3MuXG4gICAgICogQHBhcmFtIGV4YW1wbGVJZCBUaGUgSUQgb2YgdGhlIGV4YW1wbGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBleGFtcGxlSWQgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHsgX2F3YWl0SGFuZGxlcjogdHJ1ZSB9KTtcbiAgICAgICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjYWxsYmFjayBoYW5kbGVyLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcInJ1bl9jb2xsZWN0b3JcIlxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBJRCBvZiB0aGUgZXhhbXBsZS4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhhbXBsZUlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBBbiBhcnJheSBvZiB0cmFjZWQgcnVucy4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2VkUnVuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4YW1wbGVJZCA9IGV4YW1wbGVJZDtcbiAgICAgICAgdGhpcy50cmFjZWRSdW5zID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcnNpc3RzIHRoZSBnaXZlbiBydW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJ1biBvYmplY3QgdG8gcGVyc2lzdC5cbiAgICAgKi9cbiAgICBhc3luYyBwZXJzaXN0UnVuKHJ1bikge1xuICAgICAgICBjb25zdCBydW5fID0geyAuLi5ydW4gfTtcbiAgICAgICAgcnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCA9IHRoaXMuZXhhbXBsZUlkO1xuICAgICAgICB0aGlzLnRyYWNlZFJ1bnMucHVzaChydW5fKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/run_collector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/tracer_langchain.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangChainTracer: () => (/* binding */ LangChainTracer)\n/* harmony export */ });\n/* harmony import */ var langsmith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.js\");\n/* harmony import */ var langsmith_run_trees__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langsmith/run_trees */ \"(rsc)/./node_modules/langsmith/run_trees.js\");\n/* harmony import */ var langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! langsmith/singletons/traceable */ \"(rsc)/./node_modules/langsmith/singletons/traceable.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\");\n/* harmony import */ var _singletons_tracer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../singletons/tracer.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.js\");\n\n\n\n\n\nclass LangChainTracer extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseTracer {\n    constructor(fields = {}) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"langchain_tracer\"\n        });\n        Object.defineProperty(this, \"projectName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exampleId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"usesRunTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        const { exampleId, projectName, client, replicas } = fields;\n        this.projectName = projectName ?? (0,langsmith__WEBPACK_IMPORTED_MODULE_0__.getDefaultProjectName)();\n        this.replicas = replicas;\n        this.exampleId = exampleId;\n        this.client = client ?? (0,_singletons_tracer_js__WEBPACK_IMPORTED_MODULE_4__.getDefaultLangChainClientSingleton)();\n        const traceableTree = LangChainTracer.getTraceableRunTree();\n        if (traceableTree) {\n            this.updateFromRunTree(traceableTree);\n        }\n    }\n    async persistRun(_run) { }\n    async onRunCreate(run) {\n        const runTree = this.getRunTreeWithTracingConfig(run.id);\n        await runTree?.postRun();\n    }\n    async onRunUpdate(run) {\n        const runTree = this.getRunTreeWithTracingConfig(run.id);\n        await runTree?.patchRun();\n    }\n    getRun(id) {\n        return this.runTreeMap.get(id);\n    }\n    updateFromRunTree(runTree) {\n        this.runTreeMap.set(runTree.id, runTree);\n        let rootRun = runTree;\n        const visited = new Set();\n        while (rootRun.parent_run) {\n            if (visited.has(rootRun.id))\n                break;\n            visited.add(rootRun.id);\n            if (!rootRun.parent_run)\n                break;\n            rootRun = rootRun.parent_run;\n        }\n        visited.clear();\n        const queue = [rootRun];\n        while (queue.length > 0) {\n            const current = queue.shift();\n            if (!current || visited.has(current.id))\n                continue;\n            visited.add(current.id);\n            this.runTreeMap.set(current.id, current);\n            if (current.child_runs) {\n                queue.push(...current.child_runs);\n            }\n        }\n        this.client = runTree.client ?? this.client;\n        this.replicas = runTree.replicas ?? this.replicas;\n        this.projectName = runTree.project_name ?? this.projectName;\n        this.exampleId = runTree.reference_example_id ?? this.exampleId;\n    }\n    getRunTreeWithTracingConfig(id) {\n        const runTree = this.runTreeMap.get(id);\n        if (!runTree)\n            return undefined;\n        return new langsmith_run_trees__WEBPACK_IMPORTED_MODULE_1__.RunTree({\n            ...runTree,\n            client: this.client,\n            project_name: this.projectName,\n            replicas: this.replicas,\n            reference_example_id: this.exampleId,\n            tracingEnabled: true,\n        });\n    }\n    static getTraceableRunTree() {\n        try {\n            return (\n            // The type cast here provides forward compatibility. Old versions of LangSmith will just\n            // ignore the permitAbsentRunTree arg.\n            (0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_2__.getCurrentRunTree)(true));\n        }\n        catch {\n            return undefined;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRDtBQUNMO0FBQ3FCO0FBQzVCO0FBQ3NDO0FBQ3RFLDhCQUE4QixnREFBVTtBQUMvQywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsMkNBQTJDO0FBQzNELDBDQUEwQyxnRUFBcUI7QUFDL0Q7QUFDQTtBQUNBLGdDQUFnQyx5RkFBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHRyYWNlcnNcXHRyYWNlcl9sYW5nY2hhaW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RGVmYXVsdFByb2plY3ROYW1lLCB9IGZyb20gXCJsYW5nc21pdGhcIjtcbmltcG9ydCB7IFJ1blRyZWUgfSBmcm9tIFwibGFuZ3NtaXRoL3J1bl90cmVlc1wiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudFJ1blRyZWUgfSBmcm9tIFwibGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlXCI7XG5pbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdExhbmdDaGFpbkNsaWVudFNpbmdsZXRvbiB9IGZyb20gXCIuLi9zaW5nbGV0b25zL3RyYWNlci5qc1wiO1xuZXhwb3J0IGNsYXNzIExhbmdDaGFpblRyYWNlciBleHRlbmRzIEJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwibGFuZ2NoYWluX3RyYWNlclwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0TmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGFtcGxlSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcGxpY2FzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVzZXNSdW5UcmVlTWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGV4YW1wbGVJZCwgcHJvamVjdE5hbWUsIGNsaWVudCwgcmVwbGljYXMgfSA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5wcm9qZWN0TmFtZSA9IHByb2plY3ROYW1lID8/IGdldERlZmF1bHRQcm9qZWN0TmFtZSgpO1xuICAgICAgICB0aGlzLnJlcGxpY2FzID0gcmVwbGljYXM7XG4gICAgICAgIHRoaXMuZXhhbXBsZUlkID0gZXhhbXBsZUlkO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudCA/PyBnZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uKCk7XG4gICAgICAgIGNvbnN0IHRyYWNlYWJsZVRyZWUgPSBMYW5nQ2hhaW5UcmFjZXIuZ2V0VHJhY2VhYmxlUnVuVHJlZSgpO1xuICAgICAgICBpZiAodHJhY2VhYmxlVHJlZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tUnVuVHJlZSh0cmFjZWFibGVUcmVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0UnVuKF9ydW4pIHsgfVxuICAgIGFzeW5jIG9uUnVuQ3JlYXRlKHJ1bikge1xuICAgICAgICBjb25zdCBydW5UcmVlID0gdGhpcy5nZXRSdW5UcmVlV2l0aFRyYWNpbmdDb25maWcocnVuLmlkKTtcbiAgICAgICAgYXdhaXQgcnVuVHJlZT8ucG9zdFJ1bigpO1xuICAgIH1cbiAgICBhc3luYyBvblJ1blVwZGF0ZShydW4pIHtcbiAgICAgICAgY29uc3QgcnVuVHJlZSA9IHRoaXMuZ2V0UnVuVHJlZVdpdGhUcmFjaW5nQ29uZmlnKHJ1bi5pZCk7XG4gICAgICAgIGF3YWl0IHJ1blRyZWU/LnBhdGNoUnVuKCk7XG4gICAgfVxuICAgIGdldFJ1bihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5UcmVlTWFwLmdldChpZCk7XG4gICAgfVxuICAgIHVwZGF0ZUZyb21SdW5UcmVlKHJ1blRyZWUpIHtcbiAgICAgICAgdGhpcy5ydW5UcmVlTWFwLnNldChydW5UcmVlLmlkLCBydW5UcmVlKTtcbiAgICAgICAgbGV0IHJvb3RSdW4gPSBydW5UcmVlO1xuICAgICAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICB3aGlsZSAocm9vdFJ1bi5wYXJlbnRfcnVuKSB7XG4gICAgICAgICAgICBpZiAodmlzaXRlZC5oYXMocm9vdFJ1bi5pZCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChyb290UnVuLmlkKTtcbiAgICAgICAgICAgIGlmICghcm9vdFJ1bi5wYXJlbnRfcnVuKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcm9vdFJ1biA9IHJvb3RSdW4ucGFyZW50X3J1bjtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkLmNsZWFyKCk7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW3Jvb3RSdW5dO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQgfHwgdmlzaXRlZC5oYXMoY3VycmVudC5pZCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChjdXJyZW50LmlkKTtcbiAgICAgICAgICAgIHRoaXMucnVuVHJlZU1hcC5zZXQoY3VycmVudC5pZCwgY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5jaGlsZF9ydW5zKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCguLi5jdXJyZW50LmNoaWxkX3J1bnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50ID0gcnVuVHJlZS5jbGllbnQgPz8gdGhpcy5jbGllbnQ7XG4gICAgICAgIHRoaXMucmVwbGljYXMgPSBydW5UcmVlLnJlcGxpY2FzID8/IHRoaXMucmVwbGljYXM7XG4gICAgICAgIHRoaXMucHJvamVjdE5hbWUgPSBydW5UcmVlLnByb2plY3RfbmFtZSA/PyB0aGlzLnByb2plY3ROYW1lO1xuICAgICAgICB0aGlzLmV4YW1wbGVJZCA9IHJ1blRyZWUucmVmZXJlbmNlX2V4YW1wbGVfaWQgPz8gdGhpcy5leGFtcGxlSWQ7XG4gICAgfVxuICAgIGdldFJ1blRyZWVXaXRoVHJhY2luZ0NvbmZpZyhpZCkge1xuICAgICAgICBjb25zdCBydW5UcmVlID0gdGhpcy5ydW5UcmVlTWFwLmdldChpZCk7XG4gICAgICAgIGlmICghcnVuVHJlZSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAuLi5ydW5UcmVlLFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogdGhpcy5wcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIHJlcGxpY2FzOiB0aGlzLnJlcGxpY2FzLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHRoaXMuZXhhbXBsZUlkLFxuICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VHJhY2VhYmxlUnVuVHJlZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBUaGUgdHlwZSBjYXN0IGhlcmUgcHJvdmlkZXMgZm9yd2FyZCBjb21wYXRpYmlsaXR5LiBPbGQgdmVyc2lvbnMgb2YgTGFuZ1NtaXRoIHdpbGwganVzdFxuICAgICAgICAgICAgLy8gaWdub3JlIHRoZSBwZXJtaXRBYnNlbnRSdW5UcmVlIGFyZy5cbiAgICAgICAgICAgIGdldEN1cnJlbnRSdW5UcmVlKHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain_v1.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/tracer_langchain_v1.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangChainTracerV1: () => (/* binding */ LangChainTracerV1)\n/* harmony export */ });\n/* harmony import */ var _messages_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../messages/utils.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\");\n\n\n\n/** @deprecated Use LangChainTracer instead. */\nclass LangChainTracerV1 extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseTracer {\n    constructor() {\n        super();\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"langchain_tracer\"\n        });\n        Object.defineProperty(this, \"endpoint\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") || \"http://localhost:1984\"\n        });\n        Object.defineProperty(this, \"headers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                \"Content-Type\": \"application/json\",\n            }\n        });\n        Object.defineProperty(this, \"session\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\");\n        if (apiKey) {\n            this.headers[\"x-api-key\"] = apiKey;\n        }\n    }\n    async newSession(sessionName) {\n        const sessionCreate = {\n            start_time: Date.now(),\n            name: sessionName,\n        };\n        const session = await this.persistSession(sessionCreate);\n        this.session = session;\n        return session;\n    }\n    async loadSession(sessionName) {\n        const endpoint = `${this.endpoint}/sessions?name=${sessionName}`;\n        return this._handleSessionResponse(endpoint);\n    }\n    async loadDefaultSession() {\n        const endpoint = `${this.endpoint}/sessions?name=default`;\n        return this._handleSessionResponse(endpoint);\n    }\n    async convertV2RunToRun(run) {\n        const session = this.session ?? (await this.loadDefaultSession());\n        const serialized = run.serialized;\n        let runResult;\n        if (run.run_type === \"llm\") {\n            const prompts = run.inputs.prompts\n                ? run.inputs.prompts\n                : run.inputs.messages.map((x) => (0,_messages_utils_js__WEBPACK_IMPORTED_MODULE_0__.getBufferString)(x));\n            const llmRun = {\n                uuid: run.id,\n                start_time: run.start_time,\n                end_time: run.end_time,\n                execution_order: run.execution_order,\n                child_execution_order: run.child_execution_order,\n                serialized,\n                type: run.run_type,\n                session_id: session.id,\n                prompts,\n                response: run.outputs,\n            };\n            runResult = llmRun;\n        }\n        else if (run.run_type === \"chain\") {\n            const child_runs = await Promise.all(run.child_runs.map((child_run) => this.convertV2RunToRun(child_run)));\n            const chainRun = {\n                uuid: run.id,\n                start_time: run.start_time,\n                end_time: run.end_time,\n                execution_order: run.execution_order,\n                child_execution_order: run.child_execution_order,\n                serialized,\n                type: run.run_type,\n                session_id: session.id,\n                inputs: run.inputs,\n                outputs: run.outputs,\n                child_llm_runs: child_runs.filter((child_run) => child_run.type === \"llm\"),\n                child_chain_runs: child_runs.filter((child_run) => child_run.type === \"chain\"),\n                child_tool_runs: child_runs.filter((child_run) => child_run.type === \"tool\"),\n            };\n            runResult = chainRun;\n        }\n        else if (run.run_type === \"tool\") {\n            const child_runs = await Promise.all(run.child_runs.map((child_run) => this.convertV2RunToRun(child_run)));\n            const toolRun = {\n                uuid: run.id,\n                start_time: run.start_time,\n                end_time: run.end_time,\n                execution_order: run.execution_order,\n                child_execution_order: run.child_execution_order,\n                serialized,\n                type: run.run_type,\n                session_id: session.id,\n                tool_input: run.inputs.input,\n                output: run.outputs?.output,\n                action: JSON.stringify(serialized),\n                child_llm_runs: child_runs.filter((child_run) => child_run.type === \"llm\"),\n                child_chain_runs: child_runs.filter((child_run) => child_run.type === \"chain\"),\n                child_tool_runs: child_runs.filter((child_run) => child_run.type === \"tool\"),\n            };\n            runResult = toolRun;\n        }\n        else {\n            throw new Error(`Unknown run type: ${run.run_type}`);\n        }\n        return runResult;\n    }\n    async persistRun(run) {\n        let endpoint;\n        let v1Run;\n        if (run.run_type !== undefined) {\n            v1Run = await this.convertV2RunToRun(run);\n        }\n        else {\n            v1Run = run;\n        }\n        if (v1Run.type === \"llm\") {\n            endpoint = `${this.endpoint}/llm-runs`;\n        }\n        else if (v1Run.type === \"chain\") {\n            endpoint = `${this.endpoint}/chain-runs`;\n        }\n        else {\n            endpoint = `${this.endpoint}/tool-runs`;\n        }\n        const response = await fetch(endpoint, {\n            method: \"POST\",\n            headers: this.headers,\n            body: JSON.stringify(v1Run),\n        });\n        if (!response.ok) {\n            console.error(`Failed to persist run: ${response.status} ${response.statusText}`);\n        }\n    }\n    async persistSession(sessionCreate) {\n        const endpoint = `${this.endpoint}/sessions`;\n        const response = await fetch(endpoint, {\n            method: \"POST\",\n            headers: this.headers,\n            body: JSON.stringify(sessionCreate),\n        });\n        if (!response.ok) {\n            console.error(`Failed to persist session: ${response.status} ${response.statusText}, using default session.`);\n            return {\n                id: 1,\n                ...sessionCreate,\n            };\n        }\n        return {\n            id: (await response.json()).id,\n            ...sessionCreate,\n        };\n    }\n    async _handleSessionResponse(endpoint) {\n        const response = await fetch(endpoint, {\n            method: \"GET\",\n            headers: this.headers,\n        });\n        let tracerSession;\n        if (!response.ok) {\n            console.error(`Failed to load session: ${response.status} ${response.statusText}`);\n            tracerSession = {\n                id: 1,\n                start_time: Date.now(),\n            };\n            this.session = tracerSession;\n            return tracerSession;\n        }\n        const resp = (await response.json());\n        if (resp.length === 0) {\n            tracerSession = {\n                id: 1,\n                start_time: Date.now(),\n            };\n            this.session = tracerSession;\n            return tracerSession;\n        }\n        [tracerSession] = resp;\n        this.session = tracerSession;\n        return tracerSession;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluX3YxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUQ7QUFDRTtBQUNsQjtBQUN2QztBQUNPLGdDQUFnQyxnREFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxRUFBc0I7QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLHFFQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWMsaUJBQWlCLFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1FQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0RBQW9ELGlCQUFpQixFQUFFLG9CQUFvQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdEQUF3RCxpQkFBaUIsRUFBRSxvQkFBb0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscURBQXFELGlCQUFpQixFQUFFLG9CQUFvQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xcdHJhY2VyX2xhbmdjaGFpbl92MS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRCdWZmZXJTdHJpbmcgfSBmcm9tIFwiLi4vbWVzc2FnZXMvdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBMYW5nQ2hhaW5UcmFjZXIgaW5zdGVhZC4gKi9cbmV4cG9ydCBjbGFzcyBMYW5nQ2hhaW5UcmFjZXJWMSBleHRlbmRzIEJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImxhbmdjaGFpbl90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5kcG9pbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIikgfHwgXCJodHRwOi8vbG9jYWxob3N0OjE5ODRcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVhZGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2Vzc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhcGlLZXkgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0FQSV9LRVlcIik7XG4gICAgICAgIGlmIChhcGlLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1tcIngtYXBpLWtleVwiXSA9IGFwaUtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBuZXdTZXNzaW9uKHNlc3Npb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25DcmVhdGUgPSB7XG4gICAgICAgICAgICBzdGFydF90aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgbmFtZTogc2Vzc2lvbk5hbWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCB0aGlzLnBlcnNpc3RTZXNzaW9uKHNlc3Npb25DcmVhdGUpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICB9XG4gICAgYXN5bmMgbG9hZFNlc3Npb24oc2Vzc2lvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmVuZHBvaW50fS9zZXNzaW9ucz9uYW1lPSR7c2Vzc2lvbk5hbWV9YDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVNlc3Npb25SZXNwb25zZShlbmRwb2ludCk7XG4gICAgfVxuICAgIGFzeW5jIGxvYWREZWZhdWx0U2Vzc2lvbigpIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmVuZHBvaW50fS9zZXNzaW9ucz9uYW1lPWRlZmF1bHRgO1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU2Vzc2lvblJlc3BvbnNlKGVuZHBvaW50KTtcbiAgICB9XG4gICAgYXN5bmMgY29udmVydFYyUnVuVG9SdW4ocnVuKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnNlc3Npb24gPz8gKGF3YWl0IHRoaXMubG9hZERlZmF1bHRTZXNzaW9uKCkpO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gcnVuLnNlcmlhbGl6ZWQ7XG4gICAgICAgIGxldCBydW5SZXN1bHQ7XG4gICAgICAgIGlmIChydW4ucnVuX3R5cGUgPT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21wdHMgPSBydW4uaW5wdXRzLnByb21wdHNcbiAgICAgICAgICAgICAgICA/IHJ1bi5pbnB1dHMucHJvbXB0c1xuICAgICAgICAgICAgICAgIDogcnVuLmlucHV0cy5tZXNzYWdlcy5tYXAoKHgpID0+IGdldEJ1ZmZlclN0cmluZyh4KSk7XG4gICAgICAgICAgICBjb25zdCBsbG1SdW4gPSB7XG4gICAgICAgICAgICAgICAgdXVpZDogcnVuLmlkLFxuICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHJ1bi5zdGFydF90aW1lLFxuICAgICAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyOiBydW4uZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogcnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uLmlkLFxuICAgICAgICAgICAgICAgIHByb21wdHMsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJ1bi5vdXRwdXRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJ1blJlc3VsdCA9IGxsbVJ1bjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW4ucnVuX3R5cGUgPT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRfcnVucyA9IGF3YWl0IFByb21pc2UuYWxsKHJ1bi5jaGlsZF9ydW5zLm1hcCgoY2hpbGRfcnVuKSA9PiB0aGlzLmNvbnZlcnRWMlJ1blRvUnVuKGNoaWxkX3J1bikpKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluUnVuID0ge1xuICAgICAgICAgICAgICAgIHV1aWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSxcbiAgICAgICAgICAgICAgICBlbmRfdGltZTogcnVuLmVuZF90aW1lLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcjogcnVuLmV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IHJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBydW4ucnVuX3R5cGUsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbi5pZCxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogcnVuLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgY2hpbGRfbGxtX3J1bnM6IGNoaWxkX3J1bnMuZmlsdGVyKChjaGlsZF9ydW4pID0+IGNoaWxkX3J1bi50eXBlID09PSBcImxsbVwiKSxcbiAgICAgICAgICAgICAgICBjaGlsZF9jaGFpbl9ydW5zOiBjaGlsZF9ydW5zLmZpbHRlcigoY2hpbGRfcnVuKSA9PiBjaGlsZF9ydW4udHlwZSA9PT0gXCJjaGFpblwiKSxcbiAgICAgICAgICAgICAgICBjaGlsZF90b29sX3J1bnM6IGNoaWxkX3J1bnMuZmlsdGVyKChjaGlsZF9ydW4pID0+IGNoaWxkX3J1bi50eXBlID09PSBcInRvb2xcIiksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnVuUmVzdWx0ID0gY2hhaW5SdW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuLnJ1bl90eXBlID09PSBcInRvb2xcIikge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRfcnVucyA9IGF3YWl0IFByb21pc2UuYWxsKHJ1bi5jaGlsZF9ydW5zLm1hcCgoY2hpbGRfcnVuKSA9PiB0aGlzLmNvbnZlcnRWMlJ1blRvUnVuKGNoaWxkX3J1bikpKTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xSdW4gPSB7XG4gICAgICAgICAgICAgICAgdXVpZDogcnVuLmlkLFxuICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHJ1bi5zdGFydF90aW1lLFxuICAgICAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyOiBydW4uZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogcnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uLmlkLFxuICAgICAgICAgICAgICAgIHRvb2xfaW5wdXQ6IHJ1bi5pbnB1dHMuaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBydW4ub3V0cHV0cz8ub3V0cHV0LFxuICAgICAgICAgICAgICAgIGFjdGlvbjogSlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplZCksXG4gICAgICAgICAgICAgICAgY2hpbGRfbGxtX3J1bnM6IGNoaWxkX3J1bnMuZmlsdGVyKChjaGlsZF9ydW4pID0+IGNoaWxkX3J1bi50eXBlID09PSBcImxsbVwiKSxcbiAgICAgICAgICAgICAgICBjaGlsZF9jaGFpbl9ydW5zOiBjaGlsZF9ydW5zLmZpbHRlcigoY2hpbGRfcnVuKSA9PiBjaGlsZF9ydW4udHlwZSA9PT0gXCJjaGFpblwiKSxcbiAgICAgICAgICAgICAgICBjaGlsZF90b29sX3J1bnM6IGNoaWxkX3J1bnMuZmlsdGVyKChjaGlsZF9ydW4pID0+IGNoaWxkX3J1bi50eXBlID09PSBcInRvb2xcIiksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnVuUmVzdWx0ID0gdG9vbFJ1bjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBydW4gdHlwZTogJHtydW4ucnVuX3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1blJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgcGVyc2lzdFJ1bihydW4pIHtcbiAgICAgICAgbGV0IGVuZHBvaW50O1xuICAgICAgICBsZXQgdjFSdW47XG4gICAgICAgIGlmIChydW4ucnVuX3R5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdjFSdW4gPSBhd2FpdCB0aGlzLmNvbnZlcnRWMlJ1blRvUnVuKHJ1bik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2MVJ1biA9IHJ1bjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodjFSdW4udHlwZSA9PT0gXCJsbG1cIikge1xuICAgICAgICAgICAgZW5kcG9pbnQgPSBgJHt0aGlzLmVuZHBvaW50fS9sbG0tcnVuc2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodjFSdW4udHlwZSA9PT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICBlbmRwb2ludCA9IGAke3RoaXMuZW5kcG9pbnR9L2NoYWluLXJ1bnNgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kcG9pbnQgPSBgJHt0aGlzLmVuZHBvaW50fS90b29sLXJ1bnNgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh2MVJ1biksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcGVyc2lzdCBydW46ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGVyc2lzdFNlc3Npb24oc2Vzc2lvbkNyZWF0ZSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuZW5kcG9pbnR9L3Nlc3Npb25zYDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHNlc3Npb25DcmVhdGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBlcnNpc3Qgc2Vzc2lvbjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0sIHVzaW5nIGRlZmF1bHQgc2Vzc2lvbi5gKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgLi4uc2Vzc2lvbkNyZWF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiAoYXdhaXQgcmVzcG9uc2UuanNvbigpKS5pZCxcbiAgICAgICAgICAgIC4uLnNlc3Npb25DcmVhdGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGVTZXNzaW9uUmVzcG9uc2UoZW5kcG9pbnQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRyYWNlclNlc3Npb247XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIHNlc3Npb246ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB0cmFjZXJTZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gdHJhY2VyU2Vzc2lvbjtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZXJTZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3AgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbiAgICAgICAgaWYgKHJlc3AubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0cmFjZXJTZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gdHJhY2VyU2Vzc2lvbjtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZXJTZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIFt0cmFjZXJTZXNzaW9uXSA9IHJlc3A7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHRyYWNlclNlc3Npb247XG4gICAgICAgIHJldHVybiB0cmFjZXJTZXNzaW9uO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain_v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/async_caller.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    402, // Payment Required\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst defaultFailedAttemptHandler = (error) => {\n    if (error.message.startsWith(\"Cancel\") ||\n        error.message.startsWith(\"AbortError\") ||\n        error.name === \"AbortError\") {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.code === \"ECONNABORTED\") {\n        throw error;\n    }\n    const status = \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error?.response?.status ?? error?.status;\n    if (status && STATUS_NO_RETRY.includes(+status)) {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.error?.code === \"insufficient_quota\") {\n        const err = new Error(error?.message);\n        err.name = \"InsufficientQuotaError\";\n        throw err;\n    }\n};\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.onFailedAttempt =\n            params.onFailedAttempt ?? defaultFailedAttemptHandler;\n        const PQueue = ( true ? p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"] : p_queue__WEBPACK_IMPORTED_MODULE_1__);\n        this.queue = new PQueue({ concurrency: this.maxConcurrency });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.queue.add(() => p_retry__WEBPACK_IMPORTED_MODULE_0__(() => callable(...args).catch((error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            onFailedAttempt: this.onFailedAttempt,\n            retries: this.maxRetries,\n            randomize: true,\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(() => fetch(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QjtBQUNHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXNCLEdBQUcsK0NBQWlCLEdBQUcsb0NBQVM7QUFDOUUsa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcYXN5bmNfY2FsbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwUmV0cnkgZnJvbSBcInAtcmV0cnlcIjtcbmltcG9ydCBQUXVldWVNb2QgZnJvbSBcInAtcXVldWVcIjtcbmNvbnN0IFNUQVRVU19OT19SRVRSWSA9IFtcbiAgICA0MDAsIC8vIEJhZCBSZXF1ZXN0XG4gICAgNDAxLCAvLyBVbmF1dGhvcml6ZWRcbiAgICA0MDIsIC8vIFBheW1lbnQgUmVxdWlyZWRcbiAgICA0MDMsIC8vIEZvcmJpZGRlblxuICAgIDQwNCwgLy8gTm90IEZvdW5kXG4gICAgNDA1LCAvLyBNZXRob2QgTm90IEFsbG93ZWRcbiAgICA0MDYsIC8vIE5vdCBBY2NlcHRhYmxlXG4gICAgNDA3LCAvLyBQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFxuICAgIDQwOSwgLy8gQ29uZmxpY3Rcbl07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgZGVmYXVsdEZhaWxlZEF0dGVtcHRIYW5kbGVyID0gKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkNhbmNlbFwiKSB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJBYm9ydEVycm9yXCIpIHx8XG4gICAgICAgIGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGlmIChlcnJvcj8uY29kZSA9PT0gXCJFQ09OTkFCT1JURURcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBlcnJvcj8ucmVzcG9uc2U/LnN0YXR1cyA/PyBlcnJvcj8uc3RhdHVzO1xuICAgIGlmIChzdGF0dXMgJiYgU1RBVFVTX05PX1JFVFJZLmluY2x1ZGVzKCtzdGF0dXMpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGlmIChlcnJvcj8uZXJyb3I/LmNvZGUgPT09IFwiaW5zdWZmaWNpZW50X3F1b3RhXCIpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm9yPy5tZXNzYWdlKTtcbiAgICAgICAgZXJyLm5hbWUgPSBcIkluc3VmZmljaWVudFF1b3RhRXJyb3JcIjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFzeW5jIGNhbGxzIHdpdGggY29uY3VycmVuY3kgYW5kIHJldHJ5IGxvZ2ljLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBtYWtpbmcgY2FsbHMgdG8gYW55IGtpbmQgb2YgXCJleHBlbnNpdmVcIiBleHRlcm5hbCByZXNvdXJjZSxcbiAqIGJlIGl0IGJlY2F1c2UgaXQncyByYXRlLWxpbWl0ZWQsIHN1YmplY3QgdG8gbmV0d29yayBpc3N1ZXMsIGV0Yy5cbiAqXG4gKiBDb25jdXJyZW50IGNhbGxzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4Q29uY3VycmVuY3lgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHNcbiAqIHRvIGBJbmZpbml0eWAuIFRoaXMgbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBhbGwgY2FsbHMgd2lsbCBiZSBtYWRlIGluIHBhcmFsbGVsLlxuICpcbiAqIFJldHJpZXMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhSZXRyaWVzYCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIDYuIFRoaXNcbiAqIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgZWFjaCBjYWxsIHdpbGwgYmUgcmV0cmllZCB1cCB0byA2IHRpbWVzLCB3aXRoIGFuXG4gKiBleHBvbmVudGlhbCBiYWNrb2ZmIGJldHdlZW4gZWFjaCBhdHRlbXB0LlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNDYWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhSZXRyaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkQXR0ZW1wdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gcGFyYW1zLm1heENvbmN1cnJlbmN5ID8/IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBwYXJhbXMubWF4UmV0cmllcyA/PyA2O1xuICAgICAgICB0aGlzLm9uRmFpbGVkQXR0ZW1wdCA9XG4gICAgICAgICAgICBwYXJhbXMub25GYWlsZWRBdHRlbXB0ID8/IGRlZmF1bHRGYWlsZWRBdHRlbXB0SGFuZGxlcjtcbiAgICAgICAgY29uc3QgUFF1ZXVlID0gKFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCA/IFBRdWV1ZU1vZC5kZWZhdWx0IDogUFF1ZXVlTW9kKTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWUoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmFkZCgoKSA9PiBwUmV0cnkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogdGhpcy5vbkZhaWxlZEF0dGVtcHQsXG4gICAgICAgICAgICByZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQgd2UgY2FuIGNoYW5nZSBzb21lIG9mIHRoZSBkZWZhdWx0cyBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IHRoZXkncmUgcXVpdGUgc2Vuc2libGUuXG4gICAgICAgIH0pLCB7IHRocm93T25UaW1lb3V0OiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICAvLyBOb3RlIHRoaXMgZG9lc24ndCBjYW5jZWwgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCxcbiAgICAgICAgLy8gd2hlbiBhdmFpbGFibGUgcHJlZmVyIHRvIHVzZSB0aGUgc2lnbmFsIG9wdGlvbiBvZiB0aGUgdW5kZXJseWluZyBjYWxsXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmZXRjaCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKCkgPT4gZmV0Y2goLi4uYXJncykudGhlbigocmVzKSA9PiAocmVzLm9rID8gcmVzIDogUHJvbWlzZS5yZWplY3QocmVzKSkpKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/callbacks.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)\n/* harmony export */ });\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.js\");\n\nconst isTracingEnabled = (tracingEnabled) => {\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGSMITH_TRACING\",\n        \"LANGCHAIN_TRACING\",\n    ];\n    return !!envVars.find((envVar) => (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(envVar) === \"true\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2FsbGJhY2tzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtEO0FBQzNDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLCtEQUFzQjtBQUM1RCIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcY2FsbGJhY2tzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi9lbnYuanNcIjtcbmV4cG9ydCBjb25zdCBpc1RyYWNpbmdFbmFibGVkID0gKHRyYWNpbmdFbmFibGVkKSA9PiB7XG4gICAgaWYgKHRyYWNpbmdFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNpbmdFbmFibGVkO1xuICAgIH1cbiAgICBjb25zdCBlbnZWYXJzID0gW1xuICAgICAgICBcIkxBTkdTTUlUSF9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1RSQUNJTkdfVjJcIixcbiAgICAgICAgXCJMQU5HU01JVEhfVFJBQ0lOR1wiLFxuICAgICAgICBcIkxBTkdDSEFJTl9UUkFDSU5HXCIsXG4gICAgXTtcbiAgICByZXR1cm4gISFlbnZWYXJzLmZpbmQoKGVudlZhcikgPT4gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShlbnZWYXIpID09PSBcInRydWVcIik7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/chunk_array.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chunkArray: () => (/* binding */ chunkArray)\n/* harmony export */ });\nconst chunkArray = (arr, chunkSize) => arr.reduce((chunks, elem, index) => {\n    const chunkIndex = Math.floor(index / chunkSize);\n    const chunk = chunks[chunkIndex] || [];\n    // eslint-disable-next-line no-param-reassign\n    chunks[chunkIndex] = chunk.concat([elem]);\n    return chunks;\n}, []);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2h1bmtfYXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXGNodW5rX2FycmF5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjaHVua0FycmF5ID0gKGFyciwgY2h1bmtTaXplKSA9PiBhcnIucmVkdWNlKChjaHVua3MsIGVsZW0sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgY2h1bmtJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBjaHVua1NpemUpO1xuICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2NodW5rSW5kZXhdIHx8IFtdO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGNodW5rc1tjaHVua0luZGV4XSA9IGNodW5rLmNvbmNhdChbZWxlbV0pO1xuICAgIHJldHVybiBjaHVua3M7XG59LCBbXSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/env.js":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/env.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getRuntimeEnvironmentSync: () => (/* binding */ getRuntimeEnvironmentSync),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker)\n/* harmony export */ });\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nconst isWebWorker = () => typeof globalThis === \"object\" &&\n    globalThis.constructor &&\n    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n    (typeof navigator !== \"undefined\" && navigator.userAgent.includes(\"jsdom\"));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = () => typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = () => typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\" &&\n    !isDeno();\nconst getEnv = () => {\n    let env;\n    if (isBrowser()) {\n        env = \"browser\";\n    }\n    else if (isNode()) {\n        env = \"node\";\n    }\n    else if (isWebWorker()) {\n        env = \"webworker\";\n    }\n    else if (isJsDom()) {\n        env = \"jsdom\";\n    }\n    else if (isDeno()) {\n        env = \"deno\";\n    }\n    else {\n        env = \"other\";\n    }\n    return env;\n};\nlet runtimeEnvironment;\n/**\n * @deprecated Use getRuntimeEnvironmentSync instead\n */\nasync function getRuntimeEnvironment() {\n    return getRuntimeEnvironmentSync();\n}\nfunction getRuntimeEnvironmentSync() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        runtimeEnvironment = {\n            library: \"langchain-js\",\n            runtime: env,\n        };\n    }\n    return runtimeEnvironment;\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/langchain-ai/langchainjs/issues/1412\n    try {\n        if (typeof process !== \"undefined\") {\n            // eslint-disable-next-line no-process-env\n            return process.env?.[name];\n        }\n        else if (isDeno()) {\n            return Deno?.env.get(name);\n        }\n        else {\n            return undefined;\n        }\n    }\n    catch (e) {\n        return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcZW52LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnQgY29uc3QgaXNXZWJXb3JrZXIgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcIjtcbmV4cG9ydCBjb25zdCBpc0pzRG9tID0gKCkgPT4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hbWUgPT09IFwibm9kZWpzXCIpIHx8XG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpKTtcbi8vIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gcHJvdmlkZXMgYSBgRGVub2AgZ2xvYmFsIG9iamVjdFxuLy8gd2l0aG91dCBgdmVyc2lvbmAgcHJvcGVydHlcbmV4cG9ydCBjb25zdCBpc0Rlbm8gPSAoKSA9PiB0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICgpID0+IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgIWlzRGVubygpO1xuZXhwb3J0IGNvbnN0IGdldEVudiA9ICgpID0+IHtcbiAgICBsZXQgZW52O1xuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBlbnYgPSBcImJyb3dzZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOb2RlKCkpIHtcbiAgICAgICAgZW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzV2ViV29ya2VyKCkpIHtcbiAgICAgICAgZW52ID0gXCJ3ZWJ3b3JrZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNKc0RvbSgpKSB7XG4gICAgICAgIGVudiA9IFwianNkb21cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZW5vKCkpIHtcbiAgICAgICAgZW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBlbnY7XG59O1xubGV0IHJ1bnRpbWVFbnZpcm9ubWVudDtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGdldFJ1bnRpbWVFbnZpcm9ubWVudFN5bmMgaW5zdGVhZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50KCkge1xuICAgIHJldHVybiBnZXRSdW50aW1lRW52aXJvbm1lbnRTeW5jKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50U3luYygpIHtcbiAgICBpZiAocnVudGltZUVudmlyb25tZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZW52ID0gZ2V0RW52KCk7XG4gICAgICAgIHJ1bnRpbWVFbnZpcm9ubWVudCA9IHtcbiAgICAgICAgICAgIGxpYnJhcnk6IFwibGFuZ2NoYWluLWpzXCIsXG4gICAgICAgICAgICBydW50aW1lOiBlbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5nY2hhaW4tYWkvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52Py5bbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEZW5vKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBEZW5vPy5lbnYuZ2V0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonPatchError: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.PatchError),\n/* harmony export */   _areEquals: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__._areEquals),\n/* harmony export */   applyOperation: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyOperation),\n/* harmony export */   applyPatch: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch),\n/* harmony export */   applyReducer: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyReducer),\n/* harmony export */   compare: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.compare),\n/* harmony export */   deepClone: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__._deepClone),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   escapePathComponent: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent),\n/* harmony export */   generate: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.generate),\n/* harmony export */   getValueByPointer: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.getValueByPointer),\n/* harmony export */   observe: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.observe),\n/* harmony export */   unescapePathComponent: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent),\n/* harmony export */   unobserve: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.unobserve),\n/* harmony export */   validate: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.validate),\n/* harmony export */   validator: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.validator)\n/* harmony export */ });\n/* harmony import */ var _src_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/core.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js\");\n/* harmony import */ var _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/duplex.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js\");\n/* harmony import */ var _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/helpers.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\");\n\n\n\n/**\n * Default export for backwards compat\n */\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    ..._src_core_js__WEBPACK_IMPORTED_MODULE_0__,\n    // ...duplex,\n    JsonPatchError: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.PatchError,\n    deepClone: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__._deepClone,\n    escapePathComponent: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent,\n    unescapePathComponent: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEI7QUFDRTtBQUNzRztBQUN0STtBQUNBO0FBQ0E7QUFDc0M7QUFDZ0c7QUFDdEksaUVBQWU7QUFDZixPQUFPLHlDQUFJO0FBQ1g7QUFDQSxrQkFBa0I7QUFDbEIsYUFBYTtBQUNiLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxmYXN0LWpzb24tcGF0Y2hcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL3NyYy9jb3JlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zcmMvZHVwbGV4LmpzXCI7XG5leHBvcnQgeyBQYXRjaEVycm9yIGFzIEpzb25QYXRjaEVycm9yLCBfZGVlcENsb25lIGFzIGRlZXBDbG9uZSwgZXNjYXBlUGF0aENvbXBvbmVudCwgdW5lc2NhcGVQYXRoQ29tcG9uZW50LCB9IGZyb20gXCIuL3NyYy9oZWxwZXJzLmpzXCI7XG4vKipcbiAqIERlZmF1bHQgZXhwb3J0IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4vc3JjL2NvcmUuanNcIjtcbmltcG9ydCB7IFBhdGNoRXJyb3IgYXMgSnNvblBhdGNoRXJyb3IsIF9kZWVwQ2xvbmUgYXMgZGVlcENsb25lLCBlc2NhcGVQYXRoQ29tcG9uZW50LCB1bmVzY2FwZVBhdGhDb21wb25lbnQsIH0gZnJvbSBcIi4vc3JjL2hlbHBlcnMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICAuLi5jb3JlLFxuICAgIC8vIC4uLmR1cGxleCxcbiAgICBKc29uUGF0Y2hFcnJvcixcbiAgICBkZWVwQ2xvbmUsXG4gICAgZXNjYXBlUGF0aENvbXBvbmVudCxcbiAgICB1bmVzY2FwZVBhdGhDb21wb25lbnQsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonPatchError: () => (/* binding */ JsonPatchError),\n/* harmony export */   _areEquals: () => (/* binding */ _areEquals),\n/* harmony export */   applyOperation: () => (/* binding */ applyOperation),\n/* harmony export */   applyPatch: () => (/* binding */ applyPatch),\n/* harmony export */   applyReducer: () => (/* binding */ applyReducer),\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   getValueByPointer: () => (/* binding */ getValueByPointer),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   validator: () => (/* binding */ validator)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\");\n// @ts-nocheck\n\nconst JsonPatchError = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.PatchError;\nconst deepClone = _helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone;\n/* We use a Javascript hash to store each\n function. Each hash entry (property) uses\n the operation identifiers specified in rfc6902.\n In this way, we can map each patch operation\n to its dedicated function in efficient way.\n */\n/* The operations applicable to an object */\nconst objOps = {\n    add: function (obj, key, document) {\n        obj[key] = this.value;\n        return { newDocument: document };\n    },\n    remove: function (obj, key, document) {\n        var removed = obj[key];\n        delete obj[key];\n        return { newDocument: document, removed };\n    },\n    replace: function (obj, key, document) {\n        var removed = obj[key];\n        obj[key] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: function (obj, key, document) {\n        /* in case move target overwrites an existing value,\n        return the removed value, this can be taxing performance-wise,\n        and is potentially unneeded */\n        let removed = getValueByPointer(document, this.path);\n        if (removed) {\n            removed = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(removed);\n        }\n        const originalValue = applyOperation(document, {\n            op: \"remove\",\n            path: this.from,\n        }).removed;\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: originalValue,\n        });\n        return { newDocument: document, removed };\n    },\n    copy: function (obj, key, document) {\n        const valueToCopy = getValueByPointer(document, this.from);\n        // enforce copy by value so further operations don't affect source (see issue #177)\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(valueToCopy),\n        });\n        return { newDocument: document };\n    },\n    test: function (obj, key, document) {\n        return { newDocument: document, test: _areEquals(obj[key], this.value) };\n    },\n    _get: function (obj, key, document) {\n        this.value = obj[key];\n        return { newDocument: document };\n    },\n};\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n    add: function (arr, i, document) {\n        if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(i)) {\n            arr.splice(i, 0, this.value);\n        }\n        else {\n            // array props\n            arr[i] = this.value;\n        }\n        // this may be needed when using '-' in an array\n        return { newDocument: document, index: i };\n    },\n    remove: function (arr, i, document) {\n        var removedList = arr.splice(i, 1);\n        return { newDocument: document, removed: removedList[0] };\n    },\n    replace: function (arr, i, document) {\n        var removed = arr[i];\n        arr[i] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: objOps.move,\n    copy: objOps.copy,\n    test: objOps.test,\n    _get: objOps._get,\n};\n/**\n * Retrieves a value from a JSON document by a JSON pointer.\n * Returns the value.\n *\n * @param document The document to get the value from\n * @param pointer an escaped JSON pointer\n * @return The retrieved value\n */\nfunction getValueByPointer(document, pointer) {\n    if (pointer == \"\") {\n        return document;\n    }\n    var getOriginalDestination = { op: \"_get\", path: pointer };\n    applyOperation(document, getOriginalDestination);\n    return getOriginalDestination.value;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the {newDocument, result} of the operation.\n * It modifies the `document` and `operation` objects - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return `{newDocument, result}` after the operation\n */\nfunction applyOperation(document, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {\n    if (validateOperation) {\n        if (typeof validateOperation == \"function\") {\n            validateOperation(operation, 0, document, operation.path);\n        }\n        else {\n            validator(operation, 0);\n        }\n    }\n    /* ROOT OPERATIONS */\n    if (operation.path === \"\") {\n        let returnValue = { newDocument: document };\n        if (operation.op === \"add\") {\n            returnValue.newDocument = operation.value;\n            return returnValue;\n        }\n        else if (operation.op === \"replace\") {\n            returnValue.newDocument = operation.value;\n            returnValue.removed = document; //document we removed\n            return returnValue;\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            // it's a move or copy to root\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n            if (operation.op === \"move\") {\n                // report removed item\n                returnValue.removed = document;\n            }\n            return returnValue;\n        }\n        else if (operation.op === \"test\") {\n            returnValue.test = _areEquals(document, operation.value);\n            if (returnValue.test === false) {\n                throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n            }\n            returnValue.newDocument = document;\n            return returnValue;\n        }\n        else if (operation.op === \"remove\") {\n            // a remove on root\n            returnValue.removed = document;\n            returnValue.newDocument = null;\n            return returnValue;\n        }\n        else if (operation.op === \"_get\") {\n            operation.value = document;\n            return returnValue;\n        }\n        else {\n            /* bad operation */\n            if (validateOperation) {\n                throw new JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n            }\n            else {\n                return returnValue;\n            }\n        }\n    } /* END ROOT OPERATIONS */\n    else {\n        if (!mutateDocument) {\n            document = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);\n        }\n        const path = operation.path || \"\";\n        const keys = path.split(\"/\");\n        let obj = document;\n        let t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n        let len = keys.length;\n        let existingPathFragment = undefined;\n        let key;\n        let validateFunction;\n        if (typeof validateOperation == \"function\") {\n            validateFunction = validateOperation;\n        }\n        else {\n            validateFunction = validator;\n        }\n        while (true) {\n            key = keys[t];\n            if (key && key.indexOf(\"~\") != -1) {\n                key = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.unescapePathComponent)(key);\n            }\n            if (banPrototypeModifications &&\n                (key == \"__proto__\" ||\n                    (key == \"prototype\" && t > 0 && keys[t - 1] == \"constructor\"))) {\n                throw new TypeError(\"JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README\");\n            }\n            if (validateOperation) {\n                if (existingPathFragment === undefined) {\n                    if (obj[key] === undefined) {\n                        existingPathFragment = keys.slice(0, t).join(\"/\");\n                    }\n                    else if (t == len - 1) {\n                        existingPathFragment = operation.path;\n                    }\n                    if (existingPathFragment !== undefined) {\n                        validateFunction(operation, 0, document, existingPathFragment);\n                    }\n                }\n            }\n            t++;\n            if (Array.isArray(obj)) {\n                if (key === \"-\") {\n                    key = obj.length;\n                }\n                else {\n                    if (validateOperation && !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {\n                        throw new JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);\n                    } // only parse key when it's an integer for `arr.prop` to work\n                    else if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {\n                        key = ~~key;\n                    }\n                }\n                if (t >= len) {\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\n                        throw new JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);\n                    }\n                    const returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            else {\n                if (t >= len) {\n                    const returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            obj = obj[key];\n            // If we have more keys in the path, but the next value isn't a non-null object,\n            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n            if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n                throw new JsonPatchError(\"Cannot perform operation at the desired path\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Apply a full JSON Patch array on a JSON document.\n * Returns the {newDocument, result} of the patch.\n * It modifies the `document` object and `patch` - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n *\n * @param document The document to patch\n * @param patch The patch to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return An array of `{newDocument, result}` after the patch\n */\nfunction applyPatch(document, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {\n    if (validateOperation) {\n        if (!Array.isArray(patch)) {\n            throw new JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n    }\n    if (!mutateDocument) {\n        document = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);\n    }\n    const results = new Array(patch.length);\n    for (let i = 0, length = patch.length; i < length; i++) {\n        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);\n        document = results[i].newDocument; // in case root was replaced\n    }\n    results.newDocument = document;\n    return results;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the updated document.\n * Suitable as a reducer.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @return The updated document\n */\nfunction applyReducer(document, operation, index) {\n    const operationResult = applyOperation(document, operation);\n    if (operationResult.test === false) {\n        // failed test\n        throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n    }\n    return operationResult.newDocument;\n}\n/**\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n * @param {object} operation - operation object (patch)\n * @param {number} index - index of operation in the sequence\n * @param {object} [document] - object where the operation is supposed to be applied\n * @param {string} [existingPathFragment] - comes along with `document`\n */\nfunction validator(operation, index, document, existingPathFragment) {\n    if (typeof operation !== \"object\" ||\n        operation === null ||\n        Array.isArray(operation)) {\n        throw new JsonPatchError(\"Operation is not an object\", \"OPERATION_NOT_AN_OBJECT\", index, operation, document);\n    }\n    else if (!objOps[operation.op]) {\n        throw new JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n    }\n    else if (typeof operation.path !== \"string\") {\n        throw new JsonPatchError(\"Operation `path` property is not a string\", \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if (operation.path.indexOf(\"/\") !== 0 && operation.path.length > 0) {\n        // paths that aren't empty string should start with \"/\"\n        throw new JsonPatchError('Operation `path` property must start with \"/\"', \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if ((operation.op === \"move\" || operation.op === \"copy\") &&\n        typeof operation.from !== \"string\") {\n        throw new JsonPatchError(\"Operation `from` property is not present (applicable in `move` and `copy` operations)\", \"OPERATION_FROM_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        operation.value === undefined) {\n        throw new JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasUndefined)(operation.value)) {\n        throw new JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED\", index, operation, document);\n    }\n    else if (document) {\n        if (operation.op == \"add\") {\n            var pathLen = operation.path.split(\"/\").length;\n            var existingPathLen = existingPathFragment.split(\"/\").length;\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n                throw new JsonPatchError(\"Cannot perform an `add` operation at the desired path\", \"OPERATION_PATH_CANNOT_ADD\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"replace\" ||\n            operation.op === \"remove\" ||\n            operation.op === \"_get\") {\n            if (operation.path !== existingPathFragment) {\n                throw new JsonPatchError(\"Cannot perform the operation at a path that does not exist\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            var existingValue = {\n                op: \"_get\",\n                path: operation.from,\n                value: undefined,\n            };\n            var error = validate([existingValue], document);\n            if (error && error.name === \"OPERATION_PATH_UNRESOLVABLE\") {\n                throw new JsonPatchError(\"Cannot perform the operation from a path that does not exist\", \"OPERATION_FROM_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n * If error is encountered, returns a JsonPatchError object\n * @param sequence\n * @param document\n * @returns {JsonPatchError|undefined}\n */\nfunction validate(sequence, document, externalValidator) {\n    try {\n        if (!Array.isArray(sequence)) {\n            throw new JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n        if (document) {\n            //clone document and sequence so that we can safely try applying operations\n            applyPatch((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document), (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(sequence), externalValidator || true);\n        }\n        else {\n            externalValidator = externalValidator || validator;\n            for (var i = 0; i < sequence.length; i++) {\n                externalValidator(sequence[i], i, document, undefined);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof JsonPatchError) {\n            return e;\n        }\n        else {\n            throw e;\n        }\n    }\n}\n// based on https://github.com/epoberezkin/fast-deep-equal\n// MIT License\n// Copyright (c) 2017 Evgeny Poberezkin\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nfunction _areEquals(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!_areEquals(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (arrA != arrB)\n            return false;\n        var keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!b.hasOwnProperty(keys[i]))\n                return false;\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!_areEquals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9jb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN1RztBQUNoRyx1QkFBdUIsbURBQVU7QUFDakMsa0JBQWtCLG1EQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFVO0FBQzdCLFNBQVM7QUFDVCxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzREFBUztBQUN2RDtBQUNBLHNCQUFzQjtBQUN0Qiw2QkFBNkIsc0RBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVU7QUFDN0I7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBVSxZQUFZLHVEQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxmYXN0LWpzb24tcGF0Y2hcXHNyY1xcY29yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtbm9jaGVja1xuaW1wb3J0IHsgUGF0Y2hFcnJvciwgX2RlZXBDbG9uZSwgaXNJbnRlZ2VyLCB1bmVzY2FwZVBhdGhDb21wb25lbnQsIGhhc1VuZGVmaW5lZCwgfSBmcm9tIFwiLi9oZWxwZXJzLmpzXCI7XG5leHBvcnQgY29uc3QgSnNvblBhdGNoRXJyb3IgPSBQYXRjaEVycm9yO1xuZXhwb3J0IGNvbnN0IGRlZXBDbG9uZSA9IF9kZWVwQ2xvbmU7XG4vKiBXZSB1c2UgYSBKYXZhc2NyaXB0IGhhc2ggdG8gc3RvcmUgZWFjaFxuIGZ1bmN0aW9uLiBFYWNoIGhhc2ggZW50cnkgKHByb3BlcnR5KSB1c2VzXG4gdGhlIG9wZXJhdGlvbiBpZGVudGlmaWVycyBzcGVjaWZpZWQgaW4gcmZjNjkwMi5cbiBJbiB0aGlzIHdheSwgd2UgY2FuIG1hcCBlYWNoIHBhdGNoIG9wZXJhdGlvblxuIHRvIGl0cyBkZWRpY2F0ZWQgZnVuY3Rpb24gaW4gZWZmaWNpZW50IHdheS5cbiAqL1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBvYmplY3QgKi9cbmNvbnN0IG9iak9wcyA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xuICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICAvKiBpbiBjYXNlIG1vdmUgdGFyZ2V0IG92ZXJ3cml0ZXMgYW4gZXhpc3RpbmcgdmFsdWUsXG4gICAgICAgIHJldHVybiB0aGUgcmVtb3ZlZCB2YWx1ZSwgdGhpcyBjYW4gYmUgdGF4aW5nIHBlcmZvcm1hbmNlLXdpc2UsXG4gICAgICAgIGFuZCBpcyBwb3RlbnRpYWxseSB1bm5lZWRlZCAqL1xuICAgICAgICBsZXQgcmVtb3ZlZCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLnBhdGgpO1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgcmVtb3ZlZCA9IF9kZWVwQ2xvbmUocmVtb3ZlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7XG4gICAgICAgICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgICAgICAgIHBhdGg6IHRoaXMuZnJvbSxcbiAgICAgICAgfSkucmVtb3ZlZDtcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIGNvcHk6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVUb0NvcHkgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5mcm9tKTtcbiAgICAgICAgLy8gZW5mb3JjZSBjb3B5IGJ5IHZhbHVlIHNvIGZ1cnRoZXIgb3BlcmF0aW9ucyBkb24ndCBhZmZlY3Qgc291cmNlIChzZWUgaXNzdWUgIzE3NylcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgdmFsdWU6IF9kZWVwQ2xvbmUodmFsdWVUb0NvcHkpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgdGVzdDogX2FyZUVxdWFscyhvYmpba2V5XSwgdGhpcy52YWx1ZSkgfTtcbiAgICB9LFxuICAgIF9nZXQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxufTtcbi8qIFRoZSBvcGVyYXRpb25zIGFwcGxpY2FibGUgdG8gYW4gYXJyYXkuIE1hbnkgYXJlIHRoZSBzYW1lIGFzIGZvciB0aGUgb2JqZWN0ICovXG52YXIgYXJyT3BzID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKGlzSW50ZWdlcihpKSkge1xuICAgICAgICAgICAgYXJyLnNwbGljZShpLCAwLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFycmF5IHByb3BzXG4gICAgICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgbWF5IGJlIG5lZWRlZCB3aGVuIHVzaW5nICctJyBpbiBhbiBhcnJheVxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIGluZGV4OiBpIH07XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkTGlzdCA9IGFyci5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZExpc3RbMF0gfTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gYXJyW2ldO1xuICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIG1vdmU6IG9iak9wcy5tb3ZlLFxuICAgIGNvcHk6IG9iak9wcy5jb3B5LFxuICAgIHRlc3Q6IG9iak9wcy50ZXN0LFxuICAgIF9nZXQ6IG9iak9wcy5fZ2V0LFxufTtcbi8qKlxuICogUmV0cmlldmVzIGEgdmFsdWUgZnJvbSBhIEpTT04gZG9jdW1lbnQgYnkgYSBKU09OIHBvaW50ZXIuXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGdldCB0aGUgdmFsdWUgZnJvbVxuICogQHBhcmFtIHBvaW50ZXIgYW4gZXNjYXBlZCBKU09OIHBvaW50ZXJcbiAqIEByZXR1cm4gVGhlIHJldHJpZXZlZCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHBvaW50ZXIpIHtcbiAgICBpZiAocG9pbnRlciA9PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG4gICAgdmFyIGdldE9yaWdpbmFsRGVzdGluYXRpb24gPSB7IG9wOiBcIl9nZXRcIiwgcGF0aDogcG9pbnRlciB9O1xuICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBnZXRPcmlnaW5hbERlc3RpbmF0aW9uKTtcbiAgICByZXR1cm4gZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbi52YWx1ZTtcbn1cbi8qKlxuICogQXBwbHkgYSBzaW5nbGUgSlNPTiBQYXRjaCBPcGVyYXRpb24gb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBvcGVyYXRpb24uXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBhbmQgYG9wZXJhdGlvbmAgb2JqZWN0cyAtIGl0IGdldHMgdGhlIHZhbHVlcyBieSByZWZlcmVuY2UuXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcbiAqIGBqc29ucGF0Y2guYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKG9wZXJhdGlvbikpYC5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHBhdGNoXG4gKiBAcGFyYW0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gYXBwbHlcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXG4gKiBAcGFyYW0gYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyBXaGV0aGVyIHRvIGJhbiBtb2RpZmljYXRpb25zIHRvIGBfX3Byb3RvX19gLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJuIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBvcGVyYXRpb24sIHZhbGlkYXRlT3BlcmF0aW9uID0gZmFsc2UsIG11dGF0ZURvY3VtZW50ID0gdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWUsIGluZGV4ID0gMCkge1xuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uLCAwLCBkb2N1bWVudCwgb3BlcmF0aW9uLnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdG9yKG9wZXJhdGlvbiwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogUk9PVCBPUEVSQVRJT05TICovXG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoID09PSBcIlwiKSB7XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZSA9IHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50OyAvL2RvY3VtZW50IHdlIHJlbW92ZWRcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwibW92ZVwiIHx8IG9wZXJhdGlvbi5vcCA9PT0gXCJjb3B5XCIpIHtcbiAgICAgICAgICAgIC8vIGl0J3MgYSBtb3ZlIG9yIGNvcHkgdG8gcm9vdFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgb3BlcmF0aW9uLmZyb20pOyAvLyBnZXQgdGhlIHZhbHVlIGJ5IGpzb24tcG9pbnRlciBpbiBgZnJvbWAgZmllbGRcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09IFwibW92ZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwb3J0IHJlbW92ZWQgaXRlbVxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS50ZXN0ID0gX2FyZUVxdWFscyhkb2N1bWVudCwgb3BlcmF0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJyZW1vdmVcIikge1xuICAgICAgICAgICAgLy8gYSByZW1vdmUgb24gcm9vdFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJfZ2V0XCIpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogYmFkIG9wZXJhdGlvbiAqL1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBvcGAgcHJvcGVydHkgaXMgbm90IG9uZSBvZiBvcGVyYXRpb25zIGRlZmluZWQgaW4gUkZDLTY5MDJcIiwgXCJPUEVSQVRJT05fT1BfSU5WQUxJRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IC8qIEVORCBST09UIE9QRVJBVElPTlMgKi9cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFtdXRhdGVEb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQgPSBfZGVlcENsb25lKGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoID0gb3BlcmF0aW9uLnBhdGggfHwgXCJcIjtcbiAgICAgICAgY29uc3Qga2V5cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICAgICAgICBsZXQgb2JqID0gZG9jdW1lbnQ7XG4gICAgICAgIGxldCB0ID0gMTsgLy9za2lwIGVtcHR5IGVsZW1lbnQgLSBodHRwOi8vanNwZXJmLmNvbS90by1zaGlmdC1vci1ub3QtdG8tc2hpZnRcbiAgICAgICAgbGV0IGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBsZXQgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGxldCB2YWxpZGF0ZUZ1bmN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbiA9IHZhbGlkYXRlT3BlcmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbiA9IHZhbGlkYXRvcjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAga2V5ID0ga2V5c1t0XTtcbiAgICAgICAgICAgIGlmIChrZXkgJiYga2V5LmluZGV4T2YoXCJ+XCIpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdW5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyAmJlxuICAgICAgICAgICAgICAgIChrZXkgPT0gXCJfX3Byb3RvX19cIiB8fFxuICAgICAgICAgICAgICAgICAgICAoa2V5ID09IFwicHJvdG90eXBlXCIgJiYgdCA+IDAgJiYga2V5c1t0IC0gMV0gPT0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSlNPTi1QYXRjaDogbW9kaWZ5aW5nIGBfX3Byb3RvX19gIG9yIGBjb25zdHJ1Y3Rvci9wcm90b3R5cGVgIHByb3AgaXMgYmFubmVkIGZvciBzZWN1cml0eSByZWFzb25zLCBpZiB0aGlzIHdhcyBvbiBwdXJwb3NlLCBwbGVhc2Ugc2V0IGBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zYCBmbGFnIGZhbHNlIGFuZCBwYXNzIGl0IHRvIHRoaXMgZnVuY3Rpb24uIE1vcmUgaW5mbyBpbiBmYXN0LWpzb24tcGF0Y2ggUkVBRE1FXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGF0aEZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ialtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUGF0aEZyYWdtZW50ID0ga2V5cy5zbGljZSgwLCB0KS5qb2luKFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ID09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUGF0aEZyYWdtZW50ID0gb3BlcmF0aW9uLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGF0aEZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24ob3BlcmF0aW9uLCAwLCBkb2N1bWVudCwgZXhpc3RpbmdQYXRoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCsrO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgIWlzSW50ZWdlcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJFeHBlY3RlZCBhbiB1bnNpZ25lZCBiYXNlLTEwIGludGVnZXIgdmFsdWUsIG1ha2luZyB0aGUgbmV3IHJlZmVyZW5jZWQgdmFsdWUgdGhlIGFycmF5IGVsZW1lbnQgd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleFwiLCBcIk9QRVJBVElPTl9QQVRIX0lMTEVHQUxfQVJSQVlfSU5ERVhcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIG9ubHkgcGFyc2Uga2V5IHdoZW4gaXQncyBhbiBpbnRlZ2VyIGZvciBgYXJyLnByb3BgIHRvIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNJbnRlZ2VyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IH5+a2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgb3BlcmF0aW9uLm9wID09PSBcImFkZFwiICYmIGtleSA+IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRoZSBzcGVjaWZpZWQgaW5kZXggTVVTVCBOT1QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XCIsIFwiT1BFUkFUSU9OX1ZBTFVFX09VVF9PRl9CT1VORFNcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gYXJyT3BzW29wZXJhdGlvbi5vcF0uY2FsbChvcGVyYXRpb24sIG9iaiwga2V5LCBkb2N1bWVudCk7IC8vIEFwcGx5IHBhdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsIFwiVEVTVF9PUEVSQVRJT05fRkFJTEVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gb2JqT3BzW29wZXJhdGlvbi5vcF0uY2FsbChvcGVyYXRpb24sIG9iaiwga2V5LCBkb2N1bWVudCk7IC8vIEFwcGx5IHBhdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsIFwiVEVTVF9PUEVSQVRJT05fRkFJTEVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUga2V5cyBpbiB0aGUgcGF0aCwgYnV0IHRoZSBuZXh0IHZhbHVlIGlzbid0IGEgbm9uLW51bGwgb2JqZWN0LFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFIGVycm9yIGluc3RlYWQgb2YgaXRlcmF0aW5nIGFnYWluLlxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmIHQgPCBsZW4gJiYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gYXQgdGhlIGRlc2lyZWQgcGF0aFwiLCBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFwcGx5IGEgZnVsbCBKU09OIFBhdGNoIGFycmF5IG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgcGF0Y2guXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBvYmplY3QgYW5kIGBwYXRjaGAgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5UGF0Y2goZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKHBhdGNoKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBwYXRjaCBUaGUgcGF0Y2ggdG8gYXBwbHlcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXG4gKiBAcGFyYW0gYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyBXaGV0aGVyIHRvIGJhbiBtb2RpZmljYXRpb25zIHRvIGBfX3Byb3RvX19gLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBwYXRjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaChkb2N1bWVudCwgcGF0Y2gsIHZhbGlkYXRlT3BlcmF0aW9uLCBtdXRhdGVEb2N1bWVudCA9IHRydWUsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPSB0cnVlKSB7XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlBhdGNoIHNlcXVlbmNlIG11c3QgYmUgYW4gYXJyYXlcIiwgXCJTRVFVRU5DRV9OT1RfQU5fQVJSQVlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtdXRhdGVEb2N1bWVudCkge1xuICAgICAgICBkb2N1bWVudCA9IF9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KHBhdGNoLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHBhdGNoLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gcGFzcyBtdXRhdGVEb2N1bWVudCBhcmd1bWVudCBiZWNhdXNlIGlmIGl0IHdhcyB0cnVlLCB3ZSBhbHJlYWR5IGRlZXAgY2xvbmVkIHRoZSBvYmplY3QsIHdlJ2xsIGp1c3QgcGFzcyBgdHJ1ZWBcbiAgICAgICAgcmVzdWx0c1tpXSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBwYXRjaFtpXSwgdmFsaWRhdGVPcGVyYXRpb24sIHRydWUsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMsIGkpO1xuICAgICAgICBkb2N1bWVudCA9IHJlc3VsdHNbaV0ubmV3RG9jdW1lbnQ7IC8vIGluIGNhc2Ugcm9vdCB3YXMgcmVwbGFjZWRcbiAgICB9XG4gICAgcmVzdWx0cy5uZXdEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHJldHVybiByZXN1bHRzO1xufVxuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIGRvY3VtZW50LlxuICogU3VpdGFibGUgYXMgYSByZWR1Y2VyLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHJldHVybiBUaGUgdXBkYXRlZCBkb2N1bWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlSZWR1Y2VyKGRvY3VtZW50LCBvcGVyYXRpb24sIGluZGV4KSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uUmVzdWx0ID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbik7XG4gICAgaWYgKG9wZXJhdGlvblJlc3VsdC50ZXN0ID09PSBmYWxzZSkge1xuICAgICAgICAvLyBmYWlsZWQgdGVzdFxuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uUmVzdWx0Lm5ld0RvY3VtZW50O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBzaW5nbGUgb3BlcmF0aW9uLiBDYWxsZWQgZnJvbSBganNvbnBhdGNoLnZhbGlkYXRlYC4gVGhyb3dzIGBKc29uUGF0Y2hFcnJvcmAgaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb24gLSBvcGVyYXRpb24gb2JqZWN0IChwYXRjaClcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIG9wZXJhdGlvbiBpbiB0aGUgc2VxdWVuY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBbZG9jdW1lbnRdIC0gb2JqZWN0IHdoZXJlIHRoZSBvcGVyYXRpb24gaXMgc3VwcG9zZWQgdG8gYmUgYXBwbGllZFxuICogQHBhcmFtIHtzdHJpbmd9IFtleGlzdGluZ1BhdGhGcmFnbWVudF0gLSBjb21lcyBhbG9uZyB3aXRoIGBkb2N1bWVudGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRvcihvcGVyYXRpb24sIGluZGV4LCBkb2N1bWVudCwgZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbiAhPT0gXCJvYmplY3RcIiB8fFxuICAgICAgICBvcGVyYXRpb24gPT09IG51bGwgfHxcbiAgICAgICAgQXJyYXkuaXNBcnJheShvcGVyYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBpcyBub3QgYW4gb2JqZWN0XCIsIFwiT1BFUkFUSU9OX05PVF9BTl9PQkpFQ1RcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghb2JqT3BzW29wZXJhdGlvbi5vcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBvcGAgcHJvcGVydHkgaXMgbm90IG9uZSBvZiBvcGVyYXRpb25zIGRlZmluZWQgaW4gUkZDLTY5MDJcIiwgXCJPUEVSQVRJT05fT1BfSU5WQUxJRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcGVyYXRpb24ucGF0aCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYHBhdGhgIHByb3BlcnR5IGlzIG5vdCBhIHN0cmluZ1wiLCBcIk9QRVJBVElPTl9QQVRIX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24ucGF0aC5pbmRleE9mKFwiL1wiKSAhPT0gMCAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHBhdGhzIHRoYXQgYXJlbid0IGVtcHR5IHN0cmluZyBzaG91bGQgc3RhcnQgd2l0aCBcIi9cIlxuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgbXVzdCBzdGFydCB3aXRoIFwiL1wiJywgXCJPUEVSQVRJT05fUEFUSF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIgfHwgb3BlcmF0aW9uLm9wID09PSBcImNvcHlcIikgJiZcbiAgICAgICAgdHlwZW9mIG9wZXJhdGlvbi5mcm9tICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgZnJvbWAgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgKGFwcGxpY2FibGUgaW4gYG1vdmVgIGFuZCBgY29weWAgb3BlcmF0aW9ucylcIiwgXCJPUEVSQVRJT05fRlJPTV9SRVFVSVJFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgfHxcbiAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwidGVzdFwiKSAmJlxuICAgICAgICBvcGVyYXRpb24udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucylcIiwgXCJPUEVSQVRJT05fVkFMVUVfUkVRVUlSRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSBcImFkZFwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJyZXBsYWNlXCIgfHxcbiAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInRlc3RcIikgJiZcbiAgICAgICAgaGFzVW5kZWZpbmVkKG9wZXJhdGlvbi52YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGB2YWx1ZWAgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgKGFwcGxpY2FibGUgaW4gYGFkZGAsIGByZXBsYWNlYCBhbmQgYHRlc3RgIG9wZXJhdGlvbnMpXCIsIFwiT1BFUkFUSU9OX1ZBTFVFX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT0gXCJhZGRcIikge1xuICAgICAgICAgICAgdmFyIHBhdGhMZW4gPSBvcGVyYXRpb24ucGF0aC5zcGxpdChcIi9cIikubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nUGF0aExlbiA9IGV4aXN0aW5nUGF0aEZyYWdtZW50LnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocGF0aExlbiAhPT0gZXhpc3RpbmdQYXRoTGVuICsgMSAmJiBwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJDYW5ub3QgcGVyZm9ybSBhbiBgYWRkYCBvcGVyYXRpb24gYXQgdGhlIGRlc2lyZWQgcGF0aFwiLCBcIk9QRVJBVElPTl9QQVRIX0NBTk5PVF9BRERcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJyZXBsYWNlXCIgfHxcbiAgICAgICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJyZW1vdmVcIiB8fFxuICAgICAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcIl9nZXRcIikge1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5wYXRoICE9PSBleGlzdGluZ1BhdGhGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIHRoZSBvcGVyYXRpb24gYXQgYSBwYXRoIHRoYXQgZG9lcyBub3QgZXhpc3RcIiwgXCJPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEVcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIgfHwgb3BlcmF0aW9uLm9wID09PSBcImNvcHlcIikge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgb3A6IFwiX2dldFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IG9wZXJhdGlvbi5mcm9tLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGVycm9yID0gdmFsaWRhdGUoW2V4aXN0aW5nVmFsdWVdLCBkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEVcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIHRoZSBvcGVyYXRpb24gZnJvbSBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdFwiLCBcIk9QRVJBVElPTl9GUk9NX1VOUkVTT0xWQUJMRVwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNlcXVlbmNlIG9mIG9wZXJhdGlvbnMuIElmIGBkb2N1bWVudGAgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB0aGUgc2VxdWVuY2UgaXMgYWRkaXRpb25hbGx5IHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvYmplY3QgZG9jdW1lbnQuXG4gKiBJZiBlcnJvciBpcyBlbmNvdW50ZXJlZCwgcmV0dXJucyBhIEpzb25QYXRjaEVycm9yIG9iamVjdFxuICogQHBhcmFtIHNlcXVlbmNlXG4gKiBAcGFyYW0gZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtKc29uUGF0Y2hFcnJvcnx1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShzZXF1ZW5jZSwgZG9jdW1lbnQsIGV4dGVybmFsVmFsaWRhdG9yKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheVwiLCBcIlNFUVVFTkNFX05PVF9BTl9BUlJBWVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vY2xvbmUgZG9jdW1lbnQgYW5kIHNlcXVlbmNlIHNvIHRoYXQgd2UgY2FuIHNhZmVseSB0cnkgYXBwbHlpbmcgb3BlcmF0aW9uc1xuICAgICAgICAgICAgYXBwbHlQYXRjaChfZGVlcENsb25lKGRvY3VtZW50KSwgX2RlZXBDbG9uZShzZXF1ZW5jZSksIGV4dGVybmFsVmFsaWRhdG9yIHx8IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXh0ZXJuYWxWYWxpZGF0b3IgPSBleHRlcm5hbFZhbGlkYXRvciB8fCB2YWxpZGF0b3I7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxWYWxpZGF0b3Ioc2VxdWVuY2VbaV0sIGksIGRvY3VtZW50LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgSnNvblBhdGNoRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9lcG9iZXJlemtpbi9mYXN0LWRlZXAtZXF1YWxcbi8vIE1JVCBMaWNlbnNlXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTcgRXZnZW55IFBvYmVyZXpraW5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbi8vIFNPRlRXQVJFLlxuZXhwb3J0IGZ1bmN0aW9uIF9hcmVFcXVhbHMoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgPT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgYXJyQSA9IEFycmF5LmlzQXJyYXkoYSksIGFyckIgPSBBcnJheS5pc0FycmF5KGIpLCBpLCBsZW5ndGgsIGtleTtcbiAgICAgICAgaWYgKGFyckEgJiYgYXJyQikge1xuICAgICAgICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgICAgICAgICBpZiAoIV9hcmVFcXVhbHMoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJBICE9IGFyckIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgICAgIGlmICghYi5oYXNPd25Qcm9wZXJ0eShrZXlzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghX2FyZUVxdWFscyhhW2tleV0sIGJba2V5XSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   generate: () => (/* binding */ generate),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   unobserve: () => (/* binding */ unobserve)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js\");\n// @ts-nocheck\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2013-2021 Joachim Wester\n * MIT license\n */\n\n\nvar beforeDict = new WeakMap();\nclass Mirror {\n    constructor(obj) {\n        Object.defineProperty(this, \"obj\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.obj = obj;\n    }\n}\nclass ObserverInfo {\n    constructor(callback, observer) {\n        Object.defineProperty(this, \"callback\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.callback = callback;\n        this.observer = observer;\n    }\n}\nfunction getMirror(obj) {\n    return beforeDict.get(obj);\n}\nfunction getObserverFromMirror(mirror, callback) {\n    return mirror.observers.get(callback);\n}\nfunction removeObserverFromMirror(mirror, observer) {\n    mirror.observers.delete(observer.callback);\n}\n/**\n * Detach an observer from an object\n */\nfunction unobserve(root, observer) {\n    observer.unobserve();\n}\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nfunction observe(obj, callback) {\n    var patches = [];\n    var observer;\n    var mirror = getMirror(obj);\n    if (!mirror) {\n        mirror = new Mirror(obj);\n        beforeDict.set(obj, mirror);\n    }\n    else {\n        const observerInfo = getObserverFromMirror(mirror, callback);\n        observer = observerInfo && observerInfo.observer;\n    }\n    if (observer) {\n        return observer;\n    }\n    observer = {};\n    mirror.value = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj);\n    if (callback) {\n        observer.callback = callback;\n        observer.next = null;\n        var dirtyCheck = () => {\n            generate(observer);\n        };\n        var fastCheck = () => {\n            clearTimeout(observer.next);\n            observer.next = setTimeout(dirtyCheck);\n        };\n        if (typeof window !== \"undefined\") {\n            //not Node\n            window.addEventListener(\"mouseup\", fastCheck);\n            window.addEventListener(\"keyup\", fastCheck);\n            window.addEventListener(\"mousedown\", fastCheck);\n            window.addEventListener(\"keydown\", fastCheck);\n            window.addEventListener(\"change\", fastCheck);\n        }\n    }\n    observer.patches = patches;\n    observer.object = obj;\n    observer.unobserve = () => {\n        generate(observer);\n        clearTimeout(observer.next);\n        removeObserverFromMirror(mirror, observer);\n        if (typeof window !== \"undefined\") {\n            window.removeEventListener(\"mouseup\", fastCheck);\n            window.removeEventListener(\"keyup\", fastCheck);\n            window.removeEventListener(\"mousedown\", fastCheck);\n            window.removeEventListener(\"keydown\", fastCheck);\n            window.removeEventListener(\"change\", fastCheck);\n        }\n    };\n    mirror.observers.set(callback, new ObserverInfo(callback, observer));\n    return observer;\n}\n/**\n * Generate an array of patches from an observer\n */\nfunction generate(observer, invertible = false) {\n    var mirror = beforeDict.get(observer.object);\n    _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n    if (observer.patches.length) {\n        (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.applyPatch)(mirror.value, observer.patches);\n    }\n    var temp = observer.patches;\n    if (temp.length > 0) {\n        observer.patches = [];\n        if (observer.callback) {\n            observer.callback(temp);\n        }\n    }\n    return temp;\n}\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n    if (obj === mirror) {\n        return;\n    }\n    if (typeof obj.toJSON === \"function\") {\n        obj = obj.toJSON();\n    }\n    var newKeys = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(obj);\n    var oldKeys = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(mirror);\n    var changed = false;\n    var deleted = false;\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(obj, key) &&\n            !(obj[key] === undefined &&\n                oldVal !== undefined &&\n                Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if (typeof oldVal == \"object\" &&\n                oldVal != null &&\n                typeof newVal == \"object\" &&\n                newVal != null &&\n                Array.isArray(oldVal) === Array.isArray(newVal)) {\n                _generate(oldVal, newVal, patches, path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), invertible);\n            }\n            else {\n                if (oldVal !== newVal) {\n                    changed = true;\n                    if (invertible) {\n                        patches.push({\n                            op: \"test\",\n                            path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                            value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal),\n                        });\n                    }\n                    patches.push({\n                        op: \"replace\",\n                        path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                        value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(newVal),\n                    });\n                }\n            }\n        }\n        else if (Array.isArray(mirror) === Array.isArray(obj)) {\n            if (invertible) {\n                patches.push({\n                    op: \"test\",\n                    path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                    value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal),\n                });\n            }\n            patches.push({\n                op: \"remove\",\n                path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n            });\n            deleted = true; // property has been deleted\n        }\n        else {\n            if (invertible) {\n                patches.push({ op: \"test\", path, value: mirror });\n            }\n            patches.push({ op: \"replace\", path, value: obj });\n            changed = true;\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = 0; t < newKeys.length; t++) {\n        var key = newKeys[t];\n        if (!(0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {\n            patches.push({\n                op: \"add\",\n                path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj[key]),\n            });\n        }\n    }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nfunction compare(tree1, tree2, invertible = false) {\n    var patches = [];\n    _generate(tree1, tree2, patches, \"\", invertible);\n    return patches;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9kdXBsZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkY7QUFDdEQ7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQVc7QUFDN0Isa0JBQWtCLHdEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQSxZQUFZLDJEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnRUFBbUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0VBQW1CO0FBQ2xFLG1DQUFtQyx1REFBVTtBQUM3Qyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdFQUFtQjtBQUM5RCwrQkFBK0IsdURBQVU7QUFDekMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdFQUFtQjtBQUMxRCwyQkFBMkIsdURBQVU7QUFDckMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnRUFBbUI7QUFDdEQsYUFBYTtBQUNiLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0EsYUFBYSwyREFBYztBQUMzQjtBQUNBO0FBQ0EsbUNBQW1DLGdFQUFtQjtBQUN0RCx1QkFBdUIsdURBQVU7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXGZhc3QtanNvbi1wYXRjaFxcc3JjXFxkdXBsZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcbi8vIElubGluZWQgYmVjYXVzZSBvZiBFU00gaW1wb3J0IGlzc3Vlc1xuLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXG4gKiAoYykgMjAxMy0yMDIxIEpvYWNoaW0gV2VzdGVyXG4gKiBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgeyBfZGVlcENsb25lLCBfb2JqZWN0S2V5cywgZXNjYXBlUGF0aENvbXBvbmVudCwgaGFzT3duUHJvcGVydHksIH0gZnJvbSBcIi4vaGVscGVycy5qc1wiO1xuaW1wb3J0IHsgYXBwbHlQYXRjaCB9IGZyb20gXCIuL2NvcmUuanNcIjtcbnZhciBiZWZvcmVEaWN0ID0gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIE1pcnJvciB7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ialwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvYnNlcnZlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgfVxufVxuY2xhc3MgT2JzZXJ2ZXJJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JzZXJ2ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWlycm9yKG9iaikge1xuICAgIHJldHVybiBiZWZvcmVEaWN0LmdldChvYmopO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWlycm9yLm9ic2VydmVycy5nZXQoY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpIHtcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlci5jYWxsYmFjayk7XG59XG4vKipcbiAqIERldGFjaCBhbiBvYnNlcnZlciBmcm9tIGFuIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5vYnNlcnZlKHJvb3QsIG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKCk7XG59XG4vKipcbiAqIE9ic2VydmVzIGNoYW5nZXMgbWFkZSB0byBhbiBvYmplY3QsIHdoaWNoIGNhbiB0aGVuIGJlIHJldHJpZXZlZCB1c2luZyBnZW5lcmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZShvYmosIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgdmFyIG1pcnJvciA9IGdldE1pcnJvcihvYmopO1xuICAgIGlmICghbWlycm9yKSB7XG4gICAgICAgIG1pcnJvciA9IG5ldyBNaXJyb3Iob2JqKTtcbiAgICAgICAgYmVmb3JlRGljdC5zZXQob2JqLCBtaXJyb3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJJbmZvID0gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spO1xuICAgICAgICBvYnNlcnZlciA9IG9ic2VydmVySW5mbyAmJiBvYnNlcnZlckluZm8ub2JzZXJ2ZXI7XG4gICAgfVxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIG9ic2VydmVyID0ge307XG4gICAgbWlycm9yLnZhbHVlID0gX2RlZXBDbG9uZShvYmopO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBvYnNlcnZlci5uZXh0ID0gbnVsbDtcbiAgICAgICAgdmFyIGRpcnR5Q2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmYXN0Q2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gc2V0VGltZW91dChkaXJ0eUNoZWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vbm90IE5vZGVcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYnNlcnZlci5wYXRjaGVzID0gcGF0Y2hlcztcbiAgICBvYnNlcnZlci5vYmplY3QgPSBvYmo7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlID0gKCkgPT4ge1xuICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XG4gICAgICAgIGNsZWFyVGltZW91dChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmYXN0Q2hlY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLnNldChjYWxsYmFjaywgbmV3IE9ic2VydmVySW5mbyhjYWxsYmFjaywgb2JzZXJ2ZXIpKTtcbiAgICByZXR1cm4gb2JzZXJ2ZXI7XG59XG4vKipcbiAqIEdlbmVyYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSBhbiBvYnNlcnZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGUob2JzZXJ2ZXIsIGludmVydGlibGUgPSBmYWxzZSkge1xuICAgIHZhciBtaXJyb3IgPSBiZWZvcmVEaWN0LmdldChvYnNlcnZlci5vYmplY3QpO1xuICAgIF9nZW5lcmF0ZShtaXJyb3IudmFsdWUsIG9ic2VydmVyLm9iamVjdCwgb2JzZXJ2ZXIucGF0Y2hlcywgXCJcIiwgaW52ZXJ0aWJsZSk7XG4gICAgaWYgKG9ic2VydmVyLnBhdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGFwcGx5UGF0Y2gobWlycm9yLnZhbHVlLCBvYnNlcnZlci5wYXRjaGVzKTtcbiAgICB9XG4gICAgdmFyIHRlbXAgPSBvYnNlcnZlci5wYXRjaGVzO1xuICAgIGlmICh0ZW1wLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IFtdO1xuICAgICAgICBpZiAob2JzZXJ2ZXIuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNhbGxiYWNrKHRlbXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZW1wO1xufVxuLy8gRGlydHkgY2hlY2sgaWYgb2JqIGlzIGRpZmZlcmVudCBmcm9tIG1pcnJvciwgZ2VuZXJhdGUgcGF0Y2hlcyBhbmQgdXBkYXRlIG1pcnJvclxuZnVuY3Rpb24gX2dlbmVyYXRlKG1pcnJvciwgb2JqLCBwYXRjaGVzLCBwYXRoLCBpbnZlcnRpYmxlKSB7XG4gICAgaWYgKG9iaiA9PT0gbWlycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmoudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgIH1cbiAgICB2YXIgbmV3S2V5cyA9IF9vYmplY3RLZXlzKG9iaik7XG4gICAgdmFyIG9sZEtleXMgPSBfb2JqZWN0S2V5cyhtaXJyb3IpO1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAvL2lmIGV2ZXIgXCJtb3ZlXCIgb3BlcmF0aW9uIGlzIGltcGxlbWVudGVkIGhlcmUsIG1ha2Ugc3VyZSB0aGlzIHRlc3QgcnVucyBPSzogXCJzaG91bGQgbm90IGdlbmVyYXRlIHRoZSBzYW1lIHBhdGNoIHR3aWNlIChtb3ZlKVwiXG4gICAgZm9yICh2YXIgdCA9IG9sZEtleXMubGVuZ3RoIC0gMTsgdCA+PSAwOyB0LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9sZEtleXNbdF07XG4gICAgICAgIHZhciBvbGRWYWwgPSBtaXJyb3Jba2V5XTtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwga2V5KSAmJlxuICAgICAgICAgICAgIShvYmpba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2xkVmFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KG9iaikgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWwgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIG9sZFZhbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5ld1ZhbCA9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgbmV3VmFsICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KG9sZFZhbCkgPT09IEFycmF5LmlzQXJyYXkobmV3VmFsKSkge1xuICAgICAgICAgICAgICAgIF9nZW5lcmF0ZShvbGRWYWwsIG5ld1ZhbCwgcGF0Y2hlcywgcGF0aCArIFwiL1wiICsgZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCBpbnZlcnRpYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWwgIT09IG5ld1ZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwidGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZShvbGRWYWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfZGVlcENsb25lKG5ld1ZhbCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1pcnJvcikgPT09IEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJ0ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF9kZWVwQ2xvbmUob2xkVmFsKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCArIFwiL1wiICsgZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTsgLy8gcHJvcGVydHkgaGFzIGJlZW4gZGVsZXRlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGgsIHZhbHVlOiBtaXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGgsIHZhbHVlOiBvYmogfSk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRlbGV0ZWQgJiYgbmV3S2V5cy5sZW5ndGggPT0gb2xkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG5ld0tleXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgdmFyIGtleSA9IG5ld0tleXNbdF07XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkobWlycm9yLCBrZXkpICYmIG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCArIFwiL1wiICsgZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfZGVlcENsb25lKG9ialtrZXldKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIHRoZSBkaWZmZXJlbmNlcyBpbiB0d28gb2JqZWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZSh0cmVlMSwgdHJlZTIsIGludmVydGlibGUgPSBmYWxzZSkge1xuICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgX2dlbmVyYXRlKHRyZWUxLCB0cmVlMiwgcGF0Y2hlcywgXCJcIiwgaW52ZXJ0aWJsZSk7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PatchError: () => (/* binding */ PatchError),\n/* harmony export */   _deepClone: () => (/* binding */ _deepClone),\n/* harmony export */   _getPathRecursive: () => (/* binding */ _getPathRecursive),\n/* harmony export */   _objectKeys: () => (/* binding */ _objectKeys),\n/* harmony export */   escapePathComponent: () => (/* binding */ escapePathComponent),\n/* harmony export */   getPath: () => (/* binding */ getPath),\n/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),\n/* harmony export */   hasUndefined: () => (/* binding */ hasUndefined),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   unescapePathComponent: () => (/* binding */ unescapePathComponent)\n/* harmony export */ });\n// @ts-nocheck\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj, key) {\n    return _hasOwnProperty.call(obj, key);\n}\nfunction _objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        const keys = new Array(obj.length);\n        for (let k = 0; k < keys.length; k++) {\n            keys[k] = \"\" + k;\n        }\n        return keys;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    let keys = [];\n    for (let i in obj) {\n        if (hasOwnProperty(obj, i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\n/**\n * Deeply clone the object.\n * https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n * @param  {any} obj value to clone\n * @return {any} cloned obj\n */\nfunction _deepClone(obj) {\n    switch (typeof obj) {\n        case \"object\":\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n        case \"undefined\":\n            return null; //this is how JSON.stringify behaves for array items\n        default:\n            return obj; //no need to clone primitives\n    }\n}\n//3x faster than cached /^\\d+$/.test(str)\nfunction isInteger(str) {\n    let i = 0;\n    const len = str.length;\n    let charCode;\n    while (i < len) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 48 && charCode <= 57) {\n            i++;\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Escapes a json pointer path\n * @param path The raw pointer\n * @return the Escaped path\n */\nfunction escapePathComponent(path) {\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1)\n        return path;\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nfunction unescapePathComponent(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nfunction _getPathRecursive(root, obj) {\n    let found;\n    for (let key in root) {\n        if (hasOwnProperty(root, key)) {\n            if (root[key] === obj) {\n                return escapePathComponent(key) + \"/\";\n            }\n            else if (typeof root[key] === \"object\") {\n                found = _getPathRecursive(root[key], obj);\n                if (found != \"\") {\n                    return escapePathComponent(key) + \"/\" + found;\n                }\n            }\n        }\n    }\n    return \"\";\n}\nfunction getPath(root, obj) {\n    if (root === obj) {\n        return \"/\";\n    }\n    const path = _getPathRecursive(root, obj);\n    if (path === \"\") {\n        throw new Error(\"Object not found in root\");\n    }\n    return `/${path}`;\n}\n/**\n * Recursively checks whether an object has any undefined values inside.\n */\nfunction hasUndefined(obj) {\n    if (obj === undefined) {\n        return true;\n    }\n    if (obj) {\n        if (Array.isArray(obj)) {\n            for (let i = 0, len = obj.length; i < len; i++) {\n                if (hasUndefined(obj[i])) {\n                    return true;\n                }\n            }\n        }\n        else if (typeof obj === \"object\") {\n            const objKeys = _objectKeys(obj);\n            const objKeysLength = objKeys.length;\n            for (var i = 0; i < objKeysLength; i++) {\n                if (hasUndefined(obj[objKeys[i]])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction patchErrorMessageFormatter(message, args) {\n    const messageParts = [message];\n    for (const key in args) {\n        const value = typeof args[key] === \"object\"\n            ? JSON.stringify(args[key], null, 2)\n            : args[key]; // pretty print\n        if (typeof value !== \"undefined\") {\n            messageParts.push(`${key}: ${value}`);\n        }\n    }\n    return messageParts.join(\"\\n\");\n}\nclass PatchError extends Error {\n    constructor(message, name, index, operation, tree) {\n        super(patchErrorMessageFormatter(message, { name, index, operation, tree }));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: name\n        });\n        Object.defineProperty(this, \"index\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: index\n        });\n        Object.defineProperty(this, \"operation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: operation\n        });\n        Object.defineProperty(this, \"tree\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tree\n        });\n        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n        this.message = patchErrorMessageFormatter(message, {\n            name,\n            index,\n            operation,\n            tree,\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUNBQWlDLElBQUksSUFBSSxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9EQUFvRCw4QkFBOEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxmYXN0LWpzb24tcGF0Y2hcXHNyY1xcaGVscGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtbm9jaGVja1xuLy8gSW5saW5lZCBiZWNhdXNlIG9mIEVTTSBpbXBvcnQgaXNzdWVzXG4vKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGFyY291bnRlci1KYWNrL0pTT04tUGF0Y2hcbiAqIChjKSAyMDE3LTIwMjIgSm9hY2hpbSBXZXN0ZXJcbiAqIE1JVCBsaWNlbnNlZFxuICovXG5jb25zdCBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZXhwb3J0IGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfb2JqZWN0S2V5cyhvYmopIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAga2V5c1trXSA9IFwiXCIgKyBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuICAgIGxldCBrZXlzID0gW107XG4gICAgZm9yIChsZXQgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgaSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbi8qKlxuICogRGVlcGx5IGNsb25lIHRoZSBvYmplY3QuXG4gKiBodHRwczovL2pzcGVyZi5jb20vZGVlcC1jb3B5LXZzLWpzb24tc3RyaW5naWZ5LWpzb24tcGFyc2UvMjUgKHJlY3Vyc2l2ZURlZXBDb3B5KVxuICogQHBhcmFtICB7YW55fSBvYmogdmFsdWUgdG8gY2xvbmVcbiAqIEByZXR1cm4ge2FueX0gY2xvbmVkIG9ialxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlZXBDbG9uZShvYmopIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBvYmopIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7IC8vRmFzdGVyIHRoYW4gRVM1IGNsb25lIC0gaHR0cDovL2pzcGVyZi5jb20vZGVlcC1jbG9uaW5nLW9mLW9iamVjdHMvNVxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy90aGlzIGlzIGhvdyBKU09OLnN0cmluZ2lmeSBiZWhhdmVzIGZvciBhcnJheSBpdGVtc1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG9iajsgLy9ubyBuZWVkIHRvIGNsb25lIHByaW1pdGl2ZXNcbiAgICB9XG59XG4vLzN4IGZhc3RlciB0aGFuIGNhY2hlZCAvXlxcZCskLy50ZXN0KHN0cilcbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIoc3RyKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgbGV0IGNoYXJDb2RlO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogRXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXG4gKiBAcGFyYW0gcGF0aCBUaGUgcmF3IHBvaW50ZXJcbiAqIEByZXR1cm4gdGhlIEVzY2FwZWQgcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGguaW5kZXhPZihcIi9cIikgPT09IC0xICYmIHBhdGguaW5kZXhPZihcIn5cIikgPT09IC0xKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIik7XG59XG4vKipcbiAqIFVuZXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXG4gKiBAcGFyYW0gcGF0aCBUaGUgZXNjYXBlZCBwb2ludGVyXG4gKiBAcmV0dXJuIFRoZSB1bmVzY2FwZWQgcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5lc2NhcGVQYXRoQ29tcG9uZW50KHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaikge1xuICAgIGxldCBmb3VuZDtcbiAgICBmb3IgKGxldCBrZXkgaW4gcm9vdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkocm9vdCwga2V5KSkge1xuICAgICAgICAgICAgaWYgKHJvb3Rba2V5XSA9PT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSArIFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJvb3Rba2V5XSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gX2dldFBhdGhSZWN1cnNpdmUocm9vdFtrZXldLCBvYmopO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyBcIi9cIiArIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXRoKHJvb3QsIG9iaikge1xuICAgIGlmIChyb290ID09PSBvYmopIHtcbiAgICAgICAgcmV0dXJuIFwiL1wiO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gX2dldFBhdGhSZWN1cnNpdmUocm9vdCwgb2JqKTtcbiAgICBpZiAocGF0aCA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3Qgbm90IGZvdW5kIGluIHJvb3RcIik7XG4gICAgfVxuICAgIHJldHVybiBgLyR7cGF0aH1gO1xufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBjaGVja3Mgd2hldGhlciBhbiBvYmplY3QgaGFzIGFueSB1bmRlZmluZWQgdmFsdWVzIGluc2lkZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1VuZGVmaW5lZChvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3Qgb2JqS2V5cyA9IF9vYmplY3RLZXlzKG9iaik7XG4gICAgICAgICAgICBjb25zdCBvYmpLZXlzTGVuZ3RoID0gb2JqS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW29iaktleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgYXJncykge1xuICAgIGNvbnN0IG1lc3NhZ2VQYXJ0cyA9IFttZXNzYWdlXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhcmdzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIGFyZ3Nba2V5XSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeShhcmdzW2tleV0sIG51bGwsIDIpXG4gICAgICAgICAgICA6IGFyZ3Nba2V5XTsgLy8gcHJldHR5IHByaW50XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VQYXJ0cy5wdXNoKGAke2tleX06ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VQYXJ0cy5qb2luKFwiXFxuXCIpO1xufVxuZXhwb3J0IGNsYXNzIFBhdGNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbmFtZSwgaW5kZXgsIG9wZXJhdGlvbiwgdHJlZSkge1xuICAgICAgICBzdXBlcihwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCB7IG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmRleFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wZXJhdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cmVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpOyAvLyByZXN0b3JlIHByb3RvdHlwZSBjaGFpbiwgc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80ODM0MjM1OVxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/function_calling.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToOpenAIFunction: () => (/* binding */ convertToOpenAIFunction),\n/* harmony export */   convertToOpenAITool: () => (/* binding */ convertToOpenAITool),\n/* harmony export */   isLangChainTool: () => (/* reexport safe */ _tools_types_js__WEBPACK_IMPORTED_MODULE_0__.isLangChainTool),\n/* harmony export */   isRunnableToolLike: () => (/* reexport safe */ _tools_types_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableToolLike),\n/* harmony export */   isStructuredTool: () => (/* reexport safe */ _tools_types_js__WEBPACK_IMPORTED_MODULE_0__.isStructuredTool),\n/* harmony export */   isStructuredToolParams: () => (/* reexport safe */ _tools_types_js__WEBPACK_IMPORTED_MODULE_0__.isStructuredToolParams)\n/* harmony export */ });\n/* harmony import */ var _tools_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/types.js */ \"(rsc)/./node_modules/@langchain/core/dist/tools/types.js\");\n/* harmony import */ var _json_schema_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./json_schema.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.js\");\n\n\n// These utility functions were moved to a more appropriate location,\n// but we still export them here for backwards compatibility.\n\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a format\n * that is compatible with OpenAI function calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | RunnableToolLike} tool The tool to convert to an OpenAI function.\n * @returns {FunctionDefinition} The inputted tool in OpenAI function format.\n */\nfunction convertToOpenAIFunction(tool, fields) {\n    // @TODO 0.3.0 Remove the `number` typing\n    const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n    return {\n        name: tool.name,\n        description: tool.description,\n        parameters: (0,_json_schema_js__WEBPACK_IMPORTED_MODULE_1__.toJsonSchema)(tool.schema),\n        // Do not include the `strict` field if it is `undefined`.\n        ...(fieldsCopy?.strict !== undefined ? { strict: fieldsCopy.strict } : {}),\n    };\n}\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a\n * format that is compatible with OpenAI tool calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | Record<string, any> | RunnableToolLike} tool The tool to convert to an OpenAI tool.\n * @returns {ToolDefinition} The inputted tool in OpenAI tool format.\n */\nfunction convertToOpenAITool(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntool, fields) {\n    // @TODO 0.3.0 Remove the `number` typing\n    const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n    let toolDef;\n    if ((0,_tools_types_js__WEBPACK_IMPORTED_MODULE_0__.isLangChainTool)(tool)) {\n        toolDef = {\n            type: \"function\",\n            function: convertToOpenAIFunction(tool),\n        };\n    }\n    else {\n        toolDef = tool;\n    }\n    if (fieldsCopy?.strict !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        toolDef.function.strict = fieldsCopy.strict;\n    }\n    return toolDef;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZnVuY3Rpb25fY2FsbGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFxRDtBQUNMO0FBQ2hEO0FBQ0E7QUFDbUg7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBNEM7QUFDdkQsYUFBYSxvQkFBb0I7QUFDakM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQVk7QUFDaEM7QUFDQSxpREFBaUQsNEJBQTRCLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtFO0FBQzdFLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRUFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxmdW5jdGlvbl9jYWxsaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTGFuZ0NoYWluVG9vbCwgfSBmcm9tIFwiLi4vdG9vbHMvdHlwZXMuanNcIjtcbmltcG9ydCB7IHRvSnNvblNjaGVtYSB9IGZyb20gXCIuL2pzb25fc2NoZW1hLmpzXCI7XG4vLyBUaGVzZSB1dGlsaXR5IGZ1bmN0aW9ucyB3ZXJlIG1vdmVkIHRvIGEgbW9yZSBhcHByb3ByaWF0ZSBsb2NhdGlvbixcbi8vIGJ1dCB3ZSBzdGlsbCBleHBvcnQgdGhlbSBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbmV4cG9ydCB7IGlzU3RydWN0dXJlZFRvb2wsIGlzU3RydWN0dXJlZFRvb2xQYXJhbXMsIGlzUnVubmFibGVUb29sTGlrZSwgaXNMYW5nQ2hhaW5Ub29sLCB9IGZyb20gXCIuLi90b29scy90eXBlcy5qc1wiO1xuLyoqXG4gKiBGb3JtYXRzIGEgYFN0cnVjdHVyZWRUb29sYCBvciBgUnVubmFibGVUb29sTGlrZWAgaW5zdGFuY2UgaW50byBhIGZvcm1hdFxuICogdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggT3BlbkFJIGZ1bmN0aW9uIGNhbGxpbmcuIElmIGBTdHJ1Y3R1cmVkVG9vbGAgb3JcbiAqIGBSdW5uYWJsZVRvb2xMaWtlYCBoYXMgYSB6b2Qgc2NoZW1hLCB0aGUgb3V0cHV0IHdpbGwgYmUgY29udmVydGVkIGludG8gYVxuICogSlNPTiBzY2hlbWEsIHdoaWNoIGlzIHRoZW4gdXNlZCBhcyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIE9wZW5BSSB0b29sLlxuICpcbiAqIEBwYXJhbSB7U3RydWN0dXJlZFRvb2xJbnRlcmZhY2UgfCBSdW5uYWJsZVRvb2xMaWtlfSB0b29sIFRoZSB0b29sIHRvIGNvbnZlcnQgdG8gYW4gT3BlbkFJIGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9uRGVmaW5pdGlvbn0gVGhlIGlucHV0dGVkIHRvb2wgaW4gT3BlbkFJIGZ1bmN0aW9uIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb09wZW5BSUZ1bmN0aW9uKHRvb2wsIGZpZWxkcykge1xuICAgIC8vIEBUT0RPIDAuMy4wIFJlbW92ZSB0aGUgYG51bWJlcmAgdHlwaW5nXG4gICAgY29uc3QgZmllbGRzQ29weSA9IHR5cGVvZiBmaWVsZHMgPT09IFwibnVtYmVyXCIgPyB1bmRlZmluZWQgOiBmaWVsZHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgcGFyYW1ldGVyczogdG9Kc29uU2NoZW1hKHRvb2wuc2NoZW1hKSxcbiAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgdGhlIGBzdHJpY3RgIGZpZWxkIGlmIGl0IGlzIGB1bmRlZmluZWRgLlxuICAgICAgICAuLi4oZmllbGRzQ29weT8uc3RyaWN0ICE9PSB1bmRlZmluZWQgPyB7IHN0cmljdDogZmllbGRzQ29weS5zdHJpY3QgfSA6IHt9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBGb3JtYXRzIGEgYFN0cnVjdHVyZWRUb29sYCBvciBgUnVubmFibGVUb29sTGlrZWAgaW5zdGFuY2UgaW50byBhXG4gKiBmb3JtYXQgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggT3BlbkFJIHRvb2wgY2FsbGluZy4gSWYgYFN0cnVjdHVyZWRUb29sYCBvclxuICogYFJ1bm5hYmxlVG9vbExpa2VgIGhhcyBhIHpvZCBzY2hlbWEsIHRoZSBvdXRwdXQgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBhXG4gKiBKU09OIHNjaGVtYSwgd2hpY2ggaXMgdGhlbiB1c2VkIGFzIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgT3BlbkFJIHRvb2wuXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZSB8IFJlY29yZDxzdHJpbmcsIGFueT4gfCBSdW5uYWJsZVRvb2xMaWtlfSB0b29sIFRoZSB0b29sIHRvIGNvbnZlcnQgdG8gYW4gT3BlbkFJIHRvb2wuXG4gKiBAcmV0dXJucyB7VG9vbERlZmluaXRpb259IFRoZSBpbnB1dHRlZCB0b29sIGluIE9wZW5BSSB0b29sIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb09wZW5BSVRvb2woXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudG9vbCwgZmllbGRzKSB7XG4gICAgLy8gQFRPRE8gMC4zLjAgUmVtb3ZlIHRoZSBgbnVtYmVyYCB0eXBpbmdcbiAgICBjb25zdCBmaWVsZHNDb3B5ID0gdHlwZW9mIGZpZWxkcyA9PT0gXCJudW1iZXJcIiA/IHVuZGVmaW5lZCA6IGZpZWxkcztcbiAgICBsZXQgdG9vbERlZjtcbiAgICBpZiAoaXNMYW5nQ2hhaW5Ub29sKHRvb2wpKSB7XG4gICAgICAgIHRvb2xEZWYgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBmdW5jdGlvbjogY29udmVydFRvT3BlbkFJRnVuY3Rpb24odG9vbCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0b29sRGVmID0gdG9vbDtcbiAgICB9XG4gICAgaWYgKGZpZWxkc0NvcHk/LnN0cmljdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRvb2xEZWYuZnVuY3Rpb24uc3RyaWN0ID0gZmllbGRzQ29weS5zdHJpY3Q7XG4gICAgfVxuICAgIHJldHVybiB0b29sRGVmO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/hash.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/hash.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   insecureHash: () => (/* reexport safe */ _js_sha1_hash_js__WEBPACK_IMPORTED_MODULE_0__.insecureHash),\n/* harmony export */   sha256: () => (/* reexport safe */ _js_sha256_hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256)\n/* harmony export */ });\n/* harmony import */ var _js_sha1_hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./js-sha1/hash.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.js\");\n/* harmony import */ var _js_sha256_hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js-sha256/hash.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/js-sha256/hash.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvaGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlEO0FBQ0oiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXGhhc2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgaW5zZWN1cmVIYXNoIH0gZnJvbSBcIi4vanMtc2hhMS9oYXNoLmpzXCI7XG5leHBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiLi9qcy1zaGEyNTYvaGFzaC5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/hash.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/js-sha1/hash.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   insecureHash: () => (/* binding */ insecureHash)\n/* harmony export */ });\n// @ts-nocheck\n// Inlined to deal with portability issues with importing crypto module\n/*\n * [js-sha1]{@link https://github.com/emn178/js-sha1}\n *\n * @version 0.6.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n/*jslint bitwise: true */\n\nvar root = typeof window === \"object\" ? window : {};\nvar HEX_CHARS = \"0123456789abcdef\".split(\"\");\nvar EXTRA = [-2147483648, 8388608, 32768, 128];\nvar SHIFT = [24, 16, 8, 0];\nvar OUTPUT_TYPES = [\"hex\", \"array\", \"digest\", \"arrayBuffer\"];\nvar blocks = [];\nfunction Sha1(sharedMemory) {\n    if (sharedMemory) {\n        blocks[0] =\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        this.blocks = blocks;\n    }\n    else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n    this.h0 = 0x67452301;\n    this.h1 = 0xefcdab89;\n    this.h2 = 0x98badcfe;\n    this.h3 = 0x10325476;\n    this.h4 = 0xc3d2e1f0;\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n}\nSha1.prototype.update = function (message) {\n    if (this.finalized) {\n        return;\n    }\n    var notString = typeof message !== \"string\";\n    if (notString && message.constructor === root.ArrayBuffer) {\n        message = new Uint8Array(message);\n    }\n    var code, index = 0, i, length = message.length || 0, blocks = this.blocks;\n    while (index < length) {\n        if (this.hashed) {\n            this.hashed = false;\n            blocks[0] = this.block;\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        }\n        if (notString) {\n            for (i = this.start; index < length && i < 64; ++index) {\n                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n            }\n        }\n        else {\n            for (i = this.start; index < length && i < 64; ++index) {\n                code = message.charCodeAt(index);\n                if (code < 0x80) {\n                    blocks[i >> 2] |= code << SHIFT[i++ & 3];\n                }\n                else if (code < 0x800) {\n                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else if (code < 0xd800 || code >= 0xe000) {\n                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else {\n                    code =\n                        0x10000 +\n                            (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n            }\n        }\n        this.lastByteIndex = i;\n        this.bytes += i - this.start;\n        if (i >= 64) {\n            this.block = blocks[16];\n            this.start = i - 64;\n            this.hash();\n            this.hashed = true;\n        }\n        else {\n            this.start = i;\n        }\n    }\n    if (this.bytes > 4294967295) {\n        this.hBytes += (this.bytes / 4294967296) << 0;\n        this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n};\nSha1.prototype.finalize = function () {\n    if (this.finalized) {\n        return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n        if (!this.hashed) {\n            this.hash();\n        }\n        blocks[0] = this.block;\n        blocks[16] =\n            blocks[1] =\n                blocks[2] =\n                    blocks[3] =\n                        blocks[4] =\n                            blocks[5] =\n                                blocks[6] =\n                                    blocks[7] =\n                                        blocks[8] =\n                                            blocks[9] =\n                                                blocks[10] =\n                                                    blocks[11] =\n                                                        blocks[12] =\n                                                            blocks[13] =\n                                                                blocks[14] =\n                                                                    blocks[15] =\n                                                                        0;\n    }\n    blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n    blocks[15] = this.bytes << 3;\n    this.hash();\n};\nSha1.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;\n    var f, j, t, blocks = this.blocks;\n    for (j = 16; j < 80; ++j) {\n        t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];\n        blocks[j] = (t << 1) | (t >>> 31);\n    }\n    for (j = 0; j < 20; j += 5) {\n        f = (b & c) | (~b & d);\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e + 1518500249 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = (a & b) | (~a & c);\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d + 1518500249 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = (e & a) | (~e & b);\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c + 1518500249 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = (d & e) | (~d & a);\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b + 1518500249 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = (c & d) | (~c & e);\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a + 1518500249 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 40; j += 5) {\n        f = b ^ c ^ d;\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e + 1859775393 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = a ^ b ^ c;\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d + 1859775393 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = e ^ a ^ b;\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c + 1859775393 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = d ^ e ^ a;\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b + 1859775393 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = c ^ d ^ e;\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a + 1859775393 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 60; j += 5) {\n        f = (b & c) | (b & d) | (c & d);\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e - 1894007588 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = (a & b) | (a & c) | (b & c);\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d - 1894007588 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = (e & a) | (e & b) | (a & b);\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c - 1894007588 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = (d & e) | (d & a) | (e & a);\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b - 1894007588 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = (c & d) | (c & e) | (d & e);\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a - 1894007588 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 80; j += 5) {\n        f = b ^ c ^ d;\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e - 899497514 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = a ^ b ^ c;\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d - 899497514 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = e ^ a ^ b;\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c - 899497514 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = d ^ e ^ a;\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b - 899497514 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = c ^ d ^ e;\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a - 899497514 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    this.h0 = (this.h0 + a) << 0;\n    this.h1 = (this.h1 + b) << 0;\n    this.h2 = (this.h2 + c) << 0;\n    this.h3 = (this.h3 + d) << 0;\n    this.h4 = (this.h4 + e) << 0;\n};\nSha1.prototype.hex = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n    return (HEX_CHARS[(h0 >> 28) & 0x0f] +\n        HEX_CHARS[(h0 >> 24) & 0x0f] +\n        HEX_CHARS[(h0 >> 20) & 0x0f] +\n        HEX_CHARS[(h0 >> 16) & 0x0f] +\n        HEX_CHARS[(h0 >> 12) & 0x0f] +\n        HEX_CHARS[(h0 >> 8) & 0x0f] +\n        HEX_CHARS[(h0 >> 4) & 0x0f] +\n        HEX_CHARS[h0 & 0x0f] +\n        HEX_CHARS[(h1 >> 28) & 0x0f] +\n        HEX_CHARS[(h1 >> 24) & 0x0f] +\n        HEX_CHARS[(h1 >> 20) & 0x0f] +\n        HEX_CHARS[(h1 >> 16) & 0x0f] +\n        HEX_CHARS[(h1 >> 12) & 0x0f] +\n        HEX_CHARS[(h1 >> 8) & 0x0f] +\n        HEX_CHARS[(h1 >> 4) & 0x0f] +\n        HEX_CHARS[h1 & 0x0f] +\n        HEX_CHARS[(h2 >> 28) & 0x0f] +\n        HEX_CHARS[(h2 >> 24) & 0x0f] +\n        HEX_CHARS[(h2 >> 20) & 0x0f] +\n        HEX_CHARS[(h2 >> 16) & 0x0f] +\n        HEX_CHARS[(h2 >> 12) & 0x0f] +\n        HEX_CHARS[(h2 >> 8) & 0x0f] +\n        HEX_CHARS[(h2 >> 4) & 0x0f] +\n        HEX_CHARS[h2 & 0x0f] +\n        HEX_CHARS[(h3 >> 28) & 0x0f] +\n        HEX_CHARS[(h3 >> 24) & 0x0f] +\n        HEX_CHARS[(h3 >> 20) & 0x0f] +\n        HEX_CHARS[(h3 >> 16) & 0x0f] +\n        HEX_CHARS[(h3 >> 12) & 0x0f] +\n        HEX_CHARS[(h3 >> 8) & 0x0f] +\n        HEX_CHARS[(h3 >> 4) & 0x0f] +\n        HEX_CHARS[h3 & 0x0f] +\n        HEX_CHARS[(h4 >> 28) & 0x0f] +\n        HEX_CHARS[(h4 >> 24) & 0x0f] +\n        HEX_CHARS[(h4 >> 20) & 0x0f] +\n        HEX_CHARS[(h4 >> 16) & 0x0f] +\n        HEX_CHARS[(h4 >> 12) & 0x0f] +\n        HEX_CHARS[(h4 >> 8) & 0x0f] +\n        HEX_CHARS[(h4 >> 4) & 0x0f] +\n        HEX_CHARS[h4 & 0x0f]);\n};\nSha1.prototype.toString = Sha1.prototype.hex;\nSha1.prototype.digest = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n    return [\n        (h0 >> 24) & 0xff,\n        (h0 >> 16) & 0xff,\n        (h0 >> 8) & 0xff,\n        h0 & 0xff,\n        (h1 >> 24) & 0xff,\n        (h1 >> 16) & 0xff,\n        (h1 >> 8) & 0xff,\n        h1 & 0xff,\n        (h2 >> 24) & 0xff,\n        (h2 >> 16) & 0xff,\n        (h2 >> 8) & 0xff,\n        h2 & 0xff,\n        (h3 >> 24) & 0xff,\n        (h3 >> 16) & 0xff,\n        (h3 >> 8) & 0xff,\n        h3 & 0xff,\n        (h4 >> 24) & 0xff,\n        (h4 >> 16) & 0xff,\n        (h4 >> 8) & 0xff,\n        h4 & 0xff,\n    ];\n};\nSha1.prototype.array = Sha1.prototype.digest;\nSha1.prototype.arrayBuffer = function () {\n    this.finalize();\n    var buffer = new ArrayBuffer(20);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    return buffer;\n};\nlet hasLoggedWarning = false;\n/**\n * @deprecated Use `makeDefaultKeyEncoder()` to create a custom key encoder.\n * This function will be removed in a future version.\n */\nconst insecureHash = (message) => {\n    if (!hasLoggedWarning) {\n        console.warn([\n            `The default method for hashing keys is insecure and will be replaced in a future version,`,\n            `but hasn't been replaced yet as to not break existing caches. It's recommended that you use`,\n            `a more secure hashing algorithm to avoid cache poisoning.`,\n            ``,\n            `See this page for more information:`,\n            `|`,\n            `> https://js.langchain.com/docs/troubleshooting/warnings/insecure-cache-algorithm`,\n        ].join(\"\\n\"));\n        hasLoggedWarning = true;\n    }\n    return new Sha1(true).update(message)[\"hex\"]();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanMtc2hhMS9oYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxqcy1zaGExXFxoYXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG4vLyBJbmxpbmVkIHRvIGRlYWwgd2l0aCBwb3J0YWJpbGl0eSBpc3N1ZXMgd2l0aCBpbXBvcnRpbmcgY3J5cHRvIG1vZHVsZVxuLypcbiAqIFtqcy1zaGExXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTF9XG4gKlxuICogQHZlcnNpb24gMC42LjBcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXG4gKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTQtMjAxN1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblwidXNlIHN0cmljdFwiO1xudmFyIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDoge307XG52YXIgSEVYX0NIQVJTID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCIuc3BsaXQoXCJcIik7XG52YXIgRVhUUkEgPSBbLTIxNDc0ODM2NDgsIDgzODg2MDgsIDMyNzY4LCAxMjhdO1xudmFyIFNISUZUID0gWzI0LCAxNiwgOCwgMF07XG52YXIgT1VUUFVUX1RZUEVTID0gW1wiaGV4XCIsIFwiYXJyYXlcIiwgXCJkaWdlc3RcIiwgXCJhcnJheUJ1ZmZlclwiXTtcbnZhciBibG9ja3MgPSBbXTtcbmZ1bmN0aW9uIFNoYTEoc2hhcmVkTWVtb3J5KSB7XG4gICAgaWYgKHNoYXJlZE1lbW9yeSkge1xuICAgICAgICBibG9ja3NbMF0gPVxuICAgICAgICAgICAgYmxvY2tzWzE2XSA9XG4gICAgICAgICAgICAgICAgYmxvY2tzWzFdID1cbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1szXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s2XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEwXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEyXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEzXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmJsb2NrcyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICB9XG4gICAgdGhpcy5oMCA9IDB4Njc0NTIzMDE7XG4gICAgdGhpcy5oMSA9IDB4ZWZjZGFiODk7XG4gICAgdGhpcy5oMiA9IDB4OThiYWRjZmU7XG4gICAgdGhpcy5oMyA9IDB4MTAzMjU0NzY7XG4gICAgdGhpcy5oNCA9IDB4YzNkMmUxZjA7XG4gICAgdGhpcy5ibG9jayA9IHRoaXMuc3RhcnQgPSB0aGlzLmJ5dGVzID0gdGhpcy5oQnl0ZXMgPSAwO1xuICAgIHRoaXMuZmluYWxpemVkID0gdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpcnN0ID0gdHJ1ZTtcbn1cblNoYTEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vdFN0cmluZyA9IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiO1xuICAgIGlmIChub3RTdHJpbmcgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gcm9vdC5BcnJheUJ1ZmZlcikge1xuICAgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgfVxuICAgIHZhciBjb2RlLCBpbmRleCA9IDAsIGksIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoIHx8IDAsIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5oYXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICAgICAgYmxvY2tzWzE2XSA9XG4gICAgICAgICAgICAgICAgYmxvY2tzWzFdID1cbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1szXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s2XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEwXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEyXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEzXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90U3RyaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgNjQ7ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4YzAgfCAoY29kZSA+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZTAgfCAoY29kZSA+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgMHgxMDAwMCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZjAgfCAoY29kZSA+PiAxOCkpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RCeXRlSW5kZXggPSBpO1xuICAgICAgICB0aGlzLmJ5dGVzICs9IGkgLSB0aGlzLnN0YXJ0O1xuICAgICAgICBpZiAoaSA+PSA2NCkge1xuICAgICAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1sxNl07XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gaSAtIDY0O1xuICAgICAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICAgICAgICB0aGlzLmhhc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5ieXRlcyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgdGhpcy5oQnl0ZXMgKz0gKHRoaXMuYnl0ZXMgLyA0Mjk0OTY3Mjk2KSA8PCAwO1xuICAgICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcyAlIDQyOTQ5NjcyOTY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblNoYTEucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXg7XG4gICAgYmxvY2tzWzE2XSA9IHRoaXMuYmxvY2s7XG4gICAgYmxvY2tzW2kgPj4gMl0gfD0gRVhUUkFbaSAmIDNdO1xuICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgIGlmIChpID49IDU2KSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG4gICAgICAgIGJsb2Nrc1sxNl0gPVxuICAgICAgICAgICAgYmxvY2tzWzFdID1cbiAgICAgICAgICAgICAgICBibG9ja3NbMl0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEwXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzExXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEzXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICB9XG4gICAgYmxvY2tzWzE0XSA9ICh0aGlzLmhCeXRlcyA8PCAzKSB8ICh0aGlzLmJ5dGVzID4+PiAyOSk7XG4gICAgYmxvY2tzWzE1XSA9IHRoaXMuYnl0ZXMgPDwgMztcbiAgICB0aGlzLmhhc2goKTtcbn07XG5TaGExLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gdGhpcy5oMCwgYiA9IHRoaXMuaDEsIGMgPSB0aGlzLmgyLCBkID0gdGhpcy5oMywgZSA9IHRoaXMuaDQ7XG4gICAgdmFyIGYsIGosIHQsIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuICAgIGZvciAoaiA9IDE2OyBqIDwgODA7ICsraikge1xuICAgICAgICB0ID0gYmxvY2tzW2ogLSAzXSBeIGJsb2Nrc1tqIC0gOF0gXiBibG9ja3NbaiAtIDE0XSBeIGJsb2Nrc1tqIC0gMTZdO1xuICAgICAgICBibG9ja3Nbal0gPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgfVxuICAgIGZvciAoaiA9IDA7IGogPCAyMDsgaiArPSA1KSB7XG4gICAgICAgIGYgPSAoYiAmIGMpIHwgKH5iICYgZCk7XG4gICAgICAgIHQgPSAoYSA8PCA1KSB8IChhID4+PiAyNyk7XG4gICAgICAgIGUgPSAodCArIGYgKyBlICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqXSkgPDwgMDtcbiAgICAgICAgYiA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcbiAgICAgICAgZiA9IChhICYgYikgfCAofmEgJiBjKTtcbiAgICAgICAgdCA9IChlIDw8IDUpIHwgKGUgPj4+IDI3KTtcbiAgICAgICAgZCA9ICh0ICsgZiArIGQgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyAxXSkgPDwgMDtcbiAgICAgICAgYSA9IChhIDw8IDMwKSB8IChhID4+PiAyKTtcbiAgICAgICAgZiA9IChlICYgYSkgfCAofmUgJiBiKTtcbiAgICAgICAgdCA9IChkIDw8IDUpIHwgKGQgPj4+IDI3KTtcbiAgICAgICAgYyA9ICh0ICsgZiArIGMgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyAyXSkgPDwgMDtcbiAgICAgICAgZSA9IChlIDw8IDMwKSB8IChlID4+PiAyKTtcbiAgICAgICAgZiA9IChkICYgZSkgfCAofmQgJiBhKTtcbiAgICAgICAgdCA9IChjIDw8IDUpIHwgKGMgPj4+IDI3KTtcbiAgICAgICAgYiA9ICh0ICsgZiArIGIgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyAzXSkgPDwgMDtcbiAgICAgICAgZCA9IChkIDw8IDMwKSB8IChkID4+PiAyKTtcbiAgICAgICAgZiA9IChjICYgZCkgfCAofmMgJiBlKTtcbiAgICAgICAgdCA9IChiIDw8IDUpIHwgKGIgPj4+IDI3KTtcbiAgICAgICAgYSA9ICh0ICsgZiArIGEgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyA0XSkgPDwgMDtcbiAgICAgICAgYyA9IChjIDw8IDMwKSB8IChjID4+PiAyKTtcbiAgICB9XG4gICAgZm9yICg7IGogPCA0MDsgaiArPSA1KSB7XG4gICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgIHQgPSAoYSA8PCA1KSB8IChhID4+PiAyNyk7XG4gICAgICAgIGUgPSAodCArIGYgKyBlICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqXSkgPDwgMDtcbiAgICAgICAgYiA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcbiAgICAgICAgZiA9IGEgXiBiIF4gYztcbiAgICAgICAgdCA9IChlIDw8IDUpIHwgKGUgPj4+IDI3KTtcbiAgICAgICAgZCA9ICh0ICsgZiArIGQgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2ogKyAxXSkgPDwgMDtcbiAgICAgICAgYSA9IChhIDw8IDMwKSB8IChhID4+PiAyKTtcbiAgICAgICAgZiA9IGUgXiBhIF4gYjtcbiAgICAgICAgdCA9IChkIDw8IDUpIHwgKGQgPj4+IDI3KTtcbiAgICAgICAgYyA9ICh0ICsgZiArIGMgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2ogKyAyXSkgPDwgMDtcbiAgICAgICAgZSA9IChlIDw8IDMwKSB8IChlID4+PiAyKTtcbiAgICAgICAgZiA9IGQgXiBlIF4gYTtcbiAgICAgICAgdCA9IChjIDw8IDUpIHwgKGMgPj4+IDI3KTtcbiAgICAgICAgYiA9ICh0ICsgZiArIGIgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2ogKyAzXSkgPDwgMDtcbiAgICAgICAgZCA9IChkIDw8IDMwKSB8IChkID4+PiAyKTtcbiAgICAgICAgZiA9IGMgXiBkIF4gZTtcbiAgICAgICAgdCA9IChiIDw8IDUpIHwgKGIgPj4+IDI3KTtcbiAgICAgICAgYSA9ICh0ICsgZiArIGEgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2ogKyA0XSkgPDwgMDtcbiAgICAgICAgYyA9IChjIDw8IDMwKSB8IChjID4+PiAyKTtcbiAgICB9XG4gICAgZm9yICg7IGogPCA2MDsgaiArPSA1KSB7XG4gICAgICAgIGYgPSAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XG4gICAgICAgIHQgPSAoYSA8PCA1KSB8IChhID4+PiAyNyk7XG4gICAgICAgIGUgPSAodCArIGYgKyBlIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqXSkgPDwgMDtcbiAgICAgICAgYiA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcbiAgICAgICAgZiA9IChhICYgYikgfCAoYSAmIGMpIHwgKGIgJiBjKTtcbiAgICAgICAgdCA9IChlIDw8IDUpIHwgKGUgPj4+IDI3KTtcbiAgICAgICAgZCA9ICh0ICsgZiArIGQgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2ogKyAxXSkgPDwgMDtcbiAgICAgICAgYSA9IChhIDw8IDMwKSB8IChhID4+PiAyKTtcbiAgICAgICAgZiA9IChlICYgYSkgfCAoZSAmIGIpIHwgKGEgJiBiKTtcbiAgICAgICAgdCA9IChkIDw8IDUpIHwgKGQgPj4+IDI3KTtcbiAgICAgICAgYyA9ICh0ICsgZiArIGMgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2ogKyAyXSkgPDwgMDtcbiAgICAgICAgZSA9IChlIDw8IDMwKSB8IChlID4+PiAyKTtcbiAgICAgICAgZiA9IChkICYgZSkgfCAoZCAmIGEpIHwgKGUgJiBhKTtcbiAgICAgICAgdCA9IChjIDw8IDUpIHwgKGMgPj4+IDI3KTtcbiAgICAgICAgYiA9ICh0ICsgZiArIGIgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2ogKyAzXSkgPDwgMDtcbiAgICAgICAgZCA9IChkIDw8IDMwKSB8IChkID4+PiAyKTtcbiAgICAgICAgZiA9IChjICYgZCkgfCAoYyAmIGUpIHwgKGQgJiBlKTtcbiAgICAgICAgdCA9IChiIDw8IDUpIHwgKGIgPj4+IDI3KTtcbiAgICAgICAgYSA9ICh0ICsgZiArIGEgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2ogKyA0XSkgPDwgMDtcbiAgICAgICAgYyA9IChjIDw8IDMwKSB8IChjID4+PiAyKTtcbiAgICB9XG4gICAgZm9yICg7IGogPCA4MDsgaiArPSA1KSB7XG4gICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgIHQgPSAoYSA8PCA1KSB8IChhID4+PiAyNyk7XG4gICAgICAgIGUgPSAodCArIGYgKyBlIC0gODk5NDk3NTE0ICsgYmxvY2tzW2pdKSA8PCAwO1xuICAgICAgICBiID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuICAgICAgICBmID0gYSBeIGIgXiBjO1xuICAgICAgICB0ID0gKGUgPDwgNSkgfCAoZSA+Pj4gMjcpO1xuICAgICAgICBkID0gKHQgKyBmICsgZCAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgMV0pIDw8IDA7XG4gICAgICAgIGEgPSAoYSA8PCAzMCkgfCAoYSA+Pj4gMik7XG4gICAgICAgIGYgPSBlIF4gYSBeIGI7XG4gICAgICAgIHQgPSAoZCA8PCA1KSB8IChkID4+PiAyNyk7XG4gICAgICAgIGMgPSAodCArIGYgKyBjIC0gODk5NDk3NTE0ICsgYmxvY2tzW2ogKyAyXSkgPDwgMDtcbiAgICAgICAgZSA9IChlIDw8IDMwKSB8IChlID4+PiAyKTtcbiAgICAgICAgZiA9IGQgXiBlIF4gYTtcbiAgICAgICAgdCA9IChjIDw8IDUpIHwgKGMgPj4+IDI3KTtcbiAgICAgICAgYiA9ICh0ICsgZiArIGIgLSA4OTk0OTc1MTQgKyBibG9ja3NbaiArIDNdKSA8PCAwO1xuICAgICAgICBkID0gKGQgPDwgMzApIHwgKGQgPj4+IDIpO1xuICAgICAgICBmID0gYyBeIGQgXiBlO1xuICAgICAgICB0ID0gKGIgPDwgNSkgfCAoYiA+Pj4gMjcpO1xuICAgICAgICBhID0gKHQgKyBmICsgYSAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgNF0pIDw8IDA7XG4gICAgICAgIGMgPSAoYyA8PCAzMCkgfCAoYyA+Pj4gMik7XG4gICAgfVxuICAgIHRoaXMuaDAgPSAodGhpcy5oMCArIGEpIDw8IDA7XG4gICAgdGhpcy5oMSA9ICh0aGlzLmgxICsgYikgPDwgMDtcbiAgICB0aGlzLmgyID0gKHRoaXMuaDIgKyBjKSA8PCAwO1xuICAgIHRoaXMuaDMgPSAodGhpcy5oMyArIGQpIDw8IDA7XG4gICAgdGhpcy5oNCA9ICh0aGlzLmg0ICsgZSkgPDwgMDtcbn07XG5TaGExLnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNDtcbiAgICByZXR1cm4gKEhFWF9DSEFSU1soaDAgPj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gwICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDIgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gzICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toNCAmIDB4MGZdKTtcbn07XG5TaGExLnByb3RvdHlwZS50b1N0cmluZyA9IFNoYTEucHJvdG90eXBlLmhleDtcblNoYTEucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0O1xuICAgIHJldHVybiBbXG4gICAgICAgIChoMCA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDAgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgwID4+IDgpICYgMHhmZixcbiAgICAgICAgaDAgJiAweGZmLFxuICAgICAgICAoaDEgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgxID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgxICYgMHhmZixcbiAgICAgICAgKGgyID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMiA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDIgPj4gOCkgJiAweGZmLFxuICAgICAgICBoMiAmIDB4ZmYsXG4gICAgICAgIChoMyA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDMgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgzID4+IDgpICYgMHhmZixcbiAgICAgICAgaDMgJiAweGZmLFxuICAgICAgICAoaDQgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGg0ID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoNCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGg0ICYgMHhmZixcbiAgICBdO1xufTtcblNoYTEucHJvdG90eXBlLmFycmF5ID0gU2hhMS5wcm90b3R5cGUuZGlnZXN0O1xuU2hhMS5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMjApO1xuICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigwLCB0aGlzLmgwKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoNCwgdGhpcy5oMSk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDgsIHRoaXMuaDIpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxMiwgdGhpcy5oMyk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDE2LCB0aGlzLmg0KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufTtcbmxldCBoYXNMb2dnZWRXYXJuaW5nID0gZmFsc2U7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgbWFrZURlZmF1bHRLZXlFbmNvZGVyKClgIHRvIGNyZWF0ZSBhIGN1c3RvbSBrZXkgZW5jb2Rlci5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBpbnNlY3VyZUhhc2ggPSAobWVzc2FnZSkgPT4ge1xuICAgIGlmICghaGFzTG9nZ2VkV2FybmluZykge1xuICAgICAgICBjb25zb2xlLndhcm4oW1xuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgaGFzaGluZyBrZXlzIGlzIGluc2VjdXJlIGFuZCB3aWxsIGJlIHJlcGxhY2VkIGluIGEgZnV0dXJlIHZlcnNpb24sYCxcbiAgICAgICAgICAgIGBidXQgaGFzbid0IGJlZW4gcmVwbGFjZWQgeWV0IGFzIHRvIG5vdCBicmVhayBleGlzdGluZyBjYWNoZXMuIEl0J3MgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlYCxcbiAgICAgICAgICAgIGBhIG1vcmUgc2VjdXJlIGhhc2hpbmcgYWxnb3JpdGhtIHRvIGF2b2lkIGNhY2hlIHBvaXNvbmluZy5gLFxuICAgICAgICAgICAgYGAsXG4gICAgICAgICAgICBgU2VlIHRoaXMgcGFnZSBmb3IgbW9yZSBpbmZvcm1hdGlvbjpgLFxuICAgICAgICAgICAgYHxgLFxuICAgICAgICAgICAgYOKUlD4gaHR0cHM6Ly9qcy5sYW5nY2hhaW4uY29tL2RvY3MvdHJvdWJsZXNob290aW5nL3dhcm5pbmdzL2luc2VjdXJlLWNhY2hlLWFsZ29yaXRobWAsXG4gICAgICAgIF0uam9pbihcIlxcblwiKSk7XG4gICAgICAgIGhhc0xvZ2dlZFdhcm5pbmcgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNoYTEodHJ1ZSkudXBkYXRlKG1lc3NhZ2UpW1wiaGV4XCJdKCk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/js-sha256/hash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/js-sha256/hash.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n// @ts-nocheck\n// Inlined to deal with portability issues with importing crypto module\n/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.11.1\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2025\n * @license MIT\n */\n/*jslint bitwise: true */\n\nvar HEX_CHARS = \"0123456789abcdef\".split(\"\");\nvar EXTRA = [-2147483648, 8388608, 32768, 128];\nvar SHIFT = [24, 16, 8, 0];\nvar K = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n];\nvar OUTPUT_TYPES = [\"hex\", \"array\", \"digest\", \"arrayBuffer\"];\nvar blocks = [];\nfunction Sha256(is224, sharedMemory) {\n    if (sharedMemory) {\n        blocks[0] =\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        this.blocks = blocks;\n    }\n    else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n    if (is224) {\n        this.h0 = 0xc1059ed8;\n        this.h1 = 0x367cd507;\n        this.h2 = 0x3070dd17;\n        this.h3 = 0xf70e5939;\n        this.h4 = 0xffc00b31;\n        this.h5 = 0x68581511;\n        this.h6 = 0x64f98fa7;\n        this.h7 = 0xbefa4fa4;\n    }\n    else {\n        // 256\n        this.h0 = 0x6a09e667;\n        this.h1 = 0xbb67ae85;\n        this.h2 = 0x3c6ef372;\n        this.h3 = 0xa54ff53a;\n        this.h4 = 0x510e527f;\n        this.h5 = 0x9b05688c;\n        this.h6 = 0x1f83d9ab;\n        this.h7 = 0x5be0cd19;\n    }\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n    this.is224 = is224;\n}\nSha256.prototype.update = function (message) {\n    if (this.finalized) {\n        return;\n    }\n    var notString, type = typeof message;\n    if (type !== \"string\") {\n        if (type === \"object\") {\n            if (message === null) {\n                throw new Error(ERROR);\n            }\n            else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n                message = new Uint8Array(message);\n            }\n            else if (!Array.isArray(message)) {\n                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n                    throw new Error(ERROR);\n                }\n            }\n        }\n        else {\n            throw new Error(ERROR);\n        }\n        notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n    while (index < length) {\n        if (this.hashed) {\n            this.hashed = false;\n            blocks[0] = this.block;\n            this.block =\n                blocks[16] =\n                    blocks[1] =\n                        blocks[2] =\n                            blocks[3] =\n                                blocks[4] =\n                                    blocks[5] =\n                                        blocks[6] =\n                                            blocks[7] =\n                                                blocks[8] =\n                                                    blocks[9] =\n                                                        blocks[10] =\n                                                            blocks[11] =\n                                                                blocks[12] =\n                                                                    blocks[13] =\n                                                                        blocks[14] =\n                                                                            blocks[15] =\n                                                                                0;\n        }\n        if (notString) {\n            for (i = this.start; index < length && i < 64; ++index) {\n                blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];\n            }\n        }\n        else {\n            for (i = this.start; index < length && i < 64; ++index) {\n                code = message.charCodeAt(index);\n                if (code < 0x80) {\n                    blocks[i >>> 2] |= code << SHIFT[i++ & 3];\n                }\n                else if (code < 0x800) {\n                    blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else if (code < 0xd800 || code >= 0xe000) {\n                    blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else {\n                    code =\n                        0x10000 +\n                            (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n                    blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n            }\n        }\n        this.lastByteIndex = i;\n        this.bytes += i - this.start;\n        if (i >= 64) {\n            this.block = blocks[16];\n            this.start = i - 64;\n            this.hash();\n            this.hashed = true;\n        }\n        else {\n            this.start = i;\n        }\n    }\n    if (this.bytes > 4294967295) {\n        this.hBytes += (this.bytes / 4294967296) << 0;\n        this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n};\nSha256.prototype.finalize = function () {\n    if (this.finalized) {\n        return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >>> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n        if (!this.hashed) {\n            this.hash();\n        }\n        blocks[0] = this.block;\n        blocks[16] =\n            blocks[1] =\n                blocks[2] =\n                    blocks[3] =\n                        blocks[4] =\n                            blocks[5] =\n                                blocks[6] =\n                                    blocks[7] =\n                                        blocks[8] =\n                                            blocks[9] =\n                                                blocks[10] =\n                                                    blocks[11] =\n                                                        blocks[12] =\n                                                            blocks[13] =\n                                                                blocks[14] =\n                                                                    blocks[15] =\n                                                                        0;\n    }\n    blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n    blocks[15] = this.bytes << 3;\n    this.hash();\n};\nSha256.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;\n    for (j = 16; j < 64; ++j) {\n        // rightrotate\n        t1 = blocks[j - 15];\n        s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n        t1 = blocks[j - 2];\n        s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n        blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;\n    }\n    bc = b & c;\n    for (j = 0; j < 64; j += 4) {\n        if (this.first) {\n            if (this.is224) {\n                ab = 300032;\n                t1 = blocks[0] - 1413257819;\n                h = (t1 - 150054599) << 0;\n                d = (t1 + 24177077) << 0;\n            }\n            else {\n                ab = 704751109;\n                t1 = blocks[0] - 210244248;\n                h = (t1 - 1521486534) << 0;\n                d = (t1 + 143694565) << 0;\n            }\n            this.first = false;\n        }\n        else {\n            s0 =\n                ((a >>> 2) | (a << 30)) ^\n                    ((a >>> 13) | (a << 19)) ^\n                    ((a >>> 22) | (a << 10));\n            s1 =\n                ((e >>> 6) | (e << 26)) ^\n                    ((e >>> 11) | (e << 21)) ^\n                    ((e >>> 25) | (e << 7));\n            ab = a & b;\n            maj = ab ^ (a & c) ^ bc;\n            ch = (e & f) ^ (~e & g);\n            t1 = h + s1 + ch + K[j] + blocks[j];\n            t2 = s0 + maj;\n            h = (d + t1) << 0;\n            d = (t1 + t2) << 0;\n        }\n        s0 =\n            ((d >>> 2) | (d << 30)) ^\n                ((d >>> 13) | (d << 19)) ^\n                ((d >>> 22) | (d << 10));\n        s1 =\n            ((h >>> 6) | (h << 26)) ^\n                ((h >>> 11) | (h << 21)) ^\n                ((h >>> 25) | (h << 7));\n        da = d & a;\n        maj = da ^ (d & b) ^ ab;\n        ch = (g & h) ^ (~g & e);\n        t1 = f + s1 + ch + K[j + 1] + blocks[j + 1];\n        t2 = s0 + maj;\n        g = (c + t1) << 0;\n        c = (t1 + t2) << 0;\n        s0 =\n            ((c >>> 2) | (c << 30)) ^\n                ((c >>> 13) | (c << 19)) ^\n                ((c >>> 22) | (c << 10));\n        s1 =\n            ((g >>> 6) | (g << 26)) ^\n                ((g >>> 11) | (g << 21)) ^\n                ((g >>> 25) | (g << 7));\n        cd = c & d;\n        maj = cd ^ (c & a) ^ da;\n        ch = (f & g) ^ (~f & h);\n        t1 = e + s1 + ch + K[j + 2] + blocks[j + 2];\n        t2 = s0 + maj;\n        f = (b + t1) << 0;\n        b = (t1 + t2) << 0;\n        s0 =\n            ((b >>> 2) | (b << 30)) ^\n                ((b >>> 13) | (b << 19)) ^\n                ((b >>> 22) | (b << 10));\n        s1 =\n            ((f >>> 6) | (f << 26)) ^\n                ((f >>> 11) | (f << 21)) ^\n                ((f >>> 25) | (f << 7));\n        bc = b & c;\n        maj = bc ^ (b & d) ^ cd;\n        ch = (f & g) ^ (~f & h);\n        t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n        t2 = s0 + maj;\n        e = (a + t1) << 0;\n        a = (t1 + t2) << 0;\n        this.chromeBugWorkAround = true;\n    }\n    this.h0 = (this.h0 + a) << 0;\n    this.h1 = (this.h1 + b) << 0;\n    this.h2 = (this.h2 + c) << 0;\n    this.h3 = (this.h3 + d) << 0;\n    this.h4 = (this.h4 + e) << 0;\n    this.h5 = (this.h5 + f) << 0;\n    this.h6 = (this.h6 + g) << 0;\n    this.h7 = (this.h7 + h) << 0;\n};\nSha256.prototype.hex = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;\n    var hex = HEX_CHARS[(h0 >>> 28) & 0x0f] +\n        HEX_CHARS[(h0 >>> 24) & 0x0f] +\n        HEX_CHARS[(h0 >>> 20) & 0x0f] +\n        HEX_CHARS[(h0 >>> 16) & 0x0f] +\n        HEX_CHARS[(h0 >>> 12) & 0x0f] +\n        HEX_CHARS[(h0 >>> 8) & 0x0f] +\n        HEX_CHARS[(h0 >>> 4) & 0x0f] +\n        HEX_CHARS[h0 & 0x0f] +\n        HEX_CHARS[(h1 >>> 28) & 0x0f] +\n        HEX_CHARS[(h1 >>> 24) & 0x0f] +\n        HEX_CHARS[(h1 >>> 20) & 0x0f] +\n        HEX_CHARS[(h1 >>> 16) & 0x0f] +\n        HEX_CHARS[(h1 >>> 12) & 0x0f] +\n        HEX_CHARS[(h1 >>> 8) & 0x0f] +\n        HEX_CHARS[(h1 >>> 4) & 0x0f] +\n        HEX_CHARS[h1 & 0x0f] +\n        HEX_CHARS[(h2 >>> 28) & 0x0f] +\n        HEX_CHARS[(h2 >>> 24) & 0x0f] +\n        HEX_CHARS[(h2 >>> 20) & 0x0f] +\n        HEX_CHARS[(h2 >>> 16) & 0x0f] +\n        HEX_CHARS[(h2 >>> 12) & 0x0f] +\n        HEX_CHARS[(h2 >>> 8) & 0x0f] +\n        HEX_CHARS[(h2 >>> 4) & 0x0f] +\n        HEX_CHARS[h2 & 0x0f] +\n        HEX_CHARS[(h3 >>> 28) & 0x0f] +\n        HEX_CHARS[(h3 >>> 24) & 0x0f] +\n        HEX_CHARS[(h3 >>> 20) & 0x0f] +\n        HEX_CHARS[(h3 >>> 16) & 0x0f] +\n        HEX_CHARS[(h3 >>> 12) & 0x0f] +\n        HEX_CHARS[(h3 >>> 8) & 0x0f] +\n        HEX_CHARS[(h3 >>> 4) & 0x0f] +\n        HEX_CHARS[h3 & 0x0f] +\n        HEX_CHARS[(h4 >>> 28) & 0x0f] +\n        HEX_CHARS[(h4 >>> 24) & 0x0f] +\n        HEX_CHARS[(h4 >>> 20) & 0x0f] +\n        HEX_CHARS[(h4 >>> 16) & 0x0f] +\n        HEX_CHARS[(h4 >>> 12) & 0x0f] +\n        HEX_CHARS[(h4 >>> 8) & 0x0f] +\n        HEX_CHARS[(h4 >>> 4) & 0x0f] +\n        HEX_CHARS[h4 & 0x0f] +\n        HEX_CHARS[(h5 >>> 28) & 0x0f] +\n        HEX_CHARS[(h5 >>> 24) & 0x0f] +\n        HEX_CHARS[(h5 >>> 20) & 0x0f] +\n        HEX_CHARS[(h5 >>> 16) & 0x0f] +\n        HEX_CHARS[(h5 >>> 12) & 0x0f] +\n        HEX_CHARS[(h5 >>> 8) & 0x0f] +\n        HEX_CHARS[(h5 >>> 4) & 0x0f] +\n        HEX_CHARS[h5 & 0x0f] +\n        HEX_CHARS[(h6 >>> 28) & 0x0f] +\n        HEX_CHARS[(h6 >>> 24) & 0x0f] +\n        HEX_CHARS[(h6 >>> 20) & 0x0f] +\n        HEX_CHARS[(h6 >>> 16) & 0x0f] +\n        HEX_CHARS[(h6 >>> 12) & 0x0f] +\n        HEX_CHARS[(h6 >>> 8) & 0x0f] +\n        HEX_CHARS[(h6 >>> 4) & 0x0f] +\n        HEX_CHARS[h6 & 0x0f];\n    if (!this.is224) {\n        hex +=\n            HEX_CHARS[(h7 >>> 28) & 0x0f] +\n                HEX_CHARS[(h7 >>> 24) & 0x0f] +\n                HEX_CHARS[(h7 >>> 20) & 0x0f] +\n                HEX_CHARS[(h7 >>> 16) & 0x0f] +\n                HEX_CHARS[(h7 >>> 12) & 0x0f] +\n                HEX_CHARS[(h7 >>> 8) & 0x0f] +\n                HEX_CHARS[(h7 >>> 4) & 0x0f] +\n                HEX_CHARS[h7 & 0x0f];\n    }\n    return hex;\n};\nSha256.prototype.toString = Sha256.prototype.hex;\nSha256.prototype.digest = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;\n    var arr = [\n        (h0 >>> 24) & 0xff,\n        (h0 >>> 16) & 0xff,\n        (h0 >>> 8) & 0xff,\n        h0 & 0xff,\n        (h1 >>> 24) & 0xff,\n        (h1 >>> 16) & 0xff,\n        (h1 >>> 8) & 0xff,\n        h1 & 0xff,\n        (h2 >>> 24) & 0xff,\n        (h2 >>> 16) & 0xff,\n        (h2 >>> 8) & 0xff,\n        h2 & 0xff,\n        (h3 >>> 24) & 0xff,\n        (h3 >>> 16) & 0xff,\n        (h3 >>> 8) & 0xff,\n        h3 & 0xff,\n        (h4 >>> 24) & 0xff,\n        (h4 >>> 16) & 0xff,\n        (h4 >>> 8) & 0xff,\n        h4 & 0xff,\n        (h5 >>> 24) & 0xff,\n        (h5 >>> 16) & 0xff,\n        (h5 >>> 8) & 0xff,\n        h5 & 0xff,\n        (h6 >>> 24) & 0xff,\n        (h6 >>> 16) & 0xff,\n        (h6 >>> 8) & 0xff,\n        h6 & 0xff,\n    ];\n    if (!this.is224) {\n        arr.push((h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, h7 & 0xff);\n    }\n    return arr;\n};\nSha256.prototype.array = Sha256.prototype.digest;\nSha256.prototype.arrayBuffer = function () {\n    this.finalize();\n    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    dataView.setUint32(20, this.h5);\n    dataView.setUint32(24, this.h6);\n    if (!this.is224) {\n        dataView.setUint32(28, this.h7);\n    }\n    return buffer;\n};\nconst sha256 = (...strings) => {\n    return new Sha256(false, true).update(strings.join(\"\")).hex();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanMtc2hhMjU2L2hhc2guanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcanMtc2hhMjU2XFxoYXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG4vLyBJbmxpbmVkIHRvIGRlYWwgd2l0aCBwb3J0YWJpbGl0eSBpc3N1ZXMgd2l0aCBpbXBvcnRpbmcgY3J5cHRvIG1vZHVsZVxuLyoqXG4gKiBbanMtc2hhMjU2XXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTI1Nn1cbiAqXG4gKiBAdmVyc2lvbiAwLjExLjFcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXG4gKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTQtMjAyNVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblwidXNlIHN0cmljdFwiO1xudmFyIEhFWF9DSEFSUyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiLnNwbGl0KFwiXCIpO1xudmFyIEVYVFJBID0gWy0yMTQ3NDgzNjQ4LCA4Mzg4NjA4LCAzMjc2OCwgMTI4XTtcbnZhciBTSElGVCA9IFsyNCwgMTYsIDgsIDBdO1xudmFyIEsgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSxcbiAgICAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LCAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuICAgIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsXG4gICAgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LFxuICAgIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gICAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSwgMHhhMmJmZThhMSwgMHhhODFhNjY0YixcbiAgICAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsXG4gICAgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMywgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcbiAgICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyLFxuXTtcbnZhciBPVVRQVVRfVFlQRVMgPSBbXCJoZXhcIiwgXCJhcnJheVwiLCBcImRpZ2VzdFwiLCBcImFycmF5QnVmZmVyXCJdO1xudmFyIGJsb2NrcyA9IFtdO1xuZnVuY3Rpb24gU2hhMjU2KGlzMjI0LCBzaGFyZWRNZW1vcnkpIHtcbiAgICBpZiAoc2hhcmVkTWVtb3J5KSB7XG4gICAgICAgIGJsb2Nrc1swXSA9XG4gICAgICAgICAgICBibG9ja3NbMTZdID1cbiAgICAgICAgICAgICAgICBibG9ja3NbMV0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzZdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbN10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzExXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIH1cbiAgICBpZiAoaXMyMjQpIHtcbiAgICAgICAgdGhpcy5oMCA9IDB4YzEwNTllZDg7XG4gICAgICAgIHRoaXMuaDEgPSAweDM2N2NkNTA3O1xuICAgICAgICB0aGlzLmgyID0gMHgzMDcwZGQxNztcbiAgICAgICAgdGhpcy5oMyA9IDB4ZjcwZTU5Mzk7XG4gICAgICAgIHRoaXMuaDQgPSAweGZmYzAwYjMxO1xuICAgICAgICB0aGlzLmg1ID0gMHg2ODU4MTUxMTtcbiAgICAgICAgdGhpcy5oNiA9IDB4NjRmOThmYTc7XG4gICAgICAgIHRoaXMuaDcgPSAweGJlZmE0ZmE0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gMjU2XG4gICAgICAgIHRoaXMuaDAgPSAweDZhMDllNjY3O1xuICAgICAgICB0aGlzLmgxID0gMHhiYjY3YWU4NTtcbiAgICAgICAgdGhpcy5oMiA9IDB4M2M2ZWYzNzI7XG4gICAgICAgIHRoaXMuaDMgPSAweGE1NGZmNTNhO1xuICAgICAgICB0aGlzLmg0ID0gMHg1MTBlNTI3ZjtcbiAgICAgICAgdGhpcy5oNSA9IDB4OWIwNTY4OGM7XG4gICAgICAgIHRoaXMuaDYgPSAweDFmODNkOWFiO1xuICAgICAgICB0aGlzLmg3ID0gMHg1YmUwY2QxOTtcbiAgICB9XG4gICAgdGhpcy5ibG9jayA9IHRoaXMuc3RhcnQgPSB0aGlzLmJ5dGVzID0gdGhpcy5oQnl0ZXMgPSAwO1xuICAgIHRoaXMuZmluYWxpemVkID0gdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmlzMjI0ID0gaXMyMjQ7XG59XG5TaGEyNTYucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vdFN0cmluZywgdHlwZSA9IHR5cGVvZiBtZXNzYWdlO1xuICAgIGlmICh0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIG5vdFN0cmluZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBjb2RlLCBpbmRleCA9IDAsIGksIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoLCBibG9ja3MgPSB0aGlzLmJsb2NrcztcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPVxuICAgICAgICAgICAgICAgIGJsb2Nrc1sxNl0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbN10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgMHgxMDAwMCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+Pj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcbiAgICAgICAgdGhpcy5ieXRlcyArPSBpIC0gdGhpcy5zdGFydDtcbiAgICAgICAgaWYgKGkgPj0gNjQpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGkgLSA2NDtcbiAgICAgICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgICAgICAgdGhpcy5oYXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuYnl0ZXMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgIHRoaXMuaEJ5dGVzICs9ICh0aGlzLmJ5dGVzIC8gNDI5NDk2NzI5NikgPDwgMDtcbiAgICAgICAgdGhpcy5ieXRlcyA9IHRoaXMuYnl0ZXMgJSA0Mjk0OTY3Mjk2O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5TaGEyNTYucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXg7XG4gICAgYmxvY2tzWzE2XSA9IHRoaXMuYmxvY2s7XG4gICAgYmxvY2tzW2kgPj4+IDJdIHw9IEVYVFJBW2kgJiAzXTtcbiAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICBpZiAoaSA+PSA1Nikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2goKTtcbiAgICAgICAgfVxuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBibG9ja3NbMTZdID1cbiAgICAgICAgICAgIGJsb2Nrc1sxXSA9XG4gICAgICAgICAgICAgICAgYmxvY2tzWzJdID1cbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzZdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s3XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgfVxuICAgIGJsb2Nrc1sxNF0gPSAodGhpcy5oQnl0ZXMgPDwgMykgfCAodGhpcy5ieXRlcyA+Pj4gMjkpO1xuICAgIGJsb2Nrc1sxNV0gPSB0aGlzLmJ5dGVzIDw8IDM7XG4gICAgdGhpcy5oYXNoKCk7XG59O1xuU2hhMjU2LnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gdGhpcy5oMCwgYiA9IHRoaXMuaDEsIGMgPSB0aGlzLmgyLCBkID0gdGhpcy5oMywgZSA9IHRoaXMuaDQsIGYgPSB0aGlzLmg1LCBnID0gdGhpcy5oNiwgaCA9IHRoaXMuaDcsIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBqLCBzMCwgczEsIG1haiwgdDEsIHQyLCBjaCwgYWIsIGRhLCBjZCwgYmM7XG4gICAgZm9yIChqID0gMTY7IGogPCA2NDsgKytqKSB7XG4gICAgICAgIC8vIHJpZ2h0cm90YXRlXG4gICAgICAgIHQxID0gYmxvY2tzW2ogLSAxNV07XG4gICAgICAgIHMwID0gKCh0MSA+Pj4gNykgfCAodDEgPDwgMjUpKSBeICgodDEgPj4+IDE4KSB8ICh0MSA8PCAxNCkpIF4gKHQxID4+PiAzKTtcbiAgICAgICAgdDEgPSBibG9ja3NbaiAtIDJdO1xuICAgICAgICBzMSA9ICgodDEgPj4+IDE3KSB8ICh0MSA8PCAxNSkpIF4gKCh0MSA+Pj4gMTkpIHwgKHQxIDw8IDEzKSkgXiAodDEgPj4+IDEwKTtcbiAgICAgICAgYmxvY2tzW2pdID0gKGJsb2Nrc1tqIC0gMTZdICsgczAgKyBibG9ja3NbaiAtIDddICsgczEpIDw8IDA7XG4gICAgfVxuICAgIGJjID0gYiAmIGM7XG4gICAgZm9yIChqID0gMDsgaiA8IDY0OyBqICs9IDQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMjI0KSB7XG4gICAgICAgICAgICAgICAgYWIgPSAzMDAwMzI7XG4gICAgICAgICAgICAgICAgdDEgPSBibG9ja3NbMF0gLSAxNDEzMjU3ODE5O1xuICAgICAgICAgICAgICAgIGggPSAodDEgLSAxNTAwNTQ1OTkpIDw8IDA7XG4gICAgICAgICAgICAgICAgZCA9ICh0MSArIDI0MTc3MDc3KSA8PCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWIgPSA3MDQ3NTExMDk7XG4gICAgICAgICAgICAgICAgdDEgPSBibG9ja3NbMF0gLSAyMTAyNDQyNDg7XG4gICAgICAgICAgICAgICAgaCA9ICh0MSAtIDE1MjE0ODY1MzQpIDw8IDA7XG4gICAgICAgICAgICAgICAgZCA9ICh0MSArIDE0MzY5NDU2NSkgPDwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHMwID1cbiAgICAgICAgICAgICAgICAoKGEgPj4+IDIpIHwgKGEgPDwgMzApKSBeXG4gICAgICAgICAgICAgICAgICAgICgoYSA+Pj4gMTMpIHwgKGEgPDwgMTkpKSBeXG4gICAgICAgICAgICAgICAgICAgICgoYSA+Pj4gMjIpIHwgKGEgPDwgMTApKTtcbiAgICAgICAgICAgIHMxID1cbiAgICAgICAgICAgICAgICAoKGUgPj4+IDYpIHwgKGUgPDwgMjYpKSBeXG4gICAgICAgICAgICAgICAgICAgICgoZSA+Pj4gMTEpIHwgKGUgPDwgMjEpKSBeXG4gICAgICAgICAgICAgICAgICAgICgoZSA+Pj4gMjUpIHwgKGUgPDwgNykpO1xuICAgICAgICAgICAgYWIgPSBhICYgYjtcbiAgICAgICAgICAgIG1haiA9IGFiIF4gKGEgJiBjKSBeIGJjO1xuICAgICAgICAgICAgY2ggPSAoZSAmIGYpIF4gKH5lICYgZyk7XG4gICAgICAgICAgICB0MSA9IGggKyBzMSArIGNoICsgS1tqXSArIGJsb2Nrc1tqXTtcbiAgICAgICAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICAgICAgICBoID0gKGQgKyB0MSkgPDwgMDtcbiAgICAgICAgICAgIGQgPSAodDEgKyB0MikgPDwgMDtcbiAgICAgICAgfVxuICAgICAgICBzMCA9XG4gICAgICAgICAgICAoKGQgPj4+IDIpIHwgKGQgPDwgMzApKSBeXG4gICAgICAgICAgICAgICAgKChkID4+PiAxMykgfCAoZCA8PCAxOSkpIF5cbiAgICAgICAgICAgICAgICAoKGQgPj4+IDIyKSB8IChkIDw8IDEwKSk7XG4gICAgICAgIHMxID1cbiAgICAgICAgICAgICgoaCA+Pj4gNikgfCAoaCA8PCAyNikpIF5cbiAgICAgICAgICAgICAgICAoKGggPj4+IDExKSB8IChoIDw8IDIxKSkgXlxuICAgICAgICAgICAgICAgICgoaCA+Pj4gMjUpIHwgKGggPDwgNykpO1xuICAgICAgICBkYSA9IGQgJiBhO1xuICAgICAgICBtYWogPSBkYSBeIChkICYgYikgXiBhYjtcbiAgICAgICAgY2ggPSAoZyAmIGgpIF4gKH5nICYgZSk7XG4gICAgICAgIHQxID0gZiArIHMxICsgY2ggKyBLW2ogKyAxXSArIGJsb2Nrc1tqICsgMV07XG4gICAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICAgIGcgPSAoYyArIHQxKSA8PCAwO1xuICAgICAgICBjID0gKHQxICsgdDIpIDw8IDA7XG4gICAgICAgIHMwID1cbiAgICAgICAgICAgICgoYyA+Pj4gMikgfCAoYyA8PCAzMCkpIF5cbiAgICAgICAgICAgICAgICAoKGMgPj4+IDEzKSB8IChjIDw8IDE5KSkgXlxuICAgICAgICAgICAgICAgICgoYyA+Pj4gMjIpIHwgKGMgPDwgMTApKTtcbiAgICAgICAgczEgPVxuICAgICAgICAgICAgKChnID4+PiA2KSB8IChnIDw8IDI2KSkgXlxuICAgICAgICAgICAgICAgICgoZyA+Pj4gMTEpIHwgKGcgPDwgMjEpKSBeXG4gICAgICAgICAgICAgICAgKChnID4+PiAyNSkgfCAoZyA8PCA3KSk7XG4gICAgICAgIGNkID0gYyAmIGQ7XG4gICAgICAgIG1haiA9IGNkIF4gKGMgJiBhKSBeIGRhO1xuICAgICAgICBjaCA9IChmICYgZykgXiAofmYgJiBoKTtcbiAgICAgICAgdDEgPSBlICsgczEgKyBjaCArIEtbaiArIDJdICsgYmxvY2tzW2ogKyAyXTtcbiAgICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgICAgZiA9IChiICsgdDEpIDw8IDA7XG4gICAgICAgIGIgPSAodDEgKyB0MikgPDwgMDtcbiAgICAgICAgczAgPVxuICAgICAgICAgICAgKChiID4+PiAyKSB8IChiIDw8IDMwKSkgXlxuICAgICAgICAgICAgICAgICgoYiA+Pj4gMTMpIHwgKGIgPDwgMTkpKSBeXG4gICAgICAgICAgICAgICAgKChiID4+PiAyMikgfCAoYiA8PCAxMCkpO1xuICAgICAgICBzMSA9XG4gICAgICAgICAgICAoKGYgPj4+IDYpIHwgKGYgPDwgMjYpKSBeXG4gICAgICAgICAgICAgICAgKChmID4+PiAxMSkgfCAoZiA8PCAyMSkpIF5cbiAgICAgICAgICAgICAgICAoKGYgPj4+IDI1KSB8IChmIDw8IDcpKTtcbiAgICAgICAgYmMgPSBiICYgYztcbiAgICAgICAgbWFqID0gYmMgXiAoYiAmIGQpIF4gY2Q7XG4gICAgICAgIGNoID0gKGYgJiBnKSBeICh+ZiAmIGgpO1xuICAgICAgICB0MSA9IGUgKyBzMSArIGNoICsgS1tqICsgM10gKyBibG9ja3NbaiArIDNdO1xuICAgICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgICBlID0gKGEgKyB0MSkgPDwgMDtcbiAgICAgICAgYSA9ICh0MSArIHQyKSA8PCAwO1xuICAgICAgICB0aGlzLmNocm9tZUJ1Z1dvcmtBcm91bmQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmgwID0gKHRoaXMuaDAgKyBhKSA8PCAwO1xuICAgIHRoaXMuaDEgPSAodGhpcy5oMSArIGIpIDw8IDA7XG4gICAgdGhpcy5oMiA9ICh0aGlzLmgyICsgYykgPDwgMDtcbiAgICB0aGlzLmgzID0gKHRoaXMuaDMgKyBkKSA8PCAwO1xuICAgIHRoaXMuaDQgPSAodGhpcy5oNCArIGUpIDw8IDA7XG4gICAgdGhpcy5oNSA9ICh0aGlzLmg1ICsgZikgPDwgMDtcbiAgICB0aGlzLmg2ID0gKHRoaXMuaDYgKyBnKSA8PCAwO1xuICAgIHRoaXMuaDcgPSAodGhpcy5oNyArIGgpIDw8IDA7XG59O1xuU2hhMjU2LnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNCwgaDUgPSB0aGlzLmg1LCBoNiA9IHRoaXMuaDYsIGg3ID0gdGhpcy5oNztcbiAgICB2YXIgaGV4ID0gSEVYX0NIQVJTWyhoMCA+Pj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+Pj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gwICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+Pj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+Pj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDEgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+Pj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+Pj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+Pj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMiAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+Pj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+Pj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gzICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+Pj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+Pj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDQgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDUgPj4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNSA+Pj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1ID4+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDUgPj4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNSA+Pj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1ID4+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNSA+Pj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toNSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNiA+Pj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg2ID4+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDYgPj4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNiA+Pj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg2ID4+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDYgPj4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg2ID4+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2g2ICYgMHgwZl07XG4gICAgaWYgKCF0aGlzLmlzMjI0KSB7XG4gICAgICAgIGhleCArPVxuICAgICAgICAgICAgSEVYX0NIQVJTWyhoNyA+Pj4gMjgpICYgMHgwZl0gK1xuICAgICAgICAgICAgICAgIEhFWF9DSEFSU1soaDcgPj4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+PiAyMCkgJiAweDBmXSArXG4gICAgICAgICAgICAgICAgSEVYX0NIQVJTWyhoNyA+Pj4gMTYpICYgMHgwZl0gK1xuICAgICAgICAgICAgICAgIEhFWF9DSEFSU1soaDcgPj4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgICAgICAgICBIRVhfQ0hBUlNbaDcgJiAweDBmXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn07XG5TaGEyNTYucHJvdG90eXBlLnRvU3RyaW5nID0gU2hhMjU2LnByb3RvdHlwZS5oZXg7XG5TaGEyNTYucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0LCBoNSA9IHRoaXMuaDUsIGg2ID0gdGhpcy5oNiwgaDcgPSB0aGlzLmg3O1xuICAgIHZhciBhcnIgPSBbXG4gICAgICAgIChoMCA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgwID4+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDAgPj4+IDgpICYgMHhmZixcbiAgICAgICAgaDAgJiAweGZmLFxuICAgICAgICAoaDEgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMSA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgxID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgxICYgMHhmZixcbiAgICAgICAgKGgyID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDIgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMiA+Pj4gOCkgJiAweGZmLFxuICAgICAgICBoMiAmIDB4ZmYsXG4gICAgICAgIChoMyA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgzID4+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDMgPj4+IDgpICYgMHhmZixcbiAgICAgICAgaDMgJiAweGZmLFxuICAgICAgICAoaDQgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoNCA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgKGg0ID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGg0ICYgMHhmZixcbiAgICAgICAgKGg1ID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDUgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoNSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICBoNSAmIDB4ZmYsXG4gICAgICAgIChoNiA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgKGg2ID4+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDYgPj4+IDgpICYgMHhmZixcbiAgICAgICAgaDYgJiAweGZmLFxuICAgIF07XG4gICAgaWYgKCF0aGlzLmlzMjI0KSB7XG4gICAgICAgIGFyci5wdXNoKChoNyA+Pj4gMjQpICYgMHhmZiwgKGg3ID4+PiAxNikgJiAweGZmLCAoaDcgPj4+IDgpICYgMHhmZiwgaDcgJiAweGZmKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn07XG5TaGEyNTYucHJvdG90eXBlLmFycmF5ID0gU2hhMjU2LnByb3RvdHlwZS5kaWdlc3Q7XG5TaGEyNTYucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuaXMyMjQgPyAyOCA6IDMyKTtcbiAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMCwgdGhpcy5oMCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDQsIHRoaXMuaDEpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig4LCB0aGlzLmgyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTIsIHRoaXMuaDMpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxNiwgdGhpcy5oNCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDIwLCB0aGlzLmg1KTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMjQsIHRoaXMuaDYpO1xuICAgIGlmICghdGhpcy5pczIyNCkge1xuICAgICAgICBkYXRhVmlldy5zZXRVaW50MzIoMjgsIHRoaXMuaDcpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufTtcbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAoLi4uc3RyaW5ncykgPT4ge1xuICAgIHJldHVybiBuZXcgU2hhMjU2KGZhbHNlLCB0cnVlKS51cGRhdGUoc3RyaW5ncy5qb2luKFwiXCIpKS5oZXgoKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/js-sha256/hash.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseJsonMarkdown: () => (/* binding */ parseJsonMarkdown),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson)\n/* harmony export */ });\nfunction parseJsonMarkdown(s, parser = parsePartialJson) {\n    // eslint-disable-next-line no-param-reassign\n    s = s.trim();\n    const firstFenceIndex = s.indexOf(\"```\");\n    if (firstFenceIndex === -1) {\n        return parser(s);\n    }\n    let contentAfterFence = s.substring(firstFenceIndex + 3);\n    if (contentAfterFence.startsWith(\"json\\n\")) {\n        contentAfterFence = contentAfterFence.substring(5);\n    }\n    else if (contentAfterFence.startsWith(\"json\")) {\n        contentAfterFence = contentAfterFence.substring(4);\n    }\n    else if (contentAfterFence.startsWith(\"\\n\")) {\n        contentAfterFence = contentAfterFence.substring(1);\n    }\n    const closingFenceIndex = contentAfterFence.indexOf(\"```\");\n    let finalContent = contentAfterFence;\n    if (closingFenceIndex !== -1) {\n        finalContent = contentAfterFence.substring(0, closingFenceIndex);\n    }\n    return parser(finalContent.trim());\n}\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nfunction parsePartialJson(s) {\n    // If the input is undefined, return null to indicate failure.\n    if (typeof s === \"undefined\") {\n        return null;\n    }\n    // Attempt to parse the string as-is.\n    try {\n        return JSON.parse(s);\n    }\n    catch (error) {\n        // Pass\n    }\n    // Initialize variables.\n    let new_s = \"\";\n    const stack = [];\n    let isInsideString = false;\n    let escaped = false;\n    // Process each character in the string one at a time.\n    for (let char of s) {\n        if (isInsideString) {\n            if (char === '\"' && !escaped) {\n                isInsideString = false;\n            }\n            else if (char === \"\\n\" && !escaped) {\n                char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n            }\n            else if (char === \"\\\\\") {\n                escaped = !escaped;\n            }\n            else {\n                escaped = false;\n            }\n        }\n        else {\n            if (char === '\"') {\n                isInsideString = true;\n                escaped = false;\n            }\n            else if (char === \"{\") {\n                stack.push(\"}\");\n            }\n            else if (char === \"[\") {\n                stack.push(\"]\");\n            }\n            else if (char === \"}\" || char === \"]\") {\n                if (stack && stack[stack.length - 1] === char) {\n                    stack.pop();\n                }\n                else {\n                    // Mismatched closing character; the input is malformed.\n                    return null;\n                }\n            }\n        }\n        // Append the processed character to the new string.\n        new_s += char;\n    }\n    // If we're still inside a string at the end of processing,\n    // we need to close the string.\n    if (isInsideString) {\n        new_s += '\"';\n    }\n    // Close any remaining open structures in the reverse order that they were opened.\n    for (let i = stack.length - 1; i >= 0; i -= 1) {\n        new_s += stack[i];\n    }\n    // Attempt to parse the modified string as JSON.\n    try {\n        return JSON.parse(new_s);\n    }\n    catch (error) {\n        // If we still can't parse the string as JSON, return null to indicate failure.\n        return null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcGFyc2VKc29uTWFya2Rvd24ocywgcGFyc2VyID0gcGFyc2VQYXJ0aWFsSnNvbikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHMgPSBzLnRyaW0oKTtcbiAgICBjb25zdCBmaXJzdEZlbmNlSW5kZXggPSBzLmluZGV4T2YoXCJgYGBcIik7XG4gICAgaWYgKGZpcnN0RmVuY2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlcihzKTtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnRBZnRlckZlbmNlID0gcy5zdWJzdHJpbmcoZmlyc3RGZW5jZUluZGV4ICsgMyk7XG4gICAgaWYgKGNvbnRlbnRBZnRlckZlbmNlLnN0YXJ0c1dpdGgoXCJqc29uXFxuXCIpKSB7XG4gICAgICAgIGNvbnRlbnRBZnRlckZlbmNlID0gY29udGVudEFmdGVyRmVuY2Uuc3Vic3RyaW5nKDUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZW50QWZ0ZXJGZW5jZS5zdGFydHNXaXRoKFwianNvblwiKSkge1xuICAgICAgICBjb250ZW50QWZ0ZXJGZW5jZSA9IGNvbnRlbnRBZnRlckZlbmNlLnN1YnN0cmluZyg0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGVudEFmdGVyRmVuY2Uuc3RhcnRzV2l0aChcIlxcblwiKSkge1xuICAgICAgICBjb250ZW50QWZ0ZXJGZW5jZSA9IGNvbnRlbnRBZnRlckZlbmNlLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgY29uc3QgY2xvc2luZ0ZlbmNlSW5kZXggPSBjb250ZW50QWZ0ZXJGZW5jZS5pbmRleE9mKFwiYGBgXCIpO1xuICAgIGxldCBmaW5hbENvbnRlbnQgPSBjb250ZW50QWZ0ZXJGZW5jZTtcbiAgICBpZiAoY2xvc2luZ0ZlbmNlSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGZpbmFsQ29udGVudCA9IGNvbnRlbnRBZnRlckZlbmNlLnN1YnN0cmluZygwLCBjbG9zaW5nRmVuY2VJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIoZmluYWxDb250ZW50LnRyaW0oKSk7XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0tpbGxpYW5MdWNhcy9vcGVuLWludGVycHJldGVyL2Jsb2IvbWFpbi9pbnRlcnByZXRlci9jb3JlL2xsbS91dGlscy9wYXJzZV9wYXJ0aWFsX2pzb24ucHlcbi8vIE1JVCBMaWNlbnNlXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihzKSB7XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIHVuZGVmaW5lZCwgcmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgZmFpbHVyZS5cbiAgICBpZiAodHlwZW9mIHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIHN0cmluZyBhcy1pcy5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFBhc3NcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMuXG4gICAgbGV0IG5ld19zID0gXCJcIjtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGxldCBpc0luc2lkZVN0cmluZyA9IGZhbHNlO1xuICAgIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gICAgLy8gUHJvY2VzcyBlYWNoIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIG9uZSBhdCBhIHRpbWUuXG4gICAgZm9yIChsZXQgY2hhciBvZiBzKSB7XG4gICAgICAgIGlmIChpc0luc2lkZVN0cmluZykge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcIicgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICBpc0luc2lkZVN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJcXG5cIiAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgIGNoYXIgPSBcIlxcXFxuXCI7IC8vIFJlcGxhY2UgdGhlIG5ld2xpbmUgY2hhcmFjdGVyIHdpdGggdGhlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBpc0luc2lkZVN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChcIl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIn1cIiB8fCBjaGFyID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGlmIChzdGFjayAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1pc21hdGNoZWQgY2xvc2luZyBjaGFyYWN0ZXI7IHRoZSBpbnB1dCBpcyBtYWxmb3JtZWQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgdGhlIHByb2Nlc3NlZCBjaGFyYWN0ZXIgdG8gdGhlIG5ldyBzdHJpbmcuXG4gICAgICAgIG5ld19zICs9IGNoYXI7XG4gICAgfVxuICAgIC8vIElmIHdlJ3JlIHN0aWxsIGluc2lkZSBhIHN0cmluZyBhdCB0aGUgZW5kIG9mIHByb2Nlc3NpbmcsXG4gICAgLy8gd2UgbmVlZCB0byBjbG9zZSB0aGUgc3RyaW5nLlxuICAgIGlmIChpc0luc2lkZVN0cmluZykge1xuICAgICAgICBuZXdfcyArPSAnXCInO1xuICAgIH1cbiAgICAvLyBDbG9zZSBhbnkgcmVtYWluaW5nIG9wZW4gc3RydWN0dXJlcyBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0aGF0IHRoZXkgd2VyZSBvcGVuZWQuXG4gICAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIG5ld19zICs9IHN0YWNrW2ldO1xuICAgIH1cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBtb2RpZmllZCBzdHJpbmcgYXMgSlNPTi5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShuZXdfcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiB3ZSBzdGlsbCBjYW4ndCBwYXJzZSB0aGUgc3RyaW5nIGFzIEpTT04sIHJldHVybiBudWxsIHRvIGluZGljYXRlIGZhaWx1cmUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json_patch.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPatch: () => (/* reexport safe */ _fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch),\n/* harmony export */   compare: () => (/* reexport safe */ _fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.compare)\n/* harmony export */ });\n/* harmony import */ var _fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fast-json-patch/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbl9wYXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0UiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXGpzb25fcGF0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgY29tcGFyZSwgYXBwbHlQYXRjaCwgfSBmcm9tIFwiLi9mYXN0LWpzb24tcGF0Y2gvaW5kZXguanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json_schema.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Validator: () => (/* reexport safe */ _cfworker_json_schema__WEBPACK_IMPORTED_MODULE_1__.Validator),\n/* harmony export */   deepCompareStrict: () => (/* reexport safe */ _cfworker_json_schema__WEBPACK_IMPORTED_MODULE_1__.deepCompareStrict),\n/* harmony export */   toJsonSchema: () => (/* binding */ toJsonSchema),\n/* harmony export */   validatesOnlyStrings: () => (/* binding */ validatesOnlyStrings)\n/* harmony export */ });\n/* harmony import */ var zod_v4_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v4/core */ \"(rsc)/./node_modules/zod/v4/core/to-json-schema.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var _cfworker_json_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/esm/index.js\");\n/* harmony import */ var _types_zod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types/zod.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.js\");\n\n\n\n\n\n/**\n * Converts a Zod schema or JSON schema to a JSON schema.\n * @param schema - The schema to convert.\n * @returns The converted schema.\n */\nfunction toJsonSchema(schema) {\n    if ((0,_types_zod_js__WEBPACK_IMPORTED_MODULE_2__.isZodSchemaV4)(schema)) {\n        const inputSchema = (0,_types_zod_js__WEBPACK_IMPORTED_MODULE_2__.interopZodTransformInputSchema)(schema, true);\n        if ((0,_types_zod_js__WEBPACK_IMPORTED_MODULE_2__.isZodObjectV4)(inputSchema)) {\n            const strictSchema = (0,_types_zod_js__WEBPACK_IMPORTED_MODULE_2__.interopZodObjectStrict)(inputSchema, true);\n            return (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_3__.toJSONSchema)(strictSchema);\n        }\n        else {\n            return (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_3__.toJSONSchema)(schema);\n        }\n    }\n    if ((0,_types_zod_js__WEBPACK_IMPORTED_MODULE_2__.isZodSchemaV3)(schema)) {\n        return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(schema);\n    }\n    return schema;\n}\n/**\n * Validates if a JSON schema validates only strings. May return false negatives in some edge cases\n * (like recursive or unresolvable refs).\n *\n * @param schema - The schema to validate.\n * @returns `true` if the schema validates only strings, `false` otherwise.\n */\nfunction validatesOnlyStrings(schema) {\n    // Null, undefined, or empty schema\n    if (!schema ||\n        typeof schema !== \"object\" ||\n        Object.keys(schema).length === 0 ||\n        Array.isArray(schema)) {\n        return false; // Validates anything, not just strings\n    }\n    // Explicit type constraint\n    if (\"type\" in schema) {\n        if (typeof schema.type === \"string\") {\n            return schema.type === \"string\";\n        }\n        if (Array.isArray(schema.type)) {\n            // not sure why someone would do `\"type\": [\"string\"]` or especially `\"type\": [\"string\",\n            // \"string\", \"string\", ...]` but we're not here to judge\n            return schema.type.every((t) => t === \"string\");\n        }\n        return false; // Invalid or non-string type\n    }\n    // Enum with only string values\n    if (\"enum\" in schema) {\n        return (Array.isArray(schema.enum) &&\n            schema.enum.length > 0 &&\n            schema.enum.every((val) => typeof val === \"string\"));\n    }\n    // String constant\n    if (\"const\" in schema) {\n        return typeof schema.const === \"string\";\n    }\n    // Schema combinations\n    if (\"allOf\" in schema && Array.isArray(schema.allOf)) {\n        // If any subschema validates only strings, then the overall schema validates only strings\n        return schema.allOf.some((subschema) => validatesOnlyStrings(subschema));\n    }\n    if ((\"anyOf\" in schema && Array.isArray(schema.anyOf)) ||\n        (\"oneOf\" in schema && Array.isArray(schema.oneOf))) {\n        const subschemas = (\"anyOf\" in schema ? schema.anyOf : schema.oneOf);\n        // All subschemas must validate only strings\n        return (subschemas.length > 0 &&\n            subschemas.every((subschema) => validatesOnlyStrings(subschema)));\n    }\n    // We're not going to try on this one, it's too complex - we just assume if it has a \"not\" key and hasn't matched one of the above checks, it's not a string schema.\n    if (\"not\" in schema) {\n        return false; // The not case can validate non-strings\n    }\n    if (\"$ref\" in schema && typeof schema.$ref === \"string\") {\n        const ref = schema.$ref;\n        const resolved = (0,_cfworker_json_schema__WEBPACK_IMPORTED_MODULE_1__.dereference)(schema);\n        if (resolved[ref]) {\n            return validatesOnlyStrings(resolved[ref]);\n        }\n        return false;\n    }\n    // ignore recursive refs and other cases where type is omitted for now\n    // ignore other cases for now where type is omitted\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbl9zY2hlbWEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMkM7QUFDVTtBQUNEO0FBQ2tGO0FBQ2pFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsNERBQWE7QUFDckIsNEJBQTRCLDZFQUE4QjtBQUMxRCxZQUFZLDREQUFhO0FBQ3pCLGlDQUFpQyxxRUFBc0I7QUFDdkQsbUJBQW1CLHlEQUFZO0FBQy9CO0FBQ0E7QUFDQSxtQkFBbUIseURBQVk7QUFDL0I7QUFDQTtBQUNBLFFBQVEsNERBQWE7QUFDckIsZUFBZSxtRUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXGpzb25fc2NoZW1hLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvSlNPTlNjaGVtYSB9IGZyb20gXCJ6b2QvdjQvY29yZVwiO1xuaW1wb3J0IHsgem9kVG9Kc29uU2NoZW1hIH0gZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuaW1wb3J0IHsgZGVyZWZlcmVuY2UgfSBmcm9tIFwiQGNmd29ya2VyL2pzb24tc2NoZW1hXCI7XG5pbXBvcnQgeyBpc1pvZFNjaGVtYVYzLCBpc1pvZFNjaGVtYVY0LCBpbnRlcm9wWm9kT2JqZWN0U3RyaWN0LCBpc1pvZE9iamVjdFY0LCBpbnRlcm9wWm9kVHJhbnNmb3JtSW5wdXRTY2hlbWEsIH0gZnJvbSBcIi4vdHlwZXMvem9kLmpzXCI7XG5leHBvcnQgeyBkZWVwQ29tcGFyZVN0cmljdCwgVmFsaWRhdG9yIH0gZnJvbSBcIkBjZndvcmtlci9qc29uLXNjaGVtYVwiO1xuLyoqXG4gKiBDb252ZXJ0cyBhIFpvZCBzY2hlbWEgb3IgSlNPTiBzY2hlbWEgdG8gYSBKU09OIHNjaGVtYS5cbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHNjaGVtYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvblNjaGVtYShzY2hlbWEpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IGlucHV0U2NoZW1hID0gaW50ZXJvcFpvZFRyYW5zZm9ybUlucHV0U2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIGlmIChpc1pvZE9iamVjdFY0KGlucHV0U2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaWN0U2NoZW1hID0gaW50ZXJvcFpvZE9iamVjdFN0cmljdChpbnB1dFNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdG9KU09OU2NoZW1hKHN0cmljdFNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdG9KU09OU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gem9kVG9Kc29uU2NoZW1hKHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBpZiBhIEpTT04gc2NoZW1hIHZhbGlkYXRlcyBvbmx5IHN0cmluZ3MuIE1heSByZXR1cm4gZmFsc2UgbmVnYXRpdmVzIGluIHNvbWUgZWRnZSBjYXNlc1xuICogKGxpa2UgcmVjdXJzaXZlIG9yIHVucmVzb2x2YWJsZSByZWZzKS5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2NoZW1hIHZhbGlkYXRlcyBvbmx5IHN0cmluZ3MsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVzT25seVN0cmluZ3Moc2NoZW1hKSB7XG4gICAgLy8gTnVsbCwgdW5kZWZpbmVkLCBvciBlbXB0eSBzY2hlbWFcbiAgICBpZiAoIXNjaGVtYSB8fFxuICAgICAgICB0eXBlb2Ygc2NoZW1hICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgIE9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoID09PSAwIHx8XG4gICAgICAgIEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFZhbGlkYXRlcyBhbnl0aGluZywgbm90IGp1c3Qgc3RyaW5nc1xuICAgIH1cbiAgICAvLyBFeHBsaWNpdCB0eXBlIGNvbnN0cmFpbnRcbiAgICBpZiAoXCJ0eXBlXCIgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEudHlwZSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkpIHtcbiAgICAgICAgICAgIC8vIG5vdCBzdXJlIHdoeSBzb21lb25lIHdvdWxkIGRvIGBcInR5cGVcIjogW1wic3RyaW5nXCJdYCBvciBlc3BlY2lhbGx5IGBcInR5cGVcIjogW1wic3RyaW5nXCIsXG4gICAgICAgICAgICAvLyBcInN0cmluZ1wiLCBcInN0cmluZ1wiLCAuLi5dYCBidXQgd2UncmUgbm90IGhlcmUgdG8ganVkZ2VcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEudHlwZS5ldmVyeSgodCkgPT4gdCA9PT0gXCJzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJbnZhbGlkIG9yIG5vbi1zdHJpbmcgdHlwZVxuICAgIH1cbiAgICAvLyBFbnVtIHdpdGggb25seSBzdHJpbmcgdmFsdWVzXG4gICAgaWYgKFwiZW51bVwiIGluIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pICYmXG4gICAgICAgICAgICBzY2hlbWEuZW51bS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBzY2hlbWEuZW51bS5ldmVyeSgodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSk7XG4gICAgfVxuICAgIC8vIFN0cmluZyBjb25zdGFudFxuICAgIGlmIChcImNvbnN0XCIgaW4gc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc2NoZW1hLmNvbnN0ID09PSBcInN0cmluZ1wiO1xuICAgIH1cbiAgICAvLyBTY2hlbWEgY29tYmluYXRpb25zXG4gICAgaWYgKFwiYWxsT2ZcIiBpbiBzY2hlbWEgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKSB7XG4gICAgICAgIC8vIElmIGFueSBzdWJzY2hlbWEgdmFsaWRhdGVzIG9ubHkgc3RyaW5ncywgdGhlbiB0aGUgb3ZlcmFsbCBzY2hlbWEgdmFsaWRhdGVzIG9ubHkgc3RyaW5nc1xuICAgICAgICByZXR1cm4gc2NoZW1hLmFsbE9mLnNvbWUoKHN1YnNjaGVtYSkgPT4gdmFsaWRhdGVzT25seVN0cmluZ3Moc3Vic2NoZW1hKSk7XG4gICAgfVxuICAgIGlmICgoXCJhbnlPZlwiIGluIHNjaGVtYSAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5hbnlPZikpIHx8XG4gICAgICAgIChcIm9uZU9mXCIgaW4gc2NoZW1hICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLm9uZU9mKSkpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hcyA9IChcImFueU9mXCIgaW4gc2NoZW1hID8gc2NoZW1hLmFueU9mIDogc2NoZW1hLm9uZU9mKTtcbiAgICAgICAgLy8gQWxsIHN1YnNjaGVtYXMgbXVzdCB2YWxpZGF0ZSBvbmx5IHN0cmluZ3NcbiAgICAgICAgcmV0dXJuIChzdWJzY2hlbWFzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHN1YnNjaGVtYXMuZXZlcnkoKHN1YnNjaGVtYSkgPT4gdmFsaWRhdGVzT25seVN0cmluZ3Moc3Vic2NoZW1hKSkpO1xuICAgIH1cbiAgICAvLyBXZSdyZSBub3QgZ29pbmcgdG8gdHJ5IG9uIHRoaXMgb25lLCBpdCdzIHRvbyBjb21wbGV4IC0gd2UganVzdCBhc3N1bWUgaWYgaXQgaGFzIGEgXCJub3RcIiBrZXkgYW5kIGhhc24ndCBtYXRjaGVkIG9uZSBvZiB0aGUgYWJvdmUgY2hlY2tzLCBpdCdzIG5vdCBhIHN0cmluZyBzY2hlbWEuXG4gICAgaWYgKFwibm90XCIgaW4gc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIG5vdCBjYXNlIGNhbiB2YWxpZGF0ZSBub24tc3RyaW5nc1xuICAgIH1cbiAgICBpZiAoXCIkcmVmXCIgaW4gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEuJHJlZiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCByZWYgPSBzY2hlbWEuJHJlZjtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBkZXJlZmVyZW5jZShzY2hlbWEpO1xuICAgICAgICBpZiAocmVzb2x2ZWRbcmVmXSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlc09ubHlTdHJpbmdzKHJlc29sdmVkW3JlZl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gaWdub3JlIHJlY3Vyc2l2ZSByZWZzIGFuZCBvdGhlciBjYXNlcyB3aGVyZSB0eXBlIGlzIG9taXR0ZWQgZm9yIG5vd1xuICAgIC8vIGlnbm9yZSBvdGhlciBjYXNlcyBmb3Igbm93IHdoZXJlIHR5cGUgaXMgb21pdHRlZFxuICAgIHJldHVybiBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/math.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/math.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   euclideanDistance: () => (/* binding */ euclideanDistance),\n/* harmony export */   innerProduct: () => (/* binding */ innerProduct),\n/* harmony export */   matrixFunc: () => (/* binding */ matrixFunc),\n/* harmony export */   maximalMarginalRelevance: () => (/* binding */ maximalMarginalRelevance),\n/* harmony export */   normalize: () => (/* binding */ normalize)\n/* harmony export */ });\n/* harmony import */ var _ml_distance_similarities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ml-distance/similarities.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/ml-distance/similarities.js\");\n/* harmony import */ var _ml_distance_distances_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ml-distance/distances.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/ml-distance/distances.js\");\n/* harmony import */ var _ml_distance_euclidean_euclidean_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ml-distance-euclidean/euclidean.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.js\");\n\n\n\n/**\n * Apply a row-wise function between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n * @param {VectorFunction} func - The function to apply.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the result of applying the function between the corresponding rows of X and Y.\n */\nfunction matrixFunc(X, Y, func) {\n    if (X.length === 0 ||\n        X[0].length === 0 ||\n        Y.length === 0 ||\n        Y[0].length === 0) {\n        return [[]];\n    }\n    if (X[0].length !== Y[0].length) {\n        throw new Error(`Number of columns in X and Y must be the same. X has shape ${[\n            X.length,\n            X[0].length,\n        ]} and Y has shape ${[Y.length, Y[0].length]}.`);\n    }\n    return X.map((xVector) => Y.map((yVector) => func(xVector, yVector)).map((similarity) => Number.isNaN(similarity) ? 0 : similarity));\n}\nfunction normalize(M, similarity = false) {\n    const max = matrixMaxVal(M);\n    return M.map((row) => row.map((val) => (similarity ? 1 - val / max : val / max)));\n}\n/**\n * This function calculates the row-wise cosine similarity between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the cosine similarity values between the corresponding rows of X and Y.\n */\nfunction cosineSimilarity(X, Y) {\n    return matrixFunc(X, Y, _ml_distance_similarities_js__WEBPACK_IMPORTED_MODULE_0__.cosine);\n}\nfunction innerProduct(X, Y) {\n    return matrixFunc(X, Y, _ml_distance_distances_js__WEBPACK_IMPORTED_MODULE_1__.innerProduct);\n}\nfunction euclideanDistance(X, Y) {\n    return matrixFunc(X, Y, _ml_distance_euclidean_euclidean_js__WEBPACK_IMPORTED_MODULE_2__.euclidean);\n}\n/**\n * This function implements the Maximal Marginal Relevance algorithm\n * to select a set of embeddings that maximizes the diversity and relevance to a query embedding.\n *\n * @param {number[]|number[][]} queryEmbedding - The query embedding.\n * @param {number[][]} embeddingList - The list of embeddings to select from.\n * @param {number} [lambda=0.5] - The trade-off parameter between relevance and diversity.\n * @param {number} [k=4] - The maximum number of embeddings to select.\n *\n * @returns {number[]} The indexes of the selected embeddings in the embeddingList.\n */\nfunction maximalMarginalRelevance(queryEmbedding, embeddingList, lambda = 0.5, k = 4) {\n    if (Math.min(k, embeddingList.length) <= 0) {\n        return [];\n    }\n    const queryEmbeddingExpanded = (Array.isArray(queryEmbedding[0]) ? queryEmbedding : [queryEmbedding]);\n    const similarityToQuery = cosineSimilarity(queryEmbeddingExpanded, embeddingList)[0];\n    const mostSimilarEmbeddingIndex = argMax(similarityToQuery).maxIndex;\n    const selectedEmbeddings = [embeddingList[mostSimilarEmbeddingIndex]];\n    const selectedEmbeddingsIndexes = [mostSimilarEmbeddingIndex];\n    while (selectedEmbeddingsIndexes.length < Math.min(k, embeddingList.length)) {\n        let bestScore = -Infinity;\n        let bestIndex = -1;\n        const similarityToSelected = cosineSimilarity(embeddingList, selectedEmbeddings);\n        similarityToQuery.forEach((queryScore, queryScoreIndex) => {\n            if (selectedEmbeddingsIndexes.includes(queryScoreIndex)) {\n                return;\n            }\n            const maxSimilarityToSelected = Math.max(...similarityToSelected[queryScoreIndex]);\n            const score = lambda * queryScore - (1 - lambda) * maxSimilarityToSelected;\n            if (score > bestScore) {\n                bestScore = score;\n                bestIndex = queryScoreIndex;\n            }\n        });\n        selectedEmbeddings.push(embeddingList[bestIndex]);\n        selectedEmbeddingsIndexes.push(bestIndex);\n    }\n    return selectedEmbeddingsIndexes;\n}\n/**\n * Finds the index of the maximum value in the given array.\n * @param {number[]} array - The input array.\n *\n * @returns {number} The index of the maximum value in the array. If the array is empty, returns -1.\n */\nfunction argMax(array) {\n    if (array.length === 0) {\n        return {\n            maxIndex: -1,\n            maxValue: NaN,\n        };\n    }\n    let maxValue = array[0];\n    let maxIndex = 0;\n    for (let i = 1; i < array.length; i += 1) {\n        if (array[i] > maxValue) {\n            maxIndex = i;\n            maxValue = array[i];\n        }\n    }\n    return { maxIndex, maxValue };\n}\nfunction matrixMaxVal(arrays) {\n    return arrays.reduce((acc, array) => Math.max(acc, argMax(array).maxValue), 0);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvbWF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDMkI7QUFDakI7QUFDakU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0EsV0FBVyxrQkFBa0Isd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ087QUFDUCw0QkFBNEIsZ0VBQU07QUFDbEM7QUFDTztBQUNQLDRCQUE0QixtRUFBb0I7QUFDaEQ7QUFDTztBQUNQLDRCQUE0QiwwRUFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxtYXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvc2luZSB9IGZyb20gXCIuL21sLWRpc3RhbmNlL3NpbWlsYXJpdGllcy5qc1wiO1xuaW1wb3J0IHsgaW5uZXJQcm9kdWN0IGFzIGlubmVyUHJvZHVjdERpc3RhbmNlIH0gZnJvbSBcIi4vbWwtZGlzdGFuY2UvZGlzdGFuY2VzLmpzXCI7XG5pbXBvcnQgeyBldWNsaWRlYW4gfSBmcm9tIFwiLi9tbC1kaXN0YW5jZS1ldWNsaWRlYW4vZXVjbGlkZWFuLmpzXCI7XG4vKipcbiAqIEFwcGx5IGEgcm93LXdpc2UgZnVuY3Rpb24gYmV0d2VlbiB0d28gbWF0cmljZXMgd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgY29sdW1ucy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdW119IFggLSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHtudW1iZXJbXVtdfSBZIC0gVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcGFyYW0ge1ZlY3RvckZ1bmN0aW9ufSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5LlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gWCBhbmQgWSBhcmUgbm90IHRoZSBzYW1lLlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJbXVtdIHwgW1tdXX0gQSBtYXRyaXggd2hlcmUgZWFjaCByb3cgcmVwcmVzZW50cyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBmdW5jdGlvbiBiZXR3ZWVuIHRoZSBjb3JyZXNwb25kaW5nIHJvd3Mgb2YgWCBhbmQgWS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdHJpeEZ1bmMoWCwgWSwgZnVuYykge1xuICAgIGlmIChYLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICBYWzBdLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICBZLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICBZWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW1tdXTtcbiAgICB9XG4gICAgaWYgKFhbMF0ubGVuZ3RoICE9PSBZWzBdLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE51bWJlciBvZiBjb2x1bW5zIGluIFggYW5kIFkgbXVzdCBiZSB0aGUgc2FtZS4gWCBoYXMgc2hhcGUgJHtbXG4gICAgICAgICAgICBYLmxlbmd0aCxcbiAgICAgICAgICAgIFhbMF0ubGVuZ3RoLFxuICAgICAgICBdfSBhbmQgWSBoYXMgc2hhcGUgJHtbWS5sZW5ndGgsIFlbMF0ubGVuZ3RoXX0uYCk7XG4gICAgfVxuICAgIHJldHVybiBYLm1hcCgoeFZlY3RvcikgPT4gWS5tYXAoKHlWZWN0b3IpID0+IGZ1bmMoeFZlY3RvciwgeVZlY3RvcikpLm1hcCgoc2ltaWxhcml0eSkgPT4gTnVtYmVyLmlzTmFOKHNpbWlsYXJpdHkpID8gMCA6IHNpbWlsYXJpdHkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoTSwgc2ltaWxhcml0eSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbWF4ID0gbWF0cml4TWF4VmFsKE0pO1xuICAgIHJldHVybiBNLm1hcCgocm93KSA9PiByb3cubWFwKCh2YWwpID0+IChzaW1pbGFyaXR5ID8gMSAtIHZhbCAvIG1heCA6IHZhbCAvIG1heCkpKTtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSByb3ctd2lzZSBjb3NpbmUgc2ltaWxhcml0eSBiZXR3ZWVuIHR3byBtYXRyaWNlcyB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBjb2x1bW5zLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW11bXX0gWCAtIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcltdW119IFkgLSBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIFggYW5kIFkgYXJlIG5vdCB0aGUgc2FtZS5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyW11bXSB8IFtbXV19IEEgbWF0cml4IHdoZXJlIGVhY2ggcm93IHJlcHJlc2VudHMgdGhlIGNvc2luZSBzaW1pbGFyaXR5IHZhbHVlcyBiZXR3ZWVuIHRoZSBjb3JyZXNwb25kaW5nIHJvd3Mgb2YgWCBhbmQgWS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvc2luZVNpbWlsYXJpdHkoWCwgWSkge1xuICAgIHJldHVybiBtYXRyaXhGdW5jKFgsIFksIGNvc2luZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5uZXJQcm9kdWN0KFgsIFkpIHtcbiAgICByZXR1cm4gbWF0cml4RnVuYyhYLCBZLCBpbm5lclByb2R1Y3REaXN0YW5jZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZXVjbGlkZWFuRGlzdGFuY2UoWCwgWSkge1xuICAgIHJldHVybiBtYXRyaXhGdW5jKFgsIFksIGV1Y2xpZGVhbik7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgTWF4aW1hbCBNYXJnaW5hbCBSZWxldmFuY2UgYWxnb3JpdGhtXG4gKiB0byBzZWxlY3QgYSBzZXQgb2YgZW1iZWRkaW5ncyB0aGF0IG1heGltaXplcyB0aGUgZGl2ZXJzaXR5IGFuZCByZWxldmFuY2UgdG8gYSBxdWVyeSBlbWJlZGRpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXXxudW1iZXJbXVtdfSBxdWVyeUVtYmVkZGluZyAtIFRoZSBxdWVyeSBlbWJlZGRpbmcuXG4gKiBAcGFyYW0ge251bWJlcltdW119IGVtYmVkZGluZ0xpc3QgLSBUaGUgbGlzdCBvZiBlbWJlZGRpbmdzIHRvIHNlbGVjdCBmcm9tLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsYW1iZGE9MC41XSAtIFRoZSB0cmFkZS1vZmYgcGFyYW1ldGVyIGJldHdlZW4gcmVsZXZhbmNlIGFuZCBkaXZlcnNpdHkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2s9NF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgZW1iZWRkaW5ncyB0byBzZWxlY3QuXG4gKlxuICogQHJldHVybnMge251bWJlcltdfSBUaGUgaW5kZXhlcyBvZiB0aGUgc2VsZWN0ZWQgZW1iZWRkaW5ncyBpbiB0aGUgZW1iZWRkaW5nTGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heGltYWxNYXJnaW5hbFJlbGV2YW5jZShxdWVyeUVtYmVkZGluZywgZW1iZWRkaW5nTGlzdCwgbGFtYmRhID0gMC41LCBrID0gNCkge1xuICAgIGlmIChNYXRoLm1pbihrLCBlbWJlZGRpbmdMaXN0Lmxlbmd0aCkgPD0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5RW1iZWRkaW5nRXhwYW5kZWQgPSAoQXJyYXkuaXNBcnJheShxdWVyeUVtYmVkZGluZ1swXSkgPyBxdWVyeUVtYmVkZGluZyA6IFtxdWVyeUVtYmVkZGluZ10pO1xuICAgIGNvbnN0IHNpbWlsYXJpdHlUb1F1ZXJ5ID0gY29zaW5lU2ltaWxhcml0eShxdWVyeUVtYmVkZGluZ0V4cGFuZGVkLCBlbWJlZGRpbmdMaXN0KVswXTtcbiAgICBjb25zdCBtb3N0U2ltaWxhckVtYmVkZGluZ0luZGV4ID0gYXJnTWF4KHNpbWlsYXJpdHlUb1F1ZXJ5KS5tYXhJbmRleDtcbiAgICBjb25zdCBzZWxlY3RlZEVtYmVkZGluZ3MgPSBbZW1iZWRkaW5nTGlzdFttb3N0U2ltaWxhckVtYmVkZGluZ0luZGV4XV07XG4gICAgY29uc3Qgc2VsZWN0ZWRFbWJlZGRpbmdzSW5kZXhlcyA9IFttb3N0U2ltaWxhckVtYmVkZGluZ0luZGV4XTtcbiAgICB3aGlsZSAoc2VsZWN0ZWRFbWJlZGRpbmdzSW5kZXhlcy5sZW5ndGggPCBNYXRoLm1pbihrLCBlbWJlZGRpbmdMaXN0Lmxlbmd0aCkpIHtcbiAgICAgICAgbGV0IGJlc3RTY29yZSA9IC1JbmZpbml0eTtcbiAgICAgICAgbGV0IGJlc3RJbmRleCA9IC0xO1xuICAgICAgICBjb25zdCBzaW1pbGFyaXR5VG9TZWxlY3RlZCA9IGNvc2luZVNpbWlsYXJpdHkoZW1iZWRkaW5nTGlzdCwgc2VsZWN0ZWRFbWJlZGRpbmdzKTtcbiAgICAgICAgc2ltaWxhcml0eVRvUXVlcnkuZm9yRWFjaCgocXVlcnlTY29yZSwgcXVlcnlTY29yZUluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRFbWJlZGRpbmdzSW5kZXhlcy5pbmNsdWRlcyhxdWVyeVNjb3JlSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF4U2ltaWxhcml0eVRvU2VsZWN0ZWQgPSBNYXRoLm1heCguLi5zaW1pbGFyaXR5VG9TZWxlY3RlZFtxdWVyeVNjb3JlSW5kZXhdKTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gbGFtYmRhICogcXVlcnlTY29yZSAtICgxIC0gbGFtYmRhKSAqIG1heFNpbWlsYXJpdHlUb1NlbGVjdGVkO1xuICAgICAgICAgICAgaWYgKHNjb3JlID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdEluZGV4ID0gcXVlcnlTY29yZUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2VsZWN0ZWRFbWJlZGRpbmdzLnB1c2goZW1iZWRkaW5nTGlzdFtiZXN0SW5kZXhdKTtcbiAgICAgICAgc2VsZWN0ZWRFbWJlZGRpbmdzSW5kZXhlcy5wdXNoKGJlc3RJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZEVtYmVkZGluZ3NJbmRleGVzO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIGdpdmVuIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgaW5wdXQgYXJyYXkuXG4gKlxuICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGlzIGVtcHR5LCByZXR1cm5zIC0xLlxuICovXG5mdW5jdGlvbiBhcmdNYXgoYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXhJbmRleDogLTEsXG4gICAgICAgICAgICBtYXhWYWx1ZTogTmFOLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgbWF4VmFsdWUgPSBhcnJheVswXTtcbiAgICBsZXQgbWF4SW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGFycmF5W2ldID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgICAgICAgIG1heFZhbHVlID0gYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWF4SW5kZXgsIG1heFZhbHVlIH07XG59XG5mdW5jdGlvbiBtYXRyaXhNYXhWYWwoYXJyYXlzKSB7XG4gICAgcmV0dXJuIGFycmF5cy5yZWR1Y2UoKGFjYywgYXJyYXkpID0+IE1hdGgubWF4KGFjYywgYXJnTWF4KGFycmF5KS5tYXhWYWx1ZSksIDApO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/math.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   euclidean: () => (/* binding */ euclidean),\n/* harmony export */   squaredEuclidean: () => (/* binding */ squaredEuclidean)\n/* harmony export */ });\nfunction squaredEuclidean(p, q) {\n    let d = 0;\n    for (let i = 0; i < p.length; i++) {\n        d += (p[i] - q[i]) * (p[i] - q[i]);\n    }\n    return d;\n}\nfunction euclidean(p, q) {\n    return Math.sqrt(squaredEuclidean(p, q));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvbWwtZGlzdGFuY2UtZXVjbGlkZWFuL2V1Y2xpZGVhbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcbWwtZGlzdGFuY2UtZXVjbGlkZWFuXFxldWNsaWRlYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRFdWNsaWRlYW4ocCwgcSkge1xuICAgIGxldCBkID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZCArPSAocFtpXSAtIHFbaV0pICogKHBbaV0gLSBxW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZXVjbGlkZWFuKHAsIHEpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHNxdWFyZWRFdWNsaWRlYW4ocCwgcSkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/ml-distance/distances.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/ml-distance/distances.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   innerProduct: () => (/* binding */ innerProduct)\n/* harmony export */ });\n/**\n *Returns the Inner Product similarity between vectors a and b\n * @link [Inner Product Similarity algorithm](https://www.naun.org/main/NAUN/ijmmas/mmmas-49.pdf)\n * @param a - first vector\n * @param b - second vector\n *\n */\nfunction innerProduct(a, b) {\n    let ans = 0;\n    for (let i = 0; i < a.length; i++) {\n        ans += a[i] * b[i];\n    }\n    return ans;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvbWwtZGlzdGFuY2UvZGlzdGFuY2VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcbWwtZGlzdGFuY2VcXGRpc3RhbmNlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqUmV0dXJucyB0aGUgSW5uZXIgUHJvZHVjdCBzaW1pbGFyaXR5IGJldHdlZW4gdmVjdG9ycyBhIGFuZCBiXG4gKiBAbGluayBbSW5uZXIgUHJvZHVjdCBTaW1pbGFyaXR5IGFsZ29yaXRobV0oaHR0cHM6Ly93d3cubmF1bi5vcmcvbWFpbi9OQVVOL2lqbW1hcy9tbW1hcy00OS5wZGYpXG4gKiBAcGFyYW0gYSAtIGZpcnN0IHZlY3RvclxuICogQHBhcmFtIGIgLSBzZWNvbmQgdmVjdG9yXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5uZXJQcm9kdWN0KGEsIGIpIHtcbiAgICBsZXQgYW5zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYW5zICs9IGFbaV0gKiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYW5zO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/ml-distance/distances.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/ml-distance/similarities.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/ml-distance/similarities.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cosine: () => (/* binding */ cosine)\n/* harmony export */ });\n/**\n * Returns the average of cosine distances between vectors a and b\n * @param a - first vector\n * @param b - second vector\n *\n */\nfunction cosine(a, b) {\n    let p = 0;\n    let p2 = 0;\n    let q2 = 0;\n    for (let i = 0; i < a.length; i++) {\n        p += a[i] * b[i];\n        p2 += a[i] * a[i];\n        q2 += b[i] * b[i];\n    }\n    return p / (Math.sqrt(p2) * Math.sqrt(q2));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvbWwtZGlzdGFuY2Uvc2ltaWxhcml0aWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcbWwtZGlzdGFuY2VcXHNpbWlsYXJpdGllcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJldHVybnMgdGhlIGF2ZXJhZ2Ugb2YgY29zaW5lIGRpc3RhbmNlcyBiZXR3ZWVuIHZlY3RvcnMgYSBhbmQgYlxuICogQHBhcmFtIGEgLSBmaXJzdCB2ZWN0b3JcbiAqIEBwYXJhbSBiIC0gc2Vjb25kIHZlY3RvclxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvc2luZShhLCBiKSB7XG4gICAgbGV0IHAgPSAwO1xuICAgIGxldCBwMiA9IDA7XG4gICAgbGV0IHEyID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcCArPSBhW2ldICogYltpXTtcbiAgICAgICAgcDIgKz0gYVtpXSAqIGFbaV07XG4gICAgICAgIHEyICs9IGJbaV0gKiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcCAvIChNYXRoLnNxcnQocDIpICogTWF0aC5zcXJ0KHEyKSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/ml-distance/similarities.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/sax-js/sax.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/sax-js/sax.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sax: () => (/* binding */ sax)\n/* harmony export */ });\n// @ts-nocheck\n// Inlined to deal with portability issues\n// Originally from: https://github.com/isaacs/sax-js\nconst initializeSax = function () {\n    const sax = {};\n    sax.parser = function (strict, opt) {\n        return new SAXParser(strict, opt);\n    };\n    sax.SAXParser = SAXParser;\n    sax.SAXStream = SAXStream;\n    sax.createStream = createStream;\n    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n    // since that's the earliest that a buffer overrun could occur.  This way, checks are\n    // as rare as required, but as often as necessary to ensure never crossing this bound.\n    // Furthermore, buffers are only tested at most once per write(), so passing a very\n    // large string into write() might have undesirable effects, but this is manageable by\n    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n    // edge case, result in creating at most one complete copy of the string passed in.\n    // Set to Infinity to have unlimited buffers.\n    sax.MAX_BUFFER_LENGTH = 64 * 1024;\n    const buffers = [\n        \"comment\",\n        \"sgmlDecl\",\n        \"textNode\",\n        \"tagName\",\n        \"doctype\",\n        \"procInstName\",\n        \"procInstBody\",\n        \"entity\",\n        \"attribName\",\n        \"attribValue\",\n        \"cdata\",\n        \"script\",\n    ];\n    sax.EVENTS = [\n        \"text\",\n        \"processinginstruction\",\n        \"sgmldeclaration\",\n        \"doctype\",\n        \"comment\",\n        \"opentagstart\",\n        \"attribute\",\n        \"opentag\",\n        \"closetag\",\n        \"opencdata\",\n        \"cdata\",\n        \"closecdata\",\n        \"error\",\n        \"end\",\n        \"ready\",\n        \"script\",\n        \"opennamespace\",\n        \"closenamespace\",\n    ];\n    function SAXParser(strict, opt) {\n        if (!(this instanceof SAXParser)) {\n            return new SAXParser(strict, opt);\n        }\n        var parser = this;\n        clearBuffers(parser);\n        parser.q = parser.c = \"\";\n        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n        parser.opt = opt || {};\n        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n        parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n        parser.tags = [];\n        parser.closed = parser.closedRoot = parser.sawRoot = false;\n        parser.tag = parser.error = null;\n        parser.strict = !!strict;\n        parser.noscript = !!(strict || parser.opt.noscript);\n        parser.state = S.BEGIN;\n        parser.strictEntities = parser.opt.strictEntities;\n        parser.ENTITIES = parser.strictEntities\n            ? Object.create(sax.XML_ENTITIES)\n            : Object.create(sax.ENTITIES);\n        parser.attribList = [];\n        // namespaces form a prototype chain.\n        // it always points at the current tag,\n        // which protos to its parent tag.\n        if (parser.opt.xmlns) {\n            parser.ns = Object.create(rootNS);\n        }\n        // mostly just for error reporting\n        parser.trackPosition = parser.opt.position !== false;\n        if (parser.trackPosition) {\n            parser.position = parser.line = parser.column = 0;\n        }\n        emit(parser, \"onready\");\n    }\n    if (!Object.create) {\n        Object.create = function (o) {\n            function F() { }\n            F.prototype = o;\n            var newf = new F();\n            return newf;\n        };\n    }\n    if (!Object.keys) {\n        Object.keys = function (o) {\n            var a = [];\n            for (var i in o)\n                if (o.hasOwnProperty(i))\n                    a.push(i);\n            return a;\n        };\n    }\n    function checkBufferLength(parser) {\n        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n        var maxActual = 0;\n        for (var i = 0, l = buffers.length; i < l; i++) {\n            var len = parser[buffers[i]].length;\n            if (len > maxAllowed) {\n                // Text/cdata nodes can get big, and since they're buffered,\n                // we can get here under normal conditions.\n                // Avoid issues by emitting the text node now,\n                // so at least it won't get any bigger.\n                switch (buffers[i]) {\n                    case \"textNode\":\n                        closeText(parser);\n                        break;\n                    case \"cdata\":\n                        emitNode(parser, \"oncdata\", parser.cdata);\n                        parser.cdata = \"\";\n                        break;\n                    case \"script\":\n                        emitNode(parser, \"onscript\", parser.script);\n                        parser.script = \"\";\n                        break;\n                    default:\n                        error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n                }\n            }\n            maxActual = Math.max(maxActual, len);\n        }\n        // schedule the next check for the earliest possible buffer overrun.\n        var m = sax.MAX_BUFFER_LENGTH - maxActual;\n        parser.bufferCheckPosition = m + parser.position;\n    }\n    function clearBuffers(parser) {\n        for (var i = 0, l = buffers.length; i < l; i++) {\n            parser[buffers[i]] = \"\";\n        }\n    }\n    function flushBuffers(parser) {\n        closeText(parser);\n        if (parser.cdata !== \"\") {\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n        }\n        if (parser.script !== \"\") {\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n        }\n    }\n    SAXParser.prototype = {\n        end: function () {\n            end(this);\n        },\n        write: write,\n        resume: function () {\n            this.error = null;\n            return this;\n        },\n        close: function () {\n            return this.write(null);\n        },\n        flush: function () {\n            flushBuffers(this);\n        },\n    };\n    var Stream = ReadableStream;\n    if (!Stream)\n        Stream = function () { };\n    var streamWraps = sax.EVENTS.filter(function (ev) {\n        return ev !== \"error\" && ev !== \"end\";\n    });\n    function createStream(strict, opt) {\n        return new SAXStream(strict, opt);\n    }\n    function SAXStream(strict, opt) {\n        if (!(this instanceof SAXStream)) {\n            return new SAXStream(strict, opt);\n        }\n        Stream.apply(this);\n        this._parser = new SAXParser(strict, opt);\n        this.writable = true;\n        this.readable = true;\n        var me = this;\n        this._parser.onend = function () {\n            me.emit(\"end\");\n        };\n        this._parser.onerror = function (er) {\n            me.emit(\"error\", er);\n            // if didn't throw, then means error was handled.\n            // go ahead and clear error, so we can write again.\n            me._parser.error = null;\n        };\n        this._decoder = null;\n        streamWraps.forEach(function (ev) {\n            Object.defineProperty(me, \"on\" + ev, {\n                get: function () {\n                    return me._parser[\"on\" + ev];\n                },\n                set: function (h) {\n                    if (!h) {\n                        me.removeAllListeners(ev);\n                        me._parser[\"on\" + ev] = h;\n                        return h;\n                    }\n                    me.on(ev, h);\n                },\n                enumerable: true,\n                configurable: false,\n            });\n        });\n    }\n    SAXStream.prototype = Object.create(Stream.prototype, {\n        constructor: {\n            value: SAXStream,\n        },\n    });\n    SAXStream.prototype.write = function (data) {\n        this._parser.write(data.toString());\n        this.emit(\"data\", data);\n        return true;\n    };\n    SAXStream.prototype.end = function (chunk) {\n        if (chunk && chunk.length) {\n            this.write(chunk);\n        }\n        this._parser.end();\n        return true;\n    };\n    SAXStream.prototype.on = function (ev, handler) {\n        var me = this;\n        if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n            me._parser[\"on\" + ev] = function () {\n                var args = arguments.length === 1\n                    ? [arguments[0]]\n                    : Array.apply(null, arguments);\n                args.splice(0, 0, ev);\n                me.emit.apply(me, args);\n            };\n        }\n        return Stream.prototype.on.call(me, ev, handler);\n    };\n    // this really needs to be replaced with character classes.\n    // XML allows all manner of ridiculous numbers and digits.\n    var CDATA = \"[CDATA[\";\n    var DOCTYPE = \"DOCTYPE\";\n    var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n    var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n    // This implementation works on strings, a single character at a time\n    // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n    // without a significant breaking change to either this  parser, or the\n    // JavaScript language.  Implementation of an emoji-capable xml parser\n    // is left as an exercise for the reader.\n    var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n    var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n    function isWhitespace(c) {\n        return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n    }\n    function isQuote(c) {\n        return c === '\"' || c === \"'\";\n    }\n    function isAttribEnd(c) {\n        return c === \">\" || isWhitespace(c);\n    }\n    function isMatch(regex, c) {\n        return regex.test(c);\n    }\n    function notMatch(regex, c) {\n        return !isMatch(regex, c);\n    }\n    var S = 0;\n    sax.STATE = {\n        BEGIN: S++, // leading byte order mark or whitespace\n        BEGIN_WHITESPACE: S++, // leading whitespace\n        TEXT: S++, // general stuff\n        TEXT_ENTITY: S++, // &amp and such.\n        OPEN_WAKA: S++, // <\n        SGML_DECL: S++, // <!BLARG\n        SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n        DOCTYPE: S++, // <!DOCTYPE\n        DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n        DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n        DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n        COMMENT_STARTING: S++, // <!-\n        COMMENT: S++, // <!--\n        COMMENT_ENDING: S++, // <!-- blah -\n        COMMENT_ENDED: S++, // <!-- blah --\n        CDATA: S++, // <![CDATA[ something\n        CDATA_ENDING: S++, // ]\n        CDATA_ENDING_2: S++, // ]]\n        PROC_INST: S++, // <?hi\n        PROC_INST_BODY: S++, // <?hi there\n        PROC_INST_ENDING: S++, // <?hi \"there\" ?\n        OPEN_TAG: S++, // <strong\n        OPEN_TAG_SLASH: S++, // <strong /\n        ATTRIB: S++, // <a\n        ATTRIB_NAME: S++, // <a foo\n        ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n        ATTRIB_VALUE: S++, // <a foo=\n        ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n        ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n        ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n        ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n        ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n        CLOSE_TAG: S++, // </a\n        CLOSE_TAG_SAW_WHITE: S++, // </a   >\n        SCRIPT: S++, // <script> ...\n        SCRIPT_ENDING: S++, // <script> ... <\n    };\n    sax.XML_ENTITIES = {\n        amp: \"&\",\n        gt: \">\",\n        lt: \"<\",\n        quot: '\"',\n        apos: \"'\",\n    };\n    sax.ENTITIES = {\n        amp: \"&\",\n        gt: \">\",\n        lt: \"<\",\n        quot: '\"',\n        apos: \"'\",\n        AElig: 198,\n        Aacute: 193,\n        Acirc: 194,\n        Agrave: 192,\n        Aring: 197,\n        Atilde: 195,\n        Auml: 196,\n        Ccedil: 199,\n        ETH: 208,\n        Eacute: 201,\n        Ecirc: 202,\n        Egrave: 200,\n        Euml: 203,\n        Iacute: 205,\n        Icirc: 206,\n        Igrave: 204,\n        Iuml: 207,\n        Ntilde: 209,\n        Oacute: 211,\n        Ocirc: 212,\n        Ograve: 210,\n        Oslash: 216,\n        Otilde: 213,\n        Ouml: 214,\n        THORN: 222,\n        Uacute: 218,\n        Ucirc: 219,\n        Ugrave: 217,\n        Uuml: 220,\n        Yacute: 221,\n        aacute: 225,\n        acirc: 226,\n        aelig: 230,\n        agrave: 224,\n        aring: 229,\n        atilde: 227,\n        auml: 228,\n        ccedil: 231,\n        eacute: 233,\n        ecirc: 234,\n        egrave: 232,\n        eth: 240,\n        euml: 235,\n        iacute: 237,\n        icirc: 238,\n        igrave: 236,\n        iuml: 239,\n        ntilde: 241,\n        oacute: 243,\n        ocirc: 244,\n        ograve: 242,\n        oslash: 248,\n        otilde: 245,\n        ouml: 246,\n        szlig: 223,\n        thorn: 254,\n        uacute: 250,\n        ucirc: 251,\n        ugrave: 249,\n        uuml: 252,\n        yacute: 253,\n        yuml: 255,\n        copy: 169,\n        reg: 174,\n        nbsp: 160,\n        iexcl: 161,\n        cent: 162,\n        pound: 163,\n        curren: 164,\n        yen: 165,\n        brvbar: 166,\n        sect: 167,\n        uml: 168,\n        ordf: 170,\n        laquo: 171,\n        not: 172,\n        shy: 173,\n        macr: 175,\n        deg: 176,\n        plusmn: 177,\n        sup1: 185,\n        sup2: 178,\n        sup3: 179,\n        acute: 180,\n        micro: 181,\n        para: 182,\n        middot: 183,\n        cedil: 184,\n        ordm: 186,\n        raquo: 187,\n        frac14: 188,\n        frac12: 189,\n        frac34: 190,\n        iquest: 191,\n        times: 215,\n        divide: 247,\n        OElig: 338,\n        oelig: 339,\n        Scaron: 352,\n        scaron: 353,\n        Yuml: 376,\n        fnof: 402,\n        circ: 710,\n        tilde: 732,\n        Alpha: 913,\n        Beta: 914,\n        Gamma: 915,\n        Delta: 916,\n        Epsilon: 917,\n        Zeta: 918,\n        Eta: 919,\n        Theta: 920,\n        Iota: 921,\n        Kappa: 922,\n        Lambda: 923,\n        Mu: 924,\n        Nu: 925,\n        Xi: 926,\n        Omicron: 927,\n        Pi: 928,\n        Rho: 929,\n        Sigma: 931,\n        Tau: 932,\n        Upsilon: 933,\n        Phi: 934,\n        Chi: 935,\n        Psi: 936,\n        Omega: 937,\n        alpha: 945,\n        beta: 946,\n        gamma: 947,\n        delta: 948,\n        epsilon: 949,\n        zeta: 950,\n        eta: 951,\n        theta: 952,\n        iota: 953,\n        kappa: 954,\n        lambda: 955,\n        mu: 956,\n        nu: 957,\n        xi: 958,\n        omicron: 959,\n        pi: 960,\n        rho: 961,\n        sigmaf: 962,\n        sigma: 963,\n        tau: 964,\n        upsilon: 965,\n        phi: 966,\n        chi: 967,\n        psi: 968,\n        omega: 969,\n        thetasym: 977,\n        upsih: 978,\n        piv: 982,\n        ensp: 8194,\n        emsp: 8195,\n        thinsp: 8201,\n        zwnj: 8204,\n        zwj: 8205,\n        lrm: 8206,\n        rlm: 8207,\n        ndash: 8211,\n        mdash: 8212,\n        lsquo: 8216,\n        rsquo: 8217,\n        sbquo: 8218,\n        ldquo: 8220,\n        rdquo: 8221,\n        bdquo: 8222,\n        dagger: 8224,\n        Dagger: 8225,\n        bull: 8226,\n        hellip: 8230,\n        permil: 8240,\n        prime: 8242,\n        Prime: 8243,\n        lsaquo: 8249,\n        rsaquo: 8250,\n        oline: 8254,\n        frasl: 8260,\n        euro: 8364,\n        image: 8465,\n        weierp: 8472,\n        real: 8476,\n        trade: 8482,\n        alefsym: 8501,\n        larr: 8592,\n        uarr: 8593,\n        rarr: 8594,\n        darr: 8595,\n        harr: 8596,\n        crarr: 8629,\n        lArr: 8656,\n        uArr: 8657,\n        rArr: 8658,\n        dArr: 8659,\n        hArr: 8660,\n        forall: 8704,\n        part: 8706,\n        exist: 8707,\n        empty: 8709,\n        nabla: 8711,\n        isin: 8712,\n        notin: 8713,\n        ni: 8715,\n        prod: 8719,\n        sum: 8721,\n        minus: 8722,\n        lowast: 8727,\n        radic: 8730,\n        prop: 8733,\n        infin: 8734,\n        ang: 8736,\n        and: 8743,\n        or: 8744,\n        cap: 8745,\n        cup: 8746,\n        int: 8747,\n        there4: 8756,\n        sim: 8764,\n        cong: 8773,\n        asymp: 8776,\n        ne: 8800,\n        equiv: 8801,\n        le: 8804,\n        ge: 8805,\n        sub: 8834,\n        sup: 8835,\n        nsub: 8836,\n        sube: 8838,\n        supe: 8839,\n        oplus: 8853,\n        otimes: 8855,\n        perp: 8869,\n        sdot: 8901,\n        lceil: 8968,\n        rceil: 8969,\n        lfloor: 8970,\n        rfloor: 8971,\n        lang: 9001,\n        rang: 9002,\n        loz: 9674,\n        spades: 9824,\n        clubs: 9827,\n        hearts: 9829,\n        diams: 9830,\n    };\n    Object.keys(sax.ENTITIES).forEach(function (key) {\n        var e = sax.ENTITIES[key];\n        var s = typeof e === \"number\" ? String.fromCharCode(e) : e;\n        sax.ENTITIES[key] = s;\n    });\n    for (var s in sax.STATE) {\n        sax.STATE[sax.STATE[s]] = s;\n    }\n    // shorthand\n    S = sax.STATE;\n    function emit(parser, event, data) {\n        parser[event] && parser[event](data);\n    }\n    function emitNode(parser, nodeType, data) {\n        if (parser.textNode)\n            closeText(parser);\n        emit(parser, nodeType, data);\n    }\n    function closeText(parser) {\n        parser.textNode = textopts(parser.opt, parser.textNode);\n        if (parser.textNode)\n            emit(parser, \"ontext\", parser.textNode);\n        parser.textNode = \"\";\n    }\n    function textopts(opt, text) {\n        if (opt.trim)\n            text = text.trim();\n        if (opt.normalize)\n            text = text.replace(/\\s+/g, \" \");\n        return text;\n    }\n    function error(parser, er) {\n        closeText(parser);\n        if (parser.trackPosition) {\n            er +=\n                \"\\nLine: \" +\n                    parser.line +\n                    \"\\nColumn: \" +\n                    parser.column +\n                    \"\\nChar: \" +\n                    parser.c;\n        }\n        er = new Error(er);\n        parser.error = er;\n        emit(parser, \"onerror\", er);\n        return parser;\n    }\n    function end(parser) {\n        if (parser.sawRoot && !parser.closedRoot)\n            strictFail(parser, \"Unclosed root tag\");\n        if (parser.state !== S.BEGIN &&\n            parser.state !== S.BEGIN_WHITESPACE &&\n            parser.state !== S.TEXT) {\n            error(parser, \"Unexpected end\");\n        }\n        closeText(parser);\n        parser.c = \"\";\n        parser.closed = true;\n        emit(parser, \"onend\");\n        SAXParser.call(parser, parser.strict, parser.opt);\n        return parser;\n    }\n    function strictFail(parser, message) {\n        if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n            throw new Error(\"bad call to strictFail\");\n        }\n        if (parser.strict) {\n            error(parser, message);\n        }\n    }\n    function newTag(parser) {\n        if (!parser.strict)\n            parser.tagName = parser.tagName[parser.looseCase]();\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        var tag = (parser.tag = { name: parser.tagName, attributes: {} });\n        // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n        if (parser.opt.xmlns) {\n            tag.ns = parent.ns;\n        }\n        parser.attribList.length = 0;\n        emitNode(parser, \"onopentagstart\", tag);\n    }\n    function qname(name, attribute) {\n        var i = name.indexOf(\":\");\n        var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n        var prefix = qualName[0];\n        var local = qualName[1];\n        // <x \"xmlns\"=\"http://foo\">\n        if (attribute && name === \"xmlns\") {\n            prefix = \"xmlns\";\n            local = \"\";\n        }\n        return { prefix: prefix, local: local };\n    }\n    function attrib(parser) {\n        if (!parser.strict) {\n            parser.attribName = parser.attribName[parser.looseCase]();\n        }\n        if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n            parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n            parser.attribName = parser.attribValue = \"\";\n            return;\n        }\n        if (parser.opt.xmlns) {\n            var qn = qname(parser.attribName, true);\n            var prefix = qn.prefix;\n            var local = qn.local;\n            if (prefix === \"xmlns\") {\n                // namespace binding attribute. push the binding into scope\n                if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n                    strictFail(parser, \"xml: prefix must be bound to \" +\n                        XML_NAMESPACE +\n                        \"\\n\" +\n                        \"Actual: \" +\n                        parser.attribValue);\n                }\n                else if (local === \"xmlns\" &&\n                    parser.attribValue !== XMLNS_NAMESPACE) {\n                    strictFail(parser, \"xmlns: prefix must be bound to \" +\n                        XMLNS_NAMESPACE +\n                        \"\\n\" +\n                        \"Actual: \" +\n                        parser.attribValue);\n                }\n                else {\n                    var tag = parser.tag;\n                    var parent = parser.tags[parser.tags.length - 1] || parser;\n                    if (tag.ns === parent.ns) {\n                        tag.ns = Object.create(parent.ns);\n                    }\n                    tag.ns[local] = parser.attribValue;\n                }\n            }\n            // defer onattribute events until all attributes have been seen\n            // so any new bindings can take effect. preserve attribute order\n            // so deferred events can be emitted in document order\n            parser.attribList.push([parser.attribName, parser.attribValue]);\n        }\n        else {\n            // in non-xmlns mode, we can emit the event right away\n            parser.tag.attributes[parser.attribName] = parser.attribValue;\n            emitNode(parser, \"onattribute\", {\n                name: parser.attribName,\n                value: parser.attribValue,\n            });\n        }\n        parser.attribName = parser.attribValue = \"\";\n    }\n    function openTag(parser, selfClosing) {\n        if (parser.opt.xmlns) {\n            // emit namespace binding events\n            var tag = parser.tag;\n            // add namespace info to tag\n            var qn = qname(parser.tagName);\n            tag.prefix = qn.prefix;\n            tag.local = qn.local;\n            tag.uri = tag.ns[qn.prefix] || \"\";\n            if (tag.prefix && !tag.uri) {\n                strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n                tag.uri = qn.prefix;\n            }\n            var parent = parser.tags[parser.tags.length - 1] || parser;\n            if (tag.ns && parent.ns !== tag.ns) {\n                Object.keys(tag.ns).forEach(function (p) {\n                    emitNode(parser, \"onopennamespace\", {\n                        prefix: p,\n                        uri: tag.ns[p],\n                    });\n                });\n            }\n            // handle deferred onattribute events\n            // Note: do not apply default ns to attributes:\n            //   http://www.w3.org/TR/REC-xml-names/#defaulting\n            for (var i = 0, l = parser.attribList.length; i < l; i++) {\n                var nv = parser.attribList[i];\n                var name = nv[0];\n                var value = nv[1];\n                var qualName = qname(name, true);\n                var prefix = qualName.prefix;\n                var local = qualName.local;\n                var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n                var a = {\n                    name: name,\n                    value: value,\n                    prefix: prefix,\n                    local: local,\n                    uri: uri,\n                };\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (prefix && prefix !== \"xmlns\" && !uri) {\n                    strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n                    a.uri = prefix;\n                }\n                parser.tag.attributes[name] = a;\n                emitNode(parser, \"onattribute\", a);\n            }\n            parser.attribList.length = 0;\n        }\n        parser.tag.isSelfClosing = !!selfClosing;\n        // process the tag\n        parser.sawRoot = true;\n        parser.tags.push(parser.tag);\n        emitNode(parser, \"onopentag\", parser.tag);\n        if (!selfClosing) {\n            // special case for <script> in non-strict mode.\n            if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n                parser.state = S.SCRIPT;\n            }\n            else {\n                parser.state = S.TEXT;\n            }\n            parser.tag = null;\n            parser.tagName = \"\";\n        }\n        parser.attribName = parser.attribValue = \"\";\n        parser.attribList.length = 0;\n    }\n    function closeTag(parser) {\n        if (!parser.tagName) {\n            strictFail(parser, \"Weird empty close tag.\");\n            parser.textNode += \"</>\";\n            parser.state = S.TEXT;\n            return;\n        }\n        if (parser.script) {\n            if (parser.tagName !== \"script\") {\n                parser.script += \"</\" + parser.tagName + \">\";\n                parser.tagName = \"\";\n                parser.state = S.SCRIPT;\n                return;\n            }\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n        }\n        // first make sure that the closing tag actually exists.\n        // <a><b></c></b></a> will close everything, otherwise.\n        var t = parser.tags.length;\n        var tagName = parser.tagName;\n        if (!parser.strict) {\n            tagName = tagName[parser.looseCase]();\n        }\n        var closeTo = tagName;\n        while (t--) {\n            var close = parser.tags[t];\n            if (close.name !== closeTo) {\n                // fail the first time in strict mode\n                strictFail(parser, \"Unexpected close tag\");\n            }\n            else {\n                break;\n            }\n        }\n        // didn't find it.  we already failed for strict, so just abort.\n        if (t < 0) {\n            strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n            parser.textNode += \"</\" + parser.tagName + \">\";\n            parser.state = S.TEXT;\n            return;\n        }\n        parser.tagName = tagName;\n        var s = parser.tags.length;\n        while (s-- > t) {\n            var tag = (parser.tag = parser.tags.pop());\n            parser.tagName = parser.tag.name;\n            emitNode(parser, \"onclosetag\", parser.tagName);\n            var x = {};\n            for (var i in tag.ns) {\n                x[i] = tag.ns[i];\n            }\n            var parent = parser.tags[parser.tags.length - 1] || parser;\n            if (parser.opt.xmlns && tag.ns !== parent.ns) {\n                // remove namespace bindings introduced by tag\n                Object.keys(tag.ns).forEach(function (p) {\n                    var n = tag.ns[p];\n                    emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n                });\n            }\n        }\n        if (t === 0)\n            parser.closedRoot = true;\n        parser.tagName = parser.attribValue = parser.attribName = \"\";\n        parser.attribList.length = 0;\n        parser.state = S.TEXT;\n    }\n    function parseEntity(parser) {\n        var entity = parser.entity;\n        var entityLC = entity.toLowerCase();\n        var num;\n        var numStr = \"\";\n        if (parser.ENTITIES[entity]) {\n            return parser.ENTITIES[entity];\n        }\n        if (parser.ENTITIES[entityLC]) {\n            return parser.ENTITIES[entityLC];\n        }\n        entity = entityLC;\n        if (entity.charAt(0) === \"#\") {\n            if (entity.charAt(1) === \"x\") {\n                entity = entity.slice(2);\n                num = parseInt(entity, 16);\n                numStr = num.toString(16);\n            }\n            else {\n                entity = entity.slice(1);\n                num = parseInt(entity, 10);\n                numStr = num.toString(10);\n            }\n        }\n        entity = entity.replace(/^0+/, \"\");\n        if (isNaN(num) || numStr.toLowerCase() !== entity) {\n            strictFail(parser, \"Invalid character entity\");\n            return \"&\" + parser.entity + \";\";\n        }\n        return String.fromCodePoint(num);\n    }\n    function beginWhiteSpace(parser, c) {\n        if (c === \"<\") {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n        }\n        else if (!isWhitespace(c)) {\n            // have to process this as a text node.\n            // weird, but happens.\n            strictFail(parser, \"Non-whitespace before first tag.\");\n            parser.textNode = c;\n            parser.state = S.TEXT;\n        }\n    }\n    function charAt(chunk, i) {\n        var result = \"\";\n        if (i < chunk.length) {\n            result = chunk.charAt(i);\n        }\n        return result;\n    }\n    function write(chunk) {\n        var parser = this;\n        if (this.error) {\n            throw this.error;\n        }\n        if (parser.closed) {\n            return error(parser, \"Cannot write after close. Assign an onready handler.\");\n        }\n        if (chunk === null) {\n            return end(parser);\n        }\n        if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        var i = 0;\n        var c = \"\";\n        while (true) {\n            c = charAt(chunk, i++);\n            parser.c = c;\n            if (!c) {\n                break;\n            }\n            if (parser.trackPosition) {\n                parser.position++;\n                if (c === \"\\n\") {\n                    parser.line++;\n                    parser.column = 0;\n                }\n                else {\n                    parser.column++;\n                }\n            }\n            switch (parser.state) {\n                case S.BEGIN:\n                    parser.state = S.BEGIN_WHITESPACE;\n                    if (c === \"\\uFEFF\") {\n                        continue;\n                    }\n                    beginWhiteSpace(parser, c);\n                    continue;\n                case S.BEGIN_WHITESPACE:\n                    beginWhiteSpace(parser, c);\n                    continue;\n                case S.TEXT:\n                    if (parser.sawRoot && !parser.closedRoot) {\n                        var starti = i - 1;\n                        while (c && c !== \"<\" && c !== \"&\") {\n                            c = charAt(chunk, i++);\n                            if (c && parser.trackPosition) {\n                                parser.position++;\n                                if (c === \"\\n\") {\n                                    parser.line++;\n                                    parser.column = 0;\n                                }\n                                else {\n                                    parser.column++;\n                                }\n                            }\n                        }\n                        parser.textNode += chunk.substring(starti, i - 1);\n                    }\n                    if (c === \"<\" &&\n                        !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n                        parser.state = S.OPEN_WAKA;\n                        parser.startTagPosition = parser.position;\n                    }\n                    else {\n                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n                            strictFail(parser, \"Text data outside of root node.\");\n                        }\n                        if (c === \"&\") {\n                            parser.state = S.TEXT_ENTITY;\n                        }\n                        else {\n                            parser.textNode += c;\n                        }\n                    }\n                    continue;\n                case S.SCRIPT:\n                    // only non-strict\n                    if (c === \"<\") {\n                        parser.state = S.SCRIPT_ENDING;\n                    }\n                    else {\n                        parser.script += c;\n                    }\n                    continue;\n                case S.SCRIPT_ENDING:\n                    if (c === \"/\") {\n                        parser.state = S.CLOSE_TAG;\n                    }\n                    else {\n                        parser.script += \"<\" + c;\n                        parser.state = S.SCRIPT;\n                    }\n                    continue;\n                case S.OPEN_WAKA:\n                    // either a /, ?, !, or text is coming next.\n                    if (c === \"!\") {\n                        parser.state = S.SGML_DECL;\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if (isWhitespace(c)) {\n                        // wait for it...\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        parser.state = S.OPEN_TAG;\n                        parser.tagName = c;\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.CLOSE_TAG;\n                        parser.tagName = \"\";\n                    }\n                    else if (c === \"?\") {\n                        parser.state = S.PROC_INST;\n                        parser.procInstName = parser.procInstBody = \"\";\n                    }\n                    else {\n                        strictFail(parser, \"Unencoded <\");\n                        // if there was some whitespace, then add that in.\n                        if (parser.startTagPosition + 1 < parser.position) {\n                            var pad = parser.position - parser.startTagPosition;\n                            c = new Array(pad).join(\" \") + c;\n                        }\n                        parser.textNode += \"<\" + c;\n                        parser.state = S.TEXT;\n                    }\n                    continue;\n                case S.SGML_DECL:\n                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n                        emitNode(parser, \"onopencdata\");\n                        parser.state = S.CDATA;\n                        parser.sgmlDecl = \"\";\n                        parser.cdata = \"\";\n                    }\n                    else if (parser.sgmlDecl + c === \"--\") {\n                        parser.state = S.COMMENT;\n                        parser.comment = \"\";\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n                        parser.state = S.DOCTYPE;\n                        if (parser.doctype || parser.sawRoot) {\n                            strictFail(parser, \"Inappropriately located doctype declaration\");\n                        }\n                        parser.doctype = \"\";\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if (c === \">\") {\n                        emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n                        parser.sgmlDecl = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else if (isQuote(c)) {\n                        parser.state = S.SGML_DECL_QUOTED;\n                        parser.sgmlDecl += c;\n                    }\n                    else {\n                        parser.sgmlDecl += c;\n                    }\n                    continue;\n                case S.SGML_DECL_QUOTED:\n                    if (c === parser.q) {\n                        parser.state = S.SGML_DECL;\n                        parser.q = \"\";\n                    }\n                    parser.sgmlDecl += c;\n                    continue;\n                case S.DOCTYPE:\n                    if (c === \">\") {\n                        parser.state = S.TEXT;\n                        emitNode(parser, \"ondoctype\", parser.doctype);\n                        parser.doctype = true; // just remember that we saw it.\n                    }\n                    else {\n                        parser.doctype += c;\n                        if (c === \"[\") {\n                            parser.state = S.DOCTYPE_DTD;\n                        }\n                        else if (isQuote(c)) {\n                            parser.state = S.DOCTYPE_QUOTED;\n                            parser.q = c;\n                        }\n                    }\n                    continue;\n                case S.DOCTYPE_QUOTED:\n                    parser.doctype += c;\n                    if (c === parser.q) {\n                        parser.q = \"\";\n                        parser.state = S.DOCTYPE;\n                    }\n                    continue;\n                case S.DOCTYPE_DTD:\n                    parser.doctype += c;\n                    if (c === \"]\") {\n                        parser.state = S.DOCTYPE;\n                    }\n                    else if (isQuote(c)) {\n                        parser.state = S.DOCTYPE_DTD_QUOTED;\n                        parser.q = c;\n                    }\n                    continue;\n                case S.DOCTYPE_DTD_QUOTED:\n                    parser.doctype += c;\n                    if (c === parser.q) {\n                        parser.state = S.DOCTYPE_DTD;\n                        parser.q = \"\";\n                    }\n                    continue;\n                case S.COMMENT:\n                    if (c === \"-\") {\n                        parser.state = S.COMMENT_ENDING;\n                    }\n                    else {\n                        parser.comment += c;\n                    }\n                    continue;\n                case S.COMMENT_ENDING:\n                    if (c === \"-\") {\n                        parser.state = S.COMMENT_ENDED;\n                        parser.comment = textopts(parser.opt, parser.comment);\n                        if (parser.comment) {\n                            emitNode(parser, \"oncomment\", parser.comment);\n                        }\n                        parser.comment = \"\";\n                    }\n                    else {\n                        parser.comment += \"-\" + c;\n                        parser.state = S.COMMENT;\n                    }\n                    continue;\n                case S.COMMENT_ENDED:\n                    if (c !== \">\") {\n                        strictFail(parser, \"Malformed comment\");\n                        // allow <!-- blah -- bloo --> in non-strict mode,\n                        // which is a comment of \" blah -- bloo \"\n                        parser.comment += \"--\" + c;\n                        parser.state = S.COMMENT;\n                    }\n                    else {\n                        parser.state = S.TEXT;\n                    }\n                    continue;\n                case S.CDATA:\n                    if (c === \"]\") {\n                        parser.state = S.CDATA_ENDING;\n                    }\n                    else {\n                        parser.cdata += c;\n                    }\n                    continue;\n                case S.CDATA_ENDING:\n                    if (c === \"]\") {\n                        parser.state = S.CDATA_ENDING_2;\n                    }\n                    else {\n                        parser.cdata += \"]\" + c;\n                        parser.state = S.CDATA;\n                    }\n                    continue;\n                case S.CDATA_ENDING_2:\n                    if (c === \">\") {\n                        if (parser.cdata) {\n                            emitNode(parser, \"oncdata\", parser.cdata);\n                        }\n                        emitNode(parser, \"onclosecdata\");\n                        parser.cdata = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else if (c === \"]\") {\n                        parser.cdata += \"]\";\n                    }\n                    else {\n                        parser.cdata += \"]]\" + c;\n                        parser.state = S.CDATA;\n                    }\n                    continue;\n                case S.PROC_INST:\n                    if (c === \"?\") {\n                        parser.state = S.PROC_INST_ENDING;\n                    }\n                    else if (isWhitespace(c)) {\n                        parser.state = S.PROC_INST_BODY;\n                    }\n                    else {\n                        parser.procInstName += c;\n                    }\n                    continue;\n                case S.PROC_INST_BODY:\n                    if (!parser.procInstBody && isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (c === \"?\") {\n                        parser.state = S.PROC_INST_ENDING;\n                    }\n                    else {\n                        parser.procInstBody += c;\n                    }\n                    continue;\n                case S.PROC_INST_ENDING:\n                    if (c === \">\") {\n                        emitNode(parser, \"onprocessinginstruction\", {\n                            name: parser.procInstName,\n                            body: parser.procInstBody,\n                        });\n                        parser.procInstName = parser.procInstBody = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else {\n                        parser.procInstBody += \"?\" + c;\n                        parser.state = S.PROC_INST_BODY;\n                    }\n                    continue;\n                case S.OPEN_TAG:\n                    if (isMatch(nameBody, c)) {\n                        parser.tagName += c;\n                    }\n                    else {\n                        newTag(parser);\n                        if (c === \">\") {\n                            openTag(parser);\n                        }\n                        else if (c === \"/\") {\n                            parser.state = S.OPEN_TAG_SLASH;\n                        }\n                        else {\n                            if (!isWhitespace(c)) {\n                                strictFail(parser, \"Invalid character in tag name\");\n                            }\n                            parser.state = S.ATTRIB;\n                        }\n                    }\n                    continue;\n                case S.OPEN_TAG_SLASH:\n                    if (c === \">\") {\n                        openTag(parser, true);\n                        closeTag(parser);\n                    }\n                    else {\n                        strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n                        parser.state = S.ATTRIB;\n                    }\n                    continue;\n                case S.ATTRIB:\n                    // haven't read the attribute name yet.\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.OPEN_TAG_SLASH;\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        parser.attribName = c;\n                        parser.attribValue = \"\";\n                        parser.state = S.ATTRIB_NAME;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_NAME:\n                    if (c === \"=\") {\n                        parser.state = S.ATTRIB_VALUE;\n                    }\n                    else if (c === \">\") {\n                        strictFail(parser, \"Attribute without value\");\n                        parser.attribValue = parser.attribName;\n                        attrib(parser);\n                        openTag(parser);\n                    }\n                    else if (isWhitespace(c)) {\n                        parser.state = S.ATTRIB_NAME_SAW_WHITE;\n                    }\n                    else if (isMatch(nameBody, c)) {\n                        parser.attribName += c;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_NAME_SAW_WHITE:\n                    if (c === \"=\") {\n                        parser.state = S.ATTRIB_VALUE;\n                    }\n                    else if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else {\n                        strictFail(parser, \"Attribute without value\");\n                        parser.tag.attributes[parser.attribName] = \"\";\n                        parser.attribValue = \"\";\n                        emitNode(parser, \"onattribute\", {\n                            name: parser.attribName,\n                            value: \"\",\n                        });\n                        parser.attribName = \"\";\n                        if (c === \">\") {\n                            openTag(parser);\n                        }\n                        else if (isMatch(nameStart, c)) {\n                            parser.attribName = c;\n                            parser.state = S.ATTRIB_NAME;\n                        }\n                        else {\n                            strictFail(parser, \"Invalid attribute name\");\n                            parser.state = S.ATTRIB;\n                        }\n                    }\n                    continue;\n                case S.ATTRIB_VALUE:\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (isQuote(c)) {\n                        parser.q = c;\n                        parser.state = S.ATTRIB_VALUE_QUOTED;\n                    }\n                    else {\n                        strictFail(parser, \"Unquoted attribute value\");\n                        parser.state = S.ATTRIB_VALUE_UNQUOTED;\n                        parser.attribValue = c;\n                    }\n                    continue;\n                case S.ATTRIB_VALUE_QUOTED:\n                    if (c !== parser.q) {\n                        if (c === \"&\") {\n                            parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n                        }\n                        else {\n                            parser.attribValue += c;\n                        }\n                        continue;\n                    }\n                    attrib(parser);\n                    parser.q = \"\";\n                    parser.state = S.ATTRIB_VALUE_CLOSED;\n                    continue;\n                case S.ATTRIB_VALUE_CLOSED:\n                    if (isWhitespace(c)) {\n                        parser.state = S.ATTRIB;\n                    }\n                    else if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.OPEN_TAG_SLASH;\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        strictFail(parser, \"No whitespace between attributes\");\n                        parser.attribName = c;\n                        parser.attribValue = \"\";\n                        parser.state = S.ATTRIB_NAME;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_VALUE_UNQUOTED:\n                    if (!isAttribEnd(c)) {\n                        if (c === \"&\") {\n                            parser.state = S.ATTRIB_VALUE_ENTITY_U;\n                        }\n                        else {\n                            parser.attribValue += c;\n                        }\n                        continue;\n                    }\n                    attrib(parser);\n                    if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else {\n                        parser.state = S.ATTRIB;\n                    }\n                    continue;\n                case S.CLOSE_TAG:\n                    if (!parser.tagName) {\n                        if (isWhitespace(c)) {\n                            continue;\n                        }\n                        else if (notMatch(nameStart, c)) {\n                            if (parser.script) {\n                                parser.script += \"</\" + c;\n                                parser.state = S.SCRIPT;\n                            }\n                            else {\n                                strictFail(parser, \"Invalid tagname in closing tag.\");\n                            }\n                        }\n                        else {\n                            parser.tagName = c;\n                        }\n                    }\n                    else if (c === \">\") {\n                        closeTag(parser);\n                    }\n                    else if (isMatch(nameBody, c)) {\n                        parser.tagName += c;\n                    }\n                    else if (parser.script) {\n                        parser.script += \"</\" + parser.tagName;\n                        parser.tagName = \"\";\n                        parser.state = S.SCRIPT;\n                    }\n                    else {\n                        if (!isWhitespace(c)) {\n                            strictFail(parser, \"Invalid tagname in closing tag\");\n                        }\n                        parser.state = S.CLOSE_TAG_SAW_WHITE;\n                    }\n                    continue;\n                case S.CLOSE_TAG_SAW_WHITE:\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    if (c === \">\") {\n                        closeTag(parser);\n                    }\n                    else {\n                        strictFail(parser, \"Invalid characters in closing tag\");\n                    }\n                    continue;\n                case S.TEXT_ENTITY:\n                case S.ATTRIB_VALUE_ENTITY_Q:\n                case S.ATTRIB_VALUE_ENTITY_U:\n                    var returnState;\n                    var buffer;\n                    switch (parser.state) {\n                        case S.TEXT_ENTITY:\n                            returnState = S.TEXT;\n                            buffer = \"textNode\";\n                            break;\n                        case S.ATTRIB_VALUE_ENTITY_Q:\n                            returnState = S.ATTRIB_VALUE_QUOTED;\n                            buffer = \"attribValue\";\n                            break;\n                        case S.ATTRIB_VALUE_ENTITY_U:\n                            returnState = S.ATTRIB_VALUE_UNQUOTED;\n                            buffer = \"attribValue\";\n                            break;\n                    }\n                    if (c === \";\") {\n                        if (parser.opt.unparsedEntities) {\n                            var parsedEntity = parseEntity(parser);\n                            parser.entity = \"\";\n                            parser.state = returnState;\n                            parser.write(parsedEntity);\n                        }\n                        else {\n                            parser[buffer] += parseEntity(parser);\n                            parser.entity = \"\";\n                            parser.state = returnState;\n                        }\n                    }\n                    else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n                        parser.entity += c;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid character in entity name\");\n                        parser[buffer] += \"&\" + parser.entity + c;\n                        parser.entity = \"\";\n                        parser.state = returnState;\n                    }\n                    continue;\n                default: /* istanbul ignore next */ {\n                    throw new Error(parser, \"Unknown state: \" + parser.state);\n                }\n            }\n        } // while\n        if (parser.position >= parser.bufferCheckPosition) {\n            checkBufferLength(parser);\n        }\n        return parser;\n    }\n    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n    /* istanbul ignore next */\n    if (!String.fromCodePoint) {\n        (function () {\n            var stringFromCharCode = String.fromCharCode;\n            var floor = Math.floor;\n            var fromCodePoint = function () {\n                var MAX_SIZE = 0x4000;\n                var codeUnits = [];\n                var highSurrogate;\n                var lowSurrogate;\n                var index = -1;\n                var length = arguments.length;\n                if (!length) {\n                    return \"\";\n                }\n                var result = \"\";\n                while (++index < length) {\n                    var codePoint = Number(arguments[index]);\n                    if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                        codePoint < 0 || // not a valid Unicode code point\n                        codePoint > 0x10ffff || // not a valid Unicode code point\n                        floor(codePoint) !== codePoint // not an integer\n                    ) {\n                        throw RangeError(\"Invalid code point: \" + codePoint);\n                    }\n                    if (codePoint <= 0xffff) {\n                        // BMP code point\n                        codeUnits.push(codePoint);\n                    }\n                    else {\n                        // Astral code point; split in surrogate halves\n                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                        codePoint -= 0x10000;\n                        highSurrogate = (codePoint >> 10) + 0xd800;\n                        lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                        codeUnits.push(highSurrogate, lowSurrogate);\n                    }\n                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                        result += stringFromCharCode.apply(null, codeUnits);\n                        codeUnits.length = 0;\n                    }\n                }\n                return result;\n            };\n            /* istanbul ignore next */\n            if (Object.defineProperty) {\n                Object.defineProperty(String, \"fromCodePoint\", {\n                    value: fromCodePoint,\n                    configurable: true,\n                    writable: true,\n                });\n            }\n            else {\n                String.fromCodePoint = fromCodePoint;\n            }\n        })();\n    }\n    return sax;\n};\nconst sax = /** #__PURE__ */ initializeSax();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc2F4LWpzL3NheC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNDQUFzQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1CQUFtQjtBQUM5RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDZSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcc2F4LWpzXFxzYXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcbi8vIElubGluZWQgdG8gZGVhbCB3aXRoIHBvcnRhYmlsaXR5IGlzc3Vlc1xuLy8gT3JpZ2luYWxseSBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL3NheC1qc1xuY29uc3QgaW5pdGlhbGl6ZVNheCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzYXggPSB7fTtcbiAgICBzYXgucGFyc2VyID0gZnVuY3Rpb24gKHN0cmljdCwgb3B0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KTtcbiAgICB9O1xuICAgIHNheC5TQVhQYXJzZXIgPSBTQVhQYXJzZXI7XG4gICAgc2F4LlNBWFN0cmVhbSA9IFNBWFN0cmVhbTtcbiAgICBzYXguY3JlYXRlU3RyZWFtID0gY3JlYXRlU3RyZWFtO1xuICAgIC8vIFdoZW4gd2UgcGFzcyB0aGUgTUFYX0JVRkZFUl9MRU5HVEggcG9zaXRpb24sIHN0YXJ0IGNoZWNraW5nIGZvciBidWZmZXIgb3ZlcnJ1bnMuXG4gICAgLy8gV2hlbiB3ZSBjaGVjaywgc2NoZWR1bGUgdGhlIG5leHQgY2hlY2sgZm9yIE1BWF9CVUZGRVJfTEVOR1RIIC0gKG1heChidWZmZXIgbGVuZ3RocykpLFxuICAgIC8vIHNpbmNlIHRoYXQncyB0aGUgZWFybGllc3QgdGhhdCBhIGJ1ZmZlciBvdmVycnVuIGNvdWxkIG9jY3VyLiAgVGhpcyB3YXksIGNoZWNrcyBhcmVcbiAgICAvLyBhcyByYXJlIGFzIHJlcXVpcmVkLCBidXQgYXMgb2Z0ZW4gYXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBuZXZlciBjcm9zc2luZyB0aGlzIGJvdW5kLlxuICAgIC8vIEZ1cnRoZXJtb3JlLCBidWZmZXJzIGFyZSBvbmx5IHRlc3RlZCBhdCBtb3N0IG9uY2UgcGVyIHdyaXRlKCksIHNvIHBhc3NpbmcgYSB2ZXJ5XG4gICAgLy8gbGFyZ2Ugc3RyaW5nIGludG8gd3JpdGUoKSBtaWdodCBoYXZlIHVuZGVzaXJhYmxlIGVmZmVjdHMsIGJ1dCB0aGlzIGlzIG1hbmFnZWFibGUgYnlcbiAgICAvLyB0aGUgY2FsbGVyLCBzbyBpdCBpcyBhc3N1bWVkIHRvIGJlIHNhZmUuICBUaHVzLCBhIGNhbGwgdG8gd3JpdGUoKSBtYXksIGluIHRoZSBleHRyZW1lXG4gICAgLy8gZWRnZSBjYXNlLCByZXN1bHQgaW4gY3JlYXRpbmcgYXQgbW9zdCBvbmUgY29tcGxldGUgY29weSBvZiB0aGUgc3RyaW5nIHBhc3NlZCBpbi5cbiAgICAvLyBTZXQgdG8gSW5maW5pdHkgdG8gaGF2ZSB1bmxpbWl0ZWQgYnVmZmVycy5cbiAgICBzYXguTUFYX0JVRkZFUl9MRU5HVEggPSA2NCAqIDEwMjQ7XG4gICAgY29uc3QgYnVmZmVycyA9IFtcbiAgICAgICAgXCJjb21tZW50XCIsXG4gICAgICAgIFwic2dtbERlY2xcIixcbiAgICAgICAgXCJ0ZXh0Tm9kZVwiLFxuICAgICAgICBcInRhZ05hbWVcIixcbiAgICAgICAgXCJkb2N0eXBlXCIsXG4gICAgICAgIFwicHJvY0luc3ROYW1lXCIsXG4gICAgICAgIFwicHJvY0luc3RCb2R5XCIsXG4gICAgICAgIFwiZW50aXR5XCIsXG4gICAgICAgIFwiYXR0cmliTmFtZVwiLFxuICAgICAgICBcImF0dHJpYlZhbHVlXCIsXG4gICAgICAgIFwiY2RhdGFcIixcbiAgICAgICAgXCJzY3JpcHRcIixcbiAgICBdO1xuICAgIHNheC5FVkVOVFMgPSBbXG4gICAgICAgIFwidGV4dFwiLFxuICAgICAgICBcInByb2Nlc3NpbmdpbnN0cnVjdGlvblwiLFxuICAgICAgICBcInNnbWxkZWNsYXJhdGlvblwiLFxuICAgICAgICBcImRvY3R5cGVcIixcbiAgICAgICAgXCJjb21tZW50XCIsXG4gICAgICAgIFwib3BlbnRhZ3N0YXJ0XCIsXG4gICAgICAgIFwiYXR0cmlidXRlXCIsXG4gICAgICAgIFwib3BlbnRhZ1wiLFxuICAgICAgICBcImNsb3NldGFnXCIsXG4gICAgICAgIFwib3BlbmNkYXRhXCIsXG4gICAgICAgIFwiY2RhdGFcIixcbiAgICAgICAgXCJjbG9zZWNkYXRhXCIsXG4gICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgXCJlbmRcIixcbiAgICAgICAgXCJyZWFkeVwiLFxuICAgICAgICBcInNjcmlwdFwiLFxuICAgICAgICBcIm9wZW5uYW1lc3BhY2VcIixcbiAgICAgICAgXCJjbG9zZW5hbWVzcGFjZVwiLFxuICAgIF07XG4gICAgZnVuY3Rpb24gU0FYUGFyc2VyKHN0cmljdCwgb3B0KSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTQVhQYXJzZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnNlciA9IHRoaXM7XG4gICAgICAgIGNsZWFyQnVmZmVycyhwYXJzZXIpO1xuICAgICAgICBwYXJzZXIucSA9IHBhcnNlci5jID0gXCJcIjtcbiAgICAgICAgcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24gPSBzYXguTUFYX0JVRkZFUl9MRU5HVEg7XG4gICAgICAgIHBhcnNlci5vcHQgPSBvcHQgfHwge307XG4gICAgICAgIHBhcnNlci5vcHQubG93ZXJjYXNlID0gcGFyc2VyLm9wdC5sb3dlcmNhc2UgfHwgcGFyc2VyLm9wdC5sb3dlcmNhc2V0YWdzO1xuICAgICAgICBwYXJzZXIubG9vc2VDYXNlID0gcGFyc2VyLm9wdC5sb3dlcmNhc2UgPyBcInRvTG93ZXJDYXNlXCIgOiBcInRvVXBwZXJDYXNlXCI7XG4gICAgICAgIHBhcnNlci50YWdzID0gW107XG4gICAgICAgIHBhcnNlci5jbG9zZWQgPSBwYXJzZXIuY2xvc2VkUm9vdCA9IHBhcnNlci5zYXdSb290ID0gZmFsc2U7XG4gICAgICAgIHBhcnNlci50YWcgPSBwYXJzZXIuZXJyb3IgPSBudWxsO1xuICAgICAgICBwYXJzZXIuc3RyaWN0ID0gISFzdHJpY3Q7XG4gICAgICAgIHBhcnNlci5ub3NjcmlwdCA9ICEhKHN0cmljdCB8fCBwYXJzZXIub3B0Lm5vc2NyaXB0KTtcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTjtcbiAgICAgICAgcGFyc2VyLnN0cmljdEVudGl0aWVzID0gcGFyc2VyLm9wdC5zdHJpY3RFbnRpdGllcztcbiAgICAgICAgcGFyc2VyLkVOVElUSUVTID0gcGFyc2VyLnN0cmljdEVudGl0aWVzXG4gICAgICAgICAgICA/IE9iamVjdC5jcmVhdGUoc2F4LlhNTF9FTlRJVElFUylcbiAgICAgICAgICAgIDogT2JqZWN0LmNyZWF0ZShzYXguRU5USVRJRVMpO1xuICAgICAgICBwYXJzZXIuYXR0cmliTGlzdCA9IFtdO1xuICAgICAgICAvLyBuYW1lc3BhY2VzIGZvcm0gYSBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgIC8vIGl0IGFsd2F5cyBwb2ludHMgYXQgdGhlIGN1cnJlbnQgdGFnLFxuICAgICAgICAvLyB3aGljaCBwcm90b3MgdG8gaXRzIHBhcmVudCB0YWcuXG4gICAgICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICAgICAgICBwYXJzZXIubnMgPSBPYmplY3QuY3JlYXRlKHJvb3ROUyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW9zdGx5IGp1c3QgZm9yIGVycm9yIHJlcG9ydGluZ1xuICAgICAgICBwYXJzZXIudHJhY2tQb3NpdGlvbiA9IHBhcnNlci5vcHQucG9zaXRpb24gIT09IGZhbHNlO1xuICAgICAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBhcnNlci5wb3NpdGlvbiA9IHBhcnNlci5saW5lID0gcGFyc2VyLmNvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdChwYXJzZXIsIFwib25yZWFkeVwiKTtcbiAgICB9XG4gICAgaWYgKCFPYmplY3QuY3JlYXRlKSB7XG4gICAgICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgZnVuY3Rpb24gRigpIHsgfVxuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvO1xuICAgICAgICAgICAgdmFyIG5ld2YgPSBuZXcgRigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld2Y7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbylcbiAgICAgICAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSlcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGkpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQnVmZmVyTGVuZ3RoKHBhcnNlcikge1xuICAgICAgICB2YXIgbWF4QWxsb3dlZCA9IE1hdGgubWF4KHNheC5NQVhfQlVGRkVSX0xFTkdUSCwgMTApO1xuICAgICAgICB2YXIgbWF4QWN0dWFsID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHBhcnNlcltidWZmZXJzW2ldXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuID4gbWF4QWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRleHQvY2RhdGEgbm9kZXMgY2FuIGdldCBiaWcsIGFuZCBzaW5jZSB0aGV5J3JlIGJ1ZmZlcmVkLFxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBnZXQgaGVyZSB1bmRlciBub3JtYWwgY29uZGl0aW9ucy5cbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBpc3N1ZXMgYnkgZW1pdHRpbmcgdGhlIHRleHQgbm9kZSBub3csXG4gICAgICAgICAgICAgICAgLy8gc28gYXQgbGVhc3QgaXQgd29uJ3QgZ2V0IGFueSBiaWdnZXIuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChidWZmZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0Tm9kZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VUZXh0KHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25jZGF0YVwiLCBwYXJzZXIuY2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25zY3JpcHRcIiwgcGFyc2VyLnNjcmlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IocGFyc2VyLCBcIk1heCBidWZmZXIgbGVuZ3RoIGV4Y2VlZGVkOiBcIiArIGJ1ZmZlcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1heEFjdHVhbCA9IE1hdGgubWF4KG1heEFjdHVhbCwgbGVuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgdGhlIGVhcmxpZXN0IHBvc3NpYmxlIGJ1ZmZlciBvdmVycnVuLlxuICAgICAgICB2YXIgbSA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSCAtIG1heEFjdHVhbDtcbiAgICAgICAgcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24gPSBtICsgcGFyc2VyLnBvc2l0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhckJ1ZmZlcnMocGFyc2VyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHBhcnNlcltidWZmZXJzW2ldXSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hCdWZmZXJzKHBhcnNlcikge1xuICAgICAgICBjbG9zZVRleHQocGFyc2VyKTtcbiAgICAgICAgaWYgKHBhcnNlci5jZGF0YSAhPT0gXCJcIikge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY2RhdGFcIiwgcGFyc2VyLmNkYXRhKTtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5zY3JpcHQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbnNjcmlwdFwiLCBwYXJzZXIuc2NyaXB0KTtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNBWFBhcnNlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZW5kKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogd3JpdGUsXG4gICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmx1c2hCdWZmZXJzKHRoaXMpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgdmFyIFN0cmVhbSA9IFJlYWRhYmxlU3RyZWFtO1xuICAgIGlmICghU3RyZWFtKVxuICAgICAgICBTdHJlYW0gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgdmFyIHN0cmVhbVdyYXBzID0gc2F4LkVWRU5UUy5maWx0ZXIoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHJldHVybiBldiAhPT0gXCJlcnJvclwiICYmIGV2ICE9PSBcImVuZFwiO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbShzdHJpY3QsIG9wdCkge1xuICAgICAgICByZXR1cm4gbmV3IFNBWFN0cmVhbShzdHJpY3QsIG9wdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNBWFN0cmVhbShzdHJpY3QsIG9wdCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYU3RyZWFtKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpO1xuICAgICAgICB9XG4gICAgICAgIFN0cmVhbS5hcHBseSh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFyc2VyID0gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdCk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdGhpcy5fcGFyc2VyLm9uZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWUuZW1pdChcImVuZFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGFyc2VyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgICAgIG1lLmVtaXQoXCJlcnJvclwiLCBlcik7XG4gICAgICAgICAgICAvLyBpZiBkaWRuJ3QgdGhyb3csIHRoZW4gbWVhbnMgZXJyb3Igd2FzIGhhbmRsZWQuXG4gICAgICAgICAgICAvLyBnbyBhaGVhZCBhbmQgY2xlYXIgZXJyb3IsIHNvIHdlIGNhbiB3cml0ZSBhZ2Fpbi5cbiAgICAgICAgICAgIG1lLl9wYXJzZXIuZXJyb3IgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kZWNvZGVyID0gbnVsbDtcbiAgICAgICAgc3RyZWFtV3JhcHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgXCJvblwiICsgZXYsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLl9wYXJzZXJbXCJvblwiICsgZXZdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnJlbW92ZUFsbExpc3RlbmVycyhldik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fcGFyc2VyW1wib25cIiArIGV2XSA9IGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZS5vbihldiwgaCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFNBWFN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cmVhbS5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBTQVhTdHJlYW0sXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgU0FYU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlci53cml0ZShkYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFNBWFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcnNlci5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTQVhTdHJlYW0ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUuX3BhcnNlcltcIm9uXCIgKyBldl0gJiYgc3RyZWFtV3JhcHMuaW5kZXhPZihldikgIT09IC0xKSB7XG4gICAgICAgICAgICBtZS5fcGFyc2VyW1wib25cIiArIGV2XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICAgICAgICAgPyBbYXJndW1lbnRzWzBdXVxuICAgICAgICAgICAgICAgICAgICA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgYXJncy5zcGxpY2UoMCwgMCwgZXYpO1xuICAgICAgICAgICAgICAgIG1lLmVtaXQuYXBwbHkobWUsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKG1lLCBldiwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvLyB0aGlzIHJlYWxseSBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGNoYXJhY3RlciBjbGFzc2VzLlxuICAgIC8vIFhNTCBhbGxvd3MgYWxsIG1hbm5lciBvZiByaWRpY3Vsb3VzIG51bWJlcnMgYW5kIGRpZ2l0cy5cbiAgICB2YXIgQ0RBVEEgPSBcIltDREFUQVtcIjtcbiAgICB2YXIgRE9DVFlQRSA9IFwiRE9DVFlQRVwiO1xuICAgIHZhciBYTUxfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIjtcbiAgICB2YXIgWE1MTlNfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiO1xuICAgIHZhciByb290TlMgPSB7IHhtbDogWE1MX05BTUVTUEFDRSwgeG1sbnM6IFhNTE5TX05BTUVTUEFDRSB9O1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVTdGFydENoYXJcbiAgICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHdvcmtzIG9uIHN0cmluZ3MsIGEgc2luZ2xlIGNoYXJhY3RlciBhdCBhIHRpbWVcbiAgICAvLyBhcyBzdWNoLCBpdCBjYW5ub3QgZXZlciBzdXBwb3J0IGFzdHJhbC1wbGFuZSBjaGFyYWN0ZXJzICgxMDAwMC1FRkZGRilcbiAgICAvLyB3aXRob3V0IGEgc2lnbmlmaWNhbnQgYnJlYWtpbmcgY2hhbmdlIHRvIGVpdGhlciB0aGlzICBwYXJzZXIsIG9yIHRoZVxuICAgIC8vIEphdmFTY3JpcHQgbGFuZ3VhZ2UuICBJbXBsZW1lbnRhdGlvbiBvZiBhbiBlbW9qaS1jYXBhYmxlIHhtbCBwYXJzZXJcbiAgICAvLyBpcyBsZWZ0IGFzIGFuIGV4ZXJjaXNlIGZvciB0aGUgcmVhZGVyLlxuICAgIHZhciBuYW1lU3RhcnQgPSAvWzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS87XG4gICAgdmFyIG5hbWVCb2R5ID0gL1s6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vO1xuICAgIHZhciBlbnRpdHlTdGFydCA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS87XG4gICAgdmFyIGVudGl0eUJvZHkgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vO1xuICAgIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKSB7XG4gICAgICAgIHJldHVybiBjID09PSBcIiBcIiB8fCBjID09PSBcIlxcblwiIHx8IGMgPT09IFwiXFxyXCIgfHwgYyA9PT0gXCJcXHRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNRdW90ZShjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAnXCInIHx8IGMgPT09IFwiJ1wiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0F0dHJpYkVuZChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSBcIj5cIiB8fCBpc1doaXRlc3BhY2UoYyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTWF0Y2gocmVnZXgsIGMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoYyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vdE1hdGNoKHJlZ2V4LCBjKSB7XG4gICAgICAgIHJldHVybiAhaXNNYXRjaChyZWdleCwgYyk7XG4gICAgfVxuICAgIHZhciBTID0gMDtcbiAgICBzYXguU1RBVEUgPSB7XG4gICAgICAgIEJFR0lOOiBTKyssIC8vIGxlYWRpbmcgYnl0ZSBvcmRlciBtYXJrIG9yIHdoaXRlc3BhY2VcbiAgICAgICAgQkVHSU5fV0hJVEVTUEFDRTogUysrLCAvLyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgVEVYVDogUysrLCAvLyBnZW5lcmFsIHN0dWZmXG4gICAgICAgIFRFWFRfRU5USVRZOiBTKyssIC8vICZhbXAgYW5kIHN1Y2guXG4gICAgICAgIE9QRU5fV0FLQTogUysrLCAvLyA8XG4gICAgICAgIFNHTUxfREVDTDogUysrLCAvLyA8IUJMQVJHXG4gICAgICAgIFNHTUxfREVDTF9RVU9URUQ6IFMrKywgLy8gPCFCTEFSRyBmb28gXCJiYXJcbiAgICAgICAgRE9DVFlQRTogUysrLCAvLyA8IURPQ1RZUEVcbiAgICAgICAgRE9DVFlQRV9RVU9URUQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXG4gICAgICAgIERPQ1RZUEVfRFREOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgLi4uXG4gICAgICAgIERPQ1RZUEVfRFREX1FVT1RFRDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcIiBbIFwiZm9vXG4gICAgICAgIENPTU1FTlRfU1RBUlRJTkc6IFMrKywgLy8gPCEtXG4gICAgICAgIENPTU1FTlQ6IFMrKywgLy8gPCEtLVxuICAgICAgICBDT01NRU5UX0VORElORzogUysrLCAvLyA8IS0tIGJsYWggLVxuICAgICAgICBDT01NRU5UX0VOREVEOiBTKyssIC8vIDwhLS0gYmxhaCAtLVxuICAgICAgICBDREFUQTogUysrLCAvLyA8IVtDREFUQVsgc29tZXRoaW5nXG4gICAgICAgIENEQVRBX0VORElORzogUysrLCAvLyBdXG4gICAgICAgIENEQVRBX0VORElOR18yOiBTKyssIC8vIF1dXG4gICAgICAgIFBST0NfSU5TVDogUysrLCAvLyA8P2hpXG4gICAgICAgIFBST0NfSU5TVF9CT0RZOiBTKyssIC8vIDw/aGkgdGhlcmVcbiAgICAgICAgUFJPQ19JTlNUX0VORElORzogUysrLCAvLyA8P2hpIFwidGhlcmVcIiA/XG4gICAgICAgIE9QRU5fVEFHOiBTKyssIC8vIDxzdHJvbmdcbiAgICAgICAgT1BFTl9UQUdfU0xBU0g6IFMrKywgLy8gPHN0cm9uZyAvXG4gICAgICAgIEFUVFJJQjogUysrLCAvLyA8YVxuICAgICAgICBBVFRSSUJfTkFNRTogUysrLCAvLyA8YSBmb29cbiAgICAgICAgQVRUUklCX05BTUVfU0FXX1dISVRFOiBTKyssIC8vIDxhIGZvbyBfXG4gICAgICAgIEFUVFJJQl9WQUxVRTogUysrLCAvLyA8YSBmb289XG4gICAgICAgIEFUVFJJQl9WQUxVRV9RVU9URUQ6IFMrKywgLy8gPGEgZm9vPVwiYmFyXG4gICAgICAgIEFUVFJJQl9WQUxVRV9DTE9TRUQ6IFMrKywgLy8gPGEgZm9vPVwiYmFyXCJcbiAgICAgICAgQVRUUklCX1ZBTFVFX1VOUVVPVEVEOiBTKyssIC8vIDxhIGZvbz1iYXJcbiAgICAgICAgQVRUUklCX1ZBTFVFX0VOVElUWV9ROiBTKyssIC8vIDxmb28gYmFyPVwiJnF1b3Q7XCJcbiAgICAgICAgQVRUUklCX1ZBTFVFX0VOVElUWV9VOiBTKyssIC8vIDxmb28gYmFyPSZxdW90XG4gICAgICAgIENMT1NFX1RBRzogUysrLCAvLyA8L2FcbiAgICAgICAgQ0xPU0VfVEFHX1NBV19XSElURTogUysrLCAvLyA8L2EgICA+XG4gICAgICAgIFNDUklQVDogUysrLCAvLyA8c2NyaXB0PiAuLi5cbiAgICAgICAgU0NSSVBUX0VORElORzogUysrLCAvLyA8c2NyaXB0PiAuLi4gPFxuICAgIH07XG4gICAgc2F4LlhNTF9FTlRJVElFUyA9IHtcbiAgICAgICAgYW1wOiBcIiZcIixcbiAgICAgICAgZ3Q6IFwiPlwiLFxuICAgICAgICBsdDogXCI8XCIsXG4gICAgICAgIHF1b3Q6ICdcIicsXG4gICAgICAgIGFwb3M6IFwiJ1wiLFxuICAgIH07XG4gICAgc2F4LkVOVElUSUVTID0ge1xuICAgICAgICBhbXA6IFwiJlwiLFxuICAgICAgICBndDogXCI+XCIsXG4gICAgICAgIGx0OiBcIjxcIixcbiAgICAgICAgcXVvdDogJ1wiJyxcbiAgICAgICAgYXBvczogXCInXCIsXG4gICAgICAgIEFFbGlnOiAxOTgsXG4gICAgICAgIEFhY3V0ZTogMTkzLFxuICAgICAgICBBY2lyYzogMTk0LFxuICAgICAgICBBZ3JhdmU6IDE5MixcbiAgICAgICAgQXJpbmc6IDE5NyxcbiAgICAgICAgQXRpbGRlOiAxOTUsXG4gICAgICAgIEF1bWw6IDE5NixcbiAgICAgICAgQ2NlZGlsOiAxOTksXG4gICAgICAgIEVUSDogMjA4LFxuICAgICAgICBFYWN1dGU6IDIwMSxcbiAgICAgICAgRWNpcmM6IDIwMixcbiAgICAgICAgRWdyYXZlOiAyMDAsXG4gICAgICAgIEV1bWw6IDIwMyxcbiAgICAgICAgSWFjdXRlOiAyMDUsXG4gICAgICAgIEljaXJjOiAyMDYsXG4gICAgICAgIElncmF2ZTogMjA0LFxuICAgICAgICBJdW1sOiAyMDcsXG4gICAgICAgIE50aWxkZTogMjA5LFxuICAgICAgICBPYWN1dGU6IDIxMSxcbiAgICAgICAgT2NpcmM6IDIxMixcbiAgICAgICAgT2dyYXZlOiAyMTAsXG4gICAgICAgIE9zbGFzaDogMjE2LFxuICAgICAgICBPdGlsZGU6IDIxMyxcbiAgICAgICAgT3VtbDogMjE0LFxuICAgICAgICBUSE9STjogMjIyLFxuICAgICAgICBVYWN1dGU6IDIxOCxcbiAgICAgICAgVWNpcmM6IDIxOSxcbiAgICAgICAgVWdyYXZlOiAyMTcsXG4gICAgICAgIFV1bWw6IDIyMCxcbiAgICAgICAgWWFjdXRlOiAyMjEsXG4gICAgICAgIGFhY3V0ZTogMjI1LFxuICAgICAgICBhY2lyYzogMjI2LFxuICAgICAgICBhZWxpZzogMjMwLFxuICAgICAgICBhZ3JhdmU6IDIyNCxcbiAgICAgICAgYXJpbmc6IDIyOSxcbiAgICAgICAgYXRpbGRlOiAyMjcsXG4gICAgICAgIGF1bWw6IDIyOCxcbiAgICAgICAgY2NlZGlsOiAyMzEsXG4gICAgICAgIGVhY3V0ZTogMjMzLFxuICAgICAgICBlY2lyYzogMjM0LFxuICAgICAgICBlZ3JhdmU6IDIzMixcbiAgICAgICAgZXRoOiAyNDAsXG4gICAgICAgIGV1bWw6IDIzNSxcbiAgICAgICAgaWFjdXRlOiAyMzcsXG4gICAgICAgIGljaXJjOiAyMzgsXG4gICAgICAgIGlncmF2ZTogMjM2LFxuICAgICAgICBpdW1sOiAyMzksXG4gICAgICAgIG50aWxkZTogMjQxLFxuICAgICAgICBvYWN1dGU6IDI0MyxcbiAgICAgICAgb2NpcmM6IDI0NCxcbiAgICAgICAgb2dyYXZlOiAyNDIsXG4gICAgICAgIG9zbGFzaDogMjQ4LFxuICAgICAgICBvdGlsZGU6IDI0NSxcbiAgICAgICAgb3VtbDogMjQ2LFxuICAgICAgICBzemxpZzogMjIzLFxuICAgICAgICB0aG9ybjogMjU0LFxuICAgICAgICB1YWN1dGU6IDI1MCxcbiAgICAgICAgdWNpcmM6IDI1MSxcbiAgICAgICAgdWdyYXZlOiAyNDksXG4gICAgICAgIHV1bWw6IDI1MixcbiAgICAgICAgeWFjdXRlOiAyNTMsXG4gICAgICAgIHl1bWw6IDI1NSxcbiAgICAgICAgY29weTogMTY5LFxuICAgICAgICByZWc6IDE3NCxcbiAgICAgICAgbmJzcDogMTYwLFxuICAgICAgICBpZXhjbDogMTYxLFxuICAgICAgICBjZW50OiAxNjIsXG4gICAgICAgIHBvdW5kOiAxNjMsXG4gICAgICAgIGN1cnJlbjogMTY0LFxuICAgICAgICB5ZW46IDE2NSxcbiAgICAgICAgYnJ2YmFyOiAxNjYsXG4gICAgICAgIHNlY3Q6IDE2NyxcbiAgICAgICAgdW1sOiAxNjgsXG4gICAgICAgIG9yZGY6IDE3MCxcbiAgICAgICAgbGFxdW86IDE3MSxcbiAgICAgICAgbm90OiAxNzIsXG4gICAgICAgIHNoeTogMTczLFxuICAgICAgICBtYWNyOiAxNzUsXG4gICAgICAgIGRlZzogMTc2LFxuICAgICAgICBwbHVzbW46IDE3NyxcbiAgICAgICAgc3VwMTogMTg1LFxuICAgICAgICBzdXAyOiAxNzgsXG4gICAgICAgIHN1cDM6IDE3OSxcbiAgICAgICAgYWN1dGU6IDE4MCxcbiAgICAgICAgbWljcm86IDE4MSxcbiAgICAgICAgcGFyYTogMTgyLFxuICAgICAgICBtaWRkb3Q6IDE4MyxcbiAgICAgICAgY2VkaWw6IDE4NCxcbiAgICAgICAgb3JkbTogMTg2LFxuICAgICAgICByYXF1bzogMTg3LFxuICAgICAgICBmcmFjMTQ6IDE4OCxcbiAgICAgICAgZnJhYzEyOiAxODksXG4gICAgICAgIGZyYWMzNDogMTkwLFxuICAgICAgICBpcXVlc3Q6IDE5MSxcbiAgICAgICAgdGltZXM6IDIxNSxcbiAgICAgICAgZGl2aWRlOiAyNDcsXG4gICAgICAgIE9FbGlnOiAzMzgsXG4gICAgICAgIG9lbGlnOiAzMzksXG4gICAgICAgIFNjYXJvbjogMzUyLFxuICAgICAgICBzY2Fyb246IDM1MyxcbiAgICAgICAgWXVtbDogMzc2LFxuICAgICAgICBmbm9mOiA0MDIsXG4gICAgICAgIGNpcmM6IDcxMCxcbiAgICAgICAgdGlsZGU6IDczMixcbiAgICAgICAgQWxwaGE6IDkxMyxcbiAgICAgICAgQmV0YTogOTE0LFxuICAgICAgICBHYW1tYTogOTE1LFxuICAgICAgICBEZWx0YTogOTE2LFxuICAgICAgICBFcHNpbG9uOiA5MTcsXG4gICAgICAgIFpldGE6IDkxOCxcbiAgICAgICAgRXRhOiA5MTksXG4gICAgICAgIFRoZXRhOiA5MjAsXG4gICAgICAgIElvdGE6IDkyMSxcbiAgICAgICAgS2FwcGE6IDkyMixcbiAgICAgICAgTGFtYmRhOiA5MjMsXG4gICAgICAgIE11OiA5MjQsXG4gICAgICAgIE51OiA5MjUsXG4gICAgICAgIFhpOiA5MjYsXG4gICAgICAgIE9taWNyb246IDkyNyxcbiAgICAgICAgUGk6IDkyOCxcbiAgICAgICAgUmhvOiA5MjksXG4gICAgICAgIFNpZ21hOiA5MzEsXG4gICAgICAgIFRhdTogOTMyLFxuICAgICAgICBVcHNpbG9uOiA5MzMsXG4gICAgICAgIFBoaTogOTM0LFxuICAgICAgICBDaGk6IDkzNSxcbiAgICAgICAgUHNpOiA5MzYsXG4gICAgICAgIE9tZWdhOiA5MzcsXG4gICAgICAgIGFscGhhOiA5NDUsXG4gICAgICAgIGJldGE6IDk0NixcbiAgICAgICAgZ2FtbWE6IDk0NyxcbiAgICAgICAgZGVsdGE6IDk0OCxcbiAgICAgICAgZXBzaWxvbjogOTQ5LFxuICAgICAgICB6ZXRhOiA5NTAsXG4gICAgICAgIGV0YTogOTUxLFxuICAgICAgICB0aGV0YTogOTUyLFxuICAgICAgICBpb3RhOiA5NTMsXG4gICAgICAgIGthcHBhOiA5NTQsXG4gICAgICAgIGxhbWJkYTogOTU1LFxuICAgICAgICBtdTogOTU2LFxuICAgICAgICBudTogOTU3LFxuICAgICAgICB4aTogOTU4LFxuICAgICAgICBvbWljcm9uOiA5NTksXG4gICAgICAgIHBpOiA5NjAsXG4gICAgICAgIHJobzogOTYxLFxuICAgICAgICBzaWdtYWY6IDk2MixcbiAgICAgICAgc2lnbWE6IDk2MyxcbiAgICAgICAgdGF1OiA5NjQsXG4gICAgICAgIHVwc2lsb246IDk2NSxcbiAgICAgICAgcGhpOiA5NjYsXG4gICAgICAgIGNoaTogOTY3LFxuICAgICAgICBwc2k6IDk2OCxcbiAgICAgICAgb21lZ2E6IDk2OSxcbiAgICAgICAgdGhldGFzeW06IDk3NyxcbiAgICAgICAgdXBzaWg6IDk3OCxcbiAgICAgICAgcGl2OiA5ODIsXG4gICAgICAgIGVuc3A6IDgxOTQsXG4gICAgICAgIGVtc3A6IDgxOTUsXG4gICAgICAgIHRoaW5zcDogODIwMSxcbiAgICAgICAgenduajogODIwNCxcbiAgICAgICAgendqOiA4MjA1LFxuICAgICAgICBscm06IDgyMDYsXG4gICAgICAgIHJsbTogODIwNyxcbiAgICAgICAgbmRhc2g6IDgyMTEsXG4gICAgICAgIG1kYXNoOiA4MjEyLFxuICAgICAgICBsc3F1bzogODIxNixcbiAgICAgICAgcnNxdW86IDgyMTcsXG4gICAgICAgIHNicXVvOiA4MjE4LFxuICAgICAgICBsZHF1bzogODIyMCxcbiAgICAgICAgcmRxdW86IDgyMjEsXG4gICAgICAgIGJkcXVvOiA4MjIyLFxuICAgICAgICBkYWdnZXI6IDgyMjQsXG4gICAgICAgIERhZ2dlcjogODIyNSxcbiAgICAgICAgYnVsbDogODIyNixcbiAgICAgICAgaGVsbGlwOiA4MjMwLFxuICAgICAgICBwZXJtaWw6IDgyNDAsXG4gICAgICAgIHByaW1lOiA4MjQyLFxuICAgICAgICBQcmltZTogODI0MyxcbiAgICAgICAgbHNhcXVvOiA4MjQ5LFxuICAgICAgICByc2FxdW86IDgyNTAsXG4gICAgICAgIG9saW5lOiA4MjU0LFxuICAgICAgICBmcmFzbDogODI2MCxcbiAgICAgICAgZXVybzogODM2NCxcbiAgICAgICAgaW1hZ2U6IDg0NjUsXG4gICAgICAgIHdlaWVycDogODQ3MixcbiAgICAgICAgcmVhbDogODQ3NixcbiAgICAgICAgdHJhZGU6IDg0ODIsXG4gICAgICAgIGFsZWZzeW06IDg1MDEsXG4gICAgICAgIGxhcnI6IDg1OTIsXG4gICAgICAgIHVhcnI6IDg1OTMsXG4gICAgICAgIHJhcnI6IDg1OTQsXG4gICAgICAgIGRhcnI6IDg1OTUsXG4gICAgICAgIGhhcnI6IDg1OTYsXG4gICAgICAgIGNyYXJyOiA4NjI5LFxuICAgICAgICBsQXJyOiA4NjU2LFxuICAgICAgICB1QXJyOiA4NjU3LFxuICAgICAgICByQXJyOiA4NjU4LFxuICAgICAgICBkQXJyOiA4NjU5LFxuICAgICAgICBoQXJyOiA4NjYwLFxuICAgICAgICBmb3JhbGw6IDg3MDQsXG4gICAgICAgIHBhcnQ6IDg3MDYsXG4gICAgICAgIGV4aXN0OiA4NzA3LFxuICAgICAgICBlbXB0eTogODcwOSxcbiAgICAgICAgbmFibGE6IDg3MTEsXG4gICAgICAgIGlzaW46IDg3MTIsXG4gICAgICAgIG5vdGluOiA4NzEzLFxuICAgICAgICBuaTogODcxNSxcbiAgICAgICAgcHJvZDogODcxOSxcbiAgICAgICAgc3VtOiA4NzIxLFxuICAgICAgICBtaW51czogODcyMixcbiAgICAgICAgbG93YXN0OiA4NzI3LFxuICAgICAgICByYWRpYzogODczMCxcbiAgICAgICAgcHJvcDogODczMyxcbiAgICAgICAgaW5maW46IDg3MzQsXG4gICAgICAgIGFuZzogODczNixcbiAgICAgICAgYW5kOiA4NzQzLFxuICAgICAgICBvcjogODc0NCxcbiAgICAgICAgY2FwOiA4NzQ1LFxuICAgICAgICBjdXA6IDg3NDYsXG4gICAgICAgIGludDogODc0NyxcbiAgICAgICAgdGhlcmU0OiA4NzU2LFxuICAgICAgICBzaW06IDg3NjQsXG4gICAgICAgIGNvbmc6IDg3NzMsXG4gICAgICAgIGFzeW1wOiA4Nzc2LFxuICAgICAgICBuZTogODgwMCxcbiAgICAgICAgZXF1aXY6IDg4MDEsXG4gICAgICAgIGxlOiA4ODA0LFxuICAgICAgICBnZTogODgwNSxcbiAgICAgICAgc3ViOiA4ODM0LFxuICAgICAgICBzdXA6IDg4MzUsXG4gICAgICAgIG5zdWI6IDg4MzYsXG4gICAgICAgIHN1YmU6IDg4MzgsXG4gICAgICAgIHN1cGU6IDg4MzksXG4gICAgICAgIG9wbHVzOiA4ODUzLFxuICAgICAgICBvdGltZXM6IDg4NTUsXG4gICAgICAgIHBlcnA6IDg4NjksXG4gICAgICAgIHNkb3Q6IDg5MDEsXG4gICAgICAgIGxjZWlsOiA4OTY4LFxuICAgICAgICByY2VpbDogODk2OSxcbiAgICAgICAgbGZsb29yOiA4OTcwLFxuICAgICAgICByZmxvb3I6IDg5NzEsXG4gICAgICAgIGxhbmc6IDkwMDEsXG4gICAgICAgIHJhbmc6IDkwMDIsXG4gICAgICAgIGxvejogOTY3NCxcbiAgICAgICAgc3BhZGVzOiA5ODI0LFxuICAgICAgICBjbHViczogOTgyNyxcbiAgICAgICAgaGVhcnRzOiA5ODI5LFxuICAgICAgICBkaWFtczogOTgzMCxcbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKHNheC5FTlRJVElFUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBlID0gc2F4LkVOVElUSUVTW2tleV07XG4gICAgICAgIHZhciBzID0gdHlwZW9mIGUgPT09IFwibnVtYmVyXCIgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpIDogZTtcbiAgICAgICAgc2F4LkVOVElUSUVTW2tleV0gPSBzO1xuICAgIH0pO1xuICAgIGZvciAodmFyIHMgaW4gc2F4LlNUQVRFKSB7XG4gICAgICAgIHNheC5TVEFURVtzYXguU1RBVEVbc11dID0gcztcbiAgICB9XG4gICAgLy8gc2hvcnRoYW5kXG4gICAgUyA9IHNheC5TVEFURTtcbiAgICBmdW5jdGlvbiBlbWl0KHBhcnNlciwgZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgcGFyc2VyW2V2ZW50XSAmJiBwYXJzZXJbZXZlbnRdKGRhdGEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbWl0Tm9kZShwYXJzZXIsIG5vZGVUeXBlLCBkYXRhKSB7XG4gICAgICAgIGlmIChwYXJzZXIudGV4dE5vZGUpXG4gICAgICAgICAgICBjbG9zZVRleHQocGFyc2VyKTtcbiAgICAgICAgZW1pdChwYXJzZXIsIG5vZGVUeXBlLCBkYXRhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvc2VUZXh0KHBhcnNlcikge1xuICAgICAgICBwYXJzZXIudGV4dE5vZGUgPSB0ZXh0b3B0cyhwYXJzZXIub3B0LCBwYXJzZXIudGV4dE5vZGUpO1xuICAgICAgICBpZiAocGFyc2VyLnRleHROb2RlKVxuICAgICAgICAgICAgZW1pdChwYXJzZXIsIFwib250ZXh0XCIsIHBhcnNlci50ZXh0Tm9kZSk7XG4gICAgICAgIHBhcnNlci50ZXh0Tm9kZSA9IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRleHRvcHRzKG9wdCwgdGV4dCkge1xuICAgICAgICBpZiAob3B0LnRyaW0pXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG4gICAgICAgIGlmIChvcHQubm9ybWFsaXplKVxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvcihwYXJzZXIsIGVyKSB7XG4gICAgICAgIGNsb3NlVGV4dChwYXJzZXIpO1xuICAgICAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGVyICs9XG4gICAgICAgICAgICAgICAgXCJcXG5MaW5lOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5saW5lICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXG5Db2x1bW46IFwiICtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuQ2hhcjogXCIgK1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYztcbiAgICAgICAgfVxuICAgICAgICBlciA9IG5ldyBFcnJvcihlcik7XG4gICAgICAgIHBhcnNlci5lcnJvciA9IGVyO1xuICAgICAgICBlbWl0KHBhcnNlciwgXCJvbmVycm9yXCIsIGVyKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kKHBhcnNlcikge1xuICAgICAgICBpZiAocGFyc2VyLnNhd1Jvb3QgJiYgIXBhcnNlci5jbG9zZWRSb290KVxuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVW5jbG9zZWQgcm9vdCB0YWdcIik7XG4gICAgICAgIGlmIChwYXJzZXIuc3RhdGUgIT09IFMuQkVHSU4gJiZcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTl9XSElURVNQQUNFICYmXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgIT09IFMuVEVYVCkge1xuICAgICAgICAgICAgZXJyb3IocGFyc2VyLCBcIlVuZXhwZWN0ZWQgZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlVGV4dChwYXJzZXIpO1xuICAgICAgICBwYXJzZXIuYyA9IFwiXCI7XG4gICAgICAgIHBhcnNlci5jbG9zZWQgPSB0cnVlO1xuICAgICAgICBlbWl0KHBhcnNlciwgXCJvbmVuZFwiKTtcbiAgICAgICAgU0FYUGFyc2VyLmNhbGwocGFyc2VyLCBwYXJzZXIuc3RyaWN0LCBwYXJzZXIub3B0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaWN0RmFpbChwYXJzZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZXIgIT09IFwib2JqZWN0XCIgfHwgIShwYXJzZXIgaW5zdGFuY2VvZiBTQVhQYXJzZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY2FsbCB0byBzdHJpY3RGYWlsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICBlcnJvcihwYXJzZXIsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5ld1RhZyhwYXJzZXIpIHtcbiAgICAgICAgaWYgKCFwYXJzZXIuc3RyaWN0KVxuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpO1xuICAgICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyO1xuICAgICAgICB2YXIgdGFnID0gKHBhcnNlci50YWcgPSB7IG5hbWU6IHBhcnNlci50YWdOYW1lLCBhdHRyaWJ1dGVzOiB7fSB9KTtcbiAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuIGlmIHRhZyBjb250YWlscyBhbiB4bWxucz1cImZvb1wiIG9yIHhtbG5zOmZvbz1cImJhclwiXG4gICAgICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICAgICAgICB0YWcubnMgPSBwYXJlbnQubnM7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMDtcbiAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9ub3BlbnRhZ3N0YXJ0XCIsIHRhZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHFuYW1lKG5hbWUsIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIHZhciBxdWFsTmFtZSA9IGkgPCAwID8gW1wiXCIsIG5hbWVdIDogbmFtZS5zcGxpdChcIjpcIik7XG4gICAgICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZVswXTtcbiAgICAgICAgdmFyIGxvY2FsID0gcXVhbE5hbWVbMV07XG4gICAgICAgIC8vIDx4IFwieG1sbnNcIj1cImh0dHA6Ly9mb29cIj5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZSAmJiBuYW1lID09PSBcInhtbG5zXCIpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IFwieG1sbnNcIjtcbiAgICAgICAgICAgIGxvY2FsID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCwgbG9jYWw6IGxvY2FsIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJpYihwYXJzZXIpIHtcbiAgICAgICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJOYW1lW3BhcnNlci5sb29zZUNhc2VdKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5hdHRyaWJMaXN0LmluZGV4T2YocGFyc2VyLmF0dHJpYk5hbWUpICE9PSAtMSB8fFxuICAgICAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHBhcnNlci5hdHRyaWJOYW1lKSkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICAgICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIuYXR0cmliTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gcW4ucHJlZml4O1xuICAgICAgICAgICAgdmFyIGxvY2FsID0gcW4ubG9jYWw7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSBcInhtbG5zXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBuYW1lc3BhY2UgYmluZGluZyBhdHRyaWJ1dGUuIHB1c2ggdGhlIGJpbmRpbmcgaW50byBzY29wZVxuICAgICAgICAgICAgICAgIGlmIChsb2NhbCA9PT0gXCJ4bWxcIiAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwieG1sOiBwcmVmaXggbXVzdCBiZSBib3VuZCB0byBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBYTUxfTkFNRVNQQUNFICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJBY3R1YWw6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsID09PSBcInhtbG5zXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICE9PSBYTUxOU19OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwieG1sbnM6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFhNTE5TX05BTUVTUEFDRSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQWN0dWFsOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcubnMgPT09IHBhcmVudC5ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnLm5zID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQubnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhZy5uc1tsb2NhbF0gPSBwYXJzZXIuYXR0cmliVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVmZXIgb25hdHRyaWJ1dGUgZXZlbnRzIHVudGlsIGFsbCBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBzZWVuXG4gICAgICAgICAgICAvLyBzbyBhbnkgbmV3IGJpbmRpbmdzIGNhbiB0YWtlIGVmZmVjdC4gcHJlc2VydmUgYXR0cmlidXRlIG9yZGVyXG4gICAgICAgICAgICAvLyBzbyBkZWZlcnJlZCBldmVudHMgY2FuIGJlIGVtaXR0ZWQgaW4gZG9jdW1lbnQgb3JkZXJcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJMaXN0LnB1c2goW3BhcnNlci5hdHRyaWJOYW1lLCBwYXJzZXIuYXR0cmliVmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIG5vbi14bWxucyBtb2RlLCB3ZSBjYW4gZW1pdCB0aGUgZXZlbnQgcmlnaHQgYXdheVxuICAgICAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9IHBhcnNlci5hdHRyaWJWYWx1ZTtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmF0dHJpYnV0ZVwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyc2VyLmF0dHJpYk5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlci5hdHRyaWJWYWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb3BlblRhZyhwYXJzZXIsIHNlbGZDbG9zaW5nKSB7XG4gICAgICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICAgICAgICAvLyBlbWl0IG5hbWVzcGFjZSBiaW5kaW5nIGV2ZW50c1xuICAgICAgICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWc7XG4gICAgICAgICAgICAvLyBhZGQgbmFtZXNwYWNlIGluZm8gdG8gdGFnXG4gICAgICAgICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIudGFnTmFtZSk7XG4gICAgICAgICAgICB0YWcucHJlZml4ID0gcW4ucHJlZml4O1xuICAgICAgICAgICAgdGFnLmxvY2FsID0gcW4ubG9jYWw7XG4gICAgICAgICAgICB0YWcudXJpID0gdGFnLm5zW3FuLnByZWZpeF0gfHwgXCJcIjtcbiAgICAgICAgICAgIGlmICh0YWcucHJlZml4ICYmICF0YWcudXJpKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiBcIiArIEpTT04uc3RyaW5naWZ5KHBhcnNlci50YWdOYW1lKSk7XG4gICAgICAgICAgICAgICAgdGFnLnVyaSA9IHFuLnByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXI7XG4gICAgICAgICAgICBpZiAodGFnLm5zICYmIHBhcmVudC5ucyAhPT0gdGFnLm5zKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbm9wZW5uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiB0YWcubnNbcF0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIGRlZmVycmVkIG9uYXR0cmlidXRlIGV2ZW50c1xuICAgICAgICAgICAgLy8gTm90ZTogZG8gbm90IGFwcGx5IGRlZmF1bHQgbnMgdG8gYXR0cmlidXRlczpcbiAgICAgICAgICAgIC8vICAgaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC1uYW1lcy8jZGVmYXVsdGluZ1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbnYgPSBwYXJzZXIuYXR0cmliTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG52WzBdO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG52WzFdO1xuICAgICAgICAgICAgICAgIHZhciBxdWFsTmFtZSA9IHFuYW1lKG5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZS5wcmVmaXg7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsID0gcXVhbE5hbWUubG9jYWw7XG4gICAgICAgICAgICAgICAgdmFyIHVyaSA9IHByZWZpeCA9PT0gXCJcIiA/IFwiXCIgOiB0YWcubnNbcHJlZml4XSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciBhID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBsb2NhbDogbG9jYWwsXG4gICAgICAgICAgICAgICAgICAgIHVyaTogdXJpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhbnkgYXR0cmlidXRlcyB3aXRoIGFuIHVuZGVmaW5lZCBuYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBmYWlsIG9uIHRoZW0gbm93LlxuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggJiYgcHJlZml4ICE9PSBcInhtbG5zXCIgJiYgIXVyaSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6IFwiICsgSlNPTi5zdHJpbmdpZnkocHJlZml4KSk7XG4gICAgICAgICAgICAgICAgICAgIGEudXJpID0gcHJlZml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbbmFtZV0gPSBhO1xuICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmF0dHJpYnV0ZVwiLCBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLnRhZy5pc1NlbGZDbG9zaW5nID0gISFzZWxmQ2xvc2luZztcbiAgICAgICAgLy8gcHJvY2VzcyB0aGUgdGFnXG4gICAgICAgIHBhcnNlci5zYXdSb290ID0gdHJ1ZTtcbiAgICAgICAgcGFyc2VyLnRhZ3MucHVzaChwYXJzZXIudGFnKTtcbiAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9ub3BlbnRhZ1wiLCBwYXJzZXIudGFnKTtcbiAgICAgICAgaWYgKCFzZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciA8c2NyaXB0PiBpbiBub24tc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICBpZiAoIXBhcnNlci5ub3NjcmlwdCAmJiBwYXJzZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNjcmlwdFwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIudGFnID0gbnVsbDtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9IFwiXCI7XG4gICAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlVGFnKHBhcnNlcikge1xuICAgICAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJXZWlyZCBlbXB0eSBjbG9zZSB0YWcuXCIpO1xuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IFwiPC8+XCI7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZXIudGFnTmFtZSAhPT0gXCJzY3JpcHRcIikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gXCI8L1wiICsgcGFyc2VyLnRhZ05hbWUgKyBcIj5cIjtcbiAgICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uc2NyaXB0XCIsIHBhcnNlci5zY3JpcHQpO1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlIGNsb3NpbmcgdGFnIGFjdHVhbGx5IGV4aXN0cy5cbiAgICAgICAgLy8gPGE+PGI+PC9jPjwvYj48L2E+IHdpbGwgY2xvc2UgZXZlcnl0aGluZywgb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgdCA9IHBhcnNlci50YWdzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBwYXJzZXIudGFnTmFtZTtcbiAgICAgICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbG9zZVRvID0gdGFnTmFtZTtcbiAgICAgICAgd2hpbGUgKHQtLSkge1xuICAgICAgICAgICAgdmFyIGNsb3NlID0gcGFyc2VyLnRhZ3NbdF07XG4gICAgICAgICAgICBpZiAoY2xvc2UubmFtZSAhPT0gY2xvc2VUbykge1xuICAgICAgICAgICAgICAgIC8vIGZhaWwgdGhlIGZpcnN0IHRpbWUgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJVbmV4cGVjdGVkIGNsb3NlIHRhZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRpZG4ndCBmaW5kIGl0LiAgd2UgYWxyZWFkeSBmYWlsZWQgZm9yIHN0cmljdCwgc28ganVzdCBhYm9ydC5cbiAgICAgICAgaWYgKHQgPCAwKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJVbm1hdGNoZWQgY2xvc2luZyB0YWc6IFwiICsgcGFyc2VyLnRhZ05hbWUpO1xuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IFwiPC9cIiArIHBhcnNlci50YWdOYW1lICsgXCI+XCI7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSB0YWdOYW1lO1xuICAgICAgICB2YXIgcyA9IHBhcnNlci50YWdzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHMtLSA+IHQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSAocGFyc2VyLnRhZyA9IHBhcnNlci50YWdzLnBvcCgpKTtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLnRhZy5uYW1lO1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY2xvc2V0YWdcIiwgcGFyc2VyLnRhZ05hbWUpO1xuICAgICAgICAgICAgdmFyIHggPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGFnLm5zKSB7XG4gICAgICAgICAgICAgICAgeFtpXSA9IHRhZy5uc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXI7XG4gICAgICAgICAgICBpZiAocGFyc2VyLm9wdC54bWxucyAmJiB0YWcubnMgIT09IHBhcmVudC5ucykge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBuYW1lc3BhY2UgYmluZGluZ3MgaW50cm9kdWNlZCBieSB0YWdcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0YWcubnMpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0YWcubnNbcF07XG4gICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmNsb3NlbmFtZXNwYWNlXCIsIHsgcHJlZml4OiBwLCB1cmk6IG4gfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPT09IDApXG4gICAgICAgICAgICBwYXJzZXIuY2xvc2VkUm9vdCA9IHRydWU7XG4gICAgICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gcGFyc2VyLmF0dHJpYk5hbWUgPSBcIlwiO1xuICAgICAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlRW50aXR5KHBhcnNlcikge1xuICAgICAgICB2YXIgZW50aXR5ID0gcGFyc2VyLmVudGl0eTtcbiAgICAgICAgdmFyIGVudGl0eUxDID0gZW50aXR5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBudW07XG4gICAgICAgIHZhciBudW1TdHIgPSBcIlwiO1xuICAgICAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eV0pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eUxDXSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ107XG4gICAgICAgIH1cbiAgICAgICAgZW50aXR5ID0gZW50aXR5TEM7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMSkgPT09IFwieFwiKSB7XG4gICAgICAgICAgICAgICAgZW50aXR5ID0gZW50aXR5LnNsaWNlKDIpO1xuICAgICAgICAgICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTYpO1xuICAgICAgICAgICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxMCk7XG4gICAgICAgICAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbnRpdHkgPSBlbnRpdHkucmVwbGFjZSgvXjArLywgXCJcIik7XG4gICAgICAgIGlmIChpc05hTihudW0pIHx8IG51bVN0ci50b0xvd2VyQ2FzZSgpICE9PSBlbnRpdHkpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgY2hhcmFjdGVyIGVudGl0eVwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIiZcIiArIHBhcnNlci5lbnRpdHkgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQobnVtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9XQUtBO1xuICAgICAgICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgLy8gaGF2ZSB0byBwcm9jZXNzIHRoaXMgYXMgYSB0ZXh0IG5vZGUuXG4gICAgICAgICAgICAvLyB3ZWlyZCwgYnV0IGhhcHBlbnMuXG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJOb24td2hpdGVzcGFjZSBiZWZvcmUgZmlyc3QgdGFnLlwiKTtcbiAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSA9IGM7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hhckF0KGNodW5rLCBpKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICBpZiAoaSA8IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2h1bmsuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlKGNodW5rKSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKHBhcnNlciwgXCJDYW5ub3Qgd3JpdGUgYWZ0ZXIgY2xvc2UuIEFzc2lnbiBhbiBvbnJlYWR5IGhhbmRsZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZChwYXJzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBjID0gXCJcIjtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKyk7XG4gICAgICAgICAgICBwYXJzZXIuYyA9IGM7XG4gICAgICAgICAgICBpZiAoIWMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5wb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5saW5lKys7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkJFR0lOOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkJFR0lOX1dISVRFU1BBQ0U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIlxcdUZFRkZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5CRUdJTl9XSElURVNQQUNFOlxuICAgICAgICAgICAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLlRFWFQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydGkgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjICYmIGMgIT09IFwiPFwiICYmIGMgIT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyAmJiBwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5saW5lKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjaHVuay5zdWJzdHJpbmcoc3RhcnRpLCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKHBhcnNlci5zYXdSb290ICYmIHBhcnNlci5jbG9zZWRSb290ICYmICFwYXJzZXIuc3RyaWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0E7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiA9IHBhcnNlci5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpICYmICghcGFyc2VyLnNhd1Jvb3QgfHwgcGFyc2VyLmNsb3NlZFJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVGV4dCBkYXRhIG91dHNpZGUgb2Ygcm9vdCBub2RlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIiZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVF9FTlRJVFk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuU0NSSVBUOlxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IG5vbi1zdHJpY3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVF9FTkRJTkc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLlNDUklQVF9FTkRJTkc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IFwiPFwiICsgYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5PUEVOX1dBS0E6XG4gICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciBhIC8sID8sICEsIG9yIHRleHQgaXMgY29taW5nIG5leHQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0w7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgaXQuLi5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgPSBwYXJzZXIucHJvY0luc3RCb2R5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIlVuZW5jb2RlZCA8XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIHNvbWUgd2hpdGVzcGFjZSwgdGhlbiBhZGQgdGhhdCBpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiArIDEgPCBwYXJzZXIucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFkID0gcGFyc2VyLnBvc2l0aW9uIC0gcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyBBcnJheShwYWQpLmpvaW4oXCIgXCIpICsgYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBcIjxcIiArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLlNHTUxfREVDTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBDREFUQSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9ub3BlbmNkYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci5zZ21sRGVjbCArIGMgPT09IFwiLS1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gRE9DVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5kb2N0eXBlIHx8IHBhcnNlci5zYXdSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW5hcHByb3ByaWF0ZWx5IGxvY2F0ZWQgZG9jdHlwZSBkZWNsYXJhdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbnNnbWxkZWNsYXJhdGlvblwiLCBwYXJzZXIuc2dtbERlY2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTF9RVU9URUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5TR01MX0RFQ0xfUVVPVEVEOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuRE9DVFlQRTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25kb2N0eXBlXCIsIHBhcnNlci5kb2N0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gdHJ1ZTsgLy8ganVzdCByZW1lbWJlciB0aGF0IHdlIHNhdyBpdC5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfRFREO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9RVU9URUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnEgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5ET0NUWVBFX1FVT1RFRDpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkRPQ1RZUEVfRFREOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfRFREX1FVT1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5xID0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuRE9DVFlQRV9EVERfUVVPVEVEOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVEQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkNPTU1FTlQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UX0VORElORztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkNPTU1FTlRfRU5ESU5HOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLmNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY29tbWVudFwiLCBwYXJzZXIuY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSBcIi1cIiArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkNPTU1FTlRfRU5ERUQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjICE9PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiTWFsZm9ybWVkIGNvbW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyA8IS0tIGJsYWggLS0gYmxvbyAtLT4gaW4gbm9uLXN0cmljdCBtb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgYSBjb21tZW50IG9mIFwiIGJsYWggLS0gYmxvbyBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gXCItLVwiICsgYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQ0RBVEE6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQV9FTkRJTkc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQ0RBVEFfRU5ESU5HOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HXzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gXCJdXCIgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQ0RBVEFfRU5ESU5HXzI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5jZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmNkYXRhXCIsIHBhcnNlci5jZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25jbG9zZWNkYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9IFwiXVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9IFwiXV1cIiArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5QUk9DX0lOU1Q6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfRU5ESU5HO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0JPRFk6XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLnByb2NJbnN0Qm9keSAmJiBpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucHJvY0luc3RCb2R5ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLlBST0NfSU5TVF9FTkRJTkc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIucHJvY0luc3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHBhcnNlci5wcm9jSW5zdEJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgPSBwYXJzZXIucHJvY0luc3RCb2R5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdEJvZHkgKz0gXCI/XCIgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuT1BFTl9UQUc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gdGFnIG5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5PUEVOX1RBR19TTEFTSDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiRm9yd2FyZC1zbGFzaCBpbiBvcGVuaW5nIHRhZyBub3QgZm9sbG93ZWQgYnkgPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUI6XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhdmVuJ3QgcmVhZCB0aGUgYXR0cmlidXRlIG5hbWUgeWV0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiQXR0cmlidXRlIHdpdGhvdXQgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYihwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRV9TQVdfV0hJVEU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRV9TQVdfV0hJVEU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkF0dHJpYnV0ZSB3aXRob3V0IHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uYXR0cmlidXRlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5xID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIlVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1FVT1RFRDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgIT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXR0cmliKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5xID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfQ0xPU0VEO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0NMT1NFRDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIk5vIHdoaXRlc3BhY2UgYmV0d2VlbiBhdHRyaWJ1dGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfVU5RVU9URUQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBdHRyaWJFbmQoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIiZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWIocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub3RNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSBcIjwvXCIgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgdGFnbmFtZSBpbiBjbG9zaW5nIHRhZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTWF0Y2gobmFtZUJvZHksIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gXCI8L1wiICsgcGFyc2VyLnRhZ05hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdfU0FXX1dISVRFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5DTE9TRV9UQUdfU0FXX1dISVRFOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIGNoYXJhY3RlcnMgaW4gY2xvc2luZyB0YWdcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLlRFWFRfRU5USVRZOlxuICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVyblN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcnNlci5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTLlRFWFRfRU5USVRZOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFwidGV4dE5vZGVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gXCJhdHRyaWJWYWx1ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFwiYXR0cmliVmFsdWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIub3B0LnVucGFyc2VkRW50aXRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkRW50aXR5ID0gcGFyc2VFbnRpdHkocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSByZXR1cm5TdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIud3JpdGUocGFyc2VkRW50aXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcltidWZmZXJdICs9IHBhcnNlRW50aXR5KHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmVudGl0eSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXRjaChwYXJzZXIuZW50aXR5Lmxlbmd0aCA/IGVudGl0eUJvZHkgOiBlbnRpdHlTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgY2hhcmFjdGVyIGluIGVudGl0eSBuYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyW2J1ZmZlcl0gKz0gXCImXCIgKyBwYXJzZXIuZW50aXR5ICsgYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VyLCBcIlVua25vd24gc3RhdGU6IFwiICsgcGFyc2VyLnN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gd2hpbGVcbiAgICAgICAgaWYgKHBhcnNlci5wb3NpdGlvbiA+PSBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgY2hlY2tCdWZmZXJMZW5ndGgocGFyc2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VyO1xuICAgIH1cbiAgICAvKiEgaHR0cDovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4xLjAgYnkgQG1hdGhpYXMgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgICAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgICAgIHZhciBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMDtcbiAgICAgICAgICAgICAgICB2YXIgY29kZVVuaXRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2hTdXJyb2dhdGU7XG4gICAgICAgICAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA8IDAgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPiAweDEwZmZmZiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb29yKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnQ6IFwiICsgY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgMHhkODAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93U3Vycm9nYXRlID0gKGNvZGVQb2ludCAlIDB4NDAwKSArIDB4ZGMwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA9PT0gbGVuZ3RoIHx8IGNvZGVVbml0cy5sZW5ndGggPiBNQVhfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVVuaXRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcsIFwiZnJvbUNvZGVQb2ludFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmcm9tQ29kZVBvaW50LFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgU3RyaW5nLmZyb21Db2RlUG9pbnQgPSBmcm9tQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2F4O1xufTtcbmNvbnN0IHNheCA9IC8qKiAjX19QVVJFX18gKi8gaW5pdGlhbGl6ZVNheCgpO1xuZXhwb3J0IHsgc2F4IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/sax-js/sax.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/signal.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/signal.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raceWithSignal: () => (/* binding */ raceWithSignal)\n/* harmony export */ });\nasync function raceWithSignal(promise, signal) {\n    if (signal === undefined) {\n        return promise;\n    }\n    let listener;\n    return Promise.race([\n        promise.catch((err) => {\n            if (!signal?.aborted) {\n                throw err;\n            }\n            else {\n                return undefined;\n            }\n        }),\n        new Promise((_, reject) => {\n            listener = () => {\n                reject(new Error(\"Aborted\"));\n            };\n            signal.addEventListener(\"abort\", listener);\n            // Must be here inside the promise to avoid a race condition\n            if (signal.aborted) {\n                reject(new Error(\"Aborted\"));\n            }\n        }),\n    ]).finally(() => signal.removeEventListener(\"abort\", listener));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc2lnbmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcc2lnbmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBhc3luYyBmdW5jdGlvbiByYWNlV2l0aFNpZ25hbChwcm9taXNlLCBzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGxldCBsaXN0ZW5lcjtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcHJvbWlzZS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRlZFwiKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBNdXN0IGJlIGhlcmUgaW5zaWRlIHRoZSBwcm9taXNlIHRvIGF2b2lkIGEgcmFjZSBjb25kaXRpb25cbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydGVkXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgXSkuZmluYWxseSgoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/signal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/stream.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/stream.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncGeneratorWithSetup: () => (/* binding */ AsyncGeneratorWithSetup),\n/* harmony export */   IterableReadableStream: () => (/* binding */ IterableReadableStream),\n/* harmony export */   atee: () => (/* binding */ atee),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   pipeGeneratorWithSetup: () => (/* binding */ pipeGeneratorWithSetup)\n/* harmony export */ });\n/* harmony import */ var _runnables_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/config.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.js\");\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../singletons/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signal.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/signal.js\");\n\n\n\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\nfunction atee(iter, length = 2) {\n    const buffers = Array.from({ length }, () => []);\n    return buffers.map(async function* makeIter(buffer) {\n        while (true) {\n            if (buffer.length === 0) {\n                const result = await iter.next();\n                for (const buffer of buffers) {\n                    buffer.push(result);\n                }\n            }\n            else if (buffer[0].done) {\n                return;\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                yield buffer.shift().value;\n            }\n        }\n    });\n}\nfunction concat(first, second) {\n    if (Array.isArray(first) && Array.isArray(second)) {\n        return first.concat(second);\n    }\n    else if (typeof first === \"string\" && typeof second === \"string\") {\n        return (first + second);\n    }\n    else if (typeof first === \"number\" && typeof second === \"number\") {\n        return (first + second);\n    }\n    else if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    \"concat\" in first &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof first.concat === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return first.concat(second);\n    }\n    else if (typeof first === \"object\" && typeof second === \"object\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const chunk = { ...first };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        for (const [key, value] of Object.entries(second)) {\n            if (key in chunk && !Array.isArray(chunk[key])) {\n                chunk[key] = concat(chunk[key], value);\n            }\n            else {\n                chunk[key] = value;\n            }\n        }\n        return chunk;\n    }\n    else {\n        throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);\n    }\n}\nclass AsyncGeneratorWithSetup {\n    constructor(params) {\n        Object.defineProperty(this, \"generator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"setup\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"signal\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResult\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResultUsed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.generator = params.generator;\n        this.config = params.config;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.signal = params.signal ?? this.config?.signal;\n        // setup is a promise that resolves only after the first iterator value\n        // is available. this is useful when setup of several piped generators\n        // needs to happen in logical order, ie. in the order in which input to\n        // to each generator is available.\n        this.setup = new Promise((resolve, reject) => {\n            void _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.runWithConfig((0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_0__.pickRunnableConfigKeys)(params.config), async () => {\n                this.firstResult = params.generator.next();\n                if (params.startSetup) {\n                    this.firstResult.then(params.startSetup).then(resolve, reject);\n                }\n                else {\n                    this.firstResult.then((_result) => resolve(undefined), reject);\n                }\n            }, true);\n        });\n    }\n    async next(...args) {\n        this.signal?.throwIfAborted();\n        if (!this.firstResultUsed) {\n            this.firstResultUsed = true;\n            return this.firstResult;\n        }\n        return _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.runWithConfig((0,_runnables_config_js__WEBPACK_IMPORTED_MODULE_0__.pickRunnableConfigKeys)(this.config), this.signal\n            ? async () => {\n                return (0,_signal_js__WEBPACK_IMPORTED_MODULE_2__.raceWithSignal)(this.generator.next(...args), this.signal);\n            }\n            : async () => {\n                return this.generator.next(...args);\n            }, true);\n    }\n    async return(value) {\n        return this.generator.return(value);\n    }\n    async throw(e) {\n        return this.generator.throw(e);\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n}\nasync function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {\n    const gen = new AsyncGeneratorWithSetup({\n        generator,\n        startSetup,\n        signal,\n    });\n    const setup = await gen.setup;\n    return { output: to(gen, setup, ...args), setup };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdFO0FBQ1k7QUFDL0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWMsTUFBTSxjQUFjO0FBQzNFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9GQUFrQyxlQUFlLDRFQUFzQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9GQUFrQyxlQUFlLDRFQUFzQjtBQUN0RjtBQUNBLHVCQUF1QiwwREFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxzdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGlja1J1bm5hYmxlQ29uZmlnS2V5cyB9IGZyb20gXCIuLi9ydW5uYWJsZXMvY29uZmlnLmpzXCI7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIH0gZnJvbSBcIi4uL3NpbmdsZXRvbnMvaW5kZXguanNcIjtcbmltcG9ydCB7IHJhY2VXaXRoU2lnbmFsIH0gZnJvbSBcIi4vc2lnbmFsLmpzXCI7XG4vKlxuICogU3VwcG9ydCBhc3luYyBpdGVyYXRvciBzeW50YXggZm9yIFJlYWRhYmxlU3RyZWFtcyBpbiBhbGwgZW52aXJvbm1lbnRzLlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vTWF0dGlhc0J1ZWxlbnMvd2ViLXN0cmVhbXMtcG9seWZpbGwvcHVsbC8xMjIjaXNzdWVjb21tZW50LTE2MjczNTQ0OTBcbiAqL1xuZXhwb3J0IGNsYXNzIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbnN1cmVSZWFkZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gdGhpcy5nZXRSZWFkZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgZXJyb3JlZFxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIC8vIElmIHdyYXBwZWQgaW4gYSBOb2RlIHN0cmVhbSwgY2FuY2VsIGlzIGFscmVhZHkgY2FsbGVkLlxuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSB0aGlzLnJlYWRlci5jYW5jZWwoKTsgLy8gY2FuY2VsIGZpcnN0LCBidXQgZG9uJ3QgYXdhaXQgeWV0XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgZmlyc3RcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyB0aHJvdyhlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHRoaXMucmVhZGVyLmNhbmNlbCgpOyAvLyBjYW5jZWwgZmlyc3QsIGJ1dCBkb24ndCBhd2FpdCB5ZXRcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayBmaXJzdFxuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTsgLy8gbm93IGF3YWl0IGl0XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlIE5vdCBwcmVzZW50IGluIE5vZGUgMTggdHlwZXMsIHJlcXVpcmVkIGluIGxhdGVzdCBOb2RlIDIyXG4gICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJldHVybigpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdHJlYW1zX0FQSS9Vc2luZ19yZWFkYWJsZV9zdHJlYW1zI3JlYWRpbmdfdGhlX3N0cmVhbVxuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnF1ZXVlIHRoZSBuZXh0IGRhdGEgY2h1bmsgaW50byBvdXIgdGFyZ2V0IHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Bc3luY0dlbmVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpeDogYGVsc2UgaWYgKHZhbHVlKWAgd2lsbCBoYW5nIHRoZSBzdHJlYW1pbmcgd2hlbiBudWxsaXNoIHZhbHVlIChlLmcuIGVtcHR5IHN0cmluZykgaXMgcHVsbGVkXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZ2VuZXJhdG9yLnJldHVybihyZWFzb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGF0ZWUoaXRlciwgbGVuZ3RoID0gMikge1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sICgpID0+IFtdKTtcbiAgICByZXR1cm4gYnVmZmVycy5tYXAoYXN5bmMgZnVuY3Rpb24qIG1ha2VJdGVyKGJ1ZmZlcikge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyWzBdLmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIHlpZWxkIGJ1ZmZlci5zaGlmdCgpLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkgJiYgQXJyYXkuaXNBcnJheShzZWNvbmQpKSB7XG4gICAgICAgIHJldHVybiBmaXJzdC5jb25jYXQoc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIChmaXJzdCArIHNlY29uZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygc2Vjb25kID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiAoZmlyc3QgKyBzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIFwiY29uY2F0XCIgaW4gZmlyc3QgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdHlwZW9mIGZpcnN0LmNvbmNhdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBmaXJzdC5jb25jYXQoc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgY2h1bmsgPSB7IC4uLmZpcnN0IH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNlY29uZCkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gY2h1bmsgJiYgIUFycmF5LmlzQXJyYXkoY2h1bmtba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBjaHVua1trZXldID0gY29uY2F0KGNodW5rW2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb25jYXQgJHt0eXBlb2YgZmlyc3R9IGFuZCAke3R5cGVvZiBzZWNvbmR9YCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VuZXJhdG9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldHVwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduYWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlyc3RSZXN1bHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlyc3RSZXN1bHRVc2VkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBwYXJhbXMuZ2VuZXJhdG9yO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHBhcmFtcy5jb25maWc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRoaXMuc2lnbmFsID0gcGFyYW1zLnNpZ25hbCA/PyB0aGlzLmNvbmZpZz8uc2lnbmFsO1xuICAgICAgICAvLyBzZXR1cCBpcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmx5IGFmdGVyIHRoZSBmaXJzdCBpdGVyYXRvciB2YWx1ZVxuICAgICAgICAvLyBpcyBhdmFpbGFibGUuIHRoaXMgaXMgdXNlZnVsIHdoZW4gc2V0dXAgb2Ygc2V2ZXJhbCBwaXBlZCBnZW5lcmF0b3JzXG4gICAgICAgIC8vIG5lZWRzIHRvIGhhcHBlbiBpbiBsb2dpY2FsIG9yZGVyLCBpZS4gaW4gdGhlIG9yZGVyIGluIHdoaWNoIGlucHV0IHRvXG4gICAgICAgIC8vIHRvIGVhY2ggZ2VuZXJhdG9yIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgdGhpcy5zZXR1cCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZvaWQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMocGFyYW1zLmNvbmZpZyksIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0UmVzdWx0ID0gcGFyYW1zLmdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zdGFydFNldHVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHQudGhlbihwYXJhbXMuc3RhcnRTZXR1cCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdC50aGVuKChfcmVzdWx0KSA9PiByZXNvbHZlKHVuZGVmaW5lZCksIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBuZXh0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgIGlmICghdGhpcy5maXJzdFJlc3VsdFVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcocGlja1J1bm5hYmxlQ29uZmlnS2V5cyh0aGlzLmNvbmZpZyksIHRoaXMuc2lnbmFsXG4gICAgICAgICAgICA/IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFjZVdpdGhTaWduYWwodGhpcy5nZW5lcmF0b3IubmV4dCguLi5hcmdzKSwgdGhpcy5zaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLm5leHQoLi4uYXJncyk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci5yZXR1cm4odmFsdWUpO1xuICAgIH1cbiAgICBhc3luYyB0aHJvdyhlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci50aHJvdyhlKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlIE5vdCBwcmVzZW50IGluIE5vZGUgMTggdHlwZXMsIHJlcXVpcmVkIGluIGxhdGVzdCBOb2RlIDIyXG4gICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJldHVybigpO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwaXBlR2VuZXJhdG9yV2l0aFNldHVwKHRvLCBnZW5lcmF0b3IsIHN0YXJ0U2V0dXAsIHNpZ25hbCwgLi4uYXJncykge1xuICAgIGNvbnN0IGdlbiA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh7XG4gICAgICAgIGdlbmVyYXRvcixcbiAgICAgICAgc3RhcnRTZXR1cCxcbiAgICAgICAgc2lnbmFsLFxuICAgIH0pO1xuICAgIGNvbnN0IHNldHVwID0gYXdhaXQgZ2VuLnNldHVwO1xuICAgIHJldHVybiB7IG91dHB1dDogdG8oZ2VuLCBzZXR1cCwgLi4uYXJncyksIHNldHVwIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/testing/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/testing/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FakeChatMessageHistory: () => (/* binding */ FakeChatMessageHistory),\n/* harmony export */   FakeChatModel: () => (/* binding */ FakeChatModel),\n/* harmony export */   FakeEmbeddings: () => (/* binding */ FakeEmbeddings),\n/* harmony export */   FakeLLM: () => (/* binding */ FakeLLM),\n/* harmony export */   FakeListChatMessageHistory: () => (/* binding */ FakeListChatMessageHistory),\n/* harmony export */   FakeListChatModel: () => (/* binding */ FakeListChatModel),\n/* harmony export */   FakeRetriever: () => (/* binding */ FakeRetriever),\n/* harmony export */   FakeRunnable: () => (/* binding */ FakeRunnable),\n/* harmony export */   FakeSplitIntoListParser: () => (/* binding */ FakeSplitIntoListParser),\n/* harmony export */   FakeStreamingChatModel: () => (/* binding */ FakeStreamingChatModel),\n/* harmony export */   FakeStreamingLLM: () => (/* binding */ FakeStreamingLLM),\n/* harmony export */   FakeTool: () => (/* binding */ FakeTool),\n/* harmony export */   FakeTracer: () => (/* binding */ FakeTracer),\n/* harmony export */   FakeVectorStore: () => (/* binding */ FakeVectorStore),\n/* harmony export */   SingleRunExtractor: () => (/* binding */ SingleRunExtractor),\n/* harmony export */   SyntheticEmbeddings: () => (/* binding */ SyntheticEmbeddings)\n/* harmony export */ });\n/* harmony import */ var _chat_history_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../chat_history.js */ \"(rsc)/./node_modules/@langchain/core/dist/chat_history.js\");\n/* harmony import */ var _documents_document_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../documents/document.js */ \"(rsc)/./node_modules/@langchain/core/dist/documents/document.js\");\n/* harmony import */ var _language_models_chat_models_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../language_models/chat_models.js */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.js\");\n/* harmony import */ var _language_models_llms_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../language_models/llms.js */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/llms.js\");\n/* harmony import */ var _messages_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../messages/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.js\");\n/* harmony import */ var _output_parsers_base_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../output_parsers/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.js\");\n/* harmony import */ var _outputs_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../outputs.js */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.js\");\n/* harmony import */ var _retrievers_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../retrievers/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/retrievers/index.js\");\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../runnables/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.js\");\n/* harmony import */ var _tools_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../tools/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/tools/index.js\");\n/* harmony import */ var _tracers_base_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../tracers/base.js */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.js\");\n/* harmony import */ var _embeddings_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../embeddings.js */ \"(rsc)/./node_modules/@langchain/core/dist/embeddings.js\");\n/* harmony import */ var _json_schema_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../json_schema.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.js\");\n/* harmony import */ var _vectorstores_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../vectorstores.js */ \"(rsc)/./node_modules/@langchain/core/dist/vectorstores.js\");\n/* harmony import */ var _ml_distance_similarities_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../ml-distance/similarities.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/ml-distance/similarities.js\");\n/* eslint-disable no-promise-executor-return */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Parser for comma-separated values. It splits the input text by commas\n * and trims the resulting values.\n */\nclass FakeSplitIntoListParser extends _output_parsers_base_js__WEBPACK_IMPORTED_MODULE_5__.BaseOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"tests\", \"fake\"]\n        });\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n    async parse(text) {\n        return text.split(\",\").map((value) => value.trim());\n    }\n}\nclass FakeRunnable extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_8__.Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"tests\", \"fake\"]\n        });\n        Object.defineProperty(this, \"returnOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.returnOptions = fields.returnOptions;\n    }\n    async invoke(input, options) {\n        if (this.returnOptions) {\n            return options ?? {};\n        }\n        return { input };\n    }\n}\nclass FakeLLM extends _language_models_llms_js__WEBPACK_IMPORTED_MODULE_3__.LLM {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"thrownErrorString\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.response = fields.response;\n        this.thrownErrorString = fields.thrownErrorString;\n    }\n    _llmType() {\n        return \"fake\";\n    }\n    async _call(prompt, _options, runManager) {\n        if (this.thrownErrorString) {\n            throw new Error(this.thrownErrorString);\n        }\n        const response = this.response ?? prompt;\n        await runManager?.handleLLMNewToken(response);\n        return response;\n    }\n}\nclass FakeStreamingLLM extends _language_models_llms_js__WEBPACK_IMPORTED_MODULE_3__.LLM {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"sleep\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        Object.defineProperty(this, \"responses\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"thrownErrorString\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.sleep = fields.sleep ?? this.sleep;\n        this.responses = fields.responses;\n        this.thrownErrorString = fields.thrownErrorString;\n    }\n    _llmType() {\n        return \"fake\";\n    }\n    async _call(prompt) {\n        if (this.thrownErrorString) {\n            throw new Error(this.thrownErrorString);\n        }\n        const response = this.responses?.[0];\n        this.responses = this.responses?.slice(1);\n        return response ?? prompt;\n    }\n    async *_streamResponseChunks(input, _options, runManager) {\n        if (this.thrownErrorString) {\n            throw new Error(this.thrownErrorString);\n        }\n        const response = this.responses?.[0];\n        this.responses = this.responses?.slice(1);\n        for (const c of response ?? input) {\n            await new Promise((resolve) => setTimeout(resolve, this.sleep));\n            yield { text: c, generationInfo: {} };\n            await runManager?.handleLLMNewToken(c);\n        }\n    }\n}\nclass FakeChatModel extends _language_models_chat_models_js__WEBPACK_IMPORTED_MODULE_2__.BaseChatModel {\n    _combineLLMOutput() {\n        return [];\n    }\n    _llmType() {\n        return \"fake\";\n    }\n    async _generate(messages, options, runManager) {\n        if (options?.stop?.length) {\n            return {\n                generations: [\n                    {\n                        message: new _messages_index_js__WEBPACK_IMPORTED_MODULE_4__.AIMessage(options.stop[0]),\n                        text: options.stop[0],\n                    },\n                ],\n            };\n        }\n        const text = messages\n            .map((m) => {\n            if (typeof m.content === \"string\") {\n                return m.content;\n            }\n            return JSON.stringify(m.content, null, 2);\n        })\n            .join(\"\\n\");\n        await runManager?.handleLLMNewToken(text);\n        return {\n            generations: [\n                {\n                    message: new _messages_index_js__WEBPACK_IMPORTED_MODULE_4__.AIMessage(text),\n                    text,\n                },\n            ],\n            llmOutput: {},\n        };\n    }\n}\nclass FakeStreamingChatModel extends _language_models_chat_models_js__WEBPACK_IMPORTED_MODULE_2__.BaseChatModel {\n    constructor({ sleep = 50, responses = [], chunks = [], toolStyle = \"openai\", thrownErrorString, ...rest }) {\n        super(rest);\n        Object.defineProperty(this, \"sleep\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        Object.defineProperty(this, \"responses\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"chunks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"toolStyle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"openai\"\n        });\n        Object.defineProperty(this, \"thrownErrorString\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tools\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.sleep = sleep;\n        this.responses = responses;\n        this.chunks = chunks;\n        this.toolStyle = toolStyle;\n        this.thrownErrorString = thrownErrorString;\n    }\n    _llmType() {\n        return \"fake\";\n    }\n    bindTools(tools) {\n        const merged = [...this.tools, ...tools];\n        const toolDicts = merged.map((t) => {\n            switch (this.toolStyle) {\n                case \"openai\":\n                    return {\n                        type: \"function\",\n                        function: {\n                            name: t.name,\n                            description: t.description,\n                            parameters: (0,_json_schema_js__WEBPACK_IMPORTED_MODULE_12__.toJsonSchema)(t.schema),\n                        },\n                    };\n                case \"anthropic\":\n                    return {\n                        name: t.name,\n                        description: t.description,\n                        input_schema: (0,_json_schema_js__WEBPACK_IMPORTED_MODULE_12__.toJsonSchema)(t.schema),\n                    };\n                case \"bedrock\":\n                    return {\n                        toolSpec: {\n                            name: t.name,\n                            description: t.description,\n                            inputSchema: (0,_json_schema_js__WEBPACK_IMPORTED_MODULE_12__.toJsonSchema)(t.schema),\n                        },\n                    };\n                case \"google\":\n                    return {\n                        name: t.name,\n                        description: t.description,\n                        parameters: (0,_json_schema_js__WEBPACK_IMPORTED_MODULE_12__.toJsonSchema)(t.schema),\n                    };\n                default:\n                    throw new Error(`Unsupported tool style: ${this.toolStyle}`);\n            }\n        });\n        const wrapped = this.toolStyle === \"google\"\n            ? [{ functionDeclarations: toolDicts }]\n            : toolDicts;\n        /* creating a *new* instance  mirrors LangChain .bind semantics for type-safety and avoiding noise */\n        const next = new FakeStreamingChatModel({\n            sleep: this.sleep,\n            responses: this.responses,\n            chunks: this.chunks,\n            toolStyle: this.toolStyle,\n            thrownErrorString: this.thrownErrorString,\n        });\n        next.tools = merged;\n        return next.withConfig({ tools: wrapped });\n    }\n    async _generate(messages, _options, _runManager) {\n        if (this.thrownErrorString) {\n            throw new Error(this.thrownErrorString);\n        }\n        const content = this.responses?.[0]?.content ?? messages[0].content ?? \"\";\n        const generation = {\n            generations: [\n                {\n                    text: \"\",\n                    message: new _messages_index_js__WEBPACK_IMPORTED_MODULE_4__.AIMessage({\n                        content,\n                        tool_calls: this.chunks?.[0]?.tool_calls,\n                    }),\n                },\n            ],\n        };\n        return generation;\n    }\n    async *_streamResponseChunks(_messages, _options, runManager) {\n        if (this.thrownErrorString) {\n            throw new Error(this.thrownErrorString);\n        }\n        if (this.chunks?.length) {\n            for (const msgChunk of this.chunks) {\n                const cg = new _outputs_js__WEBPACK_IMPORTED_MODULE_6__.ChatGenerationChunk({\n                    message: new _messages_index_js__WEBPACK_IMPORTED_MODULE_4__.AIMessageChunk({\n                        content: msgChunk.content,\n                        tool_calls: msgChunk.tool_calls,\n                        additional_kwargs: msgChunk.additional_kwargs ?? {},\n                    }),\n                    text: msgChunk.content?.toString() ?? \"\",\n                });\n                yield cg;\n                await runManager?.handleLLMNewToken(msgChunk.content, undefined, undefined, undefined, undefined, { chunk: cg });\n            }\n            return;\n        }\n        const fallback = this.responses?.[0] ??\n            new _messages_index_js__WEBPACK_IMPORTED_MODULE_4__.AIMessage(typeof _messages[0].content === \"string\" ? _messages[0].content : \"\");\n        const text = typeof fallback.content === \"string\" ? fallback.content : \"\";\n        for (const ch of text) {\n            await new Promise((r) => setTimeout(r, this.sleep));\n            const cg = new _outputs_js__WEBPACK_IMPORTED_MODULE_6__.ChatGenerationChunk({\n                message: new _messages_index_js__WEBPACK_IMPORTED_MODULE_4__.AIMessageChunk({ content: ch }),\n                text: ch,\n            });\n            yield cg;\n            await runManager?.handleLLMNewToken(ch, undefined, undefined, undefined, undefined, { chunk: cg });\n        }\n    }\n}\nclass FakeRetriever extends _retrievers_index_js__WEBPACK_IMPORTED_MODULE_7__.BaseRetriever {\n    constructor(fields) {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"test\", \"fake\"]\n        });\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\n                new _documents_document_js__WEBPACK_IMPORTED_MODULE_1__.Document({ pageContent: \"foo\" }),\n                new _documents_document_js__WEBPACK_IMPORTED_MODULE_1__.Document({ pageContent: \"bar\" }),\n            ]\n        });\n        this.output = fields?.output ?? this.output;\n    }\n    async _getRelevantDocuments(_query\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return this.output;\n    }\n}\n/**\n * A fake Chat Model that returns a predefined list of responses. It can be used\n * for testing purposes.\n * @example\n * ```typescript\n * const chat = new FakeListChatModel({\n *   responses: [\"I'll callback later.\", \"You 'console' them!\"]\n * });\n *\n * const firstMessage = new HumanMessage(\"You want to hear a JavaScript joke?\");\n * const secondMessage = new HumanMessage(\"How do you cheer up a JavaScript developer?\");\n *\n * // Call the chat model with a message and log the response\n * const firstResponse = await chat.call([firstMessage]);\n * console.log({ firstResponse });\n *\n * const secondResponse = await chat.call([secondMessage]);\n * console.log({ secondResponse });\n * ```\n */\nclass FakeListChatModel extends _language_models_chat_models_js__WEBPACK_IMPORTED_MODULE_2__.BaseChatModel {\n    static lc_name() {\n        return \"FakeListChatModel\";\n    }\n    constructor(params) {\n        super(params);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"responses\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"i\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"sleep\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"emitCustomEvent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        const { responses, sleep, emitCustomEvent } = params;\n        this.responses = responses;\n        this.sleep = sleep;\n        this.emitCustomEvent = emitCustomEvent ?? this.emitCustomEvent;\n    }\n    _combineLLMOutput() {\n        return [];\n    }\n    _llmType() {\n        return \"fake-list\";\n    }\n    async _generate(_messages, options, runManager) {\n        await this._sleepIfRequested();\n        if (options?.thrownErrorString) {\n            throw new Error(options.thrownErrorString);\n        }\n        if (this.emitCustomEvent) {\n            await runManager?.handleCustomEvent(\"some_test_event\", {\n                someval: true,\n            });\n        }\n        if (options?.stop?.length) {\n            return {\n                generations: [this._formatGeneration(options.stop[0])],\n            };\n        }\n        else {\n            const response = this._currentResponse();\n            this._incrementResponse();\n            return {\n                generations: [this._formatGeneration(response)],\n                llmOutput: {},\n            };\n        }\n    }\n    _formatGeneration(text) {\n        return {\n            message: new _messages_index_js__WEBPACK_IMPORTED_MODULE_4__.AIMessage(text),\n            text,\n        };\n    }\n    async *_streamResponseChunks(_messages, options, runManager) {\n        const response = this._currentResponse();\n        this._incrementResponse();\n        if (this.emitCustomEvent) {\n            await runManager?.handleCustomEvent(\"some_test_event\", {\n                someval: true,\n            });\n        }\n        for await (const text of response) {\n            await this._sleepIfRequested();\n            if (options?.thrownErrorString) {\n                throw new Error(options.thrownErrorString);\n            }\n            const chunk = this._createResponseChunk(text);\n            yield chunk;\n            void runManager?.handleLLMNewToken(text);\n        }\n    }\n    async _sleepIfRequested() {\n        if (this.sleep !== undefined) {\n            await this._sleep();\n        }\n    }\n    async _sleep() {\n        return new Promise((resolve) => {\n            setTimeout(() => resolve(), this.sleep);\n        });\n    }\n    _createResponseChunk(text) {\n        return new _outputs_js__WEBPACK_IMPORTED_MODULE_6__.ChatGenerationChunk({\n            message: new _messages_index_js__WEBPACK_IMPORTED_MODULE_4__.AIMessageChunk({ content: text }),\n            text,\n        });\n    }\n    _currentResponse() {\n        return this.responses[this.i];\n    }\n    _incrementResponse() {\n        if (this.i < this.responses.length - 1) {\n            this.i += 1;\n        }\n        else {\n            this.i = 0;\n        }\n    }\n    withStructuredOutput(_params, _config) {\n        return _runnables_base_js__WEBPACK_IMPORTED_MODULE_8__.RunnableLambda.from(async (input) => {\n            const message = await this.invoke(input);\n            if (message.tool_calls?.[0]?.args) {\n                return message.tool_calls[0].args;\n            }\n            if (typeof message.content === \"string\") {\n                return JSON.parse(message.content);\n            }\n            throw new Error(\"No structured output found\");\n        });\n    }\n}\nclass FakeChatMessageHistory extends _chat_history_js__WEBPACK_IMPORTED_MODULE_0__.BaseChatMessageHistory {\n    constructor() {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"message\", \"fake\"]\n        });\n        Object.defineProperty(this, \"messages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    async getMessages() {\n        return this.messages;\n    }\n    async addMessage(message) {\n        this.messages.push(message);\n    }\n    async addUserMessage(message) {\n        this.messages.push(new _messages_index_js__WEBPACK_IMPORTED_MODULE_4__.HumanMessage(message));\n    }\n    async addAIChatMessage(message) {\n        this.messages.push(new _messages_index_js__WEBPACK_IMPORTED_MODULE_4__.AIMessage(message));\n    }\n    async clear() {\n        this.messages = [];\n    }\n}\nclass FakeListChatMessageHistory extends _chat_history_js__WEBPACK_IMPORTED_MODULE_0__.BaseListChatMessageHistory {\n    constructor() {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"message\", \"fake\"]\n        });\n        Object.defineProperty(this, \"messages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    async addMessage(message) {\n        this.messages.push(message);\n    }\n    async getMessages() {\n        return this.messages;\n    }\n}\nclass FakeTracer extends _tracers_base_js__WEBPACK_IMPORTED_MODULE_10__.BaseTracer {\n    constructor() {\n        super();\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"fake_tracer\"\n        });\n        Object.defineProperty(this, \"runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    persistRun(run) {\n        this.runs.push(run);\n        return Promise.resolve();\n    }\n}\nclass FakeTool extends _tools_index_js__WEBPACK_IMPORTED_MODULE_9__.StructuredTool {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.schema = fields.schema;\n    }\n    async _call(arg, _runManager) {\n        return JSON.stringify(arg);\n    }\n}\n/**\n * A class that provides fake embeddings by overriding the embedDocuments\n * and embedQuery methods to return fixed values.\n */\nclass FakeEmbeddings extends _embeddings_js__WEBPACK_IMPORTED_MODULE_11__.Embeddings {\n    constructor(params) {\n        super(params ?? {});\n    }\n    /**\n     * Generates fixed embeddings for a list of documents.\n     * @param documents List of documents to generate embeddings for.\n     * @returns A promise that resolves with a list of fixed embeddings for each document.\n     */\n    embedDocuments(documents) {\n        return Promise.resolve(documents.map(() => [0.1, 0.2, 0.3, 0.4]));\n    }\n    /**\n     * Generates a fixed embedding for a query.\n     * @param _ The query to generate an embedding for.\n     * @returns A promise that resolves with a fixed embedding for the query.\n     */\n    embedQuery(_) {\n        return Promise.resolve([0.1, 0.2, 0.3, 0.4]);\n    }\n}\n/**\n * A class that provides synthetic embeddings by overriding the\n * embedDocuments and embedQuery methods to generate embeddings based on\n * the input documents. The embeddings are generated by converting each\n * document into chunks, calculating a numerical value for each chunk, and\n * returning an array of these values as the embedding.\n */\nclass SyntheticEmbeddings extends _embeddings_js__WEBPACK_IMPORTED_MODULE_11__.Embeddings {\n    constructor(params) {\n        super(params ?? {});\n        Object.defineProperty(this, \"vectorSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.vectorSize = params?.vectorSize ?? 4;\n    }\n    /**\n     * Generates synthetic embeddings for a list of documents.\n     * @param documents List of documents to generate embeddings for.\n     * @returns A promise that resolves with a list of synthetic embeddings for each document.\n     */\n    async embedDocuments(documents) {\n        return Promise.all(documents.map((doc) => this.embedQuery(doc)));\n    }\n    /**\n     * Generates a synthetic embedding for a document. The document is\n     * converted into chunks, a numerical value is calculated for each chunk,\n     * and an array of these values is returned as the embedding.\n     * @param document The document to generate an embedding for.\n     * @returns A promise that resolves with a synthetic embedding for the document.\n     */\n    async embedQuery(document) {\n        let doc = document;\n        // Only use the letters (and space) from the document, and make them lower case\n        doc = doc.toLowerCase().replaceAll(/[^a-z ]/g, \"\");\n        // Pad the document to make sure it has a divisible number of chunks\n        const padMod = doc.length % this.vectorSize;\n        const padGapSize = padMod === 0 ? 0 : this.vectorSize - padMod;\n        const padSize = doc.length + padGapSize;\n        doc = doc.padEnd(padSize, \" \");\n        // Break it into chunks\n        const chunkSize = doc.length / this.vectorSize;\n        const docChunk = [];\n        for (let co = 0; co < doc.length; co += chunkSize) {\n            docChunk.push(doc.slice(co, co + chunkSize));\n        }\n        // Turn each chunk into a number\n        const ret = docChunk.map((s) => {\n            let sum = 0;\n            // Get a total value by adding the value of each character in the string\n            for (let co = 0; co < s.length; co += 1) {\n                sum += s === \" \" ? 0 : s.charCodeAt(co);\n            }\n            // Reduce this to a number between 0 and 25 inclusive\n            // Then get the fractional number by dividing it by 26\n            const ret = (sum % 26) / 26;\n            return ret;\n        });\n        return ret;\n    }\n}\nclass SingleRunExtractor extends _tracers_base_js__WEBPACK_IMPORTED_MODULE_10__.BaseTracer {\n    constructor() {\n        super();\n        Object.defineProperty(this, \"runPromiseResolver\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"runPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The name of the callback handler. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"single_run_extractor\"\n        });\n        this.runPromise = new Promise((extract) => {\n            this.runPromiseResolver = extract;\n        });\n    }\n    async persistRun(run) {\n        this.runPromiseResolver(run);\n    }\n    async extract() {\n        return this.runPromise;\n    }\n}\n/**\n * Class that extends `VectorStore` to store vectors in memory. Provides\n * methods for adding documents, performing similarity searches, and\n * creating instances from texts, documents, or an existing index.\n */\nclass FakeVectorStore extends _vectorstores_js__WEBPACK_IMPORTED_MODULE_13__.VectorStore {\n    _vectorstoreType() {\n        return \"memory\";\n    }\n    constructor(embeddings, { similarity, ...rest } = {}) {\n        super(embeddings, rest);\n        Object.defineProperty(this, \"memoryVectors\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"similarity\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.similarity = similarity ?? _ml_distance_similarities_js__WEBPACK_IMPORTED_MODULE_14__.cosine;\n    }\n    /**\n     * Method to add documents to the memory vector store. It extracts the\n     * text from each document, generates embeddings for them, and adds the\n     * resulting vectors to the store.\n     * @param documents Array of `Document` instances to be added to the store.\n     * @returns Promise that resolves when all documents have been added.\n     */\n    async addDocuments(documents) {\n        const texts = documents.map(({ pageContent }) => pageContent);\n        return this.addVectors(await this.embeddings.embedDocuments(texts), documents);\n    }\n    /**\n     * Method to add vectors to the memory vector store. It creates\n     * `MemoryVector` instances for each vector and document pair and adds\n     * them to the store.\n     * @param vectors Array of vectors to be added to the store.\n     * @param documents Array of `Document` instances corresponding to the vectors.\n     * @returns Promise that resolves when all vectors have been added.\n     */\n    async addVectors(vectors, documents) {\n        const memoryVectors = vectors.map((embedding, idx) => ({\n            content: documents[idx].pageContent,\n            embedding,\n            metadata: documents[idx].metadata,\n        }));\n        this.memoryVectors = this.memoryVectors.concat(memoryVectors);\n    }\n    /**\n     * Method to perform a similarity search in the memory vector store. It\n     * calculates the similarity between the query vector and each vector in\n     * the store, sorts the results by similarity, and returns the top `k`\n     * results along with their scores.\n     * @param query Query vector to compare against the vectors in the store.\n     * @param k Number of top results to return.\n     * @param filter Optional filter function to apply to the vectors before performing the search.\n     * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.\n     */\n    async similaritySearchVectorWithScore(query, k, filter) {\n        const filterFunction = (memoryVector) => {\n            if (!filter) {\n                return true;\n            }\n            const doc = new _documents_document_js__WEBPACK_IMPORTED_MODULE_1__.Document({\n                metadata: memoryVector.metadata,\n                pageContent: memoryVector.content,\n            });\n            return filter(doc);\n        };\n        const filteredMemoryVectors = this.memoryVectors.filter(filterFunction);\n        const searches = filteredMemoryVectors\n            .map((vector, index) => ({\n            similarity: this.similarity(query, vector.embedding),\n            index,\n        }))\n            .sort((a, b) => (a.similarity > b.similarity ? -1 : 0))\n            .slice(0, k);\n        const result = searches.map((search) => [\n            new _documents_document_js__WEBPACK_IMPORTED_MODULE_1__.Document({\n                metadata: filteredMemoryVectors[search.index].metadata,\n                pageContent: filteredMemoryVectors[search.index].content,\n            }),\n            search.similarity,\n        ]);\n        return result;\n    }\n    /**\n     * Static method to create a `FakeVectorStore` instance from an array of\n     * texts. It creates a `Document` for each text and metadata pair, and\n     * adds them to the store.\n     * @param texts Array of texts to be added to the store.\n     * @param metadatas Array or single object of metadata corresponding to the texts.\n     * @param embeddings `Embeddings` instance used to generate embeddings for the texts.\n     * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.\n     * @returns Promise that resolves with a new `FakeVectorStore` instance.\n     */\n    static async fromTexts(texts, metadatas, embeddings, dbConfig) {\n        const docs = [];\n        for (let i = 0; i < texts.length; i += 1) {\n            const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n            const newDoc = new _documents_document_js__WEBPACK_IMPORTED_MODULE_1__.Document({\n                pageContent: texts[i],\n                metadata,\n            });\n            docs.push(newDoc);\n        }\n        return FakeVectorStore.fromDocuments(docs, embeddings, dbConfig);\n    }\n    /**\n     * Static method to create a `FakeVectorStore` instance from an array of\n     * `Document` instances. It adds the documents to the store.\n     * @param docs Array of `Document` instances to be added to the store.\n     * @param embeddings `Embeddings` instance used to generate embeddings for the documents.\n     * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.\n     * @returns Promise that resolves with a new `FakeVectorStore` instance.\n     */\n    static async fromDocuments(docs, embeddings, dbConfig) {\n        const instance = new this(embeddings, dbConfig);\n        await instance.addDocuments(docs);\n        return instance;\n    }\n    /**\n     * Static method to create a `FakeVectorStore` instance from an existing\n     * index. It creates a new `FakeVectorStore` instance without adding any\n     * documents or vectors.\n     * @param embeddings `Embeddings` instance used to generate embeddings for the documents.\n     * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.\n     * @returns Promise that resolves with a new `FakeVectorStore` instance.\n     */\n    static async fromExistingIndex(embeddings, dbConfig) {\n        const instance = new this(embeddings, dbConfig);\n        return instance;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdGVzdGluZy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQzRGO0FBQ3JDO0FBQ2U7QUFDbEI7QUFDK0I7QUFDbkI7QUFDUjtBQUNFO0FBQ1M7QUFDYjtBQUNIO0FBQ0Q7QUFDRDtBQUNHO0FBQ0k7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0MscUVBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsd0RBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNPLHNCQUFzQix5REFBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQix5REFBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QiwwRUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlEQUFTO0FBQzlDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlEQUFTO0FBQzFDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQywwRUFBYTtBQUN6RCxrQkFBa0IsMkZBQTJGO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOERBQVk7QUFDcEQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOERBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhEQUFZO0FBQ3JELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhEQUFZO0FBQ2hEO0FBQ0E7QUFDQSwrREFBK0QsZUFBZTtBQUM5RTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseURBQVM7QUFDMUM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQW1CO0FBQ2xELGlDQUFpQyw4REFBYztBQUMvQztBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG9IQUFvSCxXQUFXO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBbUI7QUFDOUMsNkJBQTZCLDhEQUFjLEdBQUcsYUFBYTtBQUMzRDtBQUNBLGFBQWE7QUFDYjtBQUNBLGtHQUFrRyxXQUFXO0FBQzdHO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QiwrREFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFRLEdBQUcsb0JBQW9CO0FBQ25ELG9CQUFvQiw0REFBUSxHQUFHLG9CQUFvQjtBQUNuRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNPLGdDQUFnQywwRUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQiw0REFBbUI7QUFDdEMseUJBQXlCLDhEQUFjLEdBQUcsZUFBZTtBQUN6RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08scUNBQXFDLG9FQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQVk7QUFDM0M7QUFDQTtBQUNBLCtCQUErQix5REFBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUNBQXlDLHdFQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIseURBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1QkFBdUIsMkRBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2Qix1REFBVTtBQUM5QztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyx1REFBVTtBQUNuRDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMseURBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDhCQUE4QiwwREFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCLElBQUk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDLGlFQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUFRO0FBQ3BDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFRO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0EsK0JBQStCLDREQUFRO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFx0ZXN0aW5nXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm9taXNlLWV4ZWN1dG9yLXJldHVybiAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5pbXBvcnQgeyBCYXNlQ2hhdE1lc3NhZ2VIaXN0b3J5LCBCYXNlTGlzdENoYXRNZXNzYWdlSGlzdG9yeSwgfSBmcm9tIFwiLi4vLi4vY2hhdF9oaXN0b3J5LmpzXCI7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gXCIuLi8uLi9kb2N1bWVudHMvZG9jdW1lbnQuanNcIjtcbmltcG9ydCB7IEJhc2VDaGF0TW9kZWwsIH0gZnJvbSBcIi4uLy4uL2xhbmd1YWdlX21vZGVscy9jaGF0X21vZGVscy5qc1wiO1xuaW1wb3J0IHsgTExNIH0gZnJvbSBcIi4uLy4uL2xhbmd1YWdlX21vZGVscy9sbG1zLmpzXCI7XG5pbXBvcnQgeyBBSU1lc3NhZ2UsIEFJTWVzc2FnZUNodW5rLCBIdW1hbk1lc3NhZ2UsIH0gZnJvbSBcIi4uLy4uL21lc3NhZ2VzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBCYXNlT3V0cHV0UGFyc2VyIH0gZnJvbSBcIi4uLy4uL291dHB1dF9wYXJzZXJzL2Jhc2UuanNcIjtcbmltcG9ydCB7IENoYXRHZW5lcmF0aW9uQ2h1bmssIH0gZnJvbSBcIi4uLy4uL291dHB1dHMuanNcIjtcbmltcG9ydCB7IEJhc2VSZXRyaWV2ZXIgfSBmcm9tIFwiLi4vLi4vcmV0cmlldmVycy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUnVubmFibGUsIFJ1bm5hYmxlTGFtYmRhIH0gZnJvbSBcIi4uLy4uL3J1bm5hYmxlcy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBTdHJ1Y3R1cmVkVG9vbCB9IGZyb20gXCIuLi8uLi90b29scy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQmFzZVRyYWNlciB9IGZyb20gXCIuLi8uLi90cmFjZXJzL2Jhc2UuanNcIjtcbmltcG9ydCB7IEVtYmVkZGluZ3MsIH0gZnJvbSBcIi4uLy4uL2VtYmVkZGluZ3MuanNcIjtcbmltcG9ydCB7IHRvSnNvblNjaGVtYSB9IGZyb20gXCIuLi9qc29uX3NjaGVtYS5qc1wiO1xuaW1wb3J0IHsgVmVjdG9yU3RvcmUgfSBmcm9tIFwiLi4vLi4vdmVjdG9yc3RvcmVzLmpzXCI7XG5pbXBvcnQgeyBjb3NpbmUgfSBmcm9tIFwiLi4vbWwtZGlzdGFuY2Uvc2ltaWxhcml0aWVzLmpzXCI7XG4vKipcbiAqIFBhcnNlciBmb3IgY29tbWEtc2VwYXJhdGVkIHZhbHVlcy4gSXQgc3BsaXRzIHRoZSBpbnB1dCB0ZXh0IGJ5IGNvbW1hc1xuICogYW5kIHRyaW1zIHRoZSByZXN1bHRpbmcgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgRmFrZVNwbGl0SW50b0xpc3RQYXJzZXIgZXh0ZW5kcyBCYXNlT3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJ0ZXN0c1wiLCBcImZha2VcIl1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQuc3BsaXQoXCIsXCIpLm1hcCgodmFsdWUpID0+IHZhbHVlLnRyaW0oKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZha2VSdW5uYWJsZSBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJ0ZXN0c1wiLCBcImZha2VcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJldHVybk9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXR1cm5PcHRpb25zID0gZmllbGRzLnJldHVybk9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5PcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucyA/PyB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbnB1dCB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGYWtlTExNIGV4dGVuZHMgTExNIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGhyb3duRXJyb3JTdHJpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IGZpZWxkcy5yZXNwb25zZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvclN0cmluZyA9IGZpZWxkcy50aHJvd25FcnJvclN0cmluZztcbiAgICB9XG4gICAgX2xsbVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImZha2VcIjtcbiAgICB9XG4gICAgYXN5bmMgX2NhbGwocHJvbXB0LCBfb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBpZiAodGhpcy50aHJvd25FcnJvclN0cmluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudGhyb3duRXJyb3JTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5yZXNwb25zZSA/PyBwcm9tcHQ7XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTU5ld1Rva2VuKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGYWtlU3RyZWFtaW5nTExNIGV4dGVuZHMgTExNIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2xlZXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDUwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNwb25zZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGhyb3duRXJyb3JTdHJpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zbGVlcCA9IGZpZWxkcy5zbGVlcCA/PyB0aGlzLnNsZWVwO1xuICAgICAgICB0aGlzLnJlc3BvbnNlcyA9IGZpZWxkcy5yZXNwb25zZXM7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3JTdHJpbmcgPSBmaWVsZHMudGhyb3duRXJyb3JTdHJpbmc7XG4gICAgfVxuICAgIF9sbG1UeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmYWtlXCI7XG4gICAgfVxuICAgIGFzeW5jIF9jYWxsKHByb21wdCkge1xuICAgICAgICBpZiAodGhpcy50aHJvd25FcnJvclN0cmluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudGhyb3duRXJyb3JTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5yZXNwb25zZXM/LlswXTtcbiAgICAgICAgdGhpcy5yZXNwb25zZXMgPSB0aGlzLnJlc3BvbnNlcz8uc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZSA/PyBwcm9tcHQ7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtUmVzcG9uc2VDaHVua3MoaW5wdXQsIF9vcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLnRocm93bkVycm9yU3RyaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy50aHJvd25FcnJvclN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlcz8uWzBdO1xuICAgICAgICB0aGlzLnJlc3BvbnNlcyA9IHRoaXMucmVzcG9uc2VzPy5zbGljZSgxKTtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHJlc3BvbnNlID8/IGlucHV0KSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLnNsZWVwKSk7XG4gICAgICAgICAgICB5aWVsZCB7IHRleHQ6IGMsIGdlbmVyYXRpb25JbmZvOiB7fSB9O1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNTmV3VG9rZW4oYyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRmFrZUNoYXRNb2RlbCBleHRlbmRzIEJhc2VDaGF0TW9kZWwge1xuICAgIF9jb21iaW5lTExNT3V0cHV0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIF9sbG1UeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmYWtlXCI7XG4gICAgfVxuICAgIGFzeW5jIF9nZW5lcmF0ZShtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBpZiAob3B0aW9ucz8uc3RvcD8ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBBSU1lc3NhZ2Uob3B0aW9ucy5zdG9wWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG9wdGlvbnMuc3RvcFswXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0ID0gbWVzc2FnZXNcbiAgICAgICAgICAgIC5tYXAoKG0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0uY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtLmNvbnRlbnQsIG51bGwsIDIpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTU5ld1Rva2VuKHRleHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBBSU1lc3NhZ2UodGV4dCksXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBsbG1PdXRwdXQ6IHt9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGYWtlU3RyZWFtaW5nQ2hhdE1vZGVsIGV4dGVuZHMgQmFzZUNoYXRNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoeyBzbGVlcCA9IDUwLCByZXNwb25zZXMgPSBbXSwgY2h1bmtzID0gW10sIHRvb2xTdHlsZSA9IFwib3BlbmFpXCIsIHRocm93bkVycm9yU3RyaW5nLCAuLi5yZXN0IH0pIHtcbiAgICAgICAgc3VwZXIocmVzdCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNsZWVwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA1MFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2h1bmtzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbFN0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIm9wZW5haVwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aHJvd25FcnJvclN0cmluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2xlZXAgPSBzbGVlcDtcbiAgICAgICAgdGhpcy5yZXNwb25zZXMgPSByZXNwb25zZXM7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gY2h1bmtzO1xuICAgICAgICB0aGlzLnRvb2xTdHlsZSA9IHRvb2xTdHlsZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvclN0cmluZyA9IHRocm93bkVycm9yU3RyaW5nO1xuICAgIH1cbiAgICBfbGxtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZmFrZVwiO1xuICAgIH1cbiAgICBiaW5kVG9vbHModG9vbHMpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gWy4uLnRoaXMudG9vbHMsIC4uLnRvb2xzXTtcbiAgICAgICAgY29uc3QgdG9vbERpY3RzID0gbWVyZ2VkLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRvb2xTdHlsZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVuYWlcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRvSnNvblNjaGVtYSh0LnNjaGVtYSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbnRocm9waWNcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2NoZW1hOiB0b0pzb25TY2hlbWEodC5zY2hlbWEpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgXCJiZWRyb2NrXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sU3BlYzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYTogdG9Kc29uU2NoZW1hKHQuc2NoZW1hKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSBcImdvb2dsZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHQuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0b0pzb25TY2hlbWEodC5zY2hlbWEpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdG9vbCBzdHlsZTogJHt0aGlzLnRvb2xTdHlsZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWQgPSB0aGlzLnRvb2xTdHlsZSA9PT0gXCJnb29nbGVcIlxuICAgICAgICAgICAgPyBbeyBmdW5jdGlvbkRlY2xhcmF0aW9uczogdG9vbERpY3RzIH1dXG4gICAgICAgICAgICA6IHRvb2xEaWN0cztcbiAgICAgICAgLyogY3JlYXRpbmcgYSAqbmV3KiBpbnN0YW5jZSDigJMgbWlycm9ycyBMYW5nQ2hhaW4gLmJpbmQgc2VtYW50aWNzIGZvciB0eXBlLXNhZmV0eSBhbmQgYXZvaWRpbmcgbm9pc2UgKi9cbiAgICAgICAgY29uc3QgbmV4dCA9IG5ldyBGYWtlU3RyZWFtaW5nQ2hhdE1vZGVsKHtcbiAgICAgICAgICAgIHNsZWVwOiB0aGlzLnNsZWVwLFxuICAgICAgICAgICAgcmVzcG9uc2VzOiB0aGlzLnJlc3BvbnNlcyxcbiAgICAgICAgICAgIGNodW5rczogdGhpcy5jaHVua3MsXG4gICAgICAgICAgICB0b29sU3R5bGU6IHRoaXMudG9vbFN0eWxlLFxuICAgICAgICAgICAgdGhyb3duRXJyb3JTdHJpbmc6IHRoaXMudGhyb3duRXJyb3JTdHJpbmcsXG4gICAgICAgIH0pO1xuICAgICAgICBuZXh0LnRvb2xzID0gbWVyZ2VkO1xuICAgICAgICByZXR1cm4gbmV4dC53aXRoQ29uZmlnKHsgdG9vbHM6IHdyYXBwZWQgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9nZW5lcmF0ZShtZXNzYWdlcywgX29wdGlvbnMsIF9ydW5NYW5hZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLnRocm93bkVycm9yU3RyaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy50aHJvd25FcnJvclN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMucmVzcG9uc2VzPy5bMF0/LmNvbnRlbnQgPz8gbWVzc2FnZXNbMF0uY29udGVudCA/PyBcIlwiO1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9uID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBBSU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRoaXMuY2h1bmtzPy5bMF0/LnRvb2xfY2FsbHMsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGlvbjtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1SZXNwb25zZUNodW5rcyhfbWVzc2FnZXMsIF9vcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLnRocm93bkVycm9yU3RyaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy50aHJvd25FcnJvclN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXNnQ2h1bmsgb2YgdGhpcy5jaHVua3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZyA9IG5ldyBDaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbmV3IEFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1zZ0NodW5rLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBtc2dDaHVuay50b29sX2NhbGxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IG1zZ0NodW5rLmFkZGl0aW9uYWxfa3dhcmdzID8/IHt9LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbXNnQ2h1bmsuY29udGVudD8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkIGNnO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTU5ld1Rva2VuKG1zZ0NodW5rLmNvbnRlbnQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBjaHVuazogY2cgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFsbGJhY2sgPSB0aGlzLnJlc3BvbnNlcz8uWzBdID8/XG4gICAgICAgICAgICBuZXcgQUlNZXNzYWdlKHR5cGVvZiBfbWVzc2FnZXNbMF0uY29udGVudCA9PT0gXCJzdHJpbmdcIiA/IF9tZXNzYWdlc1swXS5jb250ZW50IDogXCJcIik7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0eXBlb2YgZmFsbGJhY2suY29udGVudCA9PT0gXCJzdHJpbmdcIiA/IGZhbGxiYWNrLmNvbnRlbnQgOiBcIlwiO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRleHQpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIHRoaXMuc2xlZXApKTtcbiAgICAgICAgICAgIGNvbnN0IGNnID0gbmV3IENoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBBSU1lc3NhZ2VDaHVuayh7IGNvbnRlbnQ6IGNoIH0pLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCBjZztcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTU5ld1Rva2VuKGNoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgY2h1bms6IGNnIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZha2VSZXRyaWV2ZXIgZXh0ZW5kcyBCYXNlUmV0cmlldmVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJ0ZXN0XCIsIFwiZmFrZVwiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3V0cHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgbmV3IERvY3VtZW50KHsgcGFnZUNvbnRlbnQ6IFwiZm9vXCIgfSksXG4gICAgICAgICAgICAgICAgbmV3IERvY3VtZW50KHsgcGFnZUNvbnRlbnQ6IFwiYmFyXCIgfSksXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm91dHB1dCA9IGZpZWxkcz8ub3V0cHV0ID8/IHRoaXMub3V0cHV0O1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UmVsZXZhbnREb2N1bWVudHMoX3F1ZXJ5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0O1xuICAgIH1cbn1cbi8qKlxuICogQSBmYWtlIENoYXQgTW9kZWwgdGhhdCByZXR1cm5zIGEgcHJlZGVmaW5lZCBsaXN0IG9mIHJlc3BvbnNlcy4gSXQgY2FuIGJlIHVzZWRcbiAqIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGNoYXQgPSBuZXcgRmFrZUxpc3RDaGF0TW9kZWwoe1xuICogICByZXNwb25zZXM6IFtcIkknbGwgY2FsbGJhY2sgbGF0ZXIuXCIsIFwiWW91ICdjb25zb2xlJyB0aGVtIVwiXVxuICogfSk7XG4gKlxuICogY29uc3QgZmlyc3RNZXNzYWdlID0gbmV3IEh1bWFuTWVzc2FnZShcIllvdSB3YW50IHRvIGhlYXIgYSBKYXZhU2NyaXB0IGpva2U/XCIpO1xuICogY29uc3Qgc2Vjb25kTWVzc2FnZSA9IG5ldyBIdW1hbk1lc3NhZ2UoXCJIb3cgZG8geW91IGNoZWVyIHVwIGEgSmF2YVNjcmlwdCBkZXZlbG9wZXI/XCIpO1xuICpcbiAqIC8vIENhbGwgdGhlIGNoYXQgbW9kZWwgd2l0aCBhIG1lc3NhZ2UgYW5kIGxvZyB0aGUgcmVzcG9uc2VcbiAqIGNvbnN0IGZpcnN0UmVzcG9uc2UgPSBhd2FpdCBjaGF0LmNhbGwoW2ZpcnN0TWVzc2FnZV0pO1xuICogY29uc29sZS5sb2coeyBmaXJzdFJlc3BvbnNlIH0pO1xuICpcbiAqIGNvbnN0IHNlY29uZFJlc3BvbnNlID0gYXdhaXQgY2hhdC5jYWxsKFtzZWNvbmRNZXNzYWdlXSk7XG4gKiBjb25zb2xlLmxvZyh7IHNlY29uZFJlc3BvbnNlIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWtlTGlzdENoYXRNb2RlbCBleHRlbmRzIEJhc2VDaGF0TW9kZWwge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJGYWtlTGlzdENoYXRNb2RlbFwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNwb25zZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2xlZXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW1pdEN1c3RvbUV2ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyByZXNwb25zZXMsIHNsZWVwLCBlbWl0Q3VzdG9tRXZlbnQgfSA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5yZXNwb25zZXMgPSByZXNwb25zZXM7XG4gICAgICAgIHRoaXMuc2xlZXAgPSBzbGVlcDtcbiAgICAgICAgdGhpcy5lbWl0Q3VzdG9tRXZlbnQgPSBlbWl0Q3VzdG9tRXZlbnQgPz8gdGhpcy5lbWl0Q3VzdG9tRXZlbnQ7XG4gICAgfVxuICAgIF9jb21iaW5lTExNT3V0cHV0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIF9sbG1UeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmYWtlLWxpc3RcIjtcbiAgICB9XG4gICAgYXN5bmMgX2dlbmVyYXRlKF9tZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zbGVlcElmUmVxdWVzdGVkKCk7XG4gICAgICAgIGlmIChvcHRpb25zPy50aHJvd25FcnJvclN0cmluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbnMudGhyb3duRXJyb3JTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVtaXRDdXN0b21FdmVudCkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ3VzdG9tRXZlbnQoXCJzb21lX3Rlc3RfZXZlbnRcIiwge1xuICAgICAgICAgICAgICAgIHNvbWV2YWw6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucz8uc3RvcD8ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbdGhpcy5fZm9ybWF0R2VuZXJhdGlvbihvcHRpb25zLnN0b3BbMF0pXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuX2N1cnJlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFt0aGlzLl9mb3JtYXRHZW5lcmF0aW9uKHJlc3BvbnNlKV0sXG4gICAgICAgICAgICAgICAgbGxtT3V0cHV0OiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Zvcm1hdEdlbmVyYXRpb24odGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogbmV3IEFJTWVzc2FnZSh0ZXh0KSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtUmVzcG9uc2VDaHVua3MoX21lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5fY3VycmVudFJlc3BvbnNlKCk7XG4gICAgICAgIHRoaXMuX2luY3JlbWVudFJlc3BvbnNlKCk7XG4gICAgICAgIGlmICh0aGlzLmVtaXRDdXN0b21FdmVudCkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ3VzdG9tRXZlbnQoXCJzb21lX3Rlc3RfZXZlbnRcIiwge1xuICAgICAgICAgICAgICAgIHNvbWV2YWw6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHRleHQgb2YgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NsZWVwSWZSZXF1ZXN0ZWQoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy50aHJvd25FcnJvclN0cmluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25zLnRocm93bkVycm9yU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY3JlYXRlUmVzcG9uc2VDaHVuayh0ZXh0KTtcbiAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgdm9pZCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1OZXdUb2tlbih0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2xlZXBJZlJlcXVlc3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2xlZXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2xlZXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2xlZXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIHRoaXMuc2xlZXApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NyZWF0ZVJlc3BvbnNlQ2h1bmsodGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgbWVzc2FnZTogbmV3IEFJTWVzc2FnZUNodW5rKHsgY29udGVudDogdGV4dCB9KSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY3VycmVudFJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZXNbdGhpcy5pXTtcbiAgICB9XG4gICAgX2luY3JlbWVudFJlc3BvbnNlKCkge1xuICAgICAgICBpZiAodGhpcy5pIDwgdGhpcy5yZXNwb25zZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy5pICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhTdHJ1Y3R1cmVkT3V0cHV0KF9wYXJhbXMsIF9jb25maWcpIHtcbiAgICAgICAgcmV0dXJuIFJ1bm5hYmxlTGFtYmRhLmZyb20oYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5pbnZva2UoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudG9vbF9jYWxscz8uWzBdPy5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UudG9vbF9jYWxsc1swXS5hcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShtZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RydWN0dXJlZCBvdXRwdXQgZm91bmRcIik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGYWtlQ2hhdE1lc3NhZ2VIaXN0b3J5IGV4dGVuZHMgQmFzZUNoYXRNZXNzYWdlSGlzdG9yeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJtZXNzYWdlXCIsIFwiZmFrZVwiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRNZXNzYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXM7XG4gICAgfVxuICAgIGFzeW5jIGFkZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZFVzZXJNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKG5ldyBIdW1hbk1lc3NhZ2UobWVzc2FnZSkpO1xuICAgIH1cbiAgICBhc3luYyBhZGRBSUNoYXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKG5ldyBBSU1lc3NhZ2UobWVzc2FnZSkpO1xuICAgIH1cbiAgICBhc3luYyBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGYWtlTGlzdENoYXRNZXNzYWdlSGlzdG9yeSBleHRlbmRzIEJhc2VMaXN0Q2hhdE1lc3NhZ2VIaXN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm1lc3NhZ2VcIiwgXCJmYWtlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgfVxuICAgIGFzeW5jIGdldE1lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRmFrZVRyYWNlciBleHRlbmRzIEJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImZha2VfdHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJzaXN0UnVuKHJ1bikge1xuICAgICAgICB0aGlzLnJ1bnMucHVzaChydW4pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZha2VUb29sIGV4dGVuZHMgU3RydWN0dXJlZFRvb2wge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBmaWVsZHMuc2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyBfY2FsbChhcmcsIF9ydW5NYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyB0aGF0IHByb3ZpZGVzIGZha2UgZW1iZWRkaW5ncyBieSBvdmVycmlkaW5nIHRoZSBlbWJlZERvY3VtZW50c1xuICogYW5kIGVtYmVkUXVlcnkgbWV0aG9kcyB0byByZXR1cm4gZml4ZWQgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgRmFrZUVtYmVkZGluZ3MgZXh0ZW5kcyBFbWJlZGRpbmdzIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIocGFyYW1zID8/IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGZpeGVkIGVtYmVkZGluZ3MgZm9yIGEgbGlzdCBvZiBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIGRvY3VtZW50cyBMaXN0IG9mIGRvY3VtZW50cyB0byBnZW5lcmF0ZSBlbWJlZGRpbmdzIGZvci5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgbGlzdCBvZiBmaXhlZCBlbWJlZGRpbmdzIGZvciBlYWNoIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGVtYmVkRG9jdW1lbnRzKGRvY3VtZW50cykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRvY3VtZW50cy5tYXAoKCkgPT4gWzAuMSwgMC4yLCAwLjMsIDAuNF0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgZml4ZWQgZW1iZWRkaW5nIGZvciBhIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSBfIFRoZSBxdWVyeSB0byBnZW5lcmF0ZSBhbiBlbWJlZGRpbmcgZm9yLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBmaXhlZCBlbWJlZGRpbmcgZm9yIHRoZSBxdWVyeS5cbiAgICAgKi9cbiAgICBlbWJlZFF1ZXJ5KF8pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbMC4xLCAwLjIsIDAuMywgMC40XSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgcHJvdmlkZXMgc3ludGhldGljIGVtYmVkZGluZ3MgYnkgb3ZlcnJpZGluZyB0aGVcbiAqIGVtYmVkRG9jdW1lbnRzIGFuZCBlbWJlZFF1ZXJ5IG1ldGhvZHMgdG8gZ2VuZXJhdGUgZW1iZWRkaW5ncyBiYXNlZCBvblxuICogdGhlIGlucHV0IGRvY3VtZW50cy4gVGhlIGVtYmVkZGluZ3MgYXJlIGdlbmVyYXRlZCBieSBjb252ZXJ0aW5nIGVhY2hcbiAqIGRvY3VtZW50IGludG8gY2h1bmtzLCBjYWxjdWxhdGluZyBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFjaCBjaHVuaywgYW5kXG4gKiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlc2UgdmFsdWVzIGFzIHRoZSBlbWJlZGRpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBTeW50aGV0aWNFbWJlZGRpbmdzIGV4dGVuZHMgRW1iZWRkaW5ncyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcyA/PyB7fSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlY3RvclNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52ZWN0b3JTaXplID0gcGFyYW1zPy52ZWN0b3JTaXplID8/IDQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBzeW50aGV0aWMgZW1iZWRkaW5ncyBmb3IgYSBsaXN0IG9mIGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRzIExpc3Qgb2YgZG9jdW1lbnRzIHRvIGdlbmVyYXRlIGVtYmVkZGluZ3MgZm9yLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBsaXN0IG9mIHN5bnRoZXRpYyBlbWJlZGRpbmdzIGZvciBlYWNoIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGVtYmVkRG9jdW1lbnRzKGRvY3VtZW50cykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZG9jdW1lbnRzLm1hcCgoZG9jKSA9PiB0aGlzLmVtYmVkUXVlcnkoZG9jKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBzeW50aGV0aWMgZW1iZWRkaW5nIGZvciBhIGRvY3VtZW50LiBUaGUgZG9jdW1lbnQgaXNcbiAgICAgKiBjb252ZXJ0ZWQgaW50byBjaHVua3MsIGEgbnVtZXJpY2FsIHZhbHVlIGlzIGNhbGN1bGF0ZWQgZm9yIGVhY2ggY2h1bmssXG4gICAgICogYW5kIGFuIGFycmF5IG9mIHRoZXNlIHZhbHVlcyBpcyByZXR1cm5lZCBhcyB0aGUgZW1iZWRkaW5nLlxuICAgICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gZ2VuZXJhdGUgYW4gZW1iZWRkaW5nIGZvci5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgc3ludGhldGljIGVtYmVkZGluZyBmb3IgdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGVtYmVkUXVlcnkoZG9jdW1lbnQpIHtcbiAgICAgICAgbGV0IGRvYyA9IGRvY3VtZW50O1xuICAgICAgICAvLyBPbmx5IHVzZSB0aGUgbGV0dGVycyAoYW5kIHNwYWNlKSBmcm9tIHRoZSBkb2N1bWVudCwgYW5kIG1ha2UgdGhlbSBsb3dlciBjYXNlXG4gICAgICAgIGRvYyA9IGRvYy50b0xvd2VyQ2FzZSgpLnJlcGxhY2VBbGwoL1teYS16IF0vZywgXCJcIik7XG4gICAgICAgIC8vIFBhZCB0aGUgZG9jdW1lbnQgdG8gbWFrZSBzdXJlIGl0IGhhcyBhIGRpdmlzaWJsZSBudW1iZXIgb2YgY2h1bmtzXG4gICAgICAgIGNvbnN0IHBhZE1vZCA9IGRvYy5sZW5ndGggJSB0aGlzLnZlY3RvclNpemU7XG4gICAgICAgIGNvbnN0IHBhZEdhcFNpemUgPSBwYWRNb2QgPT09IDAgPyAwIDogdGhpcy52ZWN0b3JTaXplIC0gcGFkTW9kO1xuICAgICAgICBjb25zdCBwYWRTaXplID0gZG9jLmxlbmd0aCArIHBhZEdhcFNpemU7XG4gICAgICAgIGRvYyA9IGRvYy5wYWRFbmQocGFkU2l6ZSwgXCIgXCIpO1xuICAgICAgICAvLyBCcmVhayBpdCBpbnRvIGNodW5rc1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBkb2MubGVuZ3RoIC8gdGhpcy52ZWN0b3JTaXplO1xuICAgICAgICBjb25zdCBkb2NDaHVuayA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjbyA9IDA7IGNvIDwgZG9jLmxlbmd0aDsgY28gKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBkb2NDaHVuay5wdXNoKGRvYy5zbGljZShjbywgY28gKyBjaHVua1NpemUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUdXJuIGVhY2ggY2h1bmsgaW50byBhIG51bWJlclxuICAgICAgICBjb25zdCByZXQgPSBkb2NDaHVuay5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgLy8gR2V0IGEgdG90YWwgdmFsdWUgYnkgYWRkaW5nIHRoZSB2YWx1ZSBvZiBlYWNoIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nXG4gICAgICAgICAgICBmb3IgKGxldCBjbyA9IDA7IGNvIDwgcy5sZW5ndGg7IGNvICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcyA9PT0gXCIgXCIgPyAwIDogcy5jaGFyQ29kZUF0KGNvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlZHVjZSB0aGlzIHRvIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMjUgaW5jbHVzaXZlXG4gICAgICAgICAgICAvLyBUaGVuIGdldCB0aGUgZnJhY3Rpb25hbCBudW1iZXIgYnkgZGl2aWRpbmcgaXQgYnkgMjZcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IChzdW0gJSAyNikgLyAyNjtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTaW5nbGVSdW5FeHRyYWN0b3IgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuUHJvbWlzZVJlc29sdmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1blByb21pc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjYWxsYmFjayBoYW5kbGVyLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcInNpbmdsZV9ydW5fZXh0cmFjdG9yXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucnVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChleHRyYWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJ1blByb21pc2VSZXNvbHZlciA9IGV4dHJhY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0UnVuKHJ1bikge1xuICAgICAgICB0aGlzLnJ1blByb21pc2VSZXNvbHZlcihydW4pO1xuICAgIH1cbiAgICBhc3luYyBleHRyYWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5Qcm9taXNlO1xuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgdGhhdCBleHRlbmRzIGBWZWN0b3JTdG9yZWAgdG8gc3RvcmUgdmVjdG9ycyBpbiBtZW1vcnkuIFByb3ZpZGVzXG4gKiBtZXRob2RzIGZvciBhZGRpbmcgZG9jdW1lbnRzLCBwZXJmb3JtaW5nIHNpbWlsYXJpdHkgc2VhcmNoZXMsIGFuZFxuICogY3JlYXRpbmcgaW5zdGFuY2VzIGZyb20gdGV4dHMsIGRvY3VtZW50cywgb3IgYW4gZXhpc3RpbmcgaW5kZXguXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWtlVmVjdG9yU3RvcmUgZXh0ZW5kcyBWZWN0b3JTdG9yZSB7XG4gICAgX3ZlY3RvcnN0b3JlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwibWVtb3J5XCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGVtYmVkZGluZ3MsIHsgc2ltaWxhcml0eSwgLi4ucmVzdCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoZW1iZWRkaW5ncywgcmVzdCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lbW9yeVZlY3RvcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaW1pbGFyaXR5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2ltaWxhcml0eSA9IHNpbWlsYXJpdHkgPz8gY29zaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gYWRkIGRvY3VtZW50cyB0byB0aGUgbWVtb3J5IHZlY3RvciBzdG9yZS4gSXQgZXh0cmFjdHMgdGhlXG4gICAgICogdGV4dCBmcm9tIGVhY2ggZG9jdW1lbnQsIGdlbmVyYXRlcyBlbWJlZGRpbmdzIGZvciB0aGVtLCBhbmQgYWRkcyB0aGVcbiAgICAgKiByZXN1bHRpbmcgdmVjdG9ycyB0byB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIGRvY3VtZW50cyBBcnJheSBvZiBgRG9jdW1lbnRgIGluc3RhbmNlcyB0byBiZSBhZGRlZCB0byB0aGUgc3RvcmUuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGRvY3VtZW50cyBoYXZlIGJlZW4gYWRkZWQuXG4gICAgICovXG4gICAgYXN5bmMgYWRkRG9jdW1lbnRzKGRvY3VtZW50cykge1xuICAgICAgICBjb25zdCB0ZXh0cyA9IGRvY3VtZW50cy5tYXAoKHsgcGFnZUNvbnRlbnQgfSkgPT4gcGFnZUNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKGF3YWl0IHRoaXMuZW1iZWRkaW5ncy5lbWJlZERvY3VtZW50cyh0ZXh0cyksIGRvY3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBhZGQgdmVjdG9ycyB0byB0aGUgbWVtb3J5IHZlY3RvciBzdG9yZS4gSXQgY3JlYXRlc1xuICAgICAqIGBNZW1vcnlWZWN0b3JgIGluc3RhbmNlcyBmb3IgZWFjaCB2ZWN0b3IgYW5kIGRvY3VtZW50IHBhaXIgYW5kIGFkZHNcbiAgICAgKiB0aGVtIHRvIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0gdmVjdG9ycyBBcnJheSBvZiB2ZWN0b3JzIHRvIGJlIGFkZGVkIHRvIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRzIEFycmF5IG9mIGBEb2N1bWVudGAgaW5zdGFuY2VzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZlY3RvcnMuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHZlY3RvcnMgaGF2ZSBiZWVuIGFkZGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZFZlY3RvcnModmVjdG9ycywgZG9jdW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IG1lbW9yeVZlY3RvcnMgPSB2ZWN0b3JzLm1hcCgoZW1iZWRkaW5nLCBpZHgpID0+ICh7XG4gICAgICAgICAgICBjb250ZW50OiBkb2N1bWVudHNbaWR4XS5wYWdlQ29udGVudCxcbiAgICAgICAgICAgIGVtYmVkZGluZyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBkb2N1bWVudHNbaWR4XS5tZXRhZGF0YSxcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLm1lbW9yeVZlY3RvcnMgPSB0aGlzLm1lbW9yeVZlY3RvcnMuY29uY2F0KG1lbW9yeVZlY3RvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcGVyZm9ybSBhIHNpbWlsYXJpdHkgc2VhcmNoIGluIHRoZSBtZW1vcnkgdmVjdG9yIHN0b3JlLiBJdFxuICAgICAqIGNhbGN1bGF0ZXMgdGhlIHNpbWlsYXJpdHkgYmV0d2VlbiB0aGUgcXVlcnkgdmVjdG9yIGFuZCBlYWNoIHZlY3RvciBpblxuICAgICAqIHRoZSBzdG9yZSwgc29ydHMgdGhlIHJlc3VsdHMgYnkgc2ltaWxhcml0eSwgYW5kIHJldHVybnMgdGhlIHRvcCBga2BcbiAgICAgKiByZXN1bHRzIGFsb25nIHdpdGggdGhlaXIgc2NvcmVzLlxuICAgICAqIEBwYXJhbSBxdWVyeSBRdWVyeSB2ZWN0b3IgdG8gY29tcGFyZSBhZ2FpbnN0IHRoZSB2ZWN0b3JzIGluIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0gayBOdW1iZXIgb2YgdG9wIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgT3B0aW9uYWwgZmlsdGVyIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSB2ZWN0b3JzIGJlZm9yZSBwZXJmb3JtaW5nIHRoZSBzZWFyY2guXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgdHVwbGVzLCBlYWNoIGNvbnRhaW5pbmcgYSBgRG9jdW1lbnRgIGFuZCBpdHMgc2ltaWxhcml0eSBzY29yZS5cbiAgICAgKi9cbiAgICBhc3luYyBzaW1pbGFyaXR5U2VhcmNoVmVjdG9yV2l0aFNjb3JlKHF1ZXJ5LCBrLCBmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyRnVuY3Rpb24gPSAobWVtb3J5VmVjdG9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZG9jID0gbmV3IERvY3VtZW50KHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWVtb3J5VmVjdG9yLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50OiBtZW1vcnlWZWN0b3IuY29udGVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcihkb2MpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaWx0ZXJlZE1lbW9yeVZlY3RvcnMgPSB0aGlzLm1lbW9yeVZlY3RvcnMuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKTtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXMgPSBmaWx0ZXJlZE1lbW9yeVZlY3RvcnNcbiAgICAgICAgICAgIC5tYXAoKHZlY3RvciwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICBzaW1pbGFyaXR5OiB0aGlzLnNpbWlsYXJpdHkocXVlcnksIHZlY3Rvci5lbWJlZGRpbmcpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IChhLnNpbWlsYXJpdHkgPiBiLnNpbWlsYXJpdHkgPyAtMSA6IDApKVxuICAgICAgICAgICAgLnNsaWNlKDAsIGspO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzZWFyY2hlcy5tYXAoKHNlYXJjaCkgPT4gW1xuICAgICAgICAgICAgbmV3IERvY3VtZW50KHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogZmlsdGVyZWRNZW1vcnlWZWN0b3JzW3NlYXJjaC5pbmRleF0ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgcGFnZUNvbnRlbnQ6IGZpbHRlcmVkTWVtb3J5VmVjdG9yc1tzZWFyY2guaW5kZXhdLmNvbnRlbnQsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNlYXJjaC5zaW1pbGFyaXR5LFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBjcmVhdGUgYSBgRmFrZVZlY3RvclN0b3JlYCBpbnN0YW5jZSBmcm9tIGFuIGFycmF5IG9mXG4gICAgICogdGV4dHMuIEl0IGNyZWF0ZXMgYSBgRG9jdW1lbnRgIGZvciBlYWNoIHRleHQgYW5kIG1ldGFkYXRhIHBhaXIsIGFuZFxuICAgICAqIGFkZHMgdGhlbSB0byB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIHRleHRzIEFycmF5IG9mIHRleHRzIHRvIGJlIGFkZGVkIHRvIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFzIEFycmF5IG9yIHNpbmdsZSBvYmplY3Qgb2YgbWV0YWRhdGEgY29ycmVzcG9uZGluZyB0byB0aGUgdGV4dHMuXG4gICAgICogQHBhcmFtIGVtYmVkZGluZ3MgYEVtYmVkZGluZ3NgIGluc3RhbmNlIHVzZWQgdG8gZ2VuZXJhdGUgZW1iZWRkaW5ncyBmb3IgdGhlIHRleHRzLlxuICAgICAqIEBwYXJhbSBkYkNvbmZpZyBPcHRpb25hbCBgRmFrZVZlY3RvclN0b3JlQXJnc2AgdG8gY29uZmlndXJlIHRoZSBgRmFrZVZlY3RvclN0b3JlYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIG5ldyBgRmFrZVZlY3RvclN0b3JlYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbVRleHRzKHRleHRzLCBtZXRhZGF0YXMsIGVtYmVkZGluZ3MsIGRiQ29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGRvY3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBBcnJheS5pc0FycmF5KG1ldGFkYXRhcykgPyBtZXRhZGF0YXNbaV0gOiBtZXRhZGF0YXM7XG4gICAgICAgICAgICBjb25zdCBuZXdEb2MgPSBuZXcgRG9jdW1lbnQoe1xuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50OiB0ZXh0c1tpXSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jcy5wdXNoKG5ld0RvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZha2VWZWN0b3JTdG9yZS5mcm9tRG9jdW1lbnRzKGRvY3MsIGVtYmVkZGluZ3MsIGRiQ29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBjcmVhdGUgYSBgRmFrZVZlY3RvclN0b3JlYCBpbnN0YW5jZSBmcm9tIGFuIGFycmF5IG9mXG4gICAgICogYERvY3VtZW50YCBpbnN0YW5jZXMuIEl0IGFkZHMgdGhlIGRvY3VtZW50cyB0byB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIGRvY3MgQXJyYXkgb2YgYERvY3VtZW50YCBpbnN0YW5jZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSBlbWJlZGRpbmdzIGBFbWJlZGRpbmdzYCBpbnN0YW5jZSB1c2VkIHRvIGdlbmVyYXRlIGVtYmVkZGluZ3MgZm9yIHRoZSBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIGRiQ29uZmlnIE9wdGlvbmFsIGBGYWtlVmVjdG9yU3RvcmVBcmdzYCB0byBjb25maWd1cmUgdGhlIGBGYWtlVmVjdG9yU3RvcmVgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgbmV3IGBGYWtlVmVjdG9yU3RvcmVgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tRG9jdW1lbnRzKGRvY3MsIGVtYmVkZGluZ3MsIGRiQ29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IHRoaXMoZW1iZWRkaW5ncywgZGJDb25maWcpO1xuICAgICAgICBhd2FpdCBpbnN0YW5jZS5hZGREb2N1bWVudHMoZG9jcyk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBjcmVhdGUgYSBgRmFrZVZlY3RvclN0b3JlYCBpbnN0YW5jZSBmcm9tIGFuIGV4aXN0aW5nXG4gICAgICogaW5kZXguIEl0IGNyZWF0ZXMgYSBuZXcgYEZha2VWZWN0b3JTdG9yZWAgaW5zdGFuY2Ugd2l0aG91dCBhZGRpbmcgYW55XG4gICAgICogZG9jdW1lbnRzIG9yIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGVtYmVkZGluZ3MgYEVtYmVkZGluZ3NgIGluc3RhbmNlIHVzZWQgdG8gZ2VuZXJhdGUgZW1iZWRkaW5ncyBmb3IgdGhlIGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gZGJDb25maWcgT3B0aW9uYWwgYEZha2VWZWN0b3JTdG9yZUFyZ3NgIHRvIGNvbmZpZ3VyZSB0aGUgYEZha2VWZWN0b3JTdG9yZWAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBuZXcgYEZha2VWZWN0b3JTdG9yZWAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21FeGlzdGluZ0luZGV4KGVtYmVkZGluZ3MsIGRiQ29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IHRoaXMoZW1iZWRkaW5ncywgZGJDb25maWcpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/testing/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/tiktoken.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodingForModel: () => (/* binding */ encodingForModel),\n/* harmony export */   getEncoding: () => (/* binding */ getEncoding)\n/* harmony export */ });\n/* harmony import */ var js_tiktoken_lite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-tiktoken/lite */ \"(rsc)/./node_modules/js-tiktoken/dist/lite.js\");\n/* harmony import */ var _async_caller_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./async_caller.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.js\");\n\n\nconst cache = {};\nconst caller = /* #__PURE__ */ new _async_caller_js__WEBPACK_IMPORTED_MODULE_1__.AsyncCaller({});\nasync function getEncoding(encoding) {\n    if (!(encoding in cache)) {\n        cache[encoding] = caller\n            .fetch(`https://tiktoken.pages.dev/js/${encoding}.json`)\n            .then((res) => res.json())\n            .then((data) => new js_tiktoken_lite__WEBPACK_IMPORTED_MODULE_0__.Tiktoken(data))\n            .catch((e) => {\n            delete cache[encoding];\n            throw e;\n        });\n    }\n    return await cache[encoding];\n}\nasync function encodingForModel(model) {\n    return getEncoding((0,js_tiktoken_lite__WEBPACK_IMPORTED_MODULE_0__.getEncodingNameForModel)(model));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdGlrdG9rZW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzRTtBQUN0QjtBQUNoRDtBQUNBLG1DQUFtQyx5REFBVyxHQUFHO0FBQzFDO0FBQ1A7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0EsZ0NBQWdDLHNEQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1Qix5RUFBdUI7QUFDOUMiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXHRpa3Rva2VuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRpa3Rva2VuLCBnZXRFbmNvZGluZ05hbWVGb3JNb2RlbCwgfSBmcm9tIFwianMtdGlrdG9rZW4vbGl0ZVwiO1xuaW1wb3J0IHsgQXN5bmNDYWxsZXIgfSBmcm9tIFwiLi9hc3luY19jYWxsZXIuanNcIjtcbmNvbnN0IGNhY2hlID0ge307XG5jb25zdCBjYWxsZXIgPSAvKiAjX19QVVJFX18gKi8gbmV3IEFzeW5jQ2FsbGVyKHt9KTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbmNvZGluZyhlbmNvZGluZykge1xuICAgIGlmICghKGVuY29kaW5nIGluIGNhY2hlKSkge1xuICAgICAgICBjYWNoZVtlbmNvZGluZ10gPSBjYWxsZXJcbiAgICAgICAgICAgIC5mZXRjaChgaHR0cHM6Ly90aWt0b2tlbi5wYWdlcy5kZXYvanMvJHtlbmNvZGluZ30uanNvbmApXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IG5ldyBUaWt0b2tlbihkYXRhKSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2VuY29kaW5nXTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgY2FjaGVbZW5jb2RpbmddO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY29kaW5nRm9yTW9kZWwobW9kZWwpIHtcbiAgICByZXR1cm4gZ2V0RW5jb2RpbmcoZ2V0RW5jb2RpbmdOYW1lRm9yTW9kZWwobW9kZWwpKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/types/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/types/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extendInteropZodObject: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.extendInteropZodObject),\n/* harmony export */   getInteropZodDefaultGetter: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.getInteropZodDefaultGetter),\n/* harmony export */   getInteropZodObjectShape: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.getInteropZodObjectShape),\n/* harmony export */   getSchemaDescription: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.getSchemaDescription),\n/* harmony export */   interopParse: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.interopParse),\n/* harmony export */   interopParseAsync: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.interopParseAsync),\n/* harmony export */   interopSafeParse: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.interopSafeParse),\n/* harmony export */   interopSafeParseAsync: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.interopSafeParseAsync),\n/* harmony export */   interopZodObjectPartial: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.interopZodObjectPartial),\n/* harmony export */   interopZodObjectPassthrough: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.interopZodObjectPassthrough),\n/* harmony export */   interopZodObjectStrict: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.interopZodObjectStrict),\n/* harmony export */   interopZodTransformInputSchema: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.interopZodTransformInputSchema),\n/* harmony export */   isInteropZodObject: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.isInteropZodObject),\n/* harmony export */   isInteropZodSchema: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.isInteropZodSchema),\n/* harmony export */   isShapelessZodSchema: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.isShapelessZodSchema),\n/* harmony export */   isSimpleStringZodSchema: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.isSimpleStringZodSchema),\n/* harmony export */   isZodArrayV4: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.isZodArrayV4),\n/* harmony export */   isZodObjectV3: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.isZodObjectV3),\n/* harmony export */   isZodObjectV4: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.isZodObjectV4),\n/* harmony export */   isZodSchema: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.isZodSchema),\n/* harmony export */   isZodSchemaV3: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.isZodSchemaV3),\n/* harmony export */   isZodSchemaV4: () => (/* reexport safe */ _zod_js__WEBPACK_IMPORTED_MODULE_0__.isZodSchemaV4)\n/* harmony export */ });\n/* harmony import */ var _zod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zod.js */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdHlwZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUIiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXHR5cGVzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLi96b2QuanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/types/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/types/zod.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extendInteropZodObject: () => (/* binding */ extendInteropZodObject),\n/* harmony export */   getInteropZodDefaultGetter: () => (/* binding */ getInteropZodDefaultGetter),\n/* harmony export */   getInteropZodObjectShape: () => (/* binding */ getInteropZodObjectShape),\n/* harmony export */   getSchemaDescription: () => (/* binding */ getSchemaDescription),\n/* harmony export */   interopParse: () => (/* binding */ interopParse),\n/* harmony export */   interopParseAsync: () => (/* binding */ interopParseAsync),\n/* harmony export */   interopSafeParse: () => (/* binding */ interopSafeParse),\n/* harmony export */   interopSafeParseAsync: () => (/* binding */ interopSafeParseAsync),\n/* harmony export */   interopZodObjectPartial: () => (/* binding */ interopZodObjectPartial),\n/* harmony export */   interopZodObjectPassthrough: () => (/* binding */ interopZodObjectPassthrough),\n/* harmony export */   interopZodObjectStrict: () => (/* binding */ interopZodObjectStrict),\n/* harmony export */   interopZodTransformInputSchema: () => (/* binding */ interopZodTransformInputSchema),\n/* harmony export */   isInteropZodObject: () => (/* binding */ isInteropZodObject),\n/* harmony export */   isInteropZodSchema: () => (/* binding */ isInteropZodSchema),\n/* harmony export */   isShapelessZodSchema: () => (/* binding */ isShapelessZodSchema),\n/* harmony export */   isSimpleStringZodSchema: () => (/* binding */ isSimpleStringZodSchema),\n/* harmony export */   isZodArrayV4: () => (/* binding */ isZodArrayV4),\n/* harmony export */   isZodObjectV3: () => (/* binding */ isZodObjectV3),\n/* harmony export */   isZodObjectV4: () => (/* binding */ isZodObjectV4),\n/* harmony export */   isZodSchema: () => (/* binding */ isZodSchema),\n/* harmony export */   isZodSchemaV3: () => (/* binding */ isZodSchemaV3),\n/* harmony export */   isZodSchemaV4: () => (/* binding */ isZodSchemaV4)\n/* harmony export */ });\n/* harmony import */ var zod_v4_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod/v4/core */ \"(rsc)/./node_modules/zod/v4/core/parse.js\");\n/* harmony import */ var zod_v4_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod/v4/core */ \"(rsc)/./node_modules/zod/v4/core/registries.js\");\n/* harmony import */ var zod_v4_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod/v4/core */ \"(rsc)/./node_modules/zod/v4/core/util.js\");\n/* harmony import */ var zod_v4_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v4/core */ \"(rsc)/./node_modules/zod/v4/core/schemas.js\");\n/* harmony import */ var zod_v4_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zod/v4/core */ \"(rsc)/./node_modules/zod/v4/core/api.js\");\n\nfunction isZodSchemaV4(schema) {\n    if (typeof schema !== \"object\" || schema === null) {\n        return false;\n    }\n    const obj = schema;\n    if (!(\"_zod\" in obj)) {\n        return false;\n    }\n    const zod = obj._zod;\n    return (typeof zod === \"object\" &&\n        zod !== null &&\n        \"def\" in zod);\n}\nfunction isZodSchemaV3(schema) {\n    if (typeof schema !== \"object\" || schema === null) {\n        return false;\n    }\n    const obj = schema;\n    if (!(\"_def\" in obj) || \"_zod\" in obj) {\n        return false;\n    }\n    const def = obj._def;\n    return (typeof def === \"object\" &&\n        def != null &&\n        \"typeName\" in def);\n}\n/** Backward compatible isZodSchema for Zod 3 */\nfunction isZodSchema(schema) {\n    if (isZodSchemaV4(schema)) {\n        console.warn(\"[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior.\");\n    }\n    return isZodSchemaV3(schema);\n}\n/**\n * Given either a Zod schema, or plain object, determine if the input is a Zod schema.\n *\n * @param {unknown} input\n * @returns {boolean} Whether or not the provided input is a Zod schema.\n */\nfunction isInteropZodSchema(input) {\n    if (!input) {\n        return false;\n    }\n    if (typeof input !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(input)) {\n        return false;\n    }\n    if (isZodSchemaV4(input) ||\n        isZodSchemaV3(input)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns a safe parse result.\n * This function handles both Zod v3 and v4 schemas, returning a result object indicating success or failure.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<InteropZodSafeParseResult<T>>} A promise that resolves to a safe parse result object.\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nasync function interopSafeParseAsync(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        try {\n            const data = await (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_0__.parseAsync)(schema, input);\n            return {\n                success: true,\n                data,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error,\n            };\n        }\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.safeParse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<T>} A promise that resolves to the parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nasync function interopParseAsync(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        return (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_0__.parse)(schema, input);\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.parse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Safely parses the input using the provided Zod schema (v3 or v4) and returns a result object\n * indicating success or failure. This function is compatible with both Zod v3 and v4 schemas.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {InteropZodSafeParseResult<T>} An object with either the parsed data (on success)\n *   or the error (on failure).\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nfunction interopSafeParse(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        try {\n            const data = (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_0__.parse)(schema, input);\n            return {\n                success: true,\n                data,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error,\n            };\n        }\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.safeParse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {T} The parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nfunction interopParse(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        return (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_0__.parse)(schema, input);\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.parse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Retrieves the description from a schema definition (v3, v4, or plain object), if available.\n *\n * @param {unknown} schema - The schema to extract the description from.\n * @returns {string | undefined} The description of the schema, or undefined if not present.\n */\nfunction getSchemaDescription(schema) {\n    if (isZodSchemaV4(schema)) {\n        return zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.get(schema)?.description;\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.description;\n    }\n    if (\"description\" in schema && typeof schema.description === \"string\") {\n        return schema.description;\n    }\n    return undefined;\n}\n/**\n * Determines if the provided Zod schema is \"shapeless\".\n * A shapeless schema is one that does not define any object shape,\n * such as ZodString, ZodNumber, ZodBoolean, ZodAny, etc.\n * For ZodObject, it must have no shape keys to be considered shapeless.\n * ZodRecord schemas are considered shapeless since they define dynamic\n * key-value mappings without fixed keys.\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is shapeless, false otherwise.\n */\nfunction isShapelessZodSchema(schema) {\n    if (!isInteropZodSchema(schema)) {\n        return false;\n    }\n    // Check for v3 schemas\n    if (isZodSchemaV3(schema)) {\n        // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n        const def = schema._def;\n        // ZodObject is only shaped if it has actual shape keys\n        if (def.typeName === \"ZodObject\") {\n            const obj = schema;\n            return !obj.shape || Object.keys(obj.shape).length === 0;\n        }\n        // ZodRecord is shapeless (dynamic key-value mapping)\n        if (def.typeName === \"ZodRecord\") {\n            return true;\n        }\n    }\n    // Check for v4 schemas\n    if (isZodSchemaV4(schema)) {\n        const def = schema._zod.def;\n        // Object type is only shaped if it has actual shape keys\n        if (def.type === \"object\") {\n            const obj = schema;\n            return !obj.shape || Object.keys(obj.shape).length === 0;\n        }\n        // Record type is shapeless (dynamic key-value mapping)\n        if (def.type === \"record\") {\n            return true;\n        }\n    }\n    // For other schemas, check if they have a `shape` property\n    // If they don't have shape, they're likely shapeless\n    if (typeof schema === \"object\" && schema !== null && !(\"shape\" in schema)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if the provided Zod schema should be treated as a simple string schema\n * that maps to DynamicTool. This aligns with the type-level constraint of\n * InteropZodType<string | undefined> which only matches basic string schemas.\n * If the provided schema is just z.string(), we can make the determination that\n * the tool is just a generic string tool that doesn't require any input validation.\n *\n * This function only returns true for basic ZodString schemas, including:\n * - Basic string schemas (z.string())\n * - String schemas with validations (z.string().min(1), z.string().email(), etc.)\n *\n * This function returns false for everything else, including:\n * - String schemas with defaults (z.string().default(\"value\"))\n * - Branded string schemas (z.string().brand<\"UserId\">())\n * - String schemas with catch operations (z.string().catch(\"default\"))\n * - Optional/nullable string schemas (z.string().optional())\n * - Transformed schemas (z.string().transform() or z.object().transform())\n * - Object or record schemas, even if they're empty\n * - Any other schema type\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is a basic ZodString, false otherwise.\n */\nfunction isSimpleStringZodSchema(schema) {\n    if (!isInteropZodSchema(schema)) {\n        return false;\n    }\n    // For v3 schemas\n    if (isZodSchemaV3(schema)) {\n        // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n        const def = schema._def;\n        // Only accept basic ZodString\n        return def.typeName === \"ZodString\";\n    }\n    // For v4 schemas\n    if (isZodSchemaV4(schema)) {\n        const def = schema._zod.def;\n        // Only accept basic string type\n        return def.type === \"string\";\n    }\n    return false;\n}\nfunction isZodObjectV3(obj) {\n    // Zod v3 object schemas have _def.typeName === \"ZodObject\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_def\" in obj &&\n        typeof obj._def === \"object\" &&\n        obj._def !== null &&\n        \"typeName\" in obj._def &&\n        obj._def.typeName === \"ZodObject\") {\n        return true;\n    }\n    return false;\n}\nfunction isZodObjectV4(obj) {\n    if (!isZodSchemaV4(obj))\n        return false;\n    // Zod v4 object schemas have _zod.def.type === \"object\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_zod\" in obj &&\n        typeof obj._zod === \"object\" &&\n        obj._zod !== null &&\n        \"def\" in obj._zod &&\n        typeof obj._zod.def === \"object\" &&\n        obj._zod.def !== null &&\n        \"type\" in obj._zod.def &&\n        obj._zod.def.type === \"object\") {\n        return true;\n    }\n    return false;\n}\nfunction isZodArrayV4(obj) {\n    if (!isZodSchemaV4(obj))\n        return false;\n    // Zod v4 array schemas have _zod.def.type === \"array\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_zod\" in obj &&\n        typeof obj._zod === \"object\" &&\n        obj._zod !== null &&\n        \"def\" in obj._zod &&\n        typeof obj._zod.def === \"object\" &&\n        obj._zod.def !== null &&\n        \"type\" in obj._zod.def &&\n        obj._zod.def.type === \"array\") {\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if the provided value is an InteropZodObject (Zod v3 or v4 object schema).\n *\n * @param obj The value to check.\n * @returns {boolean} True if the value is a Zod v3 or v4 object schema, false otherwise.\n */\nfunction isInteropZodObject(obj) {\n    if (isZodObjectV3(obj))\n        return true;\n    if (isZodObjectV4(obj))\n        return true;\n    return false;\n}\n/**\n * Retrieves the shape (fields) of a Zod object schema, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObjectShape<T>} The shape of the object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction getInteropZodObjectShape(schema) {\n    if (isZodSchemaV3(schema)) {\n        return schema.shape;\n    }\n    if (isZodSchemaV4(schema)) {\n        return schema._zod.def.shape;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Extends a Zod object schema with additional fields, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {InteropZodObjectShape} extension - The fields to add to the schema.\n * @returns {InteropZodObject} The extended Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction extendInteropZodObject(schema, extension) {\n    if (isZodSchemaV3(schema)) {\n        return schema.extend(extension);\n    }\n    if (isZodSchemaV4(schema)) {\n        return zod_v4_core__WEBPACK_IMPORTED_MODULE_2__.extend(schema, extension);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a partial version of a Zod object schema, making all fields optional.\n * Supports both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObject} The partial Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction interopZodObjectPartial(schema) {\n    if (isZodSchemaV3(schema)) {\n        // z3: .partial() exists and works as expected\n        return schema.partial();\n    }\n    if (isZodSchemaV4(schema)) {\n        // z4: util.partial exists and works as expected\n        return zod_v4_core__WEBPACK_IMPORTED_MODULE_2__.partial(zod_v4_core__WEBPACK_IMPORTED_MODULE_3__.$ZodOptional, schema, undefined);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a strict version of a Zod object schema, disallowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies strictness\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply strictness recursively to nested objects/arrays.\n * @returns {InteropZodObject} The strict Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction interopZodObjectStrict(schema, recursive = false) {\n    if (isZodSchemaV3(schema)) {\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema.strict();\n    }\n    if (isZodObjectV4(schema)) {\n        const outputShape = schema._zod.def.shape;\n        if (recursive) {\n            for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n                // If the shape key is a v4 object schema, we need to make it strict\n                if (isZodObjectV4(keySchema)) {\n                    const outputSchema = interopZodObjectStrict(keySchema, recursive);\n                    outputShape[key] = outputSchema;\n                }\n                // If the shape key is a v4 array schema, we need to make the element\n                // schema strict if it's an object schema\n                else if (isZodArrayV4(keySchema)) {\n                    let elementSchema = keySchema._zod.def.element;\n                    if (isZodObjectV4(elementSchema)) {\n                        elementSchema = interopZodObjectStrict(elementSchema, recursive);\n                    }\n                    outputShape[key] = (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_2__.clone)(keySchema, {\n                        ...keySchema._zod.def,\n                        element: elementSchema,\n                    });\n                }\n                // Otherwise, just use the keySchema\n                else {\n                    outputShape[key] = keySchema;\n                }\n                // Assign meta fields to the keySchema\n                const meta = zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.get(keySchema);\n                if (meta)\n                    zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.add(outputShape[key], meta);\n            }\n        }\n        const modifiedSchema = (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_2__.clone)(schema, {\n            ...schema._zod.def,\n            shape: outputShape,\n            catchall: (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_4__._never)(zod_v4_core__WEBPACK_IMPORTED_MODULE_3__.$ZodNever),\n        });\n        const meta = zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.get(schema);\n        if (meta)\n            zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.add(modifiedSchema, meta);\n        return modifiedSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a passthrough version of a Zod object schema, allowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies passthrough\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply passthrough recursively to nested objects/arrays.\n * @returns {InteropZodObject} The passthrough Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction interopZodObjectPassthrough(schema, recursive = false) {\n    if (isZodObjectV3(schema)) {\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema.passthrough();\n    }\n    if (isZodObjectV4(schema)) {\n        const outputShape = schema._zod.def.shape;\n        if (recursive) {\n            for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n                // If the shape key is a v4 object schema, we need to make it passthrough\n                if (isZodObjectV4(keySchema)) {\n                    const outputSchema = interopZodObjectPassthrough(keySchema, recursive);\n                    outputShape[key] = outputSchema;\n                }\n                // If the shape key is a v4 array schema, we need to make the element\n                // schema passthrough if it's an object schema\n                else if (isZodArrayV4(keySchema)) {\n                    let elementSchema = keySchema._zod.def.element;\n                    if (isZodObjectV4(elementSchema)) {\n                        elementSchema = interopZodObjectPassthrough(elementSchema, recursive);\n                    }\n                    outputShape[key] = (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_2__.clone)(keySchema, {\n                        ...keySchema._zod.def,\n                        element: elementSchema,\n                    });\n                }\n                // Otherwise, just use the keySchema\n                else {\n                    outputShape[key] = keySchema;\n                }\n                // Assign meta fields to the keySchema\n                const meta = zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.get(keySchema);\n                if (meta)\n                    zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.add(outputShape[key], meta);\n            }\n        }\n        const modifiedSchema = (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_2__.clone)(schema, {\n            ...schema._zod.def,\n            shape: outputShape,\n            catchall: (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_4__._unknown)(zod_v4_core__WEBPACK_IMPORTED_MODULE_3__.$ZodUnknown),\n        });\n        const meta = zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.get(schema);\n        if (meta)\n            zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.add(modifiedSchema, meta);\n        return modifiedSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a getter function for the default value of a Zod schema, if one is defined.\n * Supports both Zod v3 and v4 schemas. If the schema has a default value,\n * the returned function will return that value when called. If no default is defined,\n * returns undefined.\n *\n * @template T - The type of the Zod schema.\n * @param {T} schema - The Zod schema instance (either v3 or v4).\n * @returns {(() => InferInteropZodOutput<T>) | undefined} A function that returns the default value, or undefined if no default is set.\n */\nfunction getInteropZodDefaultGetter(schema) {\n    if (isZodSchemaV3(schema)) {\n        try {\n            const defaultValue = schema.parse(undefined);\n            return () => defaultValue;\n        }\n        catch {\n            return undefined;\n        }\n    }\n    if (isZodSchemaV4(schema)) {\n        try {\n            const defaultValue = (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_0__.parse)(schema, undefined);\n            return () => defaultValue;\n        }\n        catch {\n            return undefined;\n        }\n    }\n    return undefined;\n}\nfunction isZodTransformV3(schema) {\n    return (isZodSchemaV3(schema) &&\n        \"typeName\" in schema._def &&\n        schema._def.typeName === \"ZodEffects\");\n}\nfunction isZodTransformV4(schema) {\n    return isZodSchemaV4(schema) && schema._zod.def.type === \"pipe\";\n}\n/**\n * Returns the input type of a Zod transform schema, for both v3 and v4.\n * If the schema is not a transform, returns undefined. If `recursive` is true,\n * recursively processes nested object schemas and arrays of object schemas.\n *\n * @param schema - The Zod schema instance (v3 or v4)\n * @param {boolean} [recursive=false] - Whether to recursively process nested objects/arrays.\n * @returns The input Zod schema of the transform, or undefined if not a transform\n */\nfunction interopZodTransformInputSchema(schema, recursive = false) {\n    // Zod v3: ._def.schema is the input schema for ZodEffects (transform)\n    if (isZodSchemaV3(schema)) {\n        if (isZodTransformV3(schema)) {\n            return interopZodTransformInputSchema(schema._def.schema, recursive);\n        }\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema;\n    }\n    // Zod v4: _def.type is the input schema for ZodEffects (transform)\n    if (isZodSchemaV4(schema)) {\n        let outputSchema = schema;\n        if (isZodTransformV4(schema)) {\n            outputSchema = interopZodTransformInputSchema(schema._zod.def.in, recursive);\n        }\n        if (recursive) {\n            // Handle nested object schemas\n            if (isZodObjectV4(outputSchema)) {\n                const outputShape = outputSchema._zod.def.shape;\n                for (const [key, keySchema] of Object.entries(outputSchema._zod.def.shape)) {\n                    outputShape[key] = interopZodTransformInputSchema(keySchema, recursive);\n                }\n                outputSchema = (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_2__.clone)(outputSchema, {\n                    ...outputSchema._zod.def,\n                    shape: outputShape,\n                });\n            }\n            // Handle nested array schemas\n            else if (isZodArrayV4(outputSchema)) {\n                const elementSchema = interopZodTransformInputSchema(outputSchema._zod.def.element, recursive);\n                outputSchema = (0,zod_v4_core__WEBPACK_IMPORTED_MODULE_2__.clone)(outputSchema, {\n                    ...outputSchema._zod.def,\n                    element: elementSchema,\n                });\n            }\n        }\n        const meta = zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.get(schema);\n        if (meta)\n            zod_v4_core__WEBPACK_IMPORTED_MODULE_1__.globalRegistry.add(outputSchema, meta);\n        return outputSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdHlwZXMvem9kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzSTtBQUMvSDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsdUNBQXVDO0FBQ3BELFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBLCtCQUErQix1REFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixhQUFhLFlBQVk7QUFDekIsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUDtBQUNBLGVBQWUsa0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixhQUFhLDhCQUE4QjtBQUMzQztBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QixrREFBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixhQUFhLEdBQUc7QUFDaEIsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUDtBQUNBLGVBQWUsa0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ087QUFDUDtBQUNBLGVBQWUsdURBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLDBCQUEwQjtBQUN2QyxZQUFZLE9BQU87QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWEsa0JBQWtCO0FBQy9CLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLGtCQUFrQjtBQUMvQixZQUFZLE9BQU87QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQVksQ0FBQyxxREFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxrQkFBa0I7QUFDL0IsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQUs7QUFDNUM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdURBQWM7QUFDM0M7QUFDQSxvQkFBb0IsdURBQWM7QUFDbEM7QUFDQTtBQUNBLCtCQUErQixrREFBSztBQUNwQztBQUNBO0FBQ0Esc0JBQXNCLG1EQUFNLENBQUMsa0RBQVM7QUFDdEMsU0FBUztBQUNULHFCQUFxQix1REFBYztBQUNuQztBQUNBLFlBQVksdURBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxrQkFBa0I7QUFDL0IsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQUs7QUFDNUM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdURBQWM7QUFDM0M7QUFDQSxvQkFBb0IsdURBQWM7QUFDbEM7QUFDQTtBQUNBLCtCQUErQixrREFBSztBQUNwQztBQUNBO0FBQ0Esc0JBQXNCLHFEQUFRLENBQUMsb0RBQVc7QUFDMUMsU0FBUztBQUNULHFCQUFxQix1REFBYztBQUNuQztBQUNBLFlBQVksdURBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsOENBQThDO0FBQzNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtEQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtEQUFLO0FBQ3BDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0RBQUs7QUFDcEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EscUJBQXFCLHVEQUFjO0FBQ25DO0FBQ0EsWUFBWSx1REFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcdHlwZXNcXHpvZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSwgcGFyc2VBc3luYywgZ2xvYmFsUmVnaXN0cnksIHV0aWwsIGNsb25lLCBfdW5rbm93biwgX25ldmVyLCAkWm9kVW5rbm93biwgJFpvZE5ldmVyLCAkWm9kT3B0aW9uYWwsIH0gZnJvbSBcInpvZC92NC9jb3JlXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNab2RTY2hlbWFWNChzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gXCJvYmplY3RcIiB8fCBzY2hlbWEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSBzY2hlbWE7XG4gICAgaWYgKCEoXCJfem9kXCIgaW4gb2JqKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHpvZCA9IG9iai5fem9kO1xuICAgIHJldHVybiAodHlwZW9mIHpvZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB6b2QgIT09IG51bGwgJiZcbiAgICAgICAgXCJkZWZcIiBpbiB6b2QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzWm9kU2NoZW1hVjMoc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT09IFwib2JqZWN0XCIgfHwgc2NoZW1hID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gc2NoZW1hO1xuICAgIGlmICghKFwiX2RlZlwiIGluIG9iaikgfHwgXCJfem9kXCIgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gb2JqLl9kZWY7XG4gICAgcmV0dXJuICh0eXBlb2YgZGVmID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGRlZiAhPSBudWxsICYmXG4gICAgICAgIFwidHlwZU5hbWVcIiBpbiBkZWYpO1xufVxuLyoqIEJhY2t3YXJkIGNvbXBhdGlibGUgaXNab2RTY2hlbWEgZm9yIFpvZCAzICovXG5leHBvcnQgZnVuY3Rpb24gaXNab2RTY2hlbWEoc2NoZW1hKSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gQXR0ZW1wdGluZyB0byB1c2UgWm9kIDQgc2NoZW1hIGluIGEgY29udGV4dCB3aGVyZSBab2QgMyBzY2hlbWEgaXMgZXhwZWN0ZWQuIFRoaXMgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaXNab2RTY2hlbWFWMyhzY2hlbWEpO1xufVxuLyoqXG4gKiBHaXZlbiBlaXRoZXIgYSBab2Qgc2NoZW1hLCBvciBwbGFpbiBvYmplY3QsIGRldGVybWluZSBpZiB0aGUgaW5wdXQgaXMgYSBab2Qgc2NoZW1hLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gaW5wdXRcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaW5wdXQgaXMgYSBab2Qgc2NoZW1hLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlcm9wWm9kU2NoZW1hKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNab2RTY2hlbWFWNChpbnB1dCkgfHxcbiAgICAgICAgaXNab2RTY2hlbWFWMyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcGFyc2VzIHRoZSBpbnB1dCB1c2luZyB0aGUgcHJvdmlkZWQgWm9kIHNjaGVtYSAodjMgb3IgdjQpIGFuZCByZXR1cm5zIGEgc2FmZSBwYXJzZSByZXN1bHQuXG4gKiBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgYm90aCBab2QgdjMgYW5kIHY0IHNjaGVtYXMsIHJldHVybmluZyBhIHJlc3VsdCBvYmplY3QgaW5kaWNhdGluZyBzdWNjZXNzIG9yIGZhaWx1cmUuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgZXhwZWN0ZWQgb3V0cHV0IHR5cGUgb2YgdGhlIHNjaGVtYS5cbiAqIEBwYXJhbSB7SW50ZXJvcFpvZFR5cGU8VD59IHNjaGVtYSAtIFRoZSBab2Qgc2NoZW1hICh2MyBvciB2NCkgdG8gdXNlIGZvciBwYXJzaW5nLlxuICogQHBhcmFtIHt1bmtub3dufSBpbnB1dCAtIFRoZSBpbnB1dCB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPEludGVyb3Bab2RTYWZlUGFyc2VSZXN1bHQ8VD4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHNhZmUgcGFyc2UgcmVzdWx0IG9iamVjdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NoZW1hIGlzIG5vdCBhIHJlY29nbml6ZWQgWm9kIHYzIG9yIHY0IHNjaGVtYS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGludGVyb3BTYWZlUGFyc2VBc3luYyhzY2hlbWEsIGlucHV0KSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLnNhZmVQYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZFR5cGUgb3IgejQuJFpvZFR5cGVcIik7XG59XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHBhcnNlcyB0aGUgaW5wdXQgdXNpbmcgdGhlIHByb3ZpZGVkIFpvZCBzY2hlbWEgKHYzIG9yIHY0KSBhbmQgcmV0dXJucyB0aGUgcGFyc2VkIHZhbHVlLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHBhcnNpbmcgZmFpbHMgb3IgaWYgdGhlIHNjaGVtYSBpcyBub3QgYSByZWNvZ25pemVkIFpvZCB2MyBvciB2NCBzY2hlbWEuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgZXhwZWN0ZWQgb3V0cHV0IHR5cGUgb2YgdGhlIHNjaGVtYS5cbiAqIEBwYXJhbSB7SW50ZXJvcFpvZFR5cGU8VD59IHNjaGVtYSAtIFRoZSBab2Qgc2NoZW1hICh2MyBvciB2NCkgdG8gdXNlIGZvciBwYXJzaW5nLlxuICogQHBhcmFtIHt1bmtub3dufSBpbnB1dCAtIFRoZSBpbnB1dCB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcGFyc2VkIHZhbHVlLlxuICogQHRocm93cyB7RXJyb3J9IElmIHBhcnNpbmcgZmFpbHMgb3IgdGhlIHNjaGVtYSBpcyBub3QgYSByZWNvZ25pemVkIFpvZCB2MyBvciB2NCBzY2hlbWEuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnRlcm9wUGFyc2VBc3luYyhzY2hlbWEsIGlucHV0KSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gcGFyc2Uoc2NoZW1hLCBpbnB1dCk7XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZFR5cGUgb3IgejQuJFpvZFR5cGVcIik7XG59XG4vKipcbiAqIFNhZmVseSBwYXJzZXMgdGhlIGlucHV0IHVzaW5nIHRoZSBwcm92aWRlZCBab2Qgc2NoZW1hICh2MyBvciB2NCkgYW5kIHJldHVybnMgYSByZXN1bHQgb2JqZWN0XG4gKiBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3IgZmFpbHVyZS4gVGhpcyBmdW5jdGlvbiBpcyBjb21wYXRpYmxlIHdpdGggYm90aCBab2QgdjMgYW5kIHY0IHNjaGVtYXMuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgZXhwZWN0ZWQgb3V0cHV0IHR5cGUgb2YgdGhlIHNjaGVtYS5cbiAqIEBwYXJhbSB7SW50ZXJvcFpvZFR5cGU8VD59IHNjaGVtYSAtIFRoZSBab2Qgc2NoZW1hICh2MyBvciB2NCkgdG8gdXNlIGZvciBwYXJzaW5nLlxuICogQHBhcmFtIHt1bmtub3dufSBpbnB1dCAtIFRoZSBpbnB1dCB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIHtJbnRlcm9wWm9kU2FmZVBhcnNlUmVzdWx0PFQ+fSBBbiBvYmplY3Qgd2l0aCBlaXRoZXIgdGhlIHBhcnNlZCBkYXRhIChvbiBzdWNjZXNzKVxuICogICBvciB0aGUgZXJyb3IgKG9uIGZhaWx1cmUpLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzY2hlbWEgaXMgbm90IGEgcmVjb2duaXplZCBab2QgdjMgb3IgdjQgc2NoZW1hLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJvcFNhZmVQYXJzZShzY2hlbWEsIGlucHV0KSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHBhcnNlKHNjaGVtYSwgaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5zYWZlUGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB6My5ab2RUeXBlIG9yIHo0LiRab2RUeXBlXCIpO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGlucHV0IHVzaW5nIHRoZSBwcm92aWRlZCBab2Qgc2NoZW1hICh2MyBvciB2NCkgYW5kIHJldHVybnMgdGhlIHBhcnNlZCB2YWx1ZS5cbiAqIFRocm93cyBhbiBlcnJvciBpZiBwYXJzaW5nIGZhaWxzIG9yIGlmIHRoZSBzY2hlbWEgaXMgbm90IGEgcmVjb2duaXplZCBab2QgdjMgb3IgdjQgc2NoZW1hLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIGV4cGVjdGVkIG91dHB1dCB0eXBlIG9mIHRoZSBzY2hlbWEuXG4gKiBAcGFyYW0ge0ludGVyb3Bab2RUeXBlPFQ+fSBzY2hlbWEgLSBUaGUgWm9kIHNjaGVtYSAodjMgb3IgdjQpIHRvIHVzZSBmb3IgcGFyc2luZy5cbiAqIEBwYXJhbSB7dW5rbm93bn0gaW5wdXQgLSBUaGUgaW5wdXQgdmFsdWUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyB7VH0gVGhlIHBhcnNlZCB2YWx1ZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBwYXJzaW5nIGZhaWxzIG9yIHRoZSBzY2hlbWEgaXMgbm90IGEgcmVjb2duaXplZCBab2QgdjMgb3IgdjQgc2NoZW1hLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJvcFBhcnNlKHNjaGVtYSwgaW5wdXQpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZShzY2hlbWEsIGlucHV0KTtcbiAgICB9XG4gICAgaWYgKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLnBhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgejMuWm9kVHlwZSBvciB6NC4kWm9kVHlwZVwiKTtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBkZXNjcmlwdGlvbiBmcm9tIGEgc2NoZW1hIGRlZmluaXRpb24gKHYzLCB2NCwgb3IgcGxhaW4gb2JqZWN0KSwgaWYgYXZhaWxhYmxlLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBleHRyYWN0IHRoZSBkZXNjcmlwdGlvbiBmcm9tLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBzY2hlbWEsIG9yIHVuZGVmaW5lZCBpZiBub3QgcHJlc2VudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYURlc2NyaXB0aW9uKHNjaGVtYSkge1xuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFJlZ2lzdHJ5LmdldChzY2hlbWEpPy5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgaWYgKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBpZiAoXCJkZXNjcmlwdGlvblwiIGluIHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hLmRlc2NyaXB0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb3ZpZGVkIFpvZCBzY2hlbWEgaXMgXCJzaGFwZWxlc3NcIi5cbiAqIEEgc2hhcGVsZXNzIHNjaGVtYSBpcyBvbmUgdGhhdCBkb2VzIG5vdCBkZWZpbmUgYW55IG9iamVjdCBzaGFwZSxcbiAqIHN1Y2ggYXMgWm9kU3RyaW5nLCBab2ROdW1iZXIsIFpvZEJvb2xlYW4sIFpvZEFueSwgZXRjLlxuICogRm9yIFpvZE9iamVjdCwgaXQgbXVzdCBoYXZlIG5vIHNoYXBlIGtleXMgdG8gYmUgY29uc2lkZXJlZCBzaGFwZWxlc3MuXG4gKiBab2RSZWNvcmQgc2NoZW1hcyBhcmUgY29uc2lkZXJlZCBzaGFwZWxlc3Mgc2luY2UgdGhleSBkZWZpbmUgZHluYW1pY1xuICoga2V5LXZhbHVlIG1hcHBpbmdzIHdpdGhvdXQgZml4ZWQga2V5cy5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBab2Qgc2NoZW1hIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNjaGVtYSBpcyBzaGFwZWxlc3MsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2hhcGVsZXNzWm9kU2NoZW1hKHNjaGVtYSkge1xuICAgIGlmICghaXNJbnRlcm9wWm9kU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgdjMgc2NoZW1hc1xuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHpvZCB2MyB0eXBlcyBhcmUgbm90IGNvbXBhdGlibGUgd2l0aCB6b2QgdjQgdHlwZXNcbiAgICAgICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWY7XG4gICAgICAgIC8vIFpvZE9iamVjdCBpcyBvbmx5IHNoYXBlZCBpZiBpdCBoYXMgYWN0dWFsIHNoYXBlIGtleXNcbiAgICAgICAgaWYgKGRlZi50eXBlTmFtZSA9PT0gXCJab2RPYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gc2NoZW1hO1xuICAgICAgICAgICAgcmV0dXJuICFvYmouc2hhcGUgfHwgT2JqZWN0LmtleXMob2JqLnNoYXBlKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gWm9kUmVjb3JkIGlzIHNoYXBlbGVzcyAoZHluYW1pYyBrZXktdmFsdWUgbWFwcGluZylcbiAgICAgICAgaWYgKGRlZi50eXBlTmFtZSA9PT0gXCJab2RSZWNvcmRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHY0IHNjaGVtYXNcbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICAgICAgLy8gT2JqZWN0IHR5cGUgaXMgb25seSBzaGFwZWQgaWYgaXQgaGFzIGFjdHVhbCBzaGFwZSBrZXlzXG4gICAgICAgIGlmIChkZWYudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gc2NoZW1hO1xuICAgICAgICAgICAgcmV0dXJuICFvYmouc2hhcGUgfHwgT2JqZWN0LmtleXMob2JqLnNoYXBlKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjb3JkIHR5cGUgaXMgc2hhcGVsZXNzIChkeW5hbWljIGtleS12YWx1ZSBtYXBwaW5nKVxuICAgICAgICBpZiAoZGVmLnR5cGUgPT09IFwicmVjb3JkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZvciBvdGhlciBzY2hlbWFzLCBjaGVjayBpZiB0aGV5IGhhdmUgYSBgc2hhcGVgIHByb3BlcnR5XG4gICAgLy8gSWYgdGhleSBkb24ndCBoYXZlIHNoYXBlLCB0aGV5J3JlIGxpa2VseSBzaGFwZWxlc3NcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIiAmJiBzY2hlbWEgIT09IG51bGwgJiYgIShcInNoYXBlXCIgaW4gc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm92aWRlZCBab2Qgc2NoZW1hIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgc2ltcGxlIHN0cmluZyBzY2hlbWFcbiAqIHRoYXQgbWFwcyB0byBEeW5hbWljVG9vbC4gVGhpcyBhbGlnbnMgd2l0aCB0aGUgdHlwZS1sZXZlbCBjb25zdHJhaW50IG9mXG4gKiBJbnRlcm9wWm9kVHlwZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHdoaWNoIG9ubHkgbWF0Y2hlcyBiYXNpYyBzdHJpbmcgc2NoZW1hcy5cbiAqIElmIHRoZSBwcm92aWRlZCBzY2hlbWEgaXMganVzdCB6LnN0cmluZygpLCB3ZSBjYW4gbWFrZSB0aGUgZGV0ZXJtaW5hdGlvbiB0aGF0XG4gKiB0aGUgdG9vbCBpcyBqdXN0IGEgZ2VuZXJpYyBzdHJpbmcgdG9vbCB0aGF0IGRvZXNuJ3QgcmVxdWlyZSBhbnkgaW5wdXQgdmFsaWRhdGlvbi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG9ubHkgcmV0dXJucyB0cnVlIGZvciBiYXNpYyBab2RTdHJpbmcgc2NoZW1hcywgaW5jbHVkaW5nOlxuICogLSBCYXNpYyBzdHJpbmcgc2NoZW1hcyAoei5zdHJpbmcoKSlcbiAqIC0gU3RyaW5nIHNjaGVtYXMgd2l0aCB2YWxpZGF0aW9ucyAoei5zdHJpbmcoKS5taW4oMSksIHouc3RyaW5nKCkuZW1haWwoKSwgZXRjLilcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UgZm9yIGV2ZXJ5dGhpbmcgZWxzZSwgaW5jbHVkaW5nOlxuICogLSBTdHJpbmcgc2NoZW1hcyB3aXRoIGRlZmF1bHRzICh6LnN0cmluZygpLmRlZmF1bHQoXCJ2YWx1ZVwiKSlcbiAqIC0gQnJhbmRlZCBzdHJpbmcgc2NoZW1hcyAoei5zdHJpbmcoKS5icmFuZDxcIlVzZXJJZFwiPigpKVxuICogLSBTdHJpbmcgc2NoZW1hcyB3aXRoIGNhdGNoIG9wZXJhdGlvbnMgKHouc3RyaW5nKCkuY2F0Y2goXCJkZWZhdWx0XCIpKVxuICogLSBPcHRpb25hbC9udWxsYWJsZSBzdHJpbmcgc2NoZW1hcyAoei5zdHJpbmcoKS5vcHRpb25hbCgpKVxuICogLSBUcmFuc2Zvcm1lZCBzY2hlbWFzICh6LnN0cmluZygpLnRyYW5zZm9ybSgpIG9yIHoub2JqZWN0KCkudHJhbnNmb3JtKCkpXG4gKiAtIE9iamVjdCBvciByZWNvcmQgc2NoZW1hcywgZXZlbiBpZiB0aGV5J3JlIGVtcHR5XG4gKiAtIEFueSBvdGhlciBzY2hlbWEgdHlwZVxuICpcbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFpvZCBzY2hlbWEgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2NoZW1hIGlzIGEgYmFzaWMgWm9kU3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NpbXBsZVN0cmluZ1pvZFNjaGVtYShzY2hlbWEpIHtcbiAgICBpZiAoIWlzSW50ZXJvcFpvZFNjaGVtYShzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRm9yIHYzIHNjaGVtYXNcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB6b2QgdjMgdHlwZXMgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggem9kIHY0IHR5cGVzXG4gICAgICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmO1xuICAgICAgICAvLyBPbmx5IGFjY2VwdCBiYXNpYyBab2RTdHJpbmdcbiAgICAgICAgcmV0dXJuIGRlZi50eXBlTmFtZSA9PT0gXCJab2RTdHJpbmdcIjtcbiAgICB9XG4gICAgLy8gRm9yIHY0IHNjaGVtYXNcbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICAgICAgLy8gT25seSBhY2NlcHQgYmFzaWMgc3RyaW5nIHR5cGVcbiAgICAgICAgcmV0dXJuIGRlZi50eXBlID09PSBcInN0cmluZ1wiO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNab2RPYmplY3RWMyhvYmopIHtcbiAgICAvLyBab2QgdjMgb2JqZWN0IHNjaGVtYXMgaGF2ZSBfZGVmLnR5cGVOYW1lID09PSBcIlpvZE9iamVjdFwiXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgIFwiX2RlZlwiIGluIG9iaiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLl9kZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqLl9kZWYgIT09IG51bGwgJiZcbiAgICAgICAgXCJ0eXBlTmFtZVwiIGluIG9iai5fZGVmICYmXG4gICAgICAgIG9iai5fZGVmLnR5cGVOYW1lID09PSBcIlpvZE9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNab2RPYmplY3RWNChvYmopIHtcbiAgICBpZiAoIWlzWm9kU2NoZW1hVjQob2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFpvZCB2NCBvYmplY3Qgc2NoZW1hcyBoYXZlIF96b2QuZGVmLnR5cGUgPT09IFwib2JqZWN0XCJcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgICAgXCJfem9kXCIgaW4gb2JqICYmXG4gICAgICAgIHR5cGVvZiBvYmouX3pvZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBvYmouX3pvZCAhPT0gbnVsbCAmJlxuICAgICAgICBcImRlZlwiIGluIG9iai5fem9kICYmXG4gICAgICAgIHR5cGVvZiBvYmouX3pvZC5kZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqLl96b2QuZGVmICE9PSBudWxsICYmXG4gICAgICAgIFwidHlwZVwiIGluIG9iai5fem9kLmRlZiAmJlxuICAgICAgICBvYmouX3pvZC5kZWYudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzWm9kQXJyYXlWNChvYmopIHtcbiAgICBpZiAoIWlzWm9kU2NoZW1hVjQob2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFpvZCB2NCBhcnJheSBzY2hlbWFzIGhhdmUgX3pvZC5kZWYudHlwZSA9PT0gXCJhcnJheVwiXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgIFwiX3pvZFwiIGluIG9iaiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLl96b2QgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqLl96b2QgIT09IG51bGwgJiZcbiAgICAgICAgXCJkZWZcIiBpbiBvYmouX3pvZCAmJlxuICAgICAgICB0eXBlb2Ygb2JqLl96b2QuZGVmID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIG9iai5fem9kLmRlZiAhPT0gbnVsbCAmJlxuICAgICAgICBcInR5cGVcIiBpbiBvYmouX3pvZC5kZWYgJiZcbiAgICAgICAgb2JqLl96b2QuZGVmLnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhbiBJbnRlcm9wWm9kT2JqZWN0IChab2QgdjMgb3IgdjQgb2JqZWN0IHNjaGVtYSkuXG4gKlxuICogQHBhcmFtIG9iaiBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBab2QgdjMgb3IgdjQgb2JqZWN0IHNjaGVtYSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlcm9wWm9kT2JqZWN0KG9iaikge1xuICAgIGlmIChpc1pvZE9iamVjdFYzKG9iaikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChpc1pvZE9iamVjdFY0KG9iaikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBzaGFwZSAoZmllbGRzKSBvZiBhIFpvZCBvYmplY3Qgc2NoZW1hLCBzdXBwb3J0aW5nIGJvdGggWm9kIHYzIGFuZCB2NC5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRoZSBab2Qgb2JqZWN0IHNjaGVtYS5cbiAqIEBwYXJhbSB7VH0gc2NoZW1hIC0gVGhlIFpvZCBvYmplY3Qgc2NoZW1hIGluc3RhbmNlIChlaXRoZXIgdjMgb3IgdjQpLlxuICogQHJldHVybnMge0ludGVyb3Bab2RPYmplY3RTaGFwZTxUPn0gVGhlIHNoYXBlIG9mIHRoZSBvYmplY3Qgc2NoZW1hLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzY2hlbWEgaXMgbm90IGEgWm9kIHYzIG9yIHY0IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyb3Bab2RPYmplY3RTaGFwZShzY2hlbWEpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuc2hhcGU7XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgejMuWm9kT2JqZWN0IG9yIHo0LiRab2RPYmplY3RcIik7XG59XG4vKipcbiAqIEV4dGVuZHMgYSBab2Qgb2JqZWN0IHNjaGVtYSB3aXRoIGFkZGl0aW9uYWwgZmllbGRzLCBzdXBwb3J0aW5nIGJvdGggWm9kIHYzIGFuZCB2NC5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRoZSBab2Qgb2JqZWN0IHNjaGVtYS5cbiAqIEBwYXJhbSB7VH0gc2NoZW1hIC0gVGhlIFpvZCBvYmplY3Qgc2NoZW1hIGluc3RhbmNlIChlaXRoZXIgdjMgb3IgdjQpLlxuICogQHBhcmFtIHtJbnRlcm9wWm9kT2JqZWN0U2hhcGV9IGV4dGVuc2lvbiAtIFRoZSBmaWVsZHMgdG8gYWRkIHRvIHRoZSBzY2hlbWEuXG4gKiBAcmV0dXJucyB7SW50ZXJvcFpvZE9iamVjdH0gVGhlIGV4dGVuZGVkIFpvZCBvYmplY3Qgc2NoZW1hLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzY2hlbWEgaXMgbm90IGEgWm9kIHYzIG9yIHY0IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEludGVyb3Bab2RPYmplY3Qoc2NoZW1hLCBleHRlbnNpb24pIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZXh0ZW5kKGV4dGVuc2lvbik7XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHNjaGVtYSwgZXh0ZW5zaW9uKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgejMuWm9kT2JqZWN0IG9yIHo0LiRab2RPYmplY3RcIik7XG59XG4vKipcbiAqIFJldHVybnMgYSBwYXJ0aWFsIHZlcnNpb24gb2YgYSBab2Qgb2JqZWN0IHNjaGVtYSwgbWFraW5nIGFsbCBmaWVsZHMgb3B0aW9uYWwuXG4gKiBTdXBwb3J0cyBib3RoIFpvZCB2MyBhbmQgdjQuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAcGFyYW0ge1R9IHNjaGVtYSAtIFRoZSBab2Qgb2JqZWN0IHNjaGVtYSBpbnN0YW5jZSAoZWl0aGVyIHYzIG9yIHY0KS5cbiAqIEByZXR1cm5zIHtJbnRlcm9wWm9kT2JqZWN0fSBUaGUgcGFydGlhbCBab2Qgb2JqZWN0IHNjaGVtYS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NoZW1hIGlzIG5vdCBhIFpvZCB2MyBvciB2NCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcm9wWm9kT2JqZWN0UGFydGlhbChzY2hlbWEpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIC8vIHozOiAucGFydGlhbCgpIGV4aXN0cyBhbmQgd29ya3MgYXMgZXhwZWN0ZWRcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXJ0aWFsKCk7XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgLy8gejQ6IHV0aWwucGFydGlhbCBleGlzdHMgYW5kIHdvcmtzIGFzIGV4cGVjdGVkXG4gICAgICAgIHJldHVybiB1dGlsLnBhcnRpYWwoJFpvZE9wdGlvbmFsLCBzY2hlbWEsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZE9iamVjdCBvciB6NC4kWm9kT2JqZWN0XCIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaWN0IHZlcnNpb24gb2YgYSBab2Qgb2JqZWN0IHNjaGVtYSwgZGlzYWxsb3dpbmcgdW5rbm93biBrZXlzLlxuICogU3VwcG9ydHMgYm90aCBab2QgdjMgYW5kIHY0IG9iamVjdCBzY2hlbWFzLiBJZiBgcmVjdXJzaXZlYCBpcyB0cnVlLCBhcHBsaWVzIHN0cmljdG5lc3NcbiAqIHJlY3Vyc2l2ZWx5IHRvIGFsbCBuZXN0ZWQgb2JqZWN0IHNjaGVtYXMgYW5kIGFycmF5cyBvZiBvYmplY3Qgc2NoZW1hcy5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRoZSBab2Qgb2JqZWN0IHNjaGVtYS5cbiAqIEBwYXJhbSB7VH0gc2NoZW1hIC0gVGhlIFpvZCBvYmplY3Qgc2NoZW1hIGluc3RhbmNlIChlaXRoZXIgdjMgb3IgdjQpLlxuICogQHBhcmFtIHtib29sZWFufSBbcmVjdXJzaXZlPWZhbHNlXSAtIFdoZXRoZXIgdG8gYXBwbHkgc3RyaWN0bmVzcyByZWN1cnNpdmVseSB0byBuZXN0ZWQgb2JqZWN0cy9hcnJheXMuXG4gKiBAcmV0dXJucyB7SW50ZXJvcFpvZE9iamVjdH0gVGhlIHN0cmljdCBab2Qgb2JqZWN0IHNjaGVtYS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NoZW1hIGlzIG5vdCBhIFpvZCB2MyBvciB2NCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcm9wWm9kT2JqZWN0U3RyaWN0KHNjaGVtYSwgcmVjdXJzaXZlID0gZmFsc2UpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIC8vIFRPRE86IHYzIHNjaGVtYXMgYXJlbid0IHJlY3Vyc2l2ZWx5IGhhbmRsZWQgaGVyZVxuICAgICAgICAvLyAoY3VycmVudGx5IG5vdCBuZWNlc3Nhcnkgc2luY2Ugem9kVG9Kc29uU2NoZW1hIGhhbmRsZXMgdGhpcylcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5zdHJpY3QoKTtcbiAgICB9XG4gICAgaWYgKGlzWm9kT2JqZWN0VjQoc2NoZW1hKSkge1xuICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBrZXlTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5fem9kLmRlZi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2hhcGUga2V5IGlzIGEgdjQgb2JqZWN0IHNjaGVtYSwgd2UgbmVlZCB0byBtYWtlIGl0IHN0cmljdFxuICAgICAgICAgICAgICAgIGlmIChpc1pvZE9iamVjdFY0KGtleVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0U2NoZW1hID0gaW50ZXJvcFpvZE9iamVjdFN0cmljdChrZXlTY2hlbWEsIHJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlW2tleV0gPSBvdXRwdXRTY2hlbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzaGFwZSBrZXkgaXMgYSB2NCBhcnJheSBzY2hlbWEsIHdlIG5lZWQgdG8gbWFrZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHNjaGVtYSBzdHJpY3QgaWYgaXQncyBhbiBvYmplY3Qgc2NoZW1hXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNab2RBcnJheVY0KGtleVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnRTY2hlbWEgPSBrZXlTY2hlbWEuX3pvZC5kZWYuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzWm9kT2JqZWN0VjQoZWxlbWVudFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTY2hlbWEgPSBpbnRlcm9wWm9kT2JqZWN0U3RyaWN0KGVsZW1lbnRTY2hlbWEsIHJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVba2V5XSA9IGNsb25lKGtleVNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ua2V5U2NoZW1hLl96b2QuZGVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwganVzdCB1c2UgdGhlIGtleVNjaGVtYVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZVtrZXldID0ga2V5U2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gbWV0YSBmaWVsZHMgdG8gdGhlIGtleVNjaGVtYVxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBnbG9iYWxSZWdpc3RyeS5nZXQoa2V5U2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0YSlcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsUmVnaXN0cnkuYWRkKG91dHB1dFNoYXBlW2tleV0sIG1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkU2NoZW1hID0gY2xvbmUoc2NoZW1hLCB7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgICAgICAgICBzaGFwZTogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgICBjYXRjaGFsbDogX25ldmVyKCRab2ROZXZlciksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRhID0gZ2xvYmFsUmVnaXN0cnkuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChtZXRhKVxuICAgICAgICAgICAgZ2xvYmFsUmVnaXN0cnkuYWRkKG1vZGlmaWVkU2NoZW1hLCBtZXRhKTtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkU2NoZW1hO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB6My5ab2RPYmplY3Qgb3IgejQuJFpvZE9iamVjdFwiKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHBhc3N0aHJvdWdoIHZlcnNpb24gb2YgYSBab2Qgb2JqZWN0IHNjaGVtYSwgYWxsb3dpbmcgdW5rbm93biBrZXlzLlxuICogU3VwcG9ydHMgYm90aCBab2QgdjMgYW5kIHY0IG9iamVjdCBzY2hlbWFzLiBJZiBgcmVjdXJzaXZlYCBpcyB0cnVlLCBhcHBsaWVzIHBhc3N0aHJvdWdoXG4gKiByZWN1cnNpdmVseSB0byBhbGwgbmVzdGVkIG9iamVjdCBzY2hlbWFzIGFuZCBhcnJheXMgb2Ygb2JqZWN0IHNjaGVtYXMuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAcGFyYW0ge1R9IHNjaGVtYSAtIFRoZSBab2Qgb2JqZWN0IHNjaGVtYSBpbnN0YW5jZSAoZWl0aGVyIHYzIG9yIHY0KS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlY3Vyc2l2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIGFwcGx5IHBhc3N0aHJvdWdoIHJlY3Vyc2l2ZWx5IHRvIG5lc3RlZCBvYmplY3RzL2FycmF5cy5cbiAqIEByZXR1cm5zIHtJbnRlcm9wWm9kT2JqZWN0fSBUaGUgcGFzc3Rocm91Z2ggWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNjaGVtYSBpcyBub3QgYSBab2QgdjMgb3IgdjQgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJvcFpvZE9iamVjdFBhc3N0aHJvdWdoKHNjaGVtYSwgcmVjdXJzaXZlID0gZmFsc2UpIHtcbiAgICBpZiAoaXNab2RPYmplY3RWMyhzY2hlbWEpKSB7XG4gICAgICAgIC8vIFRPRE86IHYzIHNjaGVtYXMgYXJlbid0IHJlY3Vyc2l2ZWx5IGhhbmRsZWQgaGVyZVxuICAgICAgICAvLyAoY3VycmVudGx5IG5vdCBuZWNlc3Nhcnkgc2luY2Ugem9kVG9Kc29uU2NoZW1hIGhhbmRsZXMgdGhpcylcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXNzdGhyb3VnaCgpO1xuICAgIH1cbiAgICBpZiAoaXNab2RPYmplY3RWNChzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGtleVNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLl96b2QuZGVmLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzaGFwZSBrZXkgaXMgYSB2NCBvYmplY3Qgc2NoZW1hLCB3ZSBuZWVkIHRvIG1ha2UgaXQgcGFzc3Rocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAoaXNab2RPYmplY3RWNChrZXlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dFNjaGVtYSA9IGludGVyb3Bab2RPYmplY3RQYXNzdGhyb3VnaChrZXlTY2hlbWEsIHJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlW2tleV0gPSBvdXRwdXRTY2hlbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzaGFwZSBrZXkgaXMgYSB2NCBhcnJheSBzY2hlbWEsIHdlIG5lZWQgdG8gbWFrZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHNjaGVtYSBwYXNzdGhyb3VnaCBpZiBpdCdzIGFuIG9iamVjdCBzY2hlbWFcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1pvZEFycmF5VjQoa2V5U2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudFNjaGVtYSA9IGtleVNjaGVtYS5fem9kLmRlZi5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNab2RPYmplY3RWNChlbGVtZW50U2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNjaGVtYSA9IGludGVyb3Bab2RPYmplY3RQYXNzdGhyb3VnaChlbGVtZW50U2NoZW1hLCByZWN1cnNpdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlW2tleV0gPSBjbG9uZShrZXlTY2hlbWEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmtleVNjaGVtYS5fem9kLmRlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRTY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3QgdXNlIHRoZSBrZXlTY2hlbWFcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVba2V5XSA9IGtleVNjaGVtYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIG1ldGEgZmllbGRzIHRvIHRoZSBrZXlTY2hlbWFcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gZ2xvYmFsUmVnaXN0cnkuZ2V0KGtleVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGEpXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFJlZ2lzdHJ5LmFkZChvdXRwdXRTaGFwZVtrZXldLCBtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RpZmllZFNjaGVtYSA9IGNsb25lKHNjaGVtYSwge1xuICAgICAgICAgICAgLi4uc2NoZW1hLl96b2QuZGVmLFxuICAgICAgICAgICAgc2hhcGU6IG91dHB1dFNoYXBlLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IF91bmtub3duKCRab2RVbmtub3duKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBnbG9iYWxSZWdpc3RyeS5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKG1ldGEpXG4gICAgICAgICAgICBnbG9iYWxSZWdpc3RyeS5hZGQobW9kaWZpZWRTY2hlbWEsIG1ldGEpO1xuICAgICAgICByZXR1cm4gbW9kaWZpZWRTY2hlbWE7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZE9iamVjdCBvciB6NC4kWm9kT2JqZWN0XCIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIFpvZCBzY2hlbWEsIGlmIG9uZSBpcyBkZWZpbmVkLlxuICogU3VwcG9ydHMgYm90aCBab2QgdjMgYW5kIHY0IHNjaGVtYXMuIElmIHRoZSBzY2hlbWEgaGFzIGEgZGVmYXVsdCB2YWx1ZSxcbiAqIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGF0IHZhbHVlIHdoZW4gY2FsbGVkLiBJZiBubyBkZWZhdWx0IGlzIGRlZmluZWQsXG4gKiByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRoZSBab2Qgc2NoZW1hLlxuICogQHBhcmFtIHtUfSBzY2hlbWEgLSBUaGUgWm9kIHNjaGVtYSBpbnN0YW5jZSAoZWl0aGVyIHYzIG9yIHY0KS5cbiAqIEByZXR1cm5zIHsoKCkgPT4gSW5mZXJJbnRlcm9wWm9kT3V0cHV0PFQ+KSB8IHVuZGVmaW5lZH0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUsIG9yIHVuZGVmaW5lZCBpZiBubyBkZWZhdWx0IGlzIHNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyb3Bab2REZWZhdWx0R2V0dGVyKHNjaGVtYSkge1xuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHNjaGVtYS5wYXJzZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHBhcnNlKHNjaGVtYSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNab2RUcmFuc2Zvcm1WMyhzY2hlbWEpIHtcbiAgICByZXR1cm4gKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSAmJlxuICAgICAgICBcInR5cGVOYW1lXCIgaW4gc2NoZW1hLl9kZWYgJiZcbiAgICAgICAgc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFwiWm9kRWZmZWN0c1wiKTtcbn1cbmZ1bmN0aW9uIGlzWm9kVHJhbnNmb3JtVjQoc2NoZW1hKSB7XG4gICAgcmV0dXJuIGlzWm9kU2NoZW1hVjQoc2NoZW1hKSAmJiBzY2hlbWEuX3pvZC5kZWYudHlwZSA9PT0gXCJwaXBlXCI7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGlucHV0IHR5cGUgb2YgYSBab2QgdHJhbnNmb3JtIHNjaGVtYSwgZm9yIGJvdGggdjMgYW5kIHY0LlxuICogSWYgdGhlIHNjaGVtYSBpcyBub3QgYSB0cmFuc2Zvcm0sIHJldHVybnMgdW5kZWZpbmVkLiBJZiBgcmVjdXJzaXZlYCBpcyB0cnVlLFxuICogcmVjdXJzaXZlbHkgcHJvY2Vzc2VzIG5lc3RlZCBvYmplY3Qgc2NoZW1hcyBhbmQgYXJyYXlzIG9mIG9iamVjdCBzY2hlbWFzLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgWm9kIHNjaGVtYSBpbnN0YW5jZSAodjMgb3IgdjQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdIC0gV2hldGhlciB0byByZWN1cnNpdmVseSBwcm9jZXNzIG5lc3RlZCBvYmplY3RzL2FycmF5cy5cbiAqIEByZXR1cm5zIFRoZSBpbnB1dCBab2Qgc2NoZW1hIG9mIHRoZSB0cmFuc2Zvcm0sIG9yIHVuZGVmaW5lZCBpZiBub3QgYSB0cmFuc2Zvcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyb3Bab2RUcmFuc2Zvcm1JbnB1dFNjaGVtYShzY2hlbWEsIHJlY3Vyc2l2ZSA9IGZhbHNlKSB7XG4gICAgLy8gWm9kIHYzOiAuX2RlZi5zY2hlbWEgaXMgdGhlIGlucHV0IHNjaGVtYSBmb3IgWm9kRWZmZWN0cyAodHJhbnNmb3JtKVxuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgaWYgKGlzWm9kVHJhbnNmb3JtVjMoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyb3Bab2RUcmFuc2Zvcm1JbnB1dFNjaGVtYShzY2hlbWEuX2RlZi5zY2hlbWEsIHJlY3Vyc2l2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdjMgc2NoZW1hcyBhcmVuJ3QgcmVjdXJzaXZlbHkgaGFuZGxlZCBoZXJlXG4gICAgICAgIC8vIChjdXJyZW50bHkgbm90IG5lY2Vzc2FyeSBzaW5jZSB6b2RUb0pzb25TY2hlbWEgaGFuZGxlcyB0aGlzKVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICAvLyBab2QgdjQ6IF9kZWYudHlwZSBpcyB0aGUgaW5wdXQgc2NoZW1hIGZvciBab2RFZmZlY3RzICh0cmFuc2Zvcm0pXG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICBsZXQgb3V0cHV0U2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBpZiAoaXNab2RUcmFuc2Zvcm1WNChzY2hlbWEpKSB7XG4gICAgICAgICAgICBvdXRwdXRTY2hlbWEgPSBpbnRlcm9wWm9kVHJhbnNmb3JtSW5wdXRTY2hlbWEoc2NoZW1hLl96b2QuZGVmLmluLCByZWN1cnNpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBuZXN0ZWQgb2JqZWN0IHNjaGVtYXNcbiAgICAgICAgICAgIGlmIChpc1pvZE9iamVjdFY0KG91dHB1dFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IG91dHB1dFNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGtleVNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMob3V0cHV0U2NoZW1hLl96b2QuZGVmLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZVtrZXldID0gaW50ZXJvcFpvZFRyYW5zZm9ybUlucHV0U2NoZW1hKGtleVNjaGVtYSwgcmVjdXJzaXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0U2NoZW1hID0gY2xvbmUob3V0cHV0U2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm91dHB1dFNjaGVtYS5fem9kLmRlZixcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IG91dHB1dFNoYXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIG5lc3RlZCBhcnJheSBzY2hlbWFzXG4gICAgICAgICAgICBlbHNlIGlmIChpc1pvZEFycmF5VjQob3V0cHV0U2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRTY2hlbWEgPSBpbnRlcm9wWm9kVHJhbnNmb3JtSW5wdXRTY2hlbWEob3V0cHV0U2NoZW1hLl96b2QuZGVmLmVsZW1lbnQsIHJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0U2NoZW1hID0gY2xvbmUob3V0cHV0U2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm91dHB1dFNjaGVtYS5fem9kLmRlZixcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFNjaGVtYSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0gZ2xvYmFsUmVnaXN0cnkuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChtZXRhKVxuICAgICAgICAgICAgZ2xvYmFsUmVnaXN0cnkuYWRkKG91dHB1dFNjaGVtYSwgbWV0YSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRTY2hlbWE7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZFR5cGUgb3IgejQuJFpvZFR5cGVcIik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/vectorstores.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/vectorstores.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SaveableVectorStore: () => (/* binding */ SaveableVectorStore),\n/* harmony export */   VectorStore: () => (/* binding */ VectorStore),\n/* harmony export */   VectorStoreRetriever: () => (/* binding */ VectorStoreRetriever)\n/* harmony export */ });\n/* harmony import */ var _retrievers_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./retrievers/index.js */ \"(rsc)/./node_modules/@langchain/core/dist/retrievers/index.js\");\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./load/serializable.js */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.js\");\n\n\n/**\n * Class for retrieving documents from a `VectorStore` based on vector similarity\n * or maximal marginal relevance (MMR).\n *\n * `VectorStoreRetriever` extends `BaseRetriever`, implementing methods for\n * adding documents to the underlying vector store and performing document\n * retrieval with optional configurations.\n *\n * @class VectorStoreRetriever\n * @extends BaseRetriever\n * @implements VectorStoreRetrieverInterface\n * @template V - Type of vector store implementing `VectorStoreInterface`.\n */\nclass VectorStoreRetriever extends _retrievers_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseRetriever {\n    static lc_name() {\n        return \"VectorStoreRetriever\";\n    }\n    get lc_namespace() {\n        return [\"langchain_core\", \"vectorstores\"];\n    }\n    /**\n     * Returns the type of vector store, as defined by the `vectorStore` instance.\n     *\n     * @returns {string} The vector store type.\n     */\n    _vectorstoreType() {\n        return this.vectorStore._vectorstoreType();\n    }\n    /**\n     * Initializes a new instance of `VectorStoreRetriever` with the specified configuration.\n     *\n     * This constructor configures the retriever to interact with a given `VectorStore`\n     * and supports different retrieval strategies, including similarity search and maximal\n     * marginal relevance (MMR) search. Various options allow customization of the number\n     * of documents retrieved per query, filtering based on conditions, and fine-tuning\n     * MMR-specific parameters.\n     *\n     * @param fields - Configuration options for setting up the retriever:\n     *\n     *   - `vectorStore` (required): The `VectorStore` instance implementing `VectorStoreInterface`\n     *     that will be used to store and retrieve document embeddings. This is the core component\n     *     of the retriever, enabling vector-based similarity and MMR searches.\n     *\n     *   - `k` (optional): Specifies the number of documents to retrieve per search query. If not\n     *     provided, defaults to 4. This count determines the number of most relevant documents returned\n     *     for each search operation, balancing performance with comprehensiveness.\n     *\n     *   - `searchType` (optional): Defines the search approach used by the retriever, allowing for\n     *     flexibility between two methods:\n     *       - `\"similarity\"` (default): A similarity-based search, retrieving documents with high vector\n     *         similarity to the query. This type prioritizes relevance and is often used when diversity\n     *         among results is less critical.\n     *       - `\"mmr\"`: Maximal Marginal Relevance search, which combines relevance with diversity. MMR\n     *         is useful for scenarios where varied content is essential, as it selects results that\n     *         both match the query and introduce content diversity.\n     *\n     *   - `filter` (optional): A filter of type `FilterType`, defined by the vector store, that allows\n     *     for refined and targeted search results. This filter applies specified conditions to limit\n     *     which documents are eligible for retrieval, offering control over the scope of results.\n     *\n     *   - `searchKwargs` (optional, applicable only if `searchType` is `\"mmr\"`): Additional settings\n     *     for configuring MMR-specific behavior. These parameters allow further tuning of the MMR\n     *     search process:\n     *       - `fetchK`: The initial number of documents fetched from the vector store before the MMR\n     *         algorithm is applied. Fetching a larger set enables the algorithm to select a more\n     *         diverse subset of documents.\n     *       - `lambda`: A parameter controlling the relevance-diversity balance, where 0 emphasizes\n     *         diversity and 1 prioritizes relevance. Intermediate values provide a blend of the two,\n     *         allowing customization based on the importance of content variety relative to query relevance.\n     */\n    constructor(fields) {\n        super(fields);\n        /**\n         * The instance of `VectorStore` used for storing and retrieving document embeddings.\n         * This vector store must implement the `VectorStoreInterface` to be compatible\n         * with the retrievers operations.\n         */\n        Object.defineProperty(this, \"vectorStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Specifies the number of documents to retrieve for each search query.\n         * Defaults to 4 if not specified, providing a basic result count for similarity or MMR searches.\n         */\n        Object.defineProperty(this, \"k\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 4\n        });\n        /**\n         * Determines the type of search operation to perform on the vector store.\n         *\n         * - `\"similarity\"` (default): Conducts a similarity search based purely on vector similarity\n         *   to the query.\n         * - `\"mmr\"`: Executes a maximal marginal relevance (MMR) search, balancing relevance and\n         *   diversity in the retrieved results.\n         */\n        Object.defineProperty(this, \"searchType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"similarity\"\n        });\n        /**\n         * Additional options specific to maximal marginal relevance (MMR) search, applicable\n         * only if `searchType` is set to `\"mmr\"`.\n         *\n         * Includes:\n         * - `fetchK`: The initial number of documents fetched before applying the MMR algorithm,\n         *   allowing for a larger selection from which to choose the most diverse results.\n         * - `lambda`: A parameter between 0 and 1 to adjust the relevance-diversity balance,\n         *   where 0 prioritizes diversity and 1 prioritizes relevance.\n         */\n        Object.defineProperty(this, \"searchKwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Optional filter applied to search results, defined by the `FilterType` of the vector store.\n         * Allows for refined, targeted results by restricting the returned documents based\n         * on specified filter criteria.\n         */\n        Object.defineProperty(this, \"filter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.vectorStore = fields.vectorStore;\n        this.k = fields.k ?? this.k;\n        this.searchType = fields.searchType ?? this.searchType;\n        this.filter = fields.filter;\n        if (fields.searchType === \"mmr\") {\n            this.searchKwargs = fields.searchKwargs;\n        }\n    }\n    /**\n     * Retrieves relevant documents based on the specified query, using either\n     * similarity or maximal marginal relevance (MMR) search.\n     *\n     * If `searchType` is set to `\"mmr\"`, performs an MMR search to balance\n     * similarity and diversity among results. If `searchType` is `\"similarity\"`,\n     * retrieves results purely based on similarity to the query.\n     *\n     * @param query - The query string used to find relevant documents.\n     * @param runManager - Optional callback manager for tracking retrieval progress.\n     * @returns A promise that resolves to an array of `DocumentInterface` instances\n     *          representing the most relevant documents to the query.\n     * @throws {Error} Throws an error if MMR search is requested but not supported\n     *                 by the vector store.\n     * @protected\n     */\n    async _getRelevantDocuments(query, runManager) {\n        if (this.searchType === \"mmr\") {\n            if (typeof this.vectorStore.maxMarginalRelevanceSearch !== \"function\") {\n                throw new Error(`The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`);\n            }\n            return this.vectorStore.maxMarginalRelevanceSearch(query, {\n                k: this.k,\n                filter: this.filter,\n                ...this.searchKwargs,\n            }, runManager?.getChild(\"vectorstore\"));\n        }\n        return this.vectorStore.similaritySearch(query, this.k, this.filter, runManager?.getChild(\"vectorstore\"));\n    }\n    /**\n     * Adds an array of documents to the vector store, embedding them as part of\n     * the storage process.\n     *\n     * This method delegates document embedding and storage to the `addDocuments`\n     * method of the underlying vector store.\n     *\n     * @param documents - An array of documents to embed and add to the vector store.\n     * @param options - Optional settings to customize document addition.\n     * @returns A promise that resolves to an array of document IDs or `void`,\n     *          depending on the vector store's implementation.\n     */\n    async addDocuments(documents, options) {\n        return this.vectorStore.addDocuments(documents, options);\n    }\n}\n/**\n * Abstract class representing a vector storage system for performing\n * similarity searches on embedded documents.\n *\n * `VectorStore` provides methods for adding precomputed vectors or documents,\n * removing documents based on criteria, and performing similarity searches\n * with optional scoring. Subclasses are responsible for implementing specific\n * storage mechanisms and the exact behavior of certain abstract methods.\n *\n * @abstract\n * @extends Serializable\n * @implements VectorStoreInterface\n */\nclass VectorStore extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_1__.Serializable {\n    /**\n     * Initializes a new vector store with embeddings and database configuration.\n     *\n     * @param embeddings - Instance of `EmbeddingsInterface` used to embed queries.\n     * @param dbConfig - Configuration settings for the database or storage system.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(embeddings, dbConfig) {\n        super(dbConfig);\n        /**\n         * Namespace within LangChain to uniquely identify this vector store's\n         * location, based on the vector store type.\n         *\n         * @internal\n         */\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"vectorstores\", this._vectorstoreType()]\n        });\n        /**\n         * Embeddings interface for generating vector embeddings from text queries,\n         * enabling vector-based similarity searches.\n         */\n        Object.defineProperty(this, \"embeddings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.embeddings = embeddings;\n    }\n    /**\n     * Deletes documents from the vector store based on the specified parameters.\n     *\n     * @param _params - Flexible key-value pairs defining conditions for document deletion.\n     * @returns A promise that resolves once the deletion is complete.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async delete(_params) {\n        throw new Error(\"Not implemented.\");\n    }\n    /**\n     * Searches for documents similar to a text query by embedding the query and\n     * performing a similarity search on the resulting vector.\n     *\n     * @param query - Text query for finding similar documents.\n     * @param k - Number of similar results to return. Defaults to 4.\n     * @param filter - Optional filter based on `FilterType`.\n     * @param _callbacks - Optional callbacks for monitoring search progress\n     * @returns A promise resolving to an array of `DocumentInterface` instances representing similar documents.\n     */\n    async similaritySearch(query, k = 4, filter = undefined, _callbacks = undefined // implement passing to embedQuery later\n    ) {\n        const results = await this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(query), k, filter);\n        return results.map((result) => result[0]);\n    }\n    /**\n     * Searches for documents similar to a text query by embedding the query,\n     * and returns results with similarity scores.\n     *\n     * @param query - Text query for finding similar documents.\n     * @param k - Number of similar results to return. Defaults to 4.\n     * @param filter - Optional filter based on `FilterType`.\n     * @param _callbacks - Optional callbacks for monitoring search progress\n     * @returns A promise resolving to an array of tuples, each containing a\n     *          document and its similarity score.\n     */\n    async similaritySearchWithScore(query, k = 4, filter = undefined, _callbacks = undefined // implement passing to embedQuery later\n    ) {\n        return this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(query), k, filter);\n    }\n    /**\n     * Creates a `VectorStore` instance from an array of text strings and optional\n     * metadata, using the specified embeddings and database configuration.\n     *\n     * Subclasses must implement this method to define how text and metadata\n     * are embedded and stored in the vector store. Throws an error if not overridden.\n     *\n     * @param _texts - Array of strings representing the text documents to be stored.\n     * @param _metadatas - Metadata for the texts, either as an array (one for each text)\n     *                     or a single object (applied to all texts).\n     * @param _embeddings - Instance of `EmbeddingsInterface` to embed the texts.\n     * @param _dbConfig - Database configuration settings.\n     * @returns A promise that resolves to a new `VectorStore` instance.\n     * @throws {Error} Throws an error if this method is not overridden by a subclass.\n     */\n    static fromTexts(_texts, _metadatas, _embeddings, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _dbConfig) {\n        throw new Error(\"the Langchain vectorstore implementation you are using forgot to override this, please report a bug\");\n    }\n    /**\n     * Creates a `VectorStore` instance from an array of documents, using the specified\n     * embeddings and database configuration.\n     *\n     * Subclasses must implement this method to define how documents are embedded\n     * and stored. Throws an error if not overridden.\n     *\n     * @param _docs - Array of `DocumentInterface` instances representing the documents to be stored.\n     * @param _embeddings - Instance of `EmbeddingsInterface` to embed the documents.\n     * @param _dbConfig - Database configuration settings.\n     * @returns A promise that resolves to a new `VectorStore` instance.\n     * @throws {Error} Throws an error if this method is not overridden by a subclass.\n     */\n    static fromDocuments(_docs, _embeddings, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _dbConfig) {\n        throw new Error(\"the Langchain vectorstore implementation you are using forgot to override this, please report a bug\");\n    }\n    /**\n     * Creates a `VectorStoreRetriever` instance with flexible configuration options.\n     *\n     * @param kOrFields\n     *    - If a number is provided, it sets the `k` parameter (number of items to retrieve).\n     *    - If an object is provided, it should contain various configuration options.\n     * @param filter\n     *    - Optional filter criteria to limit the items retrieved based on the specified filter type.\n     * @param callbacks\n     *    - Optional callbacks that may be triggered at specific stages of the retrieval process.\n     * @param tags\n     *    - Tags to categorize or label the `VectorStoreRetriever`. Defaults to an empty array if not provided.\n     * @param metadata\n     *    - Additional metadata as key-value pairs to add contextual information for the retrieval process.\n     * @param verbose\n     *    - If `true`, enables detailed logging for the retrieval process. Defaults to `false`.\n     *\n     * @returns\n     *    - A configured `VectorStoreRetriever` instance based on the provided parameters.\n     *\n     * @example\n     * Basic usage with a `k` value:\n     * ```typescript\n     * const retriever = myVectorStore.asRetriever(5);\n     * ```\n     *\n     * Usage with a configuration object:\n     * ```typescript\n     * const retriever = myVectorStore.asRetriever({\n     *   k: 10,\n     *   filter: myFilter,\n     *   tags: ['example', 'test'],\n     *   verbose: true,\n     *   searchType: 'mmr',\n     *   searchKwargs: { alpha: 0.5 },\n     * });\n     * ```\n     */\n    asRetriever(kOrFields, filter, callbacks, tags, metadata, verbose) {\n        if (typeof kOrFields === \"number\") {\n            return new VectorStoreRetriever({\n                vectorStore: this,\n                k: kOrFields,\n                filter,\n                tags: [...(tags ?? []), this._vectorstoreType()],\n                metadata,\n                verbose,\n                callbacks,\n            });\n        }\n        else {\n            const params = {\n                vectorStore: this,\n                k: kOrFields?.k,\n                filter: kOrFields?.filter,\n                tags: [...(kOrFields?.tags ?? []), this._vectorstoreType()],\n                metadata: kOrFields?.metadata,\n                verbose: kOrFields?.verbose,\n                callbacks: kOrFields?.callbacks,\n                searchType: kOrFields?.searchType,\n            };\n            if (kOrFields?.searchType === \"mmr\") {\n                return new VectorStoreRetriever({\n                    ...params,\n                    searchKwargs: kOrFields.searchKwargs,\n                });\n            }\n            return new VectorStoreRetriever({ ...params });\n        }\n    }\n}\n/**\n * Abstract class extending `VectorStore` that defines a contract for saving\n * and loading vector store instances.\n *\n * The `SaveableVectorStore` class allows vector store implementations to\n * persist their data and retrieve it when needed.The format for saving and\n * loading data is left to the implementing subclass.\n *\n * Subclasses must implement the `save` method to handle their custom\n * serialization logic, while the `load` method enables reconstruction of a\n * vector store from saved data, requiring compatible embeddings through the\n * `EmbeddingsInterface`.\n *\n * @abstract\n * @extends VectorStore\n */\nclass SaveableVectorStore extends VectorStore {\n    /**\n     * Loads a vector store instance from the specified directory, using the\n     * provided embeddings to ensure compatibility.\n     *\n     * This static method reconstructs a `SaveableVectorStore` from previously\n     * saved data. Implementations should interpret the saved data format to\n     * recreate the vector store instance.\n     *\n     * @param _directory - The directory path from which the vector store\n     * data will be loaded.\n     * @param _embeddings - An instance of `EmbeddingsInterface` to align\n     * the embeddings with the loaded vector data.\n     * @returns A promise that resolves to a `SaveableVectorStore` instance\n     * constructed from the saved data.\n     */\n    static load(_directory, _embeddings) {\n        throw new Error(\"Not implemented\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdmVjdG9yc3RvcmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVEO0FBQ0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsK0RBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHlCQUF5QjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsK0RBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdmVjdG9yc3RvcmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VSZXRyaWV2ZXIsIH0gZnJvbSBcIi4vcmV0cmlldmVycy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2VyaWFsaXphYmxlIH0gZnJvbSBcIi4vbG9hZC9zZXJpYWxpemFibGUuanNcIjtcbi8qKlxuICogQ2xhc3MgZm9yIHJldHJpZXZpbmcgZG9jdW1lbnRzIGZyb20gYSBgVmVjdG9yU3RvcmVgIGJhc2VkIG9uIHZlY3RvciBzaW1pbGFyaXR5XG4gKiBvciBtYXhpbWFsIG1hcmdpbmFsIHJlbGV2YW5jZSAoTU1SKS5cbiAqXG4gKiBgVmVjdG9yU3RvcmVSZXRyaWV2ZXJgIGV4dGVuZHMgYEJhc2VSZXRyaWV2ZXJgLCBpbXBsZW1lbnRpbmcgbWV0aG9kcyBmb3JcbiAqIGFkZGluZyBkb2N1bWVudHMgdG8gdGhlIHVuZGVybHlpbmcgdmVjdG9yIHN0b3JlIGFuZCBwZXJmb3JtaW5nIGRvY3VtZW50XG4gKiByZXRyaWV2YWwgd2l0aCBvcHRpb25hbCBjb25maWd1cmF0aW9ucy5cbiAqXG4gKiBAY2xhc3MgVmVjdG9yU3RvcmVSZXRyaWV2ZXJcbiAqIEBleHRlbmRzIEJhc2VSZXRyaWV2ZXJcbiAqIEBpbXBsZW1lbnRzIFZlY3RvclN0b3JlUmV0cmlldmVySW50ZXJmYWNlXG4gKiBAdGVtcGxhdGUgViAtIFR5cGUgb2YgdmVjdG9yIHN0b3JlIGltcGxlbWVudGluZyBgVmVjdG9yU3RvcmVJbnRlcmZhY2VgLlxuICovXG5leHBvcnQgY2xhc3MgVmVjdG9yU3RvcmVSZXRyaWV2ZXIgZXh0ZW5kcyBCYXNlUmV0cmlldmVyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiVmVjdG9yU3RvcmVSZXRyaWV2ZXJcIjtcbiAgICB9XG4gICAgZ2V0IGxjX25hbWVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIFtcImxhbmdjaGFpbl9jb3JlXCIsIFwidmVjdG9yc3RvcmVzXCJdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHZlY3RvciBzdG9yZSwgYXMgZGVmaW5lZCBieSB0aGUgYHZlY3RvclN0b3JlYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB2ZWN0b3Igc3RvcmUgdHlwZS5cbiAgICAgKi9cbiAgICBfdmVjdG9yc3RvcmVUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JTdG9yZS5fdmVjdG9yc3RvcmVUeXBlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBWZWN0b3JTdG9yZVJldHJpZXZlcmAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGNvbnN0cnVjdG9yIGNvbmZpZ3VyZXMgdGhlIHJldHJpZXZlciB0byBpbnRlcmFjdCB3aXRoIGEgZ2l2ZW4gYFZlY3RvclN0b3JlYFxuICAgICAqIGFuZCBzdXBwb3J0cyBkaWZmZXJlbnQgcmV0cmlldmFsIHN0cmF0ZWdpZXMsIGluY2x1ZGluZyBzaW1pbGFyaXR5IHNlYXJjaCBhbmQgbWF4aW1hbFxuICAgICAqIG1hcmdpbmFsIHJlbGV2YW5jZSAoTU1SKSBzZWFyY2guIFZhcmlvdXMgb3B0aW9ucyBhbGxvdyBjdXN0b21pemF0aW9uIG9mIHRoZSBudW1iZXJcbiAgICAgKiBvZiBkb2N1bWVudHMgcmV0cmlldmVkIHBlciBxdWVyeSwgZmlsdGVyaW5nIGJhc2VkIG9uIGNvbmRpdGlvbnMsIGFuZCBmaW5lLXR1bmluZ1xuICAgICAqIE1NUi1zcGVjaWZpYyBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkcyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3Igc2V0dGluZyB1cCB0aGUgcmV0cmlldmVyOlxuICAgICAqXG4gICAgICogICAtIGB2ZWN0b3JTdG9yZWAgKHJlcXVpcmVkKTogVGhlIGBWZWN0b3JTdG9yZWAgaW5zdGFuY2UgaW1wbGVtZW50aW5nIGBWZWN0b3JTdG9yZUludGVyZmFjZWBcbiAgICAgKiAgICAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIGRvY3VtZW50IGVtYmVkZGluZ3MuIFRoaXMgaXMgdGhlIGNvcmUgY29tcG9uZW50XG4gICAgICogICAgIG9mIHRoZSByZXRyaWV2ZXIsIGVuYWJsaW5nIHZlY3Rvci1iYXNlZCBzaW1pbGFyaXR5IGFuZCBNTVIgc2VhcmNoZXMuXG4gICAgICpcbiAgICAgKiAgIC0gYGtgIChvcHRpb25hbCk6IFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0byByZXRyaWV2ZSBwZXIgc2VhcmNoIHF1ZXJ5LiBJZiBub3RcbiAgICAgKiAgICAgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIDQuIFRoaXMgY291bnQgZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIG1vc3QgcmVsZXZhbnQgZG9jdW1lbnRzIHJldHVybmVkXG4gICAgICogICAgIGZvciBlYWNoIHNlYXJjaCBvcGVyYXRpb24sIGJhbGFuY2luZyBwZXJmb3JtYW5jZSB3aXRoIGNvbXByZWhlbnNpdmVuZXNzLlxuICAgICAqXG4gICAgICogICAtIGBzZWFyY2hUeXBlYCAob3B0aW9uYWwpOiBEZWZpbmVzIHRoZSBzZWFyY2ggYXBwcm9hY2ggdXNlZCBieSB0aGUgcmV0cmlldmVyLCBhbGxvd2luZyBmb3JcbiAgICAgKiAgICAgZmxleGliaWxpdHkgYmV0d2VlbiB0d28gbWV0aG9kczpcbiAgICAgKiAgICAgICAtIGBcInNpbWlsYXJpdHlcImAgKGRlZmF1bHQpOiBBIHNpbWlsYXJpdHktYmFzZWQgc2VhcmNoLCByZXRyaWV2aW5nIGRvY3VtZW50cyB3aXRoIGhpZ2ggdmVjdG9yXG4gICAgICogICAgICAgICBzaW1pbGFyaXR5IHRvIHRoZSBxdWVyeS4gVGhpcyB0eXBlIHByaW9yaXRpemVzIHJlbGV2YW5jZSBhbmQgaXMgb2Z0ZW4gdXNlZCB3aGVuIGRpdmVyc2l0eVxuICAgICAqICAgICAgICAgYW1vbmcgcmVzdWx0cyBpcyBsZXNzIGNyaXRpY2FsLlxuICAgICAqICAgICAgIC0gYFwibW1yXCJgOiBNYXhpbWFsIE1hcmdpbmFsIFJlbGV2YW5jZSBzZWFyY2gsIHdoaWNoIGNvbWJpbmVzIHJlbGV2YW5jZSB3aXRoIGRpdmVyc2l0eS4gTU1SXG4gICAgICogICAgICAgICBpcyB1c2VmdWwgZm9yIHNjZW5hcmlvcyB3aGVyZSB2YXJpZWQgY29udGVudCBpcyBlc3NlbnRpYWwsIGFzIGl0IHNlbGVjdHMgcmVzdWx0cyB0aGF0XG4gICAgICogICAgICAgICBib3RoIG1hdGNoIHRoZSBxdWVyeSBhbmQgaW50cm9kdWNlIGNvbnRlbnQgZGl2ZXJzaXR5LlxuICAgICAqXG4gICAgICogICAtIGBmaWx0ZXJgIChvcHRpb25hbCk6IEEgZmlsdGVyIG9mIHR5cGUgYEZpbHRlclR5cGVgLCBkZWZpbmVkIGJ5IHRoZSB2ZWN0b3Igc3RvcmUsIHRoYXQgYWxsb3dzXG4gICAgICogICAgIGZvciByZWZpbmVkIGFuZCB0YXJnZXRlZCBzZWFyY2ggcmVzdWx0cy4gVGhpcyBmaWx0ZXIgYXBwbGllcyBzcGVjaWZpZWQgY29uZGl0aW9ucyB0byBsaW1pdFxuICAgICAqICAgICB3aGljaCBkb2N1bWVudHMgYXJlIGVsaWdpYmxlIGZvciByZXRyaWV2YWwsIG9mZmVyaW5nIGNvbnRyb2wgb3ZlciB0aGUgc2NvcGUgb2YgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqICAgLSBgc2VhcmNoS3dhcmdzYCAob3B0aW9uYWwsIGFwcGxpY2FibGUgb25seSBpZiBgc2VhcmNoVHlwZWAgaXMgYFwibW1yXCJgKTogQWRkaXRpb25hbCBzZXR0aW5nc1xuICAgICAqICAgICBmb3IgY29uZmlndXJpbmcgTU1SLXNwZWNpZmljIGJlaGF2aW9yLiBUaGVzZSBwYXJhbWV0ZXJzIGFsbG93IGZ1cnRoZXIgdHVuaW5nIG9mIHRoZSBNTVJcbiAgICAgKiAgICAgc2VhcmNoIHByb2Nlc3M6XG4gICAgICogICAgICAgLSBgZmV0Y2hLYDogVGhlIGluaXRpYWwgbnVtYmVyIG9mIGRvY3VtZW50cyBmZXRjaGVkIGZyb20gdGhlIHZlY3RvciBzdG9yZSBiZWZvcmUgdGhlIE1NUlxuICAgICAqICAgICAgICAgYWxnb3JpdGhtIGlzIGFwcGxpZWQuIEZldGNoaW5nIGEgbGFyZ2VyIHNldCBlbmFibGVzIHRoZSBhbGdvcml0aG0gdG8gc2VsZWN0IGEgbW9yZVxuICAgICAqICAgICAgICAgZGl2ZXJzZSBzdWJzZXQgb2YgZG9jdW1lbnRzLlxuICAgICAqICAgICAgIC0gYGxhbWJkYWA6IEEgcGFyYW1ldGVyIGNvbnRyb2xsaW5nIHRoZSByZWxldmFuY2UtZGl2ZXJzaXR5IGJhbGFuY2UsIHdoZXJlIDAgZW1waGFzaXplc1xuICAgICAqICAgICAgICAgZGl2ZXJzaXR5IGFuZCAxIHByaW9yaXRpemVzIHJlbGV2YW5jZS4gSW50ZXJtZWRpYXRlIHZhbHVlcyBwcm92aWRlIGEgYmxlbmQgb2YgdGhlIHR3byxcbiAgICAgKiAgICAgICAgIGFsbG93aW5nIGN1c3RvbWl6YXRpb24gYmFzZWQgb24gdGhlIGltcG9ydGFuY2Ugb2YgY29udGVudCB2YXJpZXR5IHJlbGF0aXZlIHRvIHF1ZXJ5IHJlbGV2YW5jZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnN0YW5jZSBvZiBgVmVjdG9yU3RvcmVgIHVzZWQgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZG9jdW1lbnQgZW1iZWRkaW5ncy5cbiAgICAgICAgICogVGhpcyB2ZWN0b3Igc3RvcmUgbXVzdCBpbXBsZW1lbnQgdGhlIGBWZWN0b3JTdG9yZUludGVyZmFjZWAgdG8gYmUgY29tcGF0aWJsZVxuICAgICAgICAgKiB3aXRoIHRoZSByZXRyaWV2ZXLigJlzIG9wZXJhdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZWN0b3JTdG9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHRvIHJldHJpZXZlIGZvciBlYWNoIHNlYXJjaCBxdWVyeS5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gNCBpZiBub3Qgc3BlY2lmaWVkLCBwcm92aWRpbmcgYSBiYXNpYyByZXN1bHQgY291bnQgZm9yIHNpbWlsYXJpdHkgb3IgTU1SIHNlYXJjaGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgdGhlIHR5cGUgb2Ygc2VhcmNoIG9wZXJhdGlvbiB0byBwZXJmb3JtIG9uIHRoZSB2ZWN0b3Igc3RvcmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIC0gYFwic2ltaWxhcml0eVwiYCAoZGVmYXVsdCk6IENvbmR1Y3RzIGEgc2ltaWxhcml0eSBzZWFyY2ggYmFzZWQgcHVyZWx5IG9uIHZlY3RvciBzaW1pbGFyaXR5XG4gICAgICAgICAqICAgdG8gdGhlIHF1ZXJ5LlxuICAgICAgICAgKiAtIGBcIm1tclwiYDogRXhlY3V0ZXMgYSBtYXhpbWFsIG1hcmdpbmFsIHJlbGV2YW5jZSAoTU1SKSBzZWFyY2gsIGJhbGFuY2luZyByZWxldmFuY2UgYW5kXG4gICAgICAgICAqICAgZGl2ZXJzaXR5IGluIHRoZSByZXRyaWV2ZWQgcmVzdWx0cy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlYXJjaFR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwic2ltaWxhcml0eVwiXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCBvcHRpb25zIHNwZWNpZmljIHRvIG1heGltYWwgbWFyZ2luYWwgcmVsZXZhbmNlIChNTVIpIHNlYXJjaCwgYXBwbGljYWJsZVxuICAgICAgICAgKiBvbmx5IGlmIGBzZWFyY2hUeXBlYCBpcyBzZXQgdG8gYFwibW1yXCJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbmNsdWRlczpcbiAgICAgICAgICogLSBgZmV0Y2hLYDogVGhlIGluaXRpYWwgbnVtYmVyIG9mIGRvY3VtZW50cyBmZXRjaGVkIGJlZm9yZSBhcHBseWluZyB0aGUgTU1SIGFsZ29yaXRobSxcbiAgICAgICAgICogICBhbGxvd2luZyBmb3IgYSBsYXJnZXIgc2VsZWN0aW9uIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtb3N0IGRpdmVyc2UgcmVzdWx0cy5cbiAgICAgICAgICogLSBgbGFtYmRhYDogQSBwYXJhbWV0ZXIgYmV0d2VlbiAwIGFuZCAxIHRvIGFkanVzdCB0aGUgcmVsZXZhbmNlLWRpdmVyc2l0eSBiYWxhbmNlLFxuICAgICAgICAgKiAgIHdoZXJlIDAgcHJpb3JpdGl6ZXMgZGl2ZXJzaXR5IGFuZCAxIHByaW9yaXRpemVzIHJlbGV2YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlYXJjaEt3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgZmlsdGVyIGFwcGxpZWQgdG8gc2VhcmNoIHJlc3VsdHMsIGRlZmluZWQgYnkgdGhlIGBGaWx0ZXJUeXBlYCBvZiB0aGUgdmVjdG9yIHN0b3JlLlxuICAgICAgICAgKiBBbGxvd3MgZm9yIHJlZmluZWQsIHRhcmdldGVkIHJlc3VsdHMgYnkgcmVzdHJpY3RpbmcgdGhlIHJldHVybmVkIGRvY3VtZW50cyBiYXNlZFxuICAgICAgICAgKiBvbiBzcGVjaWZpZWQgZmlsdGVyIGNyaXRlcmlhLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlsdGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmVjdG9yU3RvcmUgPSBmaWVsZHMudmVjdG9yU3RvcmU7XG4gICAgICAgIHRoaXMuayA9IGZpZWxkcy5rID8/IHRoaXMuaztcbiAgICAgICAgdGhpcy5zZWFyY2hUeXBlID0gZmllbGRzLnNlYXJjaFR5cGUgPz8gdGhpcy5zZWFyY2hUeXBlO1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpZWxkcy5maWx0ZXI7XG4gICAgICAgIGlmIChmaWVsZHMuc2VhcmNoVHlwZSA9PT0gXCJtbXJcIikge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hLd2FyZ3MgPSBmaWVsZHMuc2VhcmNoS3dhcmdzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyByZWxldmFudCBkb2N1bWVudHMgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBxdWVyeSwgdXNpbmcgZWl0aGVyXG4gICAgICogc2ltaWxhcml0eSBvciBtYXhpbWFsIG1hcmdpbmFsIHJlbGV2YW5jZSAoTU1SKSBzZWFyY2guXG4gICAgICpcbiAgICAgKiBJZiBgc2VhcmNoVHlwZWAgaXMgc2V0IHRvIGBcIm1tclwiYCwgcGVyZm9ybXMgYW4gTU1SIHNlYXJjaCB0byBiYWxhbmNlXG4gICAgICogc2ltaWxhcml0eSBhbmQgZGl2ZXJzaXR5IGFtb25nIHJlc3VsdHMuIElmIGBzZWFyY2hUeXBlYCBpcyBgXCJzaW1pbGFyaXR5XCJgLFxuICAgICAqIHJldHJpZXZlcyByZXN1bHRzIHB1cmVseSBiYXNlZCBvbiBzaW1pbGFyaXR5IHRvIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSBzdHJpbmcgdXNlZCB0byBmaW5kIHJlbGV2YW50IGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gcnVuTWFuYWdlciAtIE9wdGlvbmFsIGNhbGxiYWNrIG1hbmFnZXIgZm9yIHRyYWNraW5nIHJldHJpZXZhbCBwcm9ncmVzcy5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBgRG9jdW1lbnRJbnRlcmZhY2VgIGluc3RhbmNlc1xuICAgICAqICAgICAgICAgIHJlcHJlc2VudGluZyB0aGUgbW9zdCByZWxldmFudCBkb2N1bWVudHMgdG8gdGhlIHF1ZXJ5LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgTU1SIHNlYXJjaCBpcyByZXF1ZXN0ZWQgYnV0IG5vdCBzdXBwb3J0ZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgYnkgdGhlIHZlY3RvciBzdG9yZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgX2dldFJlbGV2YW50RG9jdW1lbnRzKHF1ZXJ5LCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLnNlYXJjaFR5cGUgPT09IFwibW1yXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy52ZWN0b3JTdG9yZS5tYXhNYXJnaW5hbFJlbGV2YW5jZVNlYXJjaCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdmVjdG9yIHN0b3JlIGJhY2tpbmcgdGhpcyByZXRyaWV2ZXIsICR7dGhpcy5fdmVjdG9yc3RvcmVUeXBlKCl9IGRvZXMgbm90IHN1cHBvcnQgbWF4IG1hcmdpbmFsIHJlbGV2YW5jZSBzZWFyY2guYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JTdG9yZS5tYXhNYXJnaW5hbFJlbGV2YW5jZVNlYXJjaChxdWVyeSwge1xuICAgICAgICAgICAgICAgIGs6IHRoaXMuayxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuc2VhcmNoS3dhcmdzLFxuICAgICAgICAgICAgfSwgcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoXCJ2ZWN0b3JzdG9yZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmVjdG9yU3RvcmUuc2ltaWxhcml0eVNlYXJjaChxdWVyeSwgdGhpcy5rLCB0aGlzLmZpbHRlciwgcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoXCJ2ZWN0b3JzdG9yZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYXJyYXkgb2YgZG9jdW1lbnRzIHRvIHRoZSB2ZWN0b3Igc3RvcmUsIGVtYmVkZGluZyB0aGVtIGFzIHBhcnQgb2ZcbiAgICAgKiB0aGUgc3RvcmFnZSBwcm9jZXNzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGVsZWdhdGVzIGRvY3VtZW50IGVtYmVkZGluZyBhbmQgc3RvcmFnZSB0byB0aGUgYGFkZERvY3VtZW50c2BcbiAgICAgKiBtZXRob2Qgb2YgdGhlIHVuZGVybHlpbmcgdmVjdG9yIHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50cyAtIEFuIGFycmF5IG9mIGRvY3VtZW50cyB0byBlbWJlZCBhbmQgYWRkIHRvIHRoZSB2ZWN0b3Igc3RvcmUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5ncyB0byBjdXN0b21pemUgZG9jdW1lbnQgYWRkaXRpb24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgZG9jdW1lbnQgSURzIG9yIGB2b2lkYCxcbiAgICAgKiAgICAgICAgICBkZXBlbmRpbmcgb24gdGhlIHZlY3RvciBzdG9yZSdzIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZERvY3VtZW50cyhkb2N1bWVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVjdG9yU3RvcmUuYWRkRG9jdW1lbnRzKGRvY3VtZW50cywgb3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyByZXByZXNlbnRpbmcgYSB2ZWN0b3Igc3RvcmFnZSBzeXN0ZW0gZm9yIHBlcmZvcm1pbmdcbiAqIHNpbWlsYXJpdHkgc2VhcmNoZXMgb24gZW1iZWRkZWQgZG9jdW1lbnRzLlxuICpcbiAqIGBWZWN0b3JTdG9yZWAgcHJvdmlkZXMgbWV0aG9kcyBmb3IgYWRkaW5nIHByZWNvbXB1dGVkIHZlY3RvcnMgb3IgZG9jdW1lbnRzLFxuICogcmVtb3ZpbmcgZG9jdW1lbnRzIGJhc2VkIG9uIGNyaXRlcmlhLCBhbmQgcGVyZm9ybWluZyBzaW1pbGFyaXR5IHNlYXJjaGVzXG4gKiB3aXRoIG9wdGlvbmFsIHNjb3JpbmcuIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIGZvciBpbXBsZW1lbnRpbmcgc3BlY2lmaWNcbiAqIHN0b3JhZ2UgbWVjaGFuaXNtcyBhbmQgdGhlIGV4YWN0IGJlaGF2aW9yIG9mIGNlcnRhaW4gYWJzdHJhY3QgbWV0aG9kcy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIFNlcmlhbGl6YWJsZVxuICogQGltcGxlbWVudHMgVmVjdG9yU3RvcmVJbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGNsYXNzIFZlY3RvclN0b3JlIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyB2ZWN0b3Igc3RvcmUgd2l0aCBlbWJlZGRpbmdzIGFuZCBkYXRhYmFzZSBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVtYmVkZGluZ3MgLSBJbnN0YW5jZSBvZiBgRW1iZWRkaW5nc0ludGVyZmFjZWAgdXNlZCB0byBlbWJlZCBxdWVyaWVzLlxuICAgICAqIEBwYXJhbSBkYkNvbmZpZyAtIENvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZm9yIHRoZSBkYXRhYmFzZSBvciBzdG9yYWdlIHN5c3RlbS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0cnVjdG9yKGVtYmVkZGluZ3MsIGRiQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGRiQ29uZmlnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWVzcGFjZSB3aXRoaW4gTGFuZ0NoYWluIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgdmVjdG9yIHN0b3JlJ3NcbiAgICAgICAgICogbG9jYXRpb24sIGJhc2VkIG9uIHRoZSB2ZWN0b3Igc3RvcmUgdHlwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICAvLyBPbmx5IGV2ZXIgaW5zdGFudGlhdGVkIGluIG1haW4gTGFuZ0NoYWluXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwidmVjdG9yc3RvcmVzXCIsIHRoaXMuX3ZlY3RvcnN0b3JlVHlwZSgpXVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtYmVkZGluZ3MgaW50ZXJmYWNlIGZvciBnZW5lcmF0aW5nIHZlY3RvciBlbWJlZGRpbmdzIGZyb20gdGV4dCBxdWVyaWVzLFxuICAgICAgICAgKiBlbmFibGluZyB2ZWN0b3ItYmFzZWQgc2ltaWxhcml0eSBzZWFyY2hlcy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVtYmVkZGluZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWJlZGRpbmdzID0gZW1iZWRkaW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBkb2N1bWVudHMgZnJvbSB0aGUgdmVjdG9yIHN0b3JlIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfcGFyYW1zIC0gRmxleGlibGUga2V5LXZhbHVlIHBhaXJzIGRlZmluaW5nIGNvbmRpdGlvbnMgZm9yIGRvY3VtZW50IGRlbGV0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIGRlbGV0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgZGVsZXRlKF9wYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIGRvY3VtZW50cyBzaW1pbGFyIHRvIGEgdGV4dCBxdWVyeSBieSBlbWJlZGRpbmcgdGhlIHF1ZXJ5IGFuZFxuICAgICAqIHBlcmZvcm1pbmcgYSBzaW1pbGFyaXR5IHNlYXJjaCBvbiB0aGUgcmVzdWx0aW5nIHZlY3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRleHQgcXVlcnkgZm9yIGZpbmRpbmcgc2ltaWxhciBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIGsgLSBOdW1iZXIgb2Ygc2ltaWxhciByZXN1bHRzIHRvIHJldHVybi4gRGVmYXVsdHMgdG8gNC5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIC0gT3B0aW9uYWwgZmlsdGVyIGJhc2VkIG9uIGBGaWx0ZXJUeXBlYC5cbiAgICAgKiBAcGFyYW0gX2NhbGxiYWNrcyAtIE9wdGlvbmFsIGNhbGxiYWNrcyBmb3IgbW9uaXRvcmluZyBzZWFyY2ggcHJvZ3Jlc3NcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIGBEb2N1bWVudEludGVyZmFjZWAgaW5zdGFuY2VzIHJlcHJlc2VudGluZyBzaW1pbGFyIGRvY3VtZW50cy5cbiAgICAgKi9cbiAgICBhc3luYyBzaW1pbGFyaXR5U2VhcmNoKHF1ZXJ5LCBrID0gNCwgZmlsdGVyID0gdW5kZWZpbmVkLCBfY2FsbGJhY2tzID0gdW5kZWZpbmVkIC8vIGltcGxlbWVudCBwYXNzaW5nIHRvIGVtYmVkUXVlcnkgbGF0ZXJcbiAgICApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2ltaWxhcml0eVNlYXJjaFZlY3RvcldpdGhTY29yZShhd2FpdCB0aGlzLmVtYmVkZGluZ3MuZW1iZWRRdWVyeShxdWVyeSksIGssIGZpbHRlcik7XG4gICAgICAgIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgZG9jdW1lbnRzIHNpbWlsYXIgdG8gYSB0ZXh0IHF1ZXJ5IGJ5IGVtYmVkZGluZyB0aGUgcXVlcnksXG4gICAgICogYW5kIHJldHVybnMgcmVzdWx0cyB3aXRoIHNpbWlsYXJpdHkgc2NvcmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGV4dCBxdWVyeSBmb3IgZmluZGluZyBzaW1pbGFyIGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gayAtIE51bWJlciBvZiBzaW1pbGFyIHJlc3VsdHMgdG8gcmV0dXJuLiBEZWZhdWx0cyB0byA0LlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBPcHRpb25hbCBmaWx0ZXIgYmFzZWQgb24gYEZpbHRlclR5cGVgLlxuICAgICAqIEBwYXJhbSBfY2FsbGJhY2tzIC0gT3B0aW9uYWwgY2FsbGJhY2tzIGZvciBtb25pdG9yaW5nIHNlYXJjaCBwcm9ncmVzc1xuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgdHVwbGVzLCBlYWNoIGNvbnRhaW5pbmcgYVxuICAgICAqICAgICAgICAgIGRvY3VtZW50IGFuZCBpdHMgc2ltaWxhcml0eSBzY29yZS5cbiAgICAgKi9cbiAgICBhc3luYyBzaW1pbGFyaXR5U2VhcmNoV2l0aFNjb3JlKHF1ZXJ5LCBrID0gNCwgZmlsdGVyID0gdW5kZWZpbmVkLCBfY2FsbGJhY2tzID0gdW5kZWZpbmVkIC8vIGltcGxlbWVudCBwYXNzaW5nIHRvIGVtYmVkUXVlcnkgbGF0ZXJcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltaWxhcml0eVNlYXJjaFZlY3RvcldpdGhTY29yZShhd2FpdCB0aGlzLmVtYmVkZGluZ3MuZW1iZWRRdWVyeShxdWVyeSksIGssIGZpbHRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgVmVjdG9yU3RvcmVgIGluc3RhbmNlIGZyb20gYW4gYXJyYXkgb2YgdGV4dCBzdHJpbmdzIGFuZCBvcHRpb25hbFxuICAgICAqIG1ldGFkYXRhLCB1c2luZyB0aGUgc3BlY2lmaWVkIGVtYmVkZGluZ3MgYW5kIGRhdGFiYXNlIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIGRlZmluZSBob3cgdGV4dCBhbmQgbWV0YWRhdGFcbiAgICAgKiBhcmUgZW1iZWRkZWQgYW5kIHN0b3JlZCBpbiB0aGUgdmVjdG9yIHN0b3JlLiBUaHJvd3MgYW4gZXJyb3IgaWYgbm90IG92ZXJyaWRkZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gX3RleHRzIC0gQXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIHRleHQgZG9jdW1lbnRzIHRvIGJlIHN0b3JlZC5cbiAgICAgKiBAcGFyYW0gX21ldGFkYXRhcyAtIE1ldGFkYXRhIGZvciB0aGUgdGV4dHMsIGVpdGhlciBhcyBhbiBhcnJheSAob25lIGZvciBlYWNoIHRleHQpXG4gICAgICogICAgICAgICAgICAgICAgICAgICBvciBhIHNpbmdsZSBvYmplY3QgKGFwcGxpZWQgdG8gYWxsIHRleHRzKS5cbiAgICAgKiBAcGFyYW0gX2VtYmVkZGluZ3MgLSBJbnN0YW5jZSBvZiBgRW1iZWRkaW5nc0ludGVyZmFjZWAgdG8gZW1iZWQgdGhlIHRleHRzLlxuICAgICAqIEBwYXJhbSBfZGJDb25maWcgLSBEYXRhYmFzZSBjb25maWd1cmF0aW9uIHNldHRpbmdzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbmV3IGBWZWN0b3JTdG9yZWAgaW5zdGFuY2UuXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGlzIG1ldGhvZCBpcyBub3Qgb3ZlcnJpZGRlbiBieSBhIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVGV4dHMoX3RleHRzLCBfbWV0YWRhdGFzLCBfZW1iZWRkaW5ncywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfZGJDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhlIExhbmdjaGFpbiB2ZWN0b3JzdG9yZSBpbXBsZW1lbnRhdGlvbiB5b3UgYXJlIHVzaW5nIGZvcmdvdCB0byBvdmVycmlkZSB0aGlzLCBwbGVhc2UgcmVwb3J0IGEgYnVnXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYFZlY3RvclN0b3JlYCBpbnN0YW5jZSBmcm9tIGFuIGFycmF5IG9mIGRvY3VtZW50cywgdXNpbmcgdGhlIHNwZWNpZmllZFxuICAgICAqIGVtYmVkZGluZ3MgYW5kIGRhdGFiYXNlIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIGRlZmluZSBob3cgZG9jdW1lbnRzIGFyZSBlbWJlZGRlZFxuICAgICAqIGFuZCBzdG9yZWQuIFRocm93cyBhbiBlcnJvciBpZiBub3Qgb3ZlcnJpZGRlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfZG9jcyAtIEFycmF5IG9mIGBEb2N1bWVudEludGVyZmFjZWAgaW5zdGFuY2VzIHJlcHJlc2VudGluZyB0aGUgZG9jdW1lbnRzIHRvIGJlIHN0b3JlZC5cbiAgICAgKiBAcGFyYW0gX2VtYmVkZGluZ3MgLSBJbnN0YW5jZSBvZiBgRW1iZWRkaW5nc0ludGVyZmFjZWAgdG8gZW1iZWQgdGhlIGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gX2RiQ29uZmlnIC0gRGF0YWJhc2UgY29uZmlndXJhdGlvbiBzZXR0aW5ncy5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG5ldyBgVmVjdG9yU3RvcmVgIGluc3RhbmNlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhpcyBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4gYnkgYSBzdWJjbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbURvY3VtZW50cyhfZG9jcywgX2VtYmVkZGluZ3MsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX2RiQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRoZSBMYW5nY2hhaW4gdmVjdG9yc3RvcmUgaW1wbGVtZW50YXRpb24geW91IGFyZSB1c2luZyBmb3Jnb3QgdG8gb3ZlcnJpZGUgdGhpcywgcGxlYXNlIHJlcG9ydCBhIGJ1Z1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBWZWN0b3JTdG9yZVJldHJpZXZlcmAgaW5zdGFuY2Ugd2l0aCBmbGV4aWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga09yRmllbGRzXG4gICAgICogICAgLSBJZiBhIG51bWJlciBpcyBwcm92aWRlZCwgaXQgc2V0cyB0aGUgYGtgIHBhcmFtZXRlciAobnVtYmVyIG9mIGl0ZW1zIHRvIHJldHJpZXZlKS5cbiAgICAgKiAgICAtIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCwgaXQgc2hvdWxkIGNvbnRhaW4gdmFyaW91cyBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqICAgIC0gT3B0aW9uYWwgZmlsdGVyIGNyaXRlcmlhIHRvIGxpbWl0IHRoZSBpdGVtcyByZXRyaWV2ZWQgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmaWx0ZXIgdHlwZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzXG4gICAgICogICAgLSBPcHRpb25hbCBjYWxsYmFja3MgdGhhdCBtYXkgYmUgdHJpZ2dlcmVkIGF0IHNwZWNpZmljIHN0YWdlcyBvZiB0aGUgcmV0cmlldmFsIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHRhZ3NcbiAgICAgKiAgICAtIFRhZ3MgdG8gY2F0ZWdvcml6ZSBvciBsYWJlbCB0aGUgYFZlY3RvclN0b3JlUmV0cmlldmVyYC4gRGVmYXVsdHMgdG8gYW4gZW1wdHkgYXJyYXkgaWYgbm90IHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgICAqICAgIC0gQWRkaXRpb25hbCBtZXRhZGF0YSBhcyBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gZm9yIHRoZSByZXRyaWV2YWwgcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gdmVyYm9zZVxuICAgICAqICAgIC0gSWYgYHRydWVgLCBlbmFibGVzIGRldGFpbGVkIGxvZ2dpbmcgZm9yIHRoZSByZXRyaWV2YWwgcHJvY2Vzcy4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICogICAgLSBBIGNvbmZpZ3VyZWQgYFZlY3RvclN0b3JlUmV0cmlldmVyYCBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogQmFzaWMgdXNhZ2Ugd2l0aCBhIGBrYCB2YWx1ZTpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcmV0cmlldmVyID0gbXlWZWN0b3JTdG9yZS5hc1JldHJpZXZlcig1KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFVzYWdlIHdpdGggYSBjb25maWd1cmF0aW9uIG9iamVjdDpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcmV0cmlldmVyID0gbXlWZWN0b3JTdG9yZS5hc1JldHJpZXZlcih7XG4gICAgICogICBrOiAxMCxcbiAgICAgKiAgIGZpbHRlcjogbXlGaWx0ZXIsXG4gICAgICogICB0YWdzOiBbJ2V4YW1wbGUnLCAndGVzdCddLFxuICAgICAqICAgdmVyYm9zZTogdHJ1ZSxcbiAgICAgKiAgIHNlYXJjaFR5cGU6ICdtbXInLFxuICAgICAqICAgc2VhcmNoS3dhcmdzOiB7IGFscGhhOiAwLjUgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc1JldHJpZXZlcihrT3JGaWVsZHMsIGZpbHRlciwgY2FsbGJhY2tzLCB0YWdzLCBtZXRhZGF0YSwgdmVyYm9zZSkge1xuICAgICAgICBpZiAodHlwZW9mIGtPckZpZWxkcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3JTdG9yZVJldHJpZXZlcih7XG4gICAgICAgICAgICAgICAgdmVjdG9yU3RvcmU6IHRoaXMsXG4gICAgICAgICAgICAgICAgazoga09yRmllbGRzLFxuICAgICAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgICAgICB0YWdzOiBbLi4uKHRhZ3MgPz8gW10pLCB0aGlzLl92ZWN0b3JzdG9yZVR5cGUoKV0sXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgdmVyYm9zZSxcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB2ZWN0b3JTdG9yZTogdGhpcyxcbiAgICAgICAgICAgICAgICBrOiBrT3JGaWVsZHM/LmssXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBrT3JGaWVsZHM/LmZpbHRlcixcbiAgICAgICAgICAgICAgICB0YWdzOiBbLi4uKGtPckZpZWxkcz8udGFncyA/PyBbXSksIHRoaXMuX3ZlY3RvcnN0b3JlVHlwZSgpXSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToga09yRmllbGRzPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB2ZXJib3NlOiBrT3JGaWVsZHM/LnZlcmJvc2UsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBrT3JGaWVsZHM/LmNhbGxiYWNrcyxcbiAgICAgICAgICAgICAgICBzZWFyY2hUeXBlOiBrT3JGaWVsZHM/LnNlYXJjaFR5cGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGtPckZpZWxkcz8uc2VhcmNoVHlwZSA9PT0gXCJtbXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yU3RvcmVSZXRyaWV2ZXIoe1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaEt3YXJnczoga09yRmllbGRzLnNlYXJjaEt3YXJncyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yU3RvcmVSZXRyaWV2ZXIoeyAuLi5wYXJhbXMgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGV4dGVuZGluZyBgVmVjdG9yU3RvcmVgIHRoYXQgZGVmaW5lcyBhIGNvbnRyYWN0IGZvciBzYXZpbmdcbiAqIGFuZCBsb2FkaW5nIHZlY3RvciBzdG9yZSBpbnN0YW5jZXMuXG4gKlxuICogVGhlIGBTYXZlYWJsZVZlY3RvclN0b3JlYCBjbGFzcyBhbGxvd3MgdmVjdG9yIHN0b3JlIGltcGxlbWVudGF0aW9ucyB0b1xuICogcGVyc2lzdCB0aGVpciBkYXRhIGFuZCByZXRyaWV2ZSBpdCB3aGVuIG5lZWRlZC5UaGUgZm9ybWF0IGZvciBzYXZpbmcgYW5kXG4gKiBsb2FkaW5nIGRhdGEgaXMgbGVmdCB0byB0aGUgaW1wbGVtZW50aW5nIHN1YmNsYXNzLlxuICpcbiAqIFN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgdGhlIGBzYXZlYCBtZXRob2QgdG8gaGFuZGxlIHRoZWlyIGN1c3RvbVxuICogc2VyaWFsaXphdGlvbiBsb2dpYywgd2hpbGUgdGhlIGBsb2FkYCBtZXRob2QgZW5hYmxlcyByZWNvbnN0cnVjdGlvbiBvZiBhXG4gKiB2ZWN0b3Igc3RvcmUgZnJvbSBzYXZlZCBkYXRhLCByZXF1aXJpbmcgY29tcGF0aWJsZSBlbWJlZGRpbmdzIHRocm91Z2ggdGhlXG4gKiBgRW1iZWRkaW5nc0ludGVyZmFjZWAuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAZXh0ZW5kcyBWZWN0b3JTdG9yZVxuICovXG5leHBvcnQgY2xhc3MgU2F2ZWFibGVWZWN0b3JTdG9yZSBleHRlbmRzIFZlY3RvclN0b3JlIHtcbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHZlY3RvciBzdG9yZSBpbnN0YW5jZSBmcm9tIHRoZSBzcGVjaWZpZWQgZGlyZWN0b3J5LCB1c2luZyB0aGVcbiAgICAgKiBwcm92aWRlZCBlbWJlZGRpbmdzIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogVGhpcyBzdGF0aWMgbWV0aG9kIHJlY29uc3RydWN0cyBhIGBTYXZlYWJsZVZlY3RvclN0b3JlYCBmcm9tIHByZXZpb3VzbHlcbiAgICAgKiBzYXZlZCBkYXRhLiBJbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGludGVycHJldCB0aGUgc2F2ZWQgZGF0YSBmb3JtYXQgdG9cbiAgICAgKiByZWNyZWF0ZSB0aGUgdmVjdG9yIHN0b3JlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9kaXJlY3RvcnkgLSBUaGUgZGlyZWN0b3J5IHBhdGggZnJvbSB3aGljaCB0aGUgdmVjdG9yIHN0b3JlXG4gICAgICogZGF0YSB3aWxsIGJlIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gX2VtYmVkZGluZ3MgLSBBbiBpbnN0YW5jZSBvZiBgRW1iZWRkaW5nc0ludGVyZmFjZWAgdG8gYWxpZ25cbiAgICAgKiB0aGUgZW1iZWRkaW5ncyB3aXRoIHRoZSBsb2FkZWQgdmVjdG9yIGRhdGEuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU2F2ZWFibGVWZWN0b3JTdG9yZWAgaW5zdGFuY2VcbiAgICAgKiBjb25zdHJ1Y3RlZCBmcm9tIHRoZSBzYXZlZCBkYXRhLlxuICAgICAqL1xuICAgIHN0YXRpYyBsb2FkKF9kaXJlY3RvcnksIF9lbWJlZGRpbmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/vectorstores.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/load.js":
/*!**********************************************!*\
  !*** ./node_modules/@langchain/core/load.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   load: () => (/* reexport safe */ _dist_load_index_js__WEBPACK_IMPORTED_MODULE_0__.load)
/* harmony export */ });
/* harmony import */ var _dist_load_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/load/index.js */ "(rsc)/./node_modules/@langchain/core/dist/load/index.js");


/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/messages.js":
/*!**************************************************!*\
  !*** ./node_modules/@langchain/core/messages.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AIMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.AIMessage),
/* harmony export */   AIMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.AIMessageChunk),
/* harmony export */   BaseMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage),
/* harmony export */   BaseMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk),
/* harmony export */   ChatMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.ChatMessage),
/* harmony export */   ChatMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.ChatMessageChunk),
/* harmony export */   FunctionMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.FunctionMessage),
/* harmony export */   FunctionMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.FunctionMessageChunk),
/* harmony export */   HumanMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.HumanMessage),
/* harmony export */   HumanMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.HumanMessageChunk),
/* harmony export */   RemoveMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.RemoveMessage),
/* harmony export */   SystemMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.SystemMessage),
/* harmony export */   SystemMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.SystemMessageChunk),
/* harmony export */   ToolMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.ToolMessage),
/* harmony export */   ToolMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.ToolMessageChunk),
/* harmony export */   _isMessageFieldWithRole: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__._isMessageFieldWithRole),
/* harmony export */   _mergeDicts: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts),
/* harmony export */   _mergeLists: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__._mergeLists),
/* harmony export */   _mergeObj: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__._mergeObj),
/* harmony export */   _mergeStatus: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__._mergeStatus),
/* harmony export */   coerceMessageLikeToMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage),
/* harmony export */   convertToChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.convertToChunk),
/* harmony export */   convertToOpenAIImageBlock: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.convertToOpenAIImageBlock),
/* harmony export */   convertToProviderContentBlock: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.convertToProviderContentBlock),
/* harmony export */   defaultTextSplitter: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.defaultTextSplitter),
/* harmony export */   filterMessages: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.filterMessages),
/* harmony export */   getBufferString: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.getBufferString),
/* harmony export */   isAIMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isAIMessage),
/* harmony export */   isAIMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isAIMessageChunk),
/* harmony export */   isBase64ContentBlock: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isBase64ContentBlock),
/* harmony export */   isBaseMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isBaseMessage),
/* harmony export */   isBaseMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isBaseMessageChunk),
/* harmony export */   isChatMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isChatMessage),
/* harmony export */   isChatMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isChatMessageChunk),
/* harmony export */   isDataContentBlock: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isDataContentBlock),
/* harmony export */   isFunctionMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isFunctionMessage),
/* harmony export */   isFunctionMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isFunctionMessageChunk),
/* harmony export */   isHumanMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isHumanMessage),
/* harmony export */   isHumanMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isHumanMessageChunk),
/* harmony export */   isIDContentBlock: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isIDContentBlock),
/* harmony export */   isOpenAIToolCallArray: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isOpenAIToolCallArray),
/* harmony export */   isPlainTextContentBlock: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isPlainTextContentBlock),
/* harmony export */   isSystemMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isSystemMessage),
/* harmony export */   isSystemMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isSystemMessageChunk),
/* harmony export */   isToolMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isToolMessage),
/* harmony export */   isToolMessageChunk: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isToolMessageChunk),
/* harmony export */   isURLContentBlock: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.isURLContentBlock),
/* harmony export */   mapChatMessagesToStoredMessages: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.mapChatMessagesToStoredMessages),
/* harmony export */   mapStoredMessageToChatMessage: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.mapStoredMessageToChatMessage),
/* harmony export */   mapStoredMessagesToChatMessages: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.mapStoredMessagesToChatMessages),
/* harmony export */   mergeContent: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent),
/* harmony export */   mergeMessageRuns: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.mergeMessageRuns),
/* harmony export */   parseBase64DataUrl: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.parseBase64DataUrl),
/* harmony export */   parseMimeType: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.parseMimeType),
/* harmony export */   trimMessages: () => (/* reexport safe */ _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.trimMessages)
/* harmony export */ });
/* harmony import */ var _dist_messages_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/messages/index.js */ "(rsc)/./node_modules/@langchain/core/dist/messages/index.js");


/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxpRUFBZTtBQUNmLGNBQWMsK0RBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tbm9kZVxcbmF0aXZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGRlZmF1bHQge1xuICByYW5kb21VVUlEOiBjcnlwdG8ucmFuZG9tVVVJRFxufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyw4RUFBOEUiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tbm9kZVxccmVnZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS04XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDB8ZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmKSQvaTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDZTtBQUNmO0FBQ0EsSUFBSSxpRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tbm9kZVxccm5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuY29uc3Qgcm5kczhQb29sID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTsgLy8gIyBvZiByYW5kb20gdmFsdWVzIHRvIHByZS1hbGxvY2F0ZVxubGV0IHBvb2xQdHIgPSBybmRzOFBvb2wubGVuZ3RoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICBpZiAocG9vbFB0ciA+IHJuZHM4UG9vbC5sZW5ndGggLSAxNikge1xuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhybmRzOFBvb2wpO1xuICAgIHBvb2xQdHIgPSAwO1xuICB9XG4gIHJldHVybiBybmRzOFBvb2wuc2xpY2UocG9vbFB0ciwgcG9vbFB0ciArPSAxNik7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXHN0cmluZ2lmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgLy9cbiAgLy8gTm90ZSB0byBmdXR1cmUtc2VsZjogTm8sIHlvdSBjYW4ndCByZW1vdmUgdGhlIGB0b0xvd2VyQ2FzZSgpYCBjYWxsLlxuICAvLyBSRUY6IGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzY3NyNpc3N1ZWNvbW1lbnQtMTc1NzM1MTM1MVxuICByZXR1cm4gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTtcbiAgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuICByZXR1cm4gdXVpZDtcbn1cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pEO0FBQ0EsTUFBTSxrREFBTTtBQUNaLFdBQVcsa0RBQU07QUFDakI7QUFDQTtBQUNBLGlEQUFpRCwrQ0FBRzs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tbm9kZVxcdjQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5hdGl2ZSBmcm9tICcuL25hdGl2ZS5qcyc7XG5pbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmIChuYXRpdmUucmFuZG9tVVVJRCAmJiAhYnVmICYmICFvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5hdGl2ZS5yYW5kb21VVUlEKCk7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KHJuZHMpO1xufVxuZXhwb3J0IGRlZmF1bHQgdjQ7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsaURBQUs7QUFDMUM7QUFDQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXHZhbGlkYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/runnables.js":
/*!***************************************************!*\
  !*** ./node_modules/@langchain/core/runnables.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RouterRunnable: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RouterRunnable),
/* harmony export */   Runnable: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.Runnable),
/* harmony export */   RunnableAssign: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableAssign),
/* harmony export */   RunnableBinding: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableBinding),
/* harmony export */   RunnableBranch: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableBranch),
/* harmony export */   RunnableEach: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableEach),
/* harmony export */   RunnableLambda: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableLambda),
/* harmony export */   RunnableMap: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableMap),
/* harmony export */   RunnableParallel: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableParallel),
/* harmony export */   RunnablePassthrough: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnablePassthrough),
/* harmony export */   RunnablePick: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnablePick),
/* harmony export */   RunnableRetry: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableRetry),
/* harmony export */   RunnableSequence: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableSequence),
/* harmony export */   RunnableToolLike: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableToolLike),
/* harmony export */   RunnableWithFallbacks: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableWithFallbacks),
/* harmony export */   RunnableWithMessageHistory: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.RunnableWithMessageHistory),
/* harmony export */   _coerceToRunnable: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable),
/* harmony export */   ensureConfig: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.ensureConfig),
/* harmony export */   getCallbackManagerForConfig: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.getCallbackManagerForConfig),
/* harmony export */   mergeConfigs: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs),
/* harmony export */   patchConfig: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.patchConfig),
/* harmony export */   pickRunnableConfigKeys: () => (/* reexport safe */ _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__.pickRunnableConfigKeys)
/* harmony export */ });
/* harmony import */ var _dist_runnables_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/runnables/index.js */ "(rsc)/./node_modules/@langchain/core/dist/runnables/index.js");


/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/runnables/graph.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/runnables/graph.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Graph: () => (/* reexport safe */ _dist_runnables_graph_js__WEBPACK_IMPORTED_MODULE_0__.Graph)
/* harmony export */ });
/* harmony import */ var _dist_runnables_graph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/runnables/graph.js */ "(rsc)/./node_modules/@langchain/core/dist/runnables/graph.js");


/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/singletons.js":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/core/singletons.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _dist_singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),
/* harmony export */   MockAsyncLocalStorage: () => (/* reexport safe */ _dist_singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.MockAsyncLocalStorage),
/* harmony export */   _CONTEXT_VARIABLES_KEY: () => (/* reexport safe */ _dist_singletons_index_js__WEBPACK_IMPORTED_MODULE_0__._CONTEXT_VARIABLES_KEY)
/* harmony export */ });
/* harmony import */ var _dist_singletons_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/singletons/index.js */ "(rsc)/./node_modules/@langchain/core/dist/singletons/index.js");


/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/stream.js":
/*!******************************************************!*\
  !*** ./node_modules/@langchain/core/utils/stream.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncGeneratorWithSetup: () => (/* reexport safe */ _dist_utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.AsyncGeneratorWithSetup),
/* harmony export */   IterableReadableStream: () => (/* reexport safe */ _dist_utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.IterableReadableStream),
/* harmony export */   atee: () => (/* reexport safe */ _dist_utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.atee),
/* harmony export */   concat: () => (/* reexport safe */ _dist_utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.concat),
/* harmony export */   pipeGeneratorWithSetup: () => (/* reexport safe */ _dist_utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.pipeGeneratorWithSetup)
/* harmony export */ });
/* harmony import */ var _dist_utils_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/utils/stream.js */ "(rsc)/./node_modules/@langchain/core/dist/utils/stream.js");


/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/base.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/base.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCheckpointSaver: () => (/* binding */ BaseCheckpointSaver),\n/* harmony export */   WRITES_IDX_MAP: () => (/* binding */ WRITES_IDX_MAP),\n/* harmony export */   compareChannelVersions: () => (/* binding */ compareChannelVersions),\n/* harmony export */   copyCheckpoint: () => (/* binding */ copyCheckpoint),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   emptyCheckpoint: () => (/* binding */ emptyCheckpoint),\n/* harmony export */   getCheckpointId: () => (/* binding */ getCheckpointId),\n/* harmony export */   maxChannelVersion: () => (/* binding */ maxChannelVersion)\n/* harmony export */ });\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/id.js\");\n/* harmony import */ var _serde_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serde/types.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/types.js\");\n/* harmony import */ var _serde_jsonplus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serde/jsonplus.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/jsonplus.js\");\n\n\n\nfunction deepCopy(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return obj;\n    }\n    const newObj = Array.isArray(obj) ? [] : {};\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            newObj[key] = deepCopy(obj[key]);\n        }\n    }\n    return newObj;\n}\n/** @hidden */\nfunction emptyCheckpoint() {\n    return {\n        v: 1,\n        id: (0,_id_js__WEBPACK_IMPORTED_MODULE_0__.uuid6)(-2),\n        ts: new Date().toISOString(),\n        channel_values: {},\n        channel_versions: {},\n        versions_seen: {},\n        pending_sends: [],\n    };\n}\n/** @hidden */\nfunction copyCheckpoint(checkpoint) {\n    return {\n        v: checkpoint.v,\n        id: checkpoint.id,\n        ts: checkpoint.ts,\n        channel_values: { ...checkpoint.channel_values },\n        channel_versions: { ...checkpoint.channel_versions },\n        versions_seen: deepCopy(checkpoint.versions_seen),\n        pending_sends: [...checkpoint.pending_sends],\n    };\n}\nclass BaseCheckpointSaver {\n    constructor(serde) {\n        Object.defineProperty(this, \"serde\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new _serde_jsonplus_js__WEBPACK_IMPORTED_MODULE_2__.JsonPlusSerializer()\n        });\n        this.serde = serde || this.serde;\n    }\n    async get(config) {\n        const value = await this.getTuple(config);\n        return value ? value.checkpoint : undefined;\n    }\n    /**\n     * Generate the next version ID for a channel.\n     *\n     * Default is to use integer versions, incrementing by 1. If you override, you can use str/int/float versions,\n     * as long as they are monotonically increasing.\n     */\n    getNextVersion(current, _channel) {\n        if (typeof current === \"string\") {\n            throw new Error(\"Please override this method to use string versions.\");\n        }\n        return (current !== undefined && typeof current === \"number\" ? current + 1 : 1);\n    }\n}\nfunction compareChannelVersions(a, b) {\n    if (typeof a === \"number\" && typeof b === \"number\") {\n        return Math.sign(a - b);\n    }\n    return String(a).localeCompare(String(b));\n}\nfunction maxChannelVersion(...versions) {\n    return versions.reduce((max, version, idx) => {\n        if (idx === 0)\n            return version;\n        return compareChannelVersions(max, version) >= 0 ? max : version;\n    });\n}\n/**\n * Mapping from error type to error index.\n * Regular writes just map to their index in the list of writes being saved.\n * Special writes (e.g. errors) map to negative indices, to avoid those writes from\n * conflicting with regular writes.\n * Each Checkpointer implementation should use this mapping in put_writes.\n */\nconst WRITES_IDX_MAP = {\n    [_serde_types_js__WEBPACK_IMPORTED_MODULE_1__.ERROR]: -1,\n    [_serde_types_js__WEBPACK_IMPORTED_MODULE_1__.SCHEDULED]: -2,\n    [_serde_types_js__WEBPACK_IMPORTED_MODULE_1__.INTERRUPT]: -3,\n    [_serde_types_js__WEBPACK_IMPORTED_MODULE_1__.RESUME]: -4,\n};\nfunction getCheckpointId(config) {\n    return (config.configurable?.checkpoint_id || config.configurable?.thread_ts || \"\");\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDd0M7QUFDZjtBQUNsRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFlBQVksNkNBQUs7QUFDakI7QUFDQSwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hELDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQWtCO0FBQ3pDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsS0FBSyxrREFBSztBQUNWLEtBQUssc0RBQVM7QUFDZCxLQUFLLHNEQUFTO0FBQ2QsS0FBSyxtREFBTTtBQUNYO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoLWNoZWNrcG9pbnRcXGRpc3RcXGJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXVpZDYgfSBmcm9tIFwiLi9pZC5qc1wiO1xuaW1wb3J0IHsgRVJST1IsIElOVEVSUlVQVCwgUkVTVU1FLCBTQ0hFRFVMRUQsIH0gZnJvbSBcIi4vc2VyZGUvdHlwZXMuanNcIjtcbmltcG9ydCB7IEpzb25QbHVzU2VyaWFsaXplciB9IGZyb20gXCIuL3NlcmRlL2pzb25wbHVzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVlcENvcHkob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGNvbnN0IG5ld09iaiA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IGRlZXBDb3B5KG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqO1xufVxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eUNoZWNrcG9pbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdjogMSxcbiAgICAgICAgaWQ6IHV1aWQ2KC0yKSxcbiAgICAgICAgdHM6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgY2hhbm5lbF92YWx1ZXM6IHt9LFxuICAgICAgICBjaGFubmVsX3ZlcnNpb25zOiB7fSxcbiAgICAgICAgdmVyc2lvbnNfc2Vlbjoge30sXG4gICAgICAgIHBlbmRpbmdfc2VuZHM6IFtdLFxuICAgIH07XG59XG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlDaGVja3BvaW50KGNoZWNrcG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2OiBjaGVja3BvaW50LnYsXG4gICAgICAgIGlkOiBjaGVja3BvaW50LmlkLFxuICAgICAgICB0czogY2hlY2twb2ludC50cyxcbiAgICAgICAgY2hhbm5lbF92YWx1ZXM6IHsgLi4uY2hlY2twb2ludC5jaGFubmVsX3ZhbHVlcyB9LFxuICAgICAgICBjaGFubmVsX3ZlcnNpb25zOiB7IC4uLmNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucyB9LFxuICAgICAgICB2ZXJzaW9uc19zZWVuOiBkZWVwQ29weShjaGVja3BvaW50LnZlcnNpb25zX3NlZW4pLFxuICAgICAgICBwZW5kaW5nX3NlbmRzOiBbLi4uY2hlY2twb2ludC5wZW5kaW5nX3NlbmRzXSxcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIEJhc2VDaGVja3BvaW50U2F2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcmRlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcmRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgSnNvblBsdXNTZXJpYWxpemVyKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VyZGUgPSBzZXJkZSB8fCB0aGlzLnNlcmRlO1xuICAgIH1cbiAgICBhc3luYyBnZXQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5nZXRUdXBsZShjb25maWcpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5jaGVja3BvaW50IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgbmV4dCB2ZXJzaW9uIElEIGZvciBhIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IGlzIHRvIHVzZSBpbnRlZ2VyIHZlcnNpb25zLCBpbmNyZW1lbnRpbmcgYnkgMS4gSWYgeW91IG92ZXJyaWRlLCB5b3UgY2FuIHVzZSBzdHIvaW50L2Zsb2F0IHZlcnNpb25zLFxuICAgICAqIGFzIGxvbmcgYXMgdGhleSBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuICAgICAqL1xuICAgIGdldE5leHRWZXJzaW9uKGN1cnJlbnQsIF9jaGFubmVsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHVzZSBzdHJpbmcgdmVyc2lvbnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3VycmVudCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBjdXJyZW50ID09PSBcIm51bWJlclwiID8gY3VycmVudCArIDEgOiAxKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUNoYW5uZWxWZXJzaW9ucyhhLCBiKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBiID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24oYSAtIGIpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXhDaGFubmVsVmVyc2lvbiguLi52ZXJzaW9ucykge1xuICAgIHJldHVybiB2ZXJzaW9ucy5yZWR1Y2UoKG1heCwgdmVyc2lvbiwgaWR4KSA9PiB7XG4gICAgICAgIGlmIChpZHggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVDaGFubmVsVmVyc2lvbnMobWF4LCB2ZXJzaW9uKSA+PSAwID8gbWF4IDogdmVyc2lvbjtcbiAgICB9KTtcbn1cbi8qKlxuICogTWFwcGluZyBmcm9tIGVycm9yIHR5cGUgdG8gZXJyb3IgaW5kZXguXG4gKiBSZWd1bGFyIHdyaXRlcyBqdXN0IG1hcCB0byB0aGVpciBpbmRleCBpbiB0aGUgbGlzdCBvZiB3cml0ZXMgYmVpbmcgc2F2ZWQuXG4gKiBTcGVjaWFsIHdyaXRlcyAoZS5nLiBlcnJvcnMpIG1hcCB0byBuZWdhdGl2ZSBpbmRpY2VzLCB0byBhdm9pZCB0aG9zZSB3cml0ZXMgZnJvbVxuICogY29uZmxpY3Rpbmcgd2l0aCByZWd1bGFyIHdyaXRlcy5cbiAqIEVhY2ggQ2hlY2twb2ludGVyIGltcGxlbWVudGF0aW9uIHNob3VsZCB1c2UgdGhpcyBtYXBwaW5nIGluIHB1dF93cml0ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBXUklURVNfSURYX01BUCA9IHtcbiAgICBbRVJST1JdOiAtMSxcbiAgICBbU0NIRURVTEVEXTogLTIsXG4gICAgW0lOVEVSUlVQVF06IC0zLFxuICAgIFtSRVNVTUVdOiAtNCxcbn07XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hlY2twb2ludElkKGNvbmZpZykge1xuICAgIHJldHVybiAoY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9pZCB8fCBjb25maWcuY29uZmlndXJhYmxlPy50aHJlYWRfdHMgfHwgXCJcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/cache/base.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/cache/base.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCache: () => (/* binding */ BaseCache)\n/* harmony export */ });\n/* harmony import */ var _serde_jsonplus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../serde/jsonplus.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/jsonplus.js\");\n\nclass BaseCache {\n    /**\n     * Initialize the cache with a serializer.\n     *\n     * @param serde - The serializer to use.\n     */\n    constructor(serde) {\n        Object.defineProperty(this, \"serde\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new _serde_jsonplus_js__WEBPACK_IMPORTED_MODULE_0__.JsonPlusSerializer()\n        });\n        this.serde = serde || this.serde;\n    }\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L2NhY2hlL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEQ7QUFDbkQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrRUFBa0I7QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxkaXN0XFxjYWNoZVxcYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBKc29uUGx1c1NlcmlhbGl6ZXIgfSBmcm9tIFwiLi4vc2VyZGUvanNvbnBsdXMuanNcIjtcbmV4cG9ydCBjbGFzcyBCYXNlQ2FjaGUge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIGNhY2hlIHdpdGggYSBzZXJpYWxpemVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlcmRlIC0gVGhlIHNlcmlhbGl6ZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlcmRlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcmRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgSnNvblBsdXNTZXJpYWxpemVyKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VyZGUgPSBzZXJkZSB8fCB0aGlzLnNlcmRlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/cache/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/cache/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/cache/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCache: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCache),\n/* harmony export */   InMemoryCache: () => (/* reexport safe */ _memory_js__WEBPACK_IMPORTED_MODULE_1__.InMemoryCache)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/cache/base.js\");\n/* harmony import */ var _memory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./memory.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/cache/memory.js\");\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L2NhY2hlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEI7QUFDRTtBQUM1QiIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGgtY2hlY2twb2ludFxcZGlzdFxcY2FjaGVcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2Jhc2UuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21lbW9yeS5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/cache/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/cache/memory.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/cache/memory.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InMemoryCache: () => (/* binding */ InMemoryCache)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/cache/base.js\");\n\nclass InMemoryCache extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCache {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n    }\n    async get(keys) {\n        if (!keys.length)\n            return [];\n        const now = Date.now();\n        return (await Promise.all(keys.map(async (fullKey) => {\n            const [namespace, key] = fullKey;\n            const strNamespace = namespace.join(\",\");\n            if (strNamespace in this.cache && key in this.cache[strNamespace]) {\n                const cached = this.cache[strNamespace][key];\n                if (cached.exp == null || now < cached.exp) {\n                    const value = await this.serde.loadsTyped(cached.enc, cached.val);\n                    return [{ key: fullKey, value }];\n                }\n                else {\n                    delete this.cache[strNamespace][key];\n                }\n            }\n            return [];\n        }))).flat();\n    }\n    async set(pairs) {\n        const now = Date.now();\n        for (const { key: fullKey, value, ttl } of pairs) {\n            const [namespace, key] = fullKey;\n            const strNamespace = namespace.join(\",\");\n            const [enc, val] = await this.serde.dumpsTyped(value);\n            const exp = ttl != null ? ttl * 1000 + now : null;\n            this.cache[strNamespace] ??= {};\n            this.cache[strNamespace][key] = { enc, val, exp };\n        }\n    }\n    async clear(namespaces) {\n        if (!namespaces.length) {\n            this.cache = {};\n            return;\n        }\n        for (const namespace of namespaces) {\n            const strNamespace = namespace.join(\",\");\n            if (strNamespace in this.cache)\n                delete this.cache[strNamespace];\n        }\n    }\n}\n//# sourceMappingURL=memory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L2NhY2hlL21lbW9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzQztBQUMvQiw0QkFBNEIsK0NBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGgtY2hlY2twb2ludFxcZGlzdFxcY2FjaGVcXG1lbW9yeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ2FjaGUgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgY2xhc3MgSW5NZW1vcnlDYWNoZSBleHRlbmRzIEJhc2VDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhY2hlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KGtleXMpIHtcbiAgICAgICAgaWYgKCFrZXlzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcChhc3luYyAoZnVsbEtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW25hbWVzcGFjZSwga2V5XSA9IGZ1bGxLZXk7XG4gICAgICAgICAgICBjb25zdCBzdHJOYW1lc3BhY2UgPSBuYW1lc3BhY2Uuam9pbihcIixcIik7XG4gICAgICAgICAgICBpZiAoc3RyTmFtZXNwYWNlIGluIHRoaXMuY2FjaGUgJiYga2V5IGluIHRoaXMuY2FjaGVbc3RyTmFtZXNwYWNlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuY2FjaGVbc3RyTmFtZXNwYWNlXVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQuZXhwID09IG51bGwgfHwgbm93IDwgY2FjaGVkLmV4cCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuc2VyZGUubG9hZHNUeXBlZChjYWNoZWQuZW5jLCBjYWNoZWQudmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt7IGtleTogZnVsbEtleSwgdmFsdWUgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZVtzdHJOYW1lc3BhY2VdW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KSkpLmZsYXQoKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0KHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGZvciAoY29uc3QgeyBrZXk6IGZ1bGxLZXksIHZhbHVlLCB0dGwgfSBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgW25hbWVzcGFjZSwga2V5XSA9IGZ1bGxLZXk7XG4gICAgICAgICAgICBjb25zdCBzdHJOYW1lc3BhY2UgPSBuYW1lc3BhY2Uuam9pbihcIixcIik7XG4gICAgICAgICAgICBjb25zdCBbZW5jLCB2YWxdID0gYXdhaXQgdGhpcy5zZXJkZS5kdW1wc1R5cGVkKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cCA9IHR0bCAhPSBudWxsID8gdHRsICogMTAwMCArIG5vdyA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNhY2hlW3N0ck5hbWVzcGFjZV0gPz89IHt9O1xuICAgICAgICAgICAgdGhpcy5jYWNoZVtzdHJOYW1lc3BhY2VdW2tleV0gPSB7IGVuYywgdmFsLCBleHAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbGVhcihuYW1lc3BhY2VzKSB7XG4gICAgICAgIGlmICghbmFtZXNwYWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWVzcGFjZSBvZiBuYW1lc3BhY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJOYW1lc3BhY2UgPSBuYW1lc3BhY2Uuam9pbihcIixcIik7XG4gICAgICAgICAgICBpZiAoc3RyTmFtZXNwYWNlIGluIHRoaXMuY2FjaGUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVbc3RyTmFtZXNwYWNlXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9yeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/cache/memory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/id.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/id.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uuid5: () => (/* binding */ uuid5),\n/* harmony export */   uuid6: () => (/* binding */ uuid6)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v6.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v5.js\");\n\nfunction uuid6(clockseq) {\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({ clockseq });\n}\n// Skip UUID validation check, since UUID6s\n// generated with negative clockseq are not\n// technically compliant, but still work.\n// See: https://github.com/uuidjs/uuid/issues/511\nfunction uuid5(name, namespace) {\n    const namespaceBytes = namespace\n        .replace(/-/g, \"\")\n        .match(/.{2}/g)\n        .map((byte) => parseInt(byte, 16));\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(name, new Uint8Array(namespaceBytes));\n}\n//# sourceMappingURL=id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L2lkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBOEI7QUFDdkI7QUFDUCxXQUFXLGdEQUFFLEdBQUcsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQSxXQUFXLGdEQUFFO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGgtY2hlY2twb2ludFxcZGlzdFxcaWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdjUsIHY2IH0gZnJvbSBcInV1aWRcIjtcbmV4cG9ydCBmdW5jdGlvbiB1dWlkNihjbG9ja3NlcSkge1xuICAgIHJldHVybiB2Nih7IGNsb2Nrc2VxIH0pO1xufVxuLy8gU2tpcCBVVUlEIHZhbGlkYXRpb24gY2hlY2ssIHNpbmNlIFVVSUQ2c1xuLy8gZ2VuZXJhdGVkIHdpdGggbmVnYXRpdmUgY2xvY2tzZXEgYXJlIG5vdFxuLy8gdGVjaG5pY2FsbHkgY29tcGxpYW50LCBidXQgc3RpbGwgd29yay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL2lzc3Vlcy81MTFcbmV4cG9ydCBmdW5jdGlvbiB1dWlkNShuYW1lLCBuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBuYW1lc3BhY2VCeXRlcyA9IG5hbWVzcGFjZVxuICAgICAgICAucmVwbGFjZSgvLS9nLCBcIlwiKVxuICAgICAgICAubWF0Y2goLy57Mn0vZylcbiAgICAgICAgLm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKTtcbiAgICByZXR1cm4gdjUobmFtZSwgbmV3IFVpbnQ4QXJyYXkobmFtZXNwYWNlQnl0ZXMpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/id.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncBatchedStore: () => (/* reexport safe */ _store_index_js__WEBPACK_IMPORTED_MODULE_6__.AsyncBatchedStore),\n/* harmony export */   BaseCache: () => (/* reexport safe */ _cache_index_js__WEBPACK_IMPORTED_MODULE_7__.BaseCache),\n/* harmony export */   BaseCheckpointSaver: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseCheckpointSaver),\n/* harmony export */   BaseStore: () => (/* reexport safe */ _store_index_js__WEBPACK_IMPORTED_MODULE_6__.BaseStore),\n/* harmony export */   ERROR: () => (/* reexport safe */ _serde_types_js__WEBPACK_IMPORTED_MODULE_5__.ERROR),\n/* harmony export */   INTERRUPT: () => (/* reexport safe */ _serde_types_js__WEBPACK_IMPORTED_MODULE_5__.INTERRUPT),\n/* harmony export */   InMemoryCache: () => (/* reexport safe */ _cache_index_js__WEBPACK_IMPORTED_MODULE_7__.InMemoryCache),\n/* harmony export */   InMemoryStore: () => (/* reexport safe */ _store_index_js__WEBPACK_IMPORTED_MODULE_6__.InMemoryStore),\n/* harmony export */   InvalidNamespaceError: () => (/* reexport safe */ _store_index_js__WEBPACK_IMPORTED_MODULE_6__.InvalidNamespaceError),\n/* harmony export */   MemorySaver: () => (/* reexport safe */ _memory_js__WEBPACK_IMPORTED_MODULE_0__.MemorySaver),\n/* harmony export */   MemoryStore: () => (/* reexport safe */ _store_index_js__WEBPACK_IMPORTED_MODULE_6__.MemoryStore),\n/* harmony export */   RESUME: () => (/* reexport safe */ _serde_types_js__WEBPACK_IMPORTED_MODULE_5__.RESUME),\n/* harmony export */   SCHEDULED: () => (/* reexport safe */ _serde_types_js__WEBPACK_IMPORTED_MODULE_5__.SCHEDULED),\n/* harmony export */   TASKS: () => (/* reexport safe */ _serde_types_js__WEBPACK_IMPORTED_MODULE_5__.TASKS),\n/* harmony export */   WRITES_IDX_MAP: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.WRITES_IDX_MAP),\n/* harmony export */   compareChannelVersions: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.compareChannelVersions),\n/* harmony export */   copyCheckpoint: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.copyCheckpoint),\n/* harmony export */   deepCopy: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.deepCopy),\n/* harmony export */   emptyCheckpoint: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.emptyCheckpoint),\n/* harmony export */   getCheckpointId: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.getCheckpointId),\n/* harmony export */   getTextAtPath: () => (/* reexport safe */ _store_index_js__WEBPACK_IMPORTED_MODULE_6__.getTextAtPath),\n/* harmony export */   maxChannelVersion: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.maxChannelVersion),\n/* harmony export */   tokenizePath: () => (/* reexport safe */ _store_index_js__WEBPACK_IMPORTED_MODULE_6__.tokenizePath),\n/* harmony export */   uuid5: () => (/* reexport safe */ _id_js__WEBPACK_IMPORTED_MODULE_2__.uuid5),\n/* harmony export */   uuid6: () => (/* reexport safe */ _id_js__WEBPACK_IMPORTED_MODULE_2__.uuid6)\n/* harmony export */ });\n/* harmony import */ var _memory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memory.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/memory.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/base.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./id.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/id.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/types.js\");\n/* harmony import */ var _serde_base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./serde/base.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/base.js\");\n/* harmony import */ var _serde_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./serde/types.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/types.js\");\n/* harmony import */ var _store_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./store/index.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/index.js\");\n/* harmony import */ var _cache_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cache/index.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/cache/index.js\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNoQjtBQUNGO0FBQ0c7QUFDSztBQUNDO0FBQ0E7QUFDQTtBQUNqQyIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGgtY2hlY2twb2ludFxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgTWVtb3J5U2F2ZXIgfSBmcm9tIFwiLi9tZW1vcnkuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Jhc2UuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2lkLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90eXBlcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2VyZGUvYmFzZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2VyZGUvdHlwZXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N0b3JlL2luZGV4LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jYWNoZS9pbmRleC5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/memory.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/memory.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MemorySaver: () => (/* binding */ MemorySaver)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/base.js\");\n/* harmony import */ var _serde_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serde/types.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/types.js\");\n\n\nfunction _generateKey(threadId, checkpointNamespace, checkpointId) {\n    return JSON.stringify([threadId, checkpointNamespace, checkpointId]);\n}\nclass MemorySaver extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCheckpointSaver {\n    constructor(serde) {\n        super(serde);\n        // thread ID ->  checkpoint namespace -> checkpoint ID -> checkpoint mapping\n        Object.defineProperty(this, \"storage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"writes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n    }\n    async _getPendingSends(threadId, checkpointNs, parentCheckpointId) {\n        let pendingSends = [];\n        if (parentCheckpointId !== undefined) {\n            const key = _generateKey(threadId, checkpointNs, parentCheckpointId);\n            pendingSends = await Promise.all(Object.values(this.writes[key] || {})\n                ?.filter(([_taskId, channel]) => {\n                return channel === _serde_types_js__WEBPACK_IMPORTED_MODULE_1__.TASKS;\n            })\n                .map(([_taskId, _channel, writes]) => {\n                return this.serde.loadsTyped(\"json\", writes);\n            }) ?? []);\n        }\n        return pendingSends;\n    }\n    async getTuple(config) {\n        const thread_id = config.configurable?.thread_id;\n        const checkpoint_ns = config.configurable?.checkpoint_ns ?? \"\";\n        let checkpoint_id = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.getCheckpointId)(config);\n        if (checkpoint_id) {\n            const saved = this.storage[thread_id]?.[checkpoint_ns]?.[checkpoint_id];\n            if (saved !== undefined) {\n                const [checkpoint, metadata, parentCheckpointId] = saved;\n                const key = _generateKey(thread_id, checkpoint_ns, checkpoint_id);\n                const pending_sends = await this._getPendingSends(thread_id, checkpoint_ns, parentCheckpointId);\n                const deserializedCheckpoint = {\n                    ...(await this.serde.loadsTyped(\"json\", checkpoint)),\n                    pending_sends,\n                };\n                const pendingWrites = await Promise.all(Object.values(this.writes[key] || {}).map(async ([taskId, channel, value]) => {\n                    return [\n                        taskId,\n                        channel,\n                        await this.serde.loadsTyped(\"json\", value),\n                    ];\n                }));\n                const checkpointTuple = {\n                    config,\n                    checkpoint: deserializedCheckpoint,\n                    metadata: (await this.serde.loadsTyped(\"json\", metadata)),\n                    pendingWrites,\n                };\n                if (parentCheckpointId !== undefined) {\n                    checkpointTuple.parentConfig = {\n                        configurable: {\n                            thread_id,\n                            checkpoint_ns,\n                            checkpoint_id: parentCheckpointId,\n                        },\n                    };\n                }\n                return checkpointTuple;\n            }\n        }\n        else {\n            const checkpoints = this.storage[thread_id]?.[checkpoint_ns];\n            if (checkpoints !== undefined) {\n                // eslint-disable-next-line prefer-destructuring\n                checkpoint_id = Object.keys(checkpoints).sort((a, b) => b.localeCompare(a))[0];\n                const saved = checkpoints[checkpoint_id];\n                const [checkpoint, metadata, parentCheckpointId] = saved;\n                const key = _generateKey(thread_id, checkpoint_ns, checkpoint_id);\n                const pending_sends = await this._getPendingSends(thread_id, checkpoint_ns, parentCheckpointId);\n                const deserializedCheckpoint = {\n                    ...(await this.serde.loadsTyped(\"json\", checkpoint)),\n                    pending_sends,\n                };\n                const pendingWrites = await Promise.all(Object.values(this.writes[key] || {}).map(async ([taskId, channel, value]) => {\n                    return [\n                        taskId,\n                        channel,\n                        await this.serde.loadsTyped(\"json\", value),\n                    ];\n                }));\n                const checkpointTuple = {\n                    config: {\n                        configurable: {\n                            thread_id,\n                            checkpoint_id,\n                            checkpoint_ns,\n                        },\n                    },\n                    checkpoint: deserializedCheckpoint,\n                    metadata: (await this.serde.loadsTyped(\"json\", metadata)),\n                    pendingWrites,\n                };\n                if (parentCheckpointId !== undefined) {\n                    checkpointTuple.parentConfig = {\n                        configurable: {\n                            thread_id,\n                            checkpoint_ns,\n                            checkpoint_id: parentCheckpointId,\n                        },\n                    };\n                }\n                return checkpointTuple;\n            }\n        }\n        return undefined;\n    }\n    async *list(config, options) {\n        // eslint-disable-next-line prefer-const\n        let { before, limit, filter } = options ?? {};\n        const threadIds = config.configurable?.thread_id\n            ? [config.configurable?.thread_id]\n            : Object.keys(this.storage);\n        const configCheckpointNamespace = config.configurable?.checkpoint_ns;\n        const configCheckpointId = config.configurable?.checkpoint_id;\n        for (const threadId of threadIds) {\n            for (const checkpointNamespace of Object.keys(this.storage[threadId] ?? {})) {\n                if (configCheckpointNamespace !== undefined &&\n                    checkpointNamespace !== configCheckpointNamespace) {\n                    continue;\n                }\n                const checkpoints = this.storage[threadId]?.[checkpointNamespace] ?? {};\n                const sortedCheckpoints = Object.entries(checkpoints).sort((a, b) => b[0].localeCompare(a[0]));\n                for (const [checkpointId, [checkpoint, metadataStr, parentCheckpointId],] of sortedCheckpoints) {\n                    // Filter by checkpoint ID from config\n                    if (configCheckpointId && checkpointId !== configCheckpointId) {\n                        continue;\n                    }\n                    // Filter by checkpoint ID from before config\n                    if (before &&\n                        before.configurable?.checkpoint_id &&\n                        checkpointId >= before.configurable.checkpoint_id) {\n                        continue;\n                    }\n                    // Parse metadata\n                    const metadata = (await this.serde.loadsTyped(\"json\", metadataStr));\n                    if (filter &&\n                        !Object.entries(filter).every(([key, value]) => metadata[key] === value)) {\n                        continue;\n                    }\n                    // Limit search results\n                    if (limit !== undefined) {\n                        if (limit <= 0)\n                            break;\n                        limit -= 1;\n                    }\n                    const key = _generateKey(threadId, checkpointNamespace, checkpointId);\n                    const writes = Object.values(this.writes[key] || {});\n                    const pending_sends = await this._getPendingSends(threadId, checkpointNamespace, parentCheckpointId);\n                    const pendingWrites = await Promise.all(writes.map(async ([taskId, channel, value]) => {\n                        return [\n                            taskId,\n                            channel,\n                            await this.serde.loadsTyped(\"json\", value),\n                        ];\n                    }));\n                    const deserializedCheckpoint = {\n                        ...(await this.serde.loadsTyped(\"json\", checkpoint)),\n                        pending_sends,\n                    };\n                    const checkpointTuple = {\n                        config: {\n                            configurable: {\n                                thread_id: threadId,\n                                checkpoint_ns: checkpointNamespace,\n                                checkpoint_id: checkpointId,\n                            },\n                        },\n                        checkpoint: deserializedCheckpoint,\n                        metadata,\n                        pendingWrites,\n                    };\n                    if (parentCheckpointId !== undefined) {\n                        checkpointTuple.parentConfig = {\n                            configurable: {\n                                thread_id: threadId,\n                                checkpoint_ns: checkpointNamespace,\n                                checkpoint_id: parentCheckpointId,\n                            },\n                        };\n                    }\n                    yield checkpointTuple;\n                }\n            }\n        }\n    }\n    async put(config, checkpoint, metadata) {\n        const preparedCheckpoint = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.copyCheckpoint)(checkpoint);\n        delete preparedCheckpoint.pending_sends;\n        const threadId = config.configurable?.thread_id;\n        const checkpointNamespace = config.configurable?.checkpoint_ns ?? \"\";\n        if (threadId === undefined) {\n            throw new Error(`Failed to put checkpoint. The passed RunnableConfig is missing a required \"thread_id\" field in its \"configurable\" property.`);\n        }\n        if (!this.storage[threadId]) {\n            this.storage[threadId] = {};\n        }\n        if (!this.storage[threadId][checkpointNamespace]) {\n            this.storage[threadId][checkpointNamespace] = {};\n        }\n        const [, serializedCheckpoint] = this.serde.dumpsTyped(preparedCheckpoint);\n        const [, serializedMetadata] = this.serde.dumpsTyped(metadata);\n        this.storage[threadId][checkpointNamespace][checkpoint.id] = [\n            serializedCheckpoint,\n            serializedMetadata,\n            config.configurable?.checkpoint_id, // parent\n        ];\n        return {\n            configurable: {\n                thread_id: threadId,\n                checkpoint_ns: checkpointNamespace,\n                checkpoint_id: checkpoint.id,\n            },\n        };\n    }\n    async putWrites(config, writes, taskId) {\n        const threadId = config.configurable?.thread_id;\n        const checkpointNamespace = config.configurable?.checkpoint_ns;\n        const checkpointId = config.configurable?.checkpoint_id;\n        if (threadId === undefined) {\n            throw new Error(`Failed to put writes. The passed RunnableConfig is missing a required \"thread_id\" field in its \"configurable\" property`);\n        }\n        if (checkpointId === undefined) {\n            throw new Error(`Failed to put writes. The passed RunnableConfig is missing a required \"checkpoint_id\" field in its \"configurable\" property.`);\n        }\n        const outerKey = _generateKey(threadId, checkpointNamespace, checkpointId);\n        const outerWrites_ = this.writes[outerKey];\n        if (this.writes[outerKey] === undefined) {\n            this.writes[outerKey] = {};\n        }\n        writes.forEach(([channel, value], idx) => {\n            const [, serializedValue] = this.serde.dumpsTyped(value);\n            const innerKey = [\n                taskId,\n                _base_js__WEBPACK_IMPORTED_MODULE_0__.WRITES_IDX_MAP[channel] || idx,\n            ];\n            const innerKeyStr = `${innerKey[0]},${innerKey[1]}`;\n            if (innerKey[1] >= 0 && outerWrites_ && innerKeyStr in outerWrites_) {\n                return;\n            }\n            this.writes[outerKey][innerKeyStr] = [taskId, channel, serializedValue];\n        });\n    }\n}\n//# sourceMappingURL=memory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L21lbW9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0c7QUFDekQ7QUFDekM7QUFDQTtBQUNBO0FBQ08sMEJBQTBCLHlEQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBLG1DQUFtQyxrREFBSztBQUN4QyxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdEQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQWM7QUFDOUI7QUFDQSxtQ0FBbUMsWUFBWSxHQUFHLFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxkaXN0XFxtZW1vcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNoZWNrcG9pbnRTYXZlciwgY29weUNoZWNrcG9pbnQsIGdldENoZWNrcG9pbnRJZCwgV1JJVEVTX0lEWF9NQVAsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgVEFTS1MgfSBmcm9tIFwiLi9zZXJkZS90eXBlcy5qc1wiO1xuZnVuY3Rpb24gX2dlbmVyYXRlS2V5KHRocmVhZElkLCBjaGVja3BvaW50TmFtZXNwYWNlLCBjaGVja3BvaW50SWQpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoW3RocmVhZElkLCBjaGVja3BvaW50TmFtZXNwYWNlLCBjaGVja3BvaW50SWRdKTtcbn1cbmV4cG9ydCBjbGFzcyBNZW1vcnlTYXZlciBleHRlbmRzIEJhc2VDaGVja3BvaW50U2F2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcmRlKSB7XG4gICAgICAgIHN1cGVyKHNlcmRlKTtcbiAgICAgICAgLy8gdGhyZWFkIElEIC0+ICBjaGVja3BvaW50IG5hbWVzcGFjZSAtPiBjaGVja3BvaW50IElEIC0+IGNoZWNrcG9pbnQgbWFwcGluZ1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid3JpdGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFBlbmRpbmdTZW5kcyh0aHJlYWRJZCwgY2hlY2twb2ludE5zLCBwYXJlbnRDaGVja3BvaW50SWQpIHtcbiAgICAgICAgbGV0IHBlbmRpbmdTZW5kcyA9IFtdO1xuICAgICAgICBpZiAocGFyZW50Q2hlY2twb2ludElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IF9nZW5lcmF0ZUtleSh0aHJlYWRJZCwgY2hlY2twb2ludE5zLCBwYXJlbnRDaGVja3BvaW50SWQpO1xuICAgICAgICAgICAgcGVuZGluZ1NlbmRzID0gYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LnZhbHVlcyh0aGlzLndyaXRlc1trZXldIHx8IHt9KVxuICAgICAgICAgICAgICAgID8uZmlsdGVyKChbX3Rhc2tJZCwgY2hhbm5lbF0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbm5lbCA9PT0gVEFTS1M7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoKFtfdGFza0lkLCBfY2hhbm5lbCwgd3JpdGVzXSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmRlLmxvYWRzVHlwZWQoXCJqc29uXCIsIHdyaXRlcyk7XG4gICAgICAgICAgICB9KSA/PyBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlbmRpbmdTZW5kcztcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHVwbGUoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHRocmVhZF9pZCA9IGNvbmZpZy5jb25maWd1cmFibGU/LnRocmVhZF9pZDtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludF9ucyA9IGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfbnMgPz8gXCJcIjtcbiAgICAgICAgbGV0IGNoZWNrcG9pbnRfaWQgPSBnZXRDaGVja3BvaW50SWQoY29uZmlnKTtcbiAgICAgICAgaWYgKGNoZWNrcG9pbnRfaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhdmVkID0gdGhpcy5zdG9yYWdlW3RocmVhZF9pZF0/LltjaGVja3BvaW50X25zXT8uW2NoZWNrcG9pbnRfaWRdO1xuICAgICAgICAgICAgaWYgKHNhdmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY2hlY2twb2ludCwgbWV0YWRhdGEsIHBhcmVudENoZWNrcG9pbnRJZF0gPSBzYXZlZDtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBfZ2VuZXJhdGVLZXkodGhyZWFkX2lkLCBjaGVja3BvaW50X25zLCBjaGVja3BvaW50X2lkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nX3NlbmRzID0gYXdhaXQgdGhpcy5fZ2V0UGVuZGluZ1NlbmRzKHRocmVhZF9pZCwgY2hlY2twb2ludF9ucywgcGFyZW50Q2hlY2twb2ludElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRDaGVja3BvaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi4oYXdhaXQgdGhpcy5zZXJkZS5sb2Fkc1R5cGVkKFwianNvblwiLCBjaGVja3BvaW50KSksXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdfc2VuZHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nV3JpdGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LnZhbHVlcyh0aGlzLndyaXRlc1trZXldIHx8IHt9KS5tYXAoYXN5bmMgKFt0YXNrSWQsIGNoYW5uZWwsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VyZGUubG9hZHNUeXBlZChcImpzb25cIiwgdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja3BvaW50VHVwbGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludDogZGVzZXJpYWxpemVkQ2hlY2twb2ludCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IChhd2FpdCB0aGlzLnNlcmRlLmxvYWRzVHlwZWQoXCJqc29uXCIsIG1ldGFkYXRhKSksXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdXcml0ZXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Q2hlY2twb2ludElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludFR1cGxlLnBhcmVudENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocmVhZF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IHBhcmVudENoZWNrcG9pbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja3BvaW50VHVwbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjaGVja3BvaW50cyA9IHRoaXMuc3RvcmFnZVt0aHJlYWRfaWRdPy5bY2hlY2twb2ludF9uc107XG4gICAgICAgICAgICBpZiAoY2hlY2twb2ludHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQgPSBPYmplY3Qua2V5cyhjaGVja3BvaW50cykuc29ydCgoYSwgYikgPT4gYi5sb2NhbGVDb21wYXJlKGEpKVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzYXZlZCA9IGNoZWNrcG9pbnRzW2NoZWNrcG9pbnRfaWRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjaGVja3BvaW50LCBtZXRhZGF0YSwgcGFyZW50Q2hlY2twb2ludElkXSA9IHNhdmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IF9nZW5lcmF0ZUtleSh0aHJlYWRfaWQsIGNoZWNrcG9pbnRfbnMsIGNoZWNrcG9pbnRfaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdfc2VuZHMgPSBhd2FpdCB0aGlzLl9nZXRQZW5kaW5nU2VuZHModGhyZWFkX2lkLCBjaGVja3BvaW50X25zLCBwYXJlbnRDaGVja3BvaW50SWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZENoZWNrcG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLihhd2FpdCB0aGlzLnNlcmRlLmxvYWRzVHlwZWQoXCJqc29uXCIsIGNoZWNrcG9pbnQpKSxcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19zZW5kcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdXcml0ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKHRoaXMud3JpdGVzW2tleV0gfHwge30pLm1hcChhc3luYyAoW3Rhc2tJZCwgY2hhbm5lbCwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXJkZS5sb2Fkc1R5cGVkKFwianNvblwiLCB2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrcG9pbnRUdXBsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJlYWRfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludDogZGVzZXJpYWxpemVkQ2hlY2twb2ludCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IChhd2FpdCB0aGlzLnNlcmRlLmxvYWRzVHlwZWQoXCJqc29uXCIsIG1ldGFkYXRhKSksXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdXcml0ZXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Q2hlY2twb2ludElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludFR1cGxlLnBhcmVudENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocmVhZF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IHBhcmVudENoZWNrcG9pbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja3BvaW50VHVwbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3QoY29uZmlnLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgbGV0IHsgYmVmb3JlLCBsaW1pdCwgZmlsdGVyIH0gPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBjb25zdCB0aHJlYWRJZHMgPSBjb25maWcuY29uZmlndXJhYmxlPy50aHJlYWRfaWRcbiAgICAgICAgICAgID8gW2NvbmZpZy5jb25maWd1cmFibGU/LnRocmVhZF9pZF1cbiAgICAgICAgICAgIDogT2JqZWN0LmtleXModGhpcy5zdG9yYWdlKTtcbiAgICAgICAgY29uc3QgY29uZmlnQ2hlY2twb2ludE5hbWVzcGFjZSA9IGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfbnM7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0NoZWNrcG9pbnRJZCA9IGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfaWQ7XG4gICAgICAgIGZvciAoY29uc3QgdGhyZWFkSWQgb2YgdGhyZWFkSWRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoZWNrcG9pbnROYW1lc3BhY2Ugb2YgT2JqZWN0LmtleXModGhpcy5zdG9yYWdlW3RocmVhZElkXSA/PyB7fSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnQ2hlY2twb2ludE5hbWVzcGFjZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnROYW1lc3BhY2UgIT09IGNvbmZpZ0NoZWNrcG9pbnROYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrcG9pbnRzID0gdGhpcy5zdG9yYWdlW3RocmVhZElkXT8uW2NoZWNrcG9pbnROYW1lc3BhY2VdID8/IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZENoZWNrcG9pbnRzID0gT2JqZWN0LmVudHJpZXMoY2hlY2twb2ludHMpLnNvcnQoKGEsIGIpID0+IGJbMF0ubG9jYWxlQ29tcGFyZShhWzBdKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbY2hlY2twb2ludElkLCBbY2hlY2twb2ludCwgbWV0YWRhdGFTdHIsIHBhcmVudENoZWNrcG9pbnRJZF0sXSBvZiBzb3J0ZWRDaGVja3BvaW50cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgYnkgY2hlY2twb2ludCBJRCBmcm9tIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnQ2hlY2twb2ludElkICYmIGNoZWNrcG9pbnRJZCAhPT0gY29uZmlnQ2hlY2twb2ludElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgYnkgY2hlY2twb2ludCBJRCBmcm9tIGJlZm9yZSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9pZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludElkID49IGJlZm9yZS5jb25maWd1cmFibGUuY2hlY2twb2ludF9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSAoYXdhaXQgdGhpcy5zZXJkZS5sb2Fkc1R5cGVkKFwianNvblwiLCBtZXRhZGF0YVN0cikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5ldmVyeSgoW2tleSwgdmFsdWVdKSA9PiBtZXRhZGF0YVtrZXldID09PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIExpbWl0IHNlYXJjaCByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gX2dlbmVyYXRlS2V5KHRocmVhZElkLCBjaGVja3BvaW50TmFtZXNwYWNlLCBjaGVja3BvaW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXMgPSBPYmplY3QudmFsdWVzKHRoaXMud3JpdGVzW2tleV0gfHwge30pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nX3NlbmRzID0gYXdhaXQgdGhpcy5fZ2V0UGVuZGluZ1NlbmRzKHRocmVhZElkLCBjaGVja3BvaW50TmFtZXNwYWNlLCBwYXJlbnRDaGVja3BvaW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nV3JpdGVzID0gYXdhaXQgUHJvbWlzZS5hbGwod3JpdGVzLm1hcChhc3luYyAoW3Rhc2tJZCwgY2hhbm5lbCwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VyZGUubG9hZHNUeXBlZChcImpzb25cIiwgdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRDaGVja3BvaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGF3YWl0IHRoaXMuc2VyZGUubG9hZHNUeXBlZChcImpzb25cIiwgY2hlY2twb2ludCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19zZW5kcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2twb2ludFR1cGxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocmVhZF9pZDogdGhyZWFkSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfbnM6IGNoZWNrcG9pbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IGNoZWNrcG9pbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQ6IGRlc2VyaWFsaXplZENoZWNrcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdXcml0ZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRDaGVja3BvaW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludFR1cGxlLnBhcmVudENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyZWFkX2lkOiB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9uczogY2hlY2twb2ludE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9pZDogcGFyZW50Q2hlY2twb2ludElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGNoZWNrcG9pbnRUdXBsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHV0KGNvbmZpZywgY2hlY2twb2ludCwgbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRDaGVja3BvaW50ID0gY29weUNoZWNrcG9pbnQoY2hlY2twb2ludCk7XG4gICAgICAgIGRlbGV0ZSBwcmVwYXJlZENoZWNrcG9pbnQucGVuZGluZ19zZW5kcztcbiAgICAgICAgY29uc3QgdGhyZWFkSWQgPSBjb25maWcuY29uZmlndXJhYmxlPy50aHJlYWRfaWQ7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnROYW1lc3BhY2UgPSBjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zID8/IFwiXCI7XG4gICAgICAgIGlmICh0aHJlYWRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwdXQgY2hlY2twb2ludC4gVGhlIHBhc3NlZCBSdW5uYWJsZUNvbmZpZyBpcyBtaXNzaW5nIGEgcmVxdWlyZWQgXCJ0aHJlYWRfaWRcIiBmaWVsZCBpbiBpdHMgXCJjb25maWd1cmFibGVcIiBwcm9wZXJ0eS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3RvcmFnZVt0aHJlYWRJZF0pIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZVt0aHJlYWRJZF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3RvcmFnZVt0aHJlYWRJZF1bY2hlY2twb2ludE5hbWVzcGFjZV0pIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZVt0aHJlYWRJZF1bY2hlY2twb2ludE5hbWVzcGFjZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbLCBzZXJpYWxpemVkQ2hlY2twb2ludF0gPSB0aGlzLnNlcmRlLmR1bXBzVHlwZWQocHJlcGFyZWRDaGVja3BvaW50KTtcbiAgICAgICAgY29uc3QgWywgc2VyaWFsaXplZE1ldGFkYXRhXSA9IHRoaXMuc2VyZGUuZHVtcHNUeXBlZChtZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZVt0aHJlYWRJZF1bY2hlY2twb2ludE5hbWVzcGFjZV1bY2hlY2twb2ludC5pZF0gPSBbXG4gICAgICAgICAgICBzZXJpYWxpemVkQ2hlY2twb2ludCxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRNZXRhZGF0YSxcbiAgICAgICAgICAgIGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfaWQsIC8vIHBhcmVudFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB7XG4gICAgICAgICAgICAgICAgdGhyZWFkX2lkOiB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zOiBjaGVja3BvaW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IGNoZWNrcG9pbnQuaWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBwdXRXcml0ZXMoY29uZmlnLCB3cml0ZXMsIHRhc2tJZCkge1xuICAgICAgICBjb25zdCB0aHJlYWRJZCA9IGNvbmZpZy5jb25maWd1cmFibGU/LnRocmVhZF9pZDtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludE5hbWVzcGFjZSA9IGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfbnM7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnRJZCA9IGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfaWQ7XG4gICAgICAgIGlmICh0aHJlYWRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwdXQgd3JpdGVzLiBUaGUgcGFzc2VkIFJ1bm5hYmxlQ29uZmlnIGlzIG1pc3NpbmcgYSByZXF1aXJlZCBcInRocmVhZF9pZFwiIGZpZWxkIGluIGl0cyBcImNvbmZpZ3VyYWJsZVwiIHByb3BlcnR5YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrcG9pbnRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwdXQgd3JpdGVzLiBUaGUgcGFzc2VkIFJ1bm5hYmxlQ29uZmlnIGlzIG1pc3NpbmcgYSByZXF1aXJlZCBcImNoZWNrcG9pbnRfaWRcIiBmaWVsZCBpbiBpdHMgXCJjb25maWd1cmFibGVcIiBwcm9wZXJ0eS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRlcktleSA9IF9nZW5lcmF0ZUtleSh0aHJlYWRJZCwgY2hlY2twb2ludE5hbWVzcGFjZSwgY2hlY2twb2ludElkKTtcbiAgICAgICAgY29uc3Qgb3V0ZXJXcml0ZXNfID0gdGhpcy53cml0ZXNbb3V0ZXJLZXldO1xuICAgICAgICBpZiAodGhpcy53cml0ZXNbb3V0ZXJLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVzW291dGVyS2V5XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlcy5mb3JFYWNoKChbY2hhbm5lbCwgdmFsdWVdLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFssIHNlcmlhbGl6ZWRWYWx1ZV0gPSB0aGlzLnNlcmRlLmR1bXBzVHlwZWQodmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgaW5uZXJLZXkgPSBbXG4gICAgICAgICAgICAgICAgdGFza0lkLFxuICAgICAgICAgICAgICAgIFdSSVRFU19JRFhfTUFQW2NoYW5uZWxdIHx8IGlkeCxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBpbm5lcktleVN0ciA9IGAke2lubmVyS2V5WzBdfSwke2lubmVyS2V5WzFdfWA7XG4gICAgICAgICAgICBpZiAoaW5uZXJLZXlbMV0gPj0gMCAmJiBvdXRlcldyaXRlc18gJiYgaW5uZXJLZXlTdHIgaW4gb3V0ZXJXcml0ZXNfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53cml0ZXNbb3V0ZXJLZXldW2lubmVyS2V5U3RyXSA9IFt0YXNrSWQsIGNoYW5uZWwsIHNlcmlhbGl6ZWRWYWx1ZV07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9yeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/memory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/base.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/serde/base.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L3NlcmRlL2Jhc2UuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoLWNoZWNrcG9pbnRcXGRpc3RcXHNlcmRlXFxiYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/jsonplus.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/serde/jsonplus.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonPlusSerializer: () => (/* binding */ JsonPlusSerializer)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_load__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/load */ \"(rsc)/./node_modules/@langchain/core/load.js\");\n/* harmony import */ var _utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/fast-safe-stringify/index.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/utils/fast-safe-stringify/index.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-instanceof/no-instanceof */\n\n\nfunction isLangChainSerializedObject(value) {\n    return (value !== null &&\n        value.lc === 1 &&\n        value.type === \"constructor\" &&\n        Array.isArray(value.id));\n}\n/**\n * The replacer in stringify does not allow delegation to built-in LangChain\n * serialization methods, and instead immediately calls `.toJSON()` and\n * continues to stringify subfields.\n *\n * We therefore must start from the most nested elements in the input and\n * deserialize upwards rather than top-down.\n */\nasync function _reviver(value) {\n    if (value && typeof value === \"object\") {\n        if (Array.isArray(value)) {\n            const revivedArray = await Promise.all(value.map((item) => _reviver(item)));\n            return revivedArray;\n        }\n        else {\n            const revivedObj = {};\n            for (const [k, v] of Object.entries(value)) {\n                revivedObj[k] = await _reviver(v);\n            }\n            if (revivedObj.lc === 2 && revivedObj.type === \"undefined\") {\n                return undefined;\n            }\n            else if (revivedObj.lc === 2 &&\n                revivedObj.type === \"constructor\" &&\n                Array.isArray(revivedObj.id)) {\n                try {\n                    const constructorName = revivedObj.id[revivedObj.id.length - 1];\n                    let constructor;\n                    switch (constructorName) {\n                        case \"Set\":\n                            constructor = Set;\n                            break;\n                        case \"Map\":\n                            constructor = Map;\n                            break;\n                        case \"RegExp\":\n                            constructor = RegExp;\n                            break;\n                        case \"Error\":\n                            constructor = Error;\n                            break;\n                        default:\n                            return revivedObj;\n                    }\n                    if (revivedObj.method) {\n                        return constructor[revivedObj.method](...(revivedObj.args || []));\n                    }\n                    else {\n                        return new constructor(...(revivedObj.args || []));\n                    }\n                }\n                catch (error) {\n                    return revivedObj;\n                }\n            }\n            else if (isLangChainSerializedObject(revivedObj)) {\n                return (0,_langchain_core_load__WEBPACK_IMPORTED_MODULE_0__.load)(JSON.stringify(revivedObj));\n            }\n            return revivedObj;\n        }\n    }\n    return value;\n}\nfunction _encodeConstructorArgs(\n// eslint-disable-next-line @typescript-eslint/ban-types\nconstructor, method, args, kwargs) {\n    return {\n        lc: 2,\n        type: \"constructor\",\n        id: [constructor.name],\n        method: method ?? null,\n        args: args ?? [],\n        kwargs: kwargs ?? {},\n    };\n}\nfunction _default(obj) {\n    if (obj === undefined) {\n        return {\n            lc: 2,\n            type: \"undefined\",\n        };\n    }\n    else if (obj instanceof Set || obj instanceof Map) {\n        return _encodeConstructorArgs(obj.constructor, undefined, [\n            Array.from(obj),\n        ]);\n    }\n    else if (obj instanceof RegExp) {\n        return _encodeConstructorArgs(RegExp, undefined, [obj.source, obj.flags]);\n    }\n    else if (obj instanceof Error) {\n        return _encodeConstructorArgs(obj.constructor, undefined, [obj.message]);\n        // TODO: Remove special case\n    }\n    else if (obj?.lg_name === \"Send\") {\n        return {\n            node: obj.node,\n            args: obj.args,\n        };\n    }\n    else {\n        return obj;\n    }\n}\nclass JsonPlusSerializer {\n    _dumps(obj) {\n        const encoder = new TextEncoder();\n        return encoder.encode((0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(obj, (_, value) => {\n            return _default(value);\n        }));\n    }\n    dumpsTyped(obj) {\n        if (obj instanceof Uint8Array) {\n            return [\"bytes\", obj];\n        }\n        else {\n            return [\"json\", this._dumps(obj)];\n        }\n    }\n    async _loads(data) {\n        const parsed = JSON.parse(data);\n        return _reviver(parsed);\n    }\n    async loadsTyped(type, data) {\n        if (type === \"bytes\") {\n            return typeof data === \"string\" ? new TextEncoder().encode(data) : data;\n        }\n        else if (type === \"json\") {\n            return this._loads(typeof data === \"string\" ? data : new TextDecoder().decode(data));\n        }\n        else {\n            throw new Error(`Unknown serialization type: ${type}`);\n        }\n    }\n}\n//# sourceMappingURL=jsonplus.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L3NlcmRlL2pzb25wbHVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDNEM7QUFDcUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSw4QkFBOEIsOEVBQVM7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoLWNoZWNrcG9pbnRcXGRpc3RcXHNlcmRlXFxqc29ucGx1cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2YgKi9cbmltcG9ydCB7IGxvYWQgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL2xvYWRcIjtcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gXCIuL3V0aWxzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanNcIjtcbmZ1bmN0aW9uIGlzTGFuZ0NoYWluU2VyaWFsaXplZE9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgdmFsdWUubGMgPT09IDEgJiZcbiAgICAgICAgdmFsdWUudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUuaWQpKTtcbn1cbi8qKlxuICogVGhlIHJlcGxhY2VyIGluIHN0cmluZ2lmeSBkb2VzIG5vdCBhbGxvdyBkZWxlZ2F0aW9uIHRvIGJ1aWx0LWluIExhbmdDaGFpblxuICogc2VyaWFsaXphdGlvbiBtZXRob2RzLCBhbmQgaW5zdGVhZCBpbW1lZGlhdGVseSBjYWxscyBgLnRvSlNPTigpYCBhbmRcbiAqIGNvbnRpbnVlcyB0byBzdHJpbmdpZnkgc3ViZmllbGRzLlxuICpcbiAqIFdlIHRoZXJlZm9yZSBtdXN0IHN0YXJ0IGZyb20gdGhlIG1vc3QgbmVzdGVkIGVsZW1lbnRzIGluIHRoZSBpbnB1dCBhbmRcbiAqIGRlc2VyaWFsaXplIHVwd2FyZHMgcmF0aGVyIHRoYW4gdG9wLWRvd24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9yZXZpdmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldml2ZWRBcnJheSA9IGF3YWl0IFByb21pc2UuYWxsKHZhbHVlLm1hcCgoaXRlbSkgPT4gX3Jldml2ZXIoaXRlbSkpKTtcbiAgICAgICAgICAgIHJldHVybiByZXZpdmVkQXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXZpdmVkT2JqID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXZpdmVkT2JqW2tdID0gYXdhaXQgX3Jldml2ZXIodik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV2aXZlZE9iai5sYyA9PT0gMiAmJiByZXZpdmVkT2JqLnR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmV2aXZlZE9iai5sYyA9PT0gMiAmJlxuICAgICAgICAgICAgICAgIHJldml2ZWRPYmoudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShyZXZpdmVkT2JqLmlkKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IHJldml2ZWRPYmouaWRbcmV2aXZlZE9iai5pZC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbnN0cnVjdG9yTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNldFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gU2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1hcFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gTWFwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlJlZ0V4cFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gUmVnRXhwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSBFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldml2ZWRPYmo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldml2ZWRPYmoubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3JbcmV2aXZlZE9iai5tZXRob2RdKC4uLihyZXZpdmVkT2JqLmFyZ3MgfHwgW10pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3IoLi4uKHJldml2ZWRPYmouYXJncyB8fCBbXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV2aXZlZE9iajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0xhbmdDaGFpblNlcmlhbGl6ZWRPYmplY3QocmV2aXZlZE9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZChKU09OLnN0cmluZ2lmeShyZXZpdmVkT2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV2aXZlZE9iajtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfZW5jb2RlQ29uc3RydWN0b3JBcmdzKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmNvbnN0cnVjdG9yLCBtZXRob2QsIGFyZ3MsIGt3YXJncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxjOiAyLFxuICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgIGlkOiBbY29uc3RydWN0b3IubmFtZV0sXG4gICAgICAgIG1ldGhvZDogbWV0aG9kID8/IG51bGwsXG4gICAgICAgIGFyZ3M6IGFyZ3MgPz8gW10sXG4gICAgICAgIGt3YXJnczoga3dhcmdzID8/IHt9LFxuICAgIH07XG59XG5mdW5jdGlvbiBfZGVmYXVsdChvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxjOiAyLFxuICAgICAgICAgICAgdHlwZTogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgU2V0IHx8IG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICByZXR1cm4gX2VuY29kZUNvbnN0cnVjdG9yQXJncyhvYmouY29uc3RydWN0b3IsIHVuZGVmaW5lZCwgW1xuICAgICAgICAgICAgQXJyYXkuZnJvbShvYmopLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBfZW5jb2RlQ29uc3RydWN0b3JBcmdzKFJlZ0V4cCwgdW5kZWZpbmVkLCBbb2JqLnNvdXJjZSwgb2JqLmZsYWdzXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBfZW5jb2RlQ29uc3RydWN0b3JBcmdzKG9iai5jb25zdHJ1Y3RvciwgdW5kZWZpbmVkLCBbb2JqLm1lc3NhZ2VdKTtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHNwZWNpYWwgY2FzZVxuICAgIH1cbiAgICBlbHNlIGlmIChvYmo/LmxnX25hbWUgPT09IFwiU2VuZFwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiBvYmoubm9kZSxcbiAgICAgICAgICAgIGFyZ3M6IG9iai5hcmdzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSnNvblBsdXNTZXJpYWxpemVyIHtcbiAgICBfZHVtcHMob2JqKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHN0cmluZ2lmeShvYmosIChfLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9kZWZhdWx0KHZhbHVlKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBkdW1wc1R5cGVkKG9iaikge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcImJ5dGVzXCIsIG9ial07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW1wianNvblwiLCB0aGlzLl9kdW1wcyhvYmopXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbG9hZHMoZGF0YSkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICByZXR1cm4gX3Jldml2ZXIocGFyc2VkKTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZHNUeXBlZCh0eXBlLCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKSA6IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2Fkcyh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNlcmlhbGl6YXRpb24gdHlwZTogJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbnBsdXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/jsonplus.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/types.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/serde/types.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ERROR: () => (/* binding */ ERROR),\n/* harmony export */   INTERRUPT: () => (/* binding */ INTERRUPT),\n/* harmony export */   RESUME: () => (/* binding */ RESUME),\n/* harmony export */   SCHEDULED: () => (/* binding */ SCHEDULED),\n/* harmony export */   TASKS: () => (/* binding */ TASKS)\n/* harmony export */ });\nconst TASKS = \"__pregel_tasks\";\nconst ERROR = \"__error__\";\nconst SCHEDULED = \"__scheduled__\";\nconst INTERRUPT = \"__interrupt__\";\nconst RESUME = \"__resume__\";\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L3NlcmRlL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxkaXN0XFxzZXJkZVxcdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFRBU0tTID0gXCJfX3ByZWdlbF90YXNrc1wiO1xuZXhwb3J0IGNvbnN0IEVSUk9SID0gXCJfX2Vycm9yX19cIjtcbmV4cG9ydCBjb25zdCBTQ0hFRFVMRUQgPSBcIl9fc2NoZWR1bGVkX19cIjtcbmV4cG9ydCBjb25zdCBJTlRFUlJVUFQgPSBcIl9faW50ZXJydXB0X19cIjtcbmV4cG9ydCBjb25zdCBSRVNVTUUgPSBcIl9fcmVzdW1lX19cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/utils/fast-safe-stringify/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/serde/utils/fast-safe-stringify/index.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/* eslint-disable */\n// @ts-nocheck\n// Stringify that can handle circular references.\n// Inlined due to ESM import issues\n// Source: https://www.npmjs.com/package/fast-safe-stringify\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = \"[Circular]\";\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER,\n    };\n}\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    decirc(obj, \"\", 0, [], undefined, 0, options);\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(obj, replacer, spacer);\n        }\n        else {\n            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n        }\n    }\n    catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    }\n    finally {\n        while (arr.length !== 0) {\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            }\n            else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, { value: replace });\n            arr.push([parent, k, val, propertyDescriptor]);\n        }\n        else {\n            replacerStack.push([val, k, replace]);\n        }\n    }\n    else {\n        parent[k] = replace;\n        arr.push([parent, k, val]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            var keys = Object.keys(val);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        }\n        else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    }\n    catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    }\n    finally {\n        // Ensure that we restore the object as it was.\n        while (arr.length !== 0) {\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            }\n            else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        }\n        catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([parent, k, val]);\n                parent[k] = tmp;\n            }\n            else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer =\n        typeof replacer !== \"undefined\"\n            ? replacer\n            : function (k, v) {\n                return v;\n            };\n    return function (key, val) {\n        if (replacerStack.length > 0) {\n            for (var i = 0; i < replacerStack.length; i++) {\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L3NlcmRlL3V0aWxzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGgtY2hlY2twb2ludFxcZGlzdFxcc2VyZGVcXHV0aWxzXFxmYXN0LXNhZmUtc3RyaW5naWZ5XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcbi8vIFN0cmluZ2lmeSB0aGF0IGNhbiBoYW5kbGUgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbi8vIElubGluZWQgZHVlIHRvIEVTTSBpbXBvcnQgaXNzdWVzXG4vLyBTb3VyY2U6IGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Zhc3Qtc2FmZS1zdHJpbmdpZnlcbnZhciBMSU1JVF9SRVBMQUNFX05PREUgPSBcIlsuLi5dXCI7XG52YXIgQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFID0gXCJbQ2lyY3VsYXJdXCI7XG52YXIgYXJyID0gW107XG52YXIgcmVwbGFjZXJTdGFjayA9IFtdO1xuZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVwdGhMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgIGVkZ2VzTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIH07XG59XG4vLyBSZWd1bGFyIHN0cmluZ2lmeVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKCk7XG4gICAgfVxuICAgIGRlY2lyYyhvYmosIFwiXCIsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpO1xuICAgIHZhciByZXM7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXCJbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdXCIpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHNldFJlcGxhY2UocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspO1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnQsIGssIHsgdmFsdWU6IHJlcGxhY2UgfSk7XG4gICAgICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWwsIHByb3BlcnR5RGVzY3JpcHRvcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwbGFjZXJTdGFjay5wdXNoKFt2YWwsIGssIHJlcGxhY2VdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyZW50W2tdID0gcmVwbGFjZTtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICAgIGRlcHRoICs9IDE7XG4gICAgdmFyIGk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWwpO1xuICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICB9XG59XG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChhID4gYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgICB9XG4gICAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmo7XG4gICAgdmFyIHJlcztcbiAgICB0cnkge1xuICAgICAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcIlt1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV1cIik7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgICAgICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBhcnIucG9wKCk7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG9iamVjdCBpbiB0aGUgcmVxdWlyZWQgd2F5XG4gICAgICAgICAgICB2YXIgdG1wID0ge307XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRba10gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH1cbn1cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICAgIHJlcGxhY2VyID1cbiAgICAgICAgdHlwZW9mIHJlcGxhY2VyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IHJlcGxhY2VyXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlclN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0WzFdID09PSBrZXkgJiYgcGFydFswXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnRbMl07XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VyU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/serde/utils/fast-safe-stringify/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/base.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/store/base.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseStore: () => (/* binding */ BaseStore),\n/* harmony export */   InvalidNamespaceError: () => (/* binding */ InvalidNamespaceError),\n/* harmony export */   getTextAtPath: () => (/* binding */ getTextAtPath),\n/* harmony export */   tokenizePath: () => (/* binding */ tokenizePath)\n/* harmony export */ });\n/**\n * Error thrown when an invalid namespace is provided.\n */\nclass InvalidNamespaceError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"InvalidNamespaceError\";\n    }\n}\n/**\n * Validates the provided namespace.\n * @param namespace The namespace to validate.\n * @throws {InvalidNamespaceError} If the namespace is invalid.\n */\nfunction validateNamespace(namespace) {\n    if (namespace.length === 0) {\n        throw new InvalidNamespaceError(\"Namespace cannot be empty.\");\n    }\n    for (const label of namespace) {\n        if (typeof label !== \"string\") {\n            throw new InvalidNamespaceError(`Invalid namespace label '${label}' found in ${namespace}. Namespace labels ` +\n                `must be strings, but got ${typeof label}.`);\n        }\n        if (label.includes(\".\")) {\n            throw new InvalidNamespaceError(`Invalid namespace label '${label}' found in ${namespace}. Namespace labels cannot contain periods ('.').`);\n        }\n        if (label === \"\") {\n            throw new InvalidNamespaceError(`Namespace labels cannot be empty strings. Got ${label} in ${namespace}`);\n        }\n    }\n    if (namespace[0] === \"langgraph\") {\n        throw new InvalidNamespaceError(`Root label for namespace cannot be \"langgraph\". Got: ${namespace}`);\n    }\n}\n/**\n * Utility function to get text at a specific JSON path\n */\nfunction getTextAtPath(obj, path) {\n    const parts = path.split(\".\");\n    let current = obj;\n    for (const part of parts) {\n        if (part.includes(\"[\")) {\n            const [arrayName, indexStr] = part.split(\"[\");\n            const index = indexStr.replace(\"]\", \"\");\n            if (!current[arrayName])\n                return [];\n            if (index === \"*\") {\n                const results = [];\n                for (const item of current[arrayName]) {\n                    if (typeof item === \"string\")\n                        results.push(item);\n                }\n                return results;\n            }\n            const idx = parseInt(index, 10);\n            if (Number.isNaN(idx))\n                return [];\n            current = current[arrayName][idx];\n        }\n        else {\n            current = current[part];\n        }\n        if (current === undefined)\n            return [];\n    }\n    return typeof current === \"string\" ? [current] : [];\n}\n/**\n * Tokenizes a JSON path into parts\n */\nfunction tokenizePath(path) {\n    return path.split(\".\");\n}\n/**\n * Abstract base class for persistent key-value stores.\n *\n * Stores enable persistence and memory that can be shared across threads,\n * scoped to user IDs, assistant IDs, or other arbitrary namespaces.\n *\n * Features:\n * - Hierarchical namespaces for organization\n * - Key-value storage with metadata\n * - Vector similarity search (if configured)\n * - Filtering and pagination\n */\nclass BaseStore {\n    /**\n     * Retrieve a single item by its namespace and key.\n     *\n     * @param namespace Hierarchical path for the item\n     * @param key Unique identifier within the namespace\n     * @returns Promise resolving to the item or null if not found\n     */\n    async get(namespace, key) {\n        return (await this.batch([{ namespace, key }]))[0];\n    }\n    /**\n     * Search for items within a namespace prefix.\n     * Supports both metadata filtering and vector similarity search.\n     *\n     * @param namespacePrefix Hierarchical path prefix to search within\n     * @param options Search options for filtering and pagination\n     * @returns Promise resolving to list of matching items with relevance scores\n     *\n     * @example\n     * // Search with filters\n     * await store.search([\"documents\"], {\n     *   filter: { type: \"report\", status: \"active\" },\n     *   limit: 5,\n     *   offset: 10\n     * });\n     *\n     * // Vector similarity search\n     * await store.search([\"users\", \"content\"], {\n     *   query: \"technical documentation about APIs\",\n     *   limit: 20\n     * });\n     */\n    async search(namespacePrefix, options = {}) {\n        const { filter, limit = 10, offset = 0, query } = options;\n        return (await this.batch([\n            {\n                namespacePrefix,\n                filter,\n                limit,\n                offset,\n                query,\n            },\n        ]))[0];\n    }\n    /**\n     * Store or update an item.\n     *\n     * @param namespace Hierarchical path for the item\n     * @param key Unique identifier within the namespace\n     * @param value Object containing the item's data\n     * @param index Optional indexing configuration\n     *\n     * @example\n     * // Simple storage\n     * await store.put([\"docs\"], \"report\", { title: \"Annual Report\" });\n     *\n     * // With specific field indexing\n     * await store.put(\n     *   [\"docs\"],\n     *   \"report\",\n     *   {\n     *     title: \"Q4 Report\",\n     *     chapters: [{ content: \"...\" }, { content: \"...\" }]\n     *   },\n     *   [\"title\", \"chapters[*].content\"]\n     * );\n     */\n    async put(namespace, key, value, index) {\n        validateNamespace(namespace);\n        await this.batch([{ namespace, key, value, index }]);\n    }\n    /**\n     * Delete an item from the store.\n     *\n     * @param namespace Hierarchical path for the item\n     * @param key Unique identifier within the namespace\n     */\n    async delete(namespace, key) {\n        await this.batch([{ namespace, key, value: null }]);\n    }\n    /**\n     * List and filter namespaces in the store.\n     * Used to explore data organization and navigate the namespace hierarchy.\n     *\n     * @param options Options for listing namespaces\n     * @returns Promise resolving to list of namespace paths\n     *\n     * @example\n     * // List all namespaces under \"documents\"\n     * await store.listNamespaces({\n     *   prefix: [\"documents\"],\n     *   maxDepth: 2\n     * });\n     *\n     * // List namespaces ending with \"v1\"\n     * await store.listNamespaces({\n     *   suffix: [\"v1\"],\n     *   limit: 50\n     * });\n     */\n    async listNamespaces(options = {}) {\n        const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;\n        const matchConditions = [];\n        if (prefix) {\n            matchConditions.push({ matchType: \"prefix\", path: prefix });\n        }\n        if (suffix) {\n            matchConditions.push({ matchType: \"suffix\", path: suffix });\n        }\n        return (await this.batch([\n            {\n                matchConditions: matchConditions.length ? matchConditions : undefined,\n                maxDepth,\n                limit,\n                offset,\n            },\n        ]))[0];\n    }\n    /**\n     * Start the store. Override if initialization is needed.\n     */\n    start() { }\n    /**\n     * Stop the store. Override if cleanup is needed.\n     */\n    stop() { }\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L3N0b3JlL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE1BQU0sYUFBYSxVQUFVO0FBQ3JHLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQSx3RUFBd0UsTUFBTSxhQUFhLFVBQVU7QUFDckc7QUFDQTtBQUNBLDZGQUE2RixPQUFPLEtBQUssVUFBVTtBQUNuSDtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csVUFBVTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDO0FBQ3JEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDhDQUE4QztBQUM5QyxnQkFBZ0Isd0NBQXdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3QkFBd0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCLElBQUksZ0JBQWdCO0FBQzVELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscUNBQXFDO0FBQ3JDLGdCQUFnQixvREFBb0Q7QUFDcEU7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxkaXN0XFxzdG9yZVxcYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVycm9yIHRocm93biB3aGVuIGFuIGludmFsaWQgbmFtZXNwYWNlIGlzIHByb3ZpZGVkLlxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZE5hbWVzcGFjZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZE5hbWVzcGFjZUVycm9yXCI7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIHByb3ZpZGVkIG5hbWVzcGFjZS5cbiAqIEBwYXJhbSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSB0byB2YWxpZGF0ZS5cbiAqIEB0aHJvd3Mge0ludmFsaWROYW1lc3BhY2VFcnJvcn0gSWYgdGhlIG5hbWVzcGFjZSBpcyBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShuYW1lc3BhY2UpIHtcbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE5hbWVzcGFjZUVycm9yKFwiTmFtZXNwYWNlIGNhbm5vdCBiZSBlbXB0eS5cIik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGFiZWwgb2YgbmFtZXNwYWNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkTmFtZXNwYWNlRXJyb3IoYEludmFsaWQgbmFtZXNwYWNlIGxhYmVsICcke2xhYmVsfScgZm91bmQgaW4gJHtuYW1lc3BhY2V9LiBOYW1lc3BhY2UgbGFiZWxzIGAgK1xuICAgICAgICAgICAgICAgIGBtdXN0IGJlIHN0cmluZ3MsIGJ1dCBnb3QgJHt0eXBlb2YgbGFiZWx9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYWJlbC5pbmNsdWRlcyhcIi5cIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkTmFtZXNwYWNlRXJyb3IoYEludmFsaWQgbmFtZXNwYWNlIGxhYmVsICcke2xhYmVsfScgZm91bmQgaW4gJHtuYW1lc3BhY2V9LiBOYW1lc3BhY2UgbGFiZWxzIGNhbm5vdCBjb250YWluIHBlcmlvZHMgKCcuJykuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhYmVsID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE5hbWVzcGFjZUVycm9yKGBOYW1lc3BhY2UgbGFiZWxzIGNhbm5vdCBiZSBlbXB0eSBzdHJpbmdzLiBHb3QgJHtsYWJlbH0gaW4gJHtuYW1lc3BhY2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZVswXSA9PT0gXCJsYW5nZ3JhcGhcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE5hbWVzcGFjZUVycm9yKGBSb290IGxhYmVsIGZvciBuYW1lc3BhY2UgY2Fubm90IGJlIFwibGFuZ2dyYXBoXCIuIEdvdDogJHtuYW1lc3BhY2V9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGdldCB0ZXh0IGF0IGEgc3BlY2lmaWMgSlNPTiBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0QXRQYXRoKG9iaiwgcGF0aCkge1xuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgbGV0IGN1cnJlbnQgPSBvYmo7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0LmluY2x1ZGVzKFwiW1wiKSkge1xuICAgICAgICAgICAgY29uc3QgW2FycmF5TmFtZSwgaW5kZXhTdHJdID0gcGFydC5zcGxpdChcIltcIik7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGluZGV4U3RyLnJlcGxhY2UoXCJdXCIsIFwiXCIpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50W2FycmF5TmFtZV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY3VycmVudFthcnJheU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZHggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihpZHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2FycmF5TmFtZV1baWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIiA/IFtjdXJyZW50XSA6IFtdO1xufVxuLyoqXG4gKiBUb2tlbml6ZXMgYSBKU09OIHBhdGggaW50byBwYXJ0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5pemVQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdChcIi5cIik7XG59XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHBlcnNpc3RlbnQga2V5LXZhbHVlIHN0b3Jlcy5cbiAqXG4gKiBTdG9yZXMgZW5hYmxlIHBlcnNpc3RlbmNlIGFuZCBtZW1vcnkgdGhhdCBjYW4gYmUgc2hhcmVkIGFjcm9zcyB0aHJlYWRzLFxuICogc2NvcGVkIHRvIHVzZXIgSURzLCBhc3Npc3RhbnQgSURzLCBvciBvdGhlciBhcmJpdHJhcnkgbmFtZXNwYWNlcy5cbiAqXG4gKiBGZWF0dXJlczpcbiAqIC0gSGllcmFyY2hpY2FsIG5hbWVzcGFjZXMgZm9yIG9yZ2FuaXphdGlvblxuICogLSBLZXktdmFsdWUgc3RvcmFnZSB3aXRoIG1ldGFkYXRhXG4gKiAtIFZlY3RvciBzaW1pbGFyaXR5IHNlYXJjaCAoaWYgY29uZmlndXJlZClcbiAqIC0gRmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlU3RvcmUge1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgc2luZ2xlIGl0ZW0gYnkgaXRzIG5hbWVzcGFjZSBhbmQga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZSBIaWVyYXJjaGljYWwgcGF0aCBmb3IgdGhlIGl0ZW1cbiAgICAgKiBAcGFyYW0ga2V5IFVuaXF1ZSBpZGVudGlmaWVyIHdpdGhpbiB0aGUgbmFtZXNwYWNlXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGl0ZW0gb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBhc3luYyBnZXQobmFtZXNwYWNlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmJhdGNoKFt7IG5hbWVzcGFjZSwga2V5IH1dKSlbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgaXRlbXMgd2l0aGluIGEgbmFtZXNwYWNlIHByZWZpeC5cbiAgICAgKiBTdXBwb3J0cyBib3RoIG1ldGFkYXRhIGZpbHRlcmluZyBhbmQgdmVjdG9yIHNpbWlsYXJpdHkgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZVByZWZpeCBIaWVyYXJjaGljYWwgcGF0aCBwcmVmaXggdG8gc2VhcmNoIHdpdGhpblxuICAgICAqIEBwYXJhbSBvcHRpb25zIFNlYXJjaCBvcHRpb25zIGZvciBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb25cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBsaXN0IG9mIG1hdGNoaW5nIGl0ZW1zIHdpdGggcmVsZXZhbmNlIHNjb3Jlc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTZWFyY2ggd2l0aCBmaWx0ZXJzXG4gICAgICogYXdhaXQgc3RvcmUuc2VhcmNoKFtcImRvY3VtZW50c1wiXSwge1xuICAgICAqICAgZmlsdGVyOiB7IHR5cGU6IFwicmVwb3J0XCIsIHN0YXR1czogXCJhY3RpdmVcIiB9LFxuICAgICAqICAgbGltaXQ6IDUsXG4gICAgICogICBvZmZzZXQ6IDEwXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBWZWN0b3Igc2ltaWxhcml0eSBzZWFyY2hcbiAgICAgKiBhd2FpdCBzdG9yZS5zZWFyY2goW1widXNlcnNcIiwgXCJjb250ZW50XCJdLCB7XG4gICAgICogICBxdWVyeTogXCJ0ZWNobmljYWwgZG9jdW1lbnRhdGlvbiBhYm91dCBBUElzXCIsXG4gICAgICogICBsaW1pdDogMjBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2gobmFtZXNwYWNlUHJlZml4LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBmaWx0ZXIsIGxpbWl0ID0gMTAsIG9mZnNldCA9IDAsIHF1ZXJ5IH0gPSBvcHRpb25zO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuYmF0Y2goW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZVByZWZpeCxcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSkpWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZSBvciB1cGRhdGUgYW4gaXRlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgSGllcmFyY2hpY2FsIHBhdGggZm9yIHRoZSBpdGVtXG4gICAgICogQHBhcmFtIGtleSBVbmlxdWUgaWRlbnRpZmllciB3aXRoaW4gdGhlIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSdzIGRhdGFcbiAgICAgKiBAcGFyYW0gaW5kZXggT3B0aW9uYWwgaW5kZXhpbmcgY29uZmlndXJhdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaW1wbGUgc3RvcmFnZVxuICAgICAqIGF3YWl0IHN0b3JlLnB1dChbXCJkb2NzXCJdLCBcInJlcG9ydFwiLCB7IHRpdGxlOiBcIkFubnVhbCBSZXBvcnRcIiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFdpdGggc3BlY2lmaWMgZmllbGQgaW5kZXhpbmdcbiAgICAgKiBhd2FpdCBzdG9yZS5wdXQoXG4gICAgICogICBbXCJkb2NzXCJdLFxuICAgICAqICAgXCJyZXBvcnRcIixcbiAgICAgKiAgIHtcbiAgICAgKiAgICAgdGl0bGU6IFwiUTQgUmVwb3J0XCIsXG4gICAgICogICAgIGNoYXB0ZXJzOiBbeyBjb250ZW50OiBcIi4uLlwiIH0sIHsgY29udGVudDogXCIuLi5cIiB9XVxuICAgICAqICAgfSxcbiAgICAgKiAgIFtcInRpdGxlXCIsIFwiY2hhcHRlcnNbKl0uY29udGVudFwiXVxuICAgICAqICk7XG4gICAgICovXG4gICAgYXN5bmMgcHV0KG5hbWVzcGFjZSwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFsaWRhdGVOYW1lc3BhY2UobmFtZXNwYWNlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5iYXRjaChbeyBuYW1lc3BhY2UsIGtleSwgdmFsdWUsIGluZGV4IH1dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGl0ZW0gZnJvbSB0aGUgc3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlIEhpZXJhcmNoaWNhbCBwYXRoIGZvciB0aGUgaXRlbVxuICAgICAqIEBwYXJhbSBrZXkgVW5pcXVlIGlkZW50aWZpZXIgd2l0aGluIHRoZSBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUobmFtZXNwYWNlLCBrZXkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5iYXRjaChbeyBuYW1lc3BhY2UsIGtleSwgdmFsdWU6IG51bGwgfV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFuZCBmaWx0ZXIgbmFtZXNwYWNlcyBpbiB0aGUgc3RvcmUuXG4gICAgICogVXNlZCB0byBleHBsb3JlIGRhdGEgb3JnYW5pemF0aW9uIGFuZCBuYXZpZ2F0ZSB0aGUgbmFtZXNwYWNlIGhpZXJhcmNoeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIGxpc3RpbmcgbmFtZXNwYWNlc1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGxpc3Qgb2YgbmFtZXNwYWNlIHBhdGhzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIG5hbWVzcGFjZXMgdW5kZXIgXCJkb2N1bWVudHNcIlxuICAgICAqIGF3YWl0IHN0b3JlLmxpc3ROYW1lc3BhY2VzKHtcbiAgICAgKiAgIHByZWZpeDogW1wiZG9jdW1lbnRzXCJdLFxuICAgICAqICAgbWF4RGVwdGg6IDJcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIExpc3QgbmFtZXNwYWNlcyBlbmRpbmcgd2l0aCBcInYxXCJcbiAgICAgKiBhd2FpdCBzdG9yZS5saXN0TmFtZXNwYWNlcyh7XG4gICAgICogICBzdWZmaXg6IFtcInYxXCJdLFxuICAgICAqICAgbGltaXQ6IDUwXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYXN5bmMgbGlzdE5hbWVzcGFjZXMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBzdWZmaXgsIG1heERlcHRoLCBsaW1pdCA9IDEwMCwgb2Zmc2V0ID0gMCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgbWF0Y2hDb25kaXRpb25zID0gW107XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIG1hdGNoQ29uZGl0aW9ucy5wdXNoKHsgbWF0Y2hUeXBlOiBcInByZWZpeFwiLCBwYXRoOiBwcmVmaXggfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1ZmZpeCkge1xuICAgICAgICAgICAgbWF0Y2hDb25kaXRpb25zLnB1c2goeyBtYXRjaFR5cGU6IFwic3VmZml4XCIsIHBhdGg6IHN1ZmZpeCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuYmF0Y2goW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hdGNoQ29uZGl0aW9uczogbWF0Y2hDb25kaXRpb25zLmxlbmd0aCA/IG1hdGNoQ29uZGl0aW9ucyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtYXhEZXB0aCxcbiAgICAgICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKSlbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBzdG9yZS4gT3ZlcnJpZGUgaWYgaW5pdGlhbGl6YXRpb24gaXMgbmVlZGVkLlxuICAgICAqL1xuICAgIHN0YXJ0KCkgeyB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgc3RvcmUuIE92ZXJyaWRlIGlmIGNsZWFudXAgaXMgbmVlZGVkLlxuICAgICAqL1xuICAgIHN0b3AoKSB7IH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/batch.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/store/batch.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncBatchedStore: () => (/* binding */ AsyncBatchedStore)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/base.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Extracts and returns the underlying store from an `AsyncBatchedStore`,\n * or returns the input if it is not an `AsyncBatchedStore`.\n */\nconst extractStore = (input) => {\n    if (\"lg_name\" in input && input.lg_name === \"AsyncBatchedStore\") {\n        // @ts-expect-error is a protected property\n        return input.store;\n    }\n    return input;\n};\nclass AsyncBatchedStore extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseStore {\n    constructor(store) {\n        super();\n        Object.defineProperty(this, \"lg_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AsyncBatchedStore\"\n        });\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"nextKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"running\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"processingTask\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        this.store = extractStore(store);\n    }\n    get isRunning() {\n        return this.running;\n    }\n    /**\n     * @ignore\n     * Batch is not implemented here as we're only extending `BaseStore`\n     * to allow it to be passed where `BaseStore` is expected, and implement\n     * the convenience methods (get, search, put, delete).\n     */\n    async batch(_operations) {\n        throw new Error(\"The `batch` method is not implemented on `AsyncBatchedStore`.\" +\n            \"\\n Instead, it calls the `batch` method on the wrapped store.\" +\n            \"\\n If you are seeing this error, something is wrong.\");\n    }\n    async get(namespace, key) {\n        return this.enqueueOperation({ namespace, key });\n    }\n    async search(namespacePrefix, options) {\n        const { filter, limit = 10, offset = 0, query } = options || {};\n        return this.enqueueOperation({\n            namespacePrefix,\n            filter,\n            limit,\n            offset,\n            query,\n        });\n    }\n    async put(namespace, key, value) {\n        return this.enqueueOperation({ namespace, key, value });\n    }\n    async delete(namespace, key) {\n        return this.enqueueOperation({\n            namespace,\n            key,\n            value: null,\n        });\n    }\n    start() {\n        if (!this.running) {\n            this.running = true;\n            this.processingTask = this.processBatchQueue();\n        }\n    }\n    async stop() {\n        this.running = false;\n        if (this.processingTask) {\n            await this.processingTask;\n        }\n    }\n    enqueueOperation(operation) {\n        return new Promise((resolve, reject) => {\n            const key = this.nextKey;\n            this.nextKey += 1;\n            this.queue.set(key, { operation, resolve, reject });\n        });\n    }\n    async processBatchQueue() {\n        while (this.running) {\n            await new Promise((resolve) => {\n                setTimeout(resolve, 0);\n            });\n            if (this.queue.size === 0)\n                continue;\n            const batch = new Map(this.queue);\n            this.queue.clear();\n            try {\n                const operations = Array.from(batch.values()).map(({ operation }) => operation);\n                const results = await this.store.batch(operations);\n                batch.forEach(({ resolve }, key) => {\n                    const index = Array.from(batch.keys()).indexOf(key);\n                    resolve(results[index]);\n                });\n            }\n            catch (e) {\n                batch.forEach(({ reject }) => {\n                    reject(e);\n                });\n            }\n        }\n    }\n    // AsyncBatchedStore is internal and gets passed as args into traced tasks\n    // some BaseStores contain circular references so just serialize without it\n    // as this causes warnings when tracing with LangSmith.\n    toJSON() {\n        return {\n            queue: this.queue,\n            nextKey: this.nextKey,\n            running: this.running,\n            store: \"[LangGraphStore]\",\n        };\n    }\n}\n//# sourceMappingURL=batch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L3N0b3JlL2JhdGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQywrQ0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBLGdCQUFnQix3Q0FBd0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRCQUE0QjtBQUM5RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFdBQVc7QUFDaEY7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGgtY2hlY2twb2ludFxcZGlzdFxcc3RvcmVcXGJhdGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCB7IEJhc2VTdG9yZSwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG4vKipcbiAqIEV4dHJhY3RzIGFuZCByZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHN0b3JlIGZyb20gYW4gYEFzeW5jQmF0Y2hlZFN0b3JlYCxcbiAqIG9yIHJldHVybnMgdGhlIGlucHV0IGlmIGl0IGlzIG5vdCBhbiBgQXN5bmNCYXRjaGVkU3RvcmVgLlxuICovXG5jb25zdCBleHRyYWN0U3RvcmUgPSAoaW5wdXQpID0+IHtcbiAgICBpZiAoXCJsZ19uYW1lXCIgaW4gaW5wdXQgJiYgaW5wdXQubGdfbmFtZSA9PT0gXCJBc3luY0JhdGNoZWRTdG9yZVwiKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaXMgYSBwcm90ZWN0ZWQgcHJvcGVydHlcbiAgICAgICAgcmV0dXJuIGlucHV0LnN0b3JlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQ7XG59O1xuZXhwb3J0IGNsYXNzIEFzeW5jQmF0Y2hlZFN0b3JlIGV4dGVuZHMgQmFzZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZ19uYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIkFzeW5jQmF0Y2hlZFN0b3JlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5leHRLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bm5pbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9jZXNzaW5nVGFza1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IGV4dHJhY3RTdG9yZShzdG9yZSk7XG4gICAgfVxuICAgIGdldCBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBCYXRjaCBpcyBub3QgaW1wbGVtZW50ZWQgaGVyZSBhcyB3ZSdyZSBvbmx5IGV4dGVuZGluZyBgQmFzZVN0b3JlYFxuICAgICAqIHRvIGFsbG93IGl0IHRvIGJlIHBhc3NlZCB3aGVyZSBgQmFzZVN0b3JlYCBpcyBleHBlY3RlZCwgYW5kIGltcGxlbWVudFxuICAgICAqIHRoZSBjb252ZW5pZW5jZSBtZXRob2RzIChnZXQsIHNlYXJjaCwgcHV0LCBkZWxldGUpLlxuICAgICAqL1xuICAgIGFzeW5jIGJhdGNoKF9vcGVyYXRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgYmF0Y2hgIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgb24gYEFzeW5jQmF0Y2hlZFN0b3JlYC5cIiArXG4gICAgICAgICAgICBcIlxcbiBJbnN0ZWFkLCBpdCBjYWxscyB0aGUgYGJhdGNoYCBtZXRob2Qgb24gdGhlIHdyYXBwZWQgc3RvcmUuXCIgK1xuICAgICAgICAgICAgXCJcXG4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBlcnJvciwgc29tZXRoaW5nIGlzIHdyb25nLlwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KG5hbWVzcGFjZSwga2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVucXVldWVPcGVyYXRpb24oeyBuYW1lc3BhY2UsIGtleSB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2VhcmNoKG5hbWVzcGFjZVByZWZpeCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGZpbHRlciwgbGltaXQgPSAxMCwgb2Zmc2V0ID0gMCwgcXVlcnkgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHJldHVybiB0aGlzLmVucXVldWVPcGVyYXRpb24oe1xuICAgICAgICAgICAgbmFtZXNwYWNlUHJlZml4LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHB1dChuYW1lc3BhY2UsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZU9wZXJhdGlvbih7IG5hbWVzcGFjZSwga2V5LCB2YWx1ZSB9KTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlKG5hbWVzcGFjZSwga2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVucXVldWVPcGVyYXRpb24oe1xuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdUYXNrID0gdGhpcy5wcm9jZXNzQmF0Y2hRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nVGFzaykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzaW5nVGFzaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnF1ZXVlT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5uZXh0S2V5O1xuICAgICAgICAgICAgdGhpcy5uZXh0S2V5ICs9IDE7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnNldChrZXksIHsgb3BlcmF0aW9uLCByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzQmF0Y2hRdWV1ZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucnVubmluZykge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWV1ZS5zaXplID09PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBuZXcgTWFwKHRoaXMucXVldWUpO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRpb25zID0gQXJyYXkuZnJvbShiYXRjaC52YWx1ZXMoKSkubWFwKCh7IG9wZXJhdGlvbiB9KSA9PiBvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnN0b3JlLmJhdGNoKG9wZXJhdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goKHsgcmVzb2x2ZSB9LCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBBcnJheS5mcm9tKGJhdGNoLmtleXMoKSkuaW5kZXhPZihrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaCgoeyByZWplY3QgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXN5bmNCYXRjaGVkU3RvcmUgaXMgaW50ZXJuYWwgYW5kIGdldHMgcGFzc2VkIGFzIGFyZ3MgaW50byB0cmFjZWQgdGFza3NcbiAgICAvLyBzb21lIEJhc2VTdG9yZXMgY29udGFpbiBjaXJjdWxhciByZWZlcmVuY2VzIHNvIGp1c3Qgc2VyaWFsaXplIHdpdGhvdXQgaXRcbiAgICAvLyBhcyB0aGlzIGNhdXNlcyB3YXJuaW5ncyB3aGVuIHRyYWNpbmcgd2l0aCBMYW5nU21pdGguXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVldWU6IHRoaXMucXVldWUsXG4gICAgICAgICAgICBuZXh0S2V5OiB0aGlzLm5leHRLZXksXG4gICAgICAgICAgICBydW5uaW5nOiB0aGlzLnJ1bm5pbmcsXG4gICAgICAgICAgICBzdG9yZTogXCJbTGFuZ0dyYXBoU3RvcmVdXCIsXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmF0Y2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/batch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/store/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncBatchedStore: () => (/* reexport safe */ _batch_js__WEBPACK_IMPORTED_MODULE_1__.AsyncBatchedStore),\n/* harmony export */   BaseStore: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseStore),\n/* harmony export */   InMemoryStore: () => (/* reexport safe */ _memory_js__WEBPACK_IMPORTED_MODULE_2__.InMemoryStore),\n/* harmony export */   InvalidNamespaceError: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.InvalidNamespaceError),\n/* harmony export */   MemoryStore: () => (/* reexport safe */ _memory_js__WEBPACK_IMPORTED_MODULE_2__.MemoryStore),\n/* harmony export */   getTextAtPath: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.getTextAtPath),\n/* harmony export */   tokenizePath: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.tokenizePath)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/base.js\");\n/* harmony import */ var _batch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./batch.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/batch.js\");\n/* harmony import */ var _memory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./memory.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/memory.js\");\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L3N0b3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDQztBQUNDO0FBQzVCIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxkaXN0XFxzdG9yZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vYmFzZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vYmF0Y2guanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21lbW9yeS5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/memory.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/store/memory.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InMemoryStore: () => (/* binding */ InMemoryStore),\n/* harmony export */   MemoryStore: () => (/* binding */ MemoryStore)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/utils.js\");\n\n\n/**\n * In-memory key-value store with optional vector search.\n *\n * A lightweight store implementation using JavaScript Maps. Supports basic\n * key-value operations and vector search when configured with embeddings.\n *\n * @example\n * ```typescript\n * // Basic key-value storage\n * const store = new InMemoryStore();\n * await store.put([\"users\", \"123\"], \"prefs\", { theme: \"dark\" });\n * const item = await store.get([\"users\", \"123\"], \"prefs\");\n *\n * // Vector search with embeddings\n * import { OpenAIEmbeddings } from \"@langchain/openai\";\n * const store = new InMemoryStore({\n *   index: {\n *     dims: 1536,\n *     embeddings: new OpenAIEmbeddings({ modelName: \"text-embedding-3-small\" }),\n *   }\n * });\n *\n * // Store documents\n * await store.put([\"docs\"], \"doc1\", { text: \"Python tutorial\" });\n * await store.put([\"docs\"], \"doc2\", { text: \"TypeScript guide\" });\n *\n * // Search by similarity\n * const results = await store.search([\"docs\"], { query: \"python programming\" });\n * ```\n *\n * @warning This store keeps all data in memory. Data is lost when the process exits.\n * For persistence, use a database-backed store.\n */\nclass InMemoryStore extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseStore {\n    constructor(options) {\n        super();\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        // Namespace -> Key -> Path/field -> Vector\n        Object.defineProperty(this, \"vectors\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"_indexConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (options?.index) {\n            this._indexConfig = {\n                ...options.index,\n                __tokenizedFields: (options.index.fields ?? [\"$\"]).map((p) => [\n                    p,\n                    p === \"$\" ? [p] : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.tokenizePath)(p),\n                ]),\n            };\n        }\n    }\n    async batch(operations) {\n        const results = [];\n        const putOps = new Map();\n        const searchOps = new Map();\n        // First pass - handle gets and prepare search/put operations\n        for (let i = 0; i < operations.length; i += 1) {\n            const op = operations[i];\n            if (\"key\" in op && \"namespace\" in op && !(\"value\" in op)) {\n                // GetOperation\n                results.push(this.getOperation(op));\n            }\n            else if (\"namespacePrefix\" in op) {\n                // SearchOperation\n                const candidates = this.filterItems(op);\n                searchOps.set(i, [op, candidates]);\n                results.push(null);\n            }\n            else if (\"value\" in op) {\n                // PutOperation\n                const key = `${op.namespace.join(\":\")}:${op.key}`;\n                putOps.set(key, op);\n                results.push(null);\n            }\n            else if (\"matchConditions\" in op) {\n                // ListNamespacesOperation\n                results.push(this.listNamespacesOperation(op));\n            }\n        }\n        // Handle search operations with embeddings\n        if (searchOps.size > 0) {\n            if (this._indexConfig?.embeddings) {\n                const queries = new Set();\n                for (const [op] of searchOps.values()) {\n                    if (op.query)\n                        queries.add(op.query);\n                }\n                // Get embeddings for all queries\n                const queryEmbeddings = queries.size > 0\n                    ? await Promise.all(Array.from(queries).map((q) => this._indexConfig.embeddings.embedQuery(q)))\n                    : [];\n                const queryVectors = Object.fromEntries(Array.from(queries).map((q, i) => [q, queryEmbeddings[i]]));\n                // Process each search operation\n                for (const [i, [op, candidates]] of searchOps.entries()) {\n                    if (op.query && queryVectors[op.query]) {\n                        const queryVector = queryVectors[op.query];\n                        const scoredResults = this.scoreResults(candidates, queryVector, op.offset ?? 0, op.limit ?? 10);\n                        results[i] = scoredResults;\n                    }\n                    else {\n                        results[i] = this.paginateResults(candidates.map((item) => ({ ...item, score: undefined })), op.offset ?? 0, op.limit ?? 10);\n                    }\n                }\n            }\n            else {\n                // No embeddings - just paginate the filtered results\n                for (const [i, [op, candidates]] of searchOps.entries()) {\n                    results[i] = this.paginateResults(candidates.map((item) => ({ ...item, score: undefined })), op.offset ?? 0, op.limit ?? 10);\n                }\n            }\n        }\n        // Handle put operations with embeddings\n        if (putOps.size > 0 && this._indexConfig?.embeddings) {\n            const toEmbed = this.extractTexts(Array.from(putOps.values()));\n            if (Object.keys(toEmbed).length > 0) {\n                const embeddings = await this._indexConfig.embeddings.embedDocuments(Object.keys(toEmbed));\n                this.insertVectors(toEmbed, embeddings);\n            }\n        }\n        // Apply all put operations\n        for (const op of putOps.values()) {\n            this.putOperation(op);\n        }\n        return results;\n    }\n    getOperation(op) {\n        const namespaceKey = op.namespace.join(\":\");\n        const item = this.data.get(namespaceKey)?.get(op.key);\n        return item ?? null;\n    }\n    putOperation(op) {\n        const namespaceKey = op.namespace.join(\":\");\n        if (!this.data.has(namespaceKey)) {\n            this.data.set(namespaceKey, new Map());\n        }\n        const namespaceMap = this.data.get(namespaceKey);\n        if (op.value === null) {\n            namespaceMap.delete(op.key);\n        }\n        else {\n            const now = new Date();\n            if (namespaceMap.has(op.key)) {\n                const item = namespaceMap.get(op.key);\n                item.value = op.value;\n                item.updatedAt = now;\n            }\n            else {\n                namespaceMap.set(op.key, {\n                    value: op.value,\n                    key: op.key,\n                    namespace: op.namespace,\n                    createdAt: now,\n                    updatedAt: now,\n                });\n            }\n        }\n    }\n    listNamespacesOperation(op) {\n        const allNamespaces = Array.from(this.data.keys()).map((ns) => ns.split(\":\"));\n        let namespaces = allNamespaces;\n        if (op.matchConditions && op.matchConditions.length > 0) {\n            namespaces = namespaces.filter((ns) => op.matchConditions.every((condition) => this.doesMatch(condition, ns)));\n        }\n        if (op.maxDepth !== undefined) {\n            namespaces = Array.from(new Set(namespaces.map((ns) => ns.slice(0, op.maxDepth).join(\":\")))).map((ns) => ns.split(\":\"));\n        }\n        namespaces.sort((a, b) => a.join(\":\").localeCompare(b.join(\":\")));\n        return namespaces.slice(op.offset ?? 0, (op.offset ?? 0) + (op.limit ?? namespaces.length));\n    }\n    doesMatch(matchCondition, key) {\n        const { matchType, path } = matchCondition;\n        if (matchType === \"prefix\") {\n            if (path.length > key.length)\n                return false;\n            return path.every((pElem, index) => {\n                const kElem = key[index];\n                return pElem === \"*\" || kElem === pElem;\n            });\n        }\n        else if (matchType === \"suffix\") {\n            if (path.length > key.length)\n                return false;\n            return path.every((pElem, index) => {\n                const kElem = key[key.length - path.length + index];\n                return pElem === \"*\" || kElem === pElem;\n            });\n        }\n        throw new Error(`Unsupported match type: ${matchType}`);\n    }\n    filterItems(op) {\n        const candidates = [];\n        for (const [namespace, items] of this.data.entries()) {\n            if (namespace.startsWith(op.namespacePrefix.join(\":\"))) {\n                candidates.push(...items.values());\n            }\n        }\n        let filteredCandidates = candidates;\n        if (op.filter) {\n            filteredCandidates = candidates.filter((item) => Object.entries(op.filter).every(([key, value]) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.compareValues)(item.value[key], value)));\n        }\n        return filteredCandidates;\n    }\n    scoreResults(candidates, queryVector, offset = 0, limit = 10) {\n        const flatItems = [];\n        const flatVectors = [];\n        const scoreless = [];\n        for (const item of candidates) {\n            const vectors = this.getVectors(item);\n            if (vectors.length) {\n                for (const vector of vectors) {\n                    flatItems.push(item);\n                    flatVectors.push(vector);\n                }\n            }\n            else {\n                scoreless.push(item);\n            }\n        }\n        const scores = this.cosineSimilarity(queryVector, flatVectors);\n        const sortedResults = scores\n            .map((score, i) => [score, flatItems[i]])\n            .sort((a, b) => b[0] - a[0]);\n        const seen = new Set();\n        const kept = [];\n        for (const [score, item] of sortedResults) {\n            const key = `${item.namespace.join(\":\")}:${item.key}`;\n            if (seen.has(key))\n                continue;\n            const ix = seen.size;\n            if (ix >= offset + limit)\n                break;\n            if (ix < offset) {\n                seen.add(key);\n                continue;\n            }\n            seen.add(key);\n            kept.push([score, item]);\n        }\n        if (scoreless.length && kept.length < limit) {\n            for (const item of scoreless.slice(0, limit - kept.length)) {\n                const key = `${item.namespace.join(\":\")}:${item.key}`;\n                if (!seen.has(key)) {\n                    seen.add(key);\n                    kept.push([undefined, item]);\n                }\n            }\n        }\n        return kept.map(([score, item]) => ({\n            ...item,\n            score,\n        }));\n    }\n    paginateResults(results, offset, limit) {\n        return results.slice(offset, offset + limit);\n    }\n    extractTexts(ops) {\n        if (!ops.length || !this._indexConfig) {\n            return {};\n        }\n        const toEmbed = {};\n        for (const op of ops) {\n            if (op.value !== null && op.index !== false) {\n                const paths = op.index === null || op.index === undefined\n                    ? this._indexConfig.__tokenizedFields ?? []\n                    : op.index.map((ix) => [ix, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.tokenizePath)(ix)]);\n                for (const [path, field] of paths) {\n                    const texts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getTextAtPath)(op.value, field);\n                    if (texts.length) {\n                        if (texts.length > 1) {\n                            texts.forEach((text, i) => {\n                                if (!toEmbed[text])\n                                    toEmbed[text] = [];\n                                toEmbed[text].push([op.namespace, op.key, `${path}.${i}`]);\n                            });\n                        }\n                        else {\n                            if (!toEmbed[texts[0]])\n                                toEmbed[texts[0]] = [];\n                            toEmbed[texts[0]].push([op.namespace, op.key, path]);\n                        }\n                    }\n                }\n            }\n        }\n        return toEmbed;\n    }\n    insertVectors(texts, embeddings) {\n        for (const [text, metadata] of Object.entries(texts)) {\n            const embedding = embeddings.shift();\n            if (!embedding) {\n                throw new Error(`No embedding found for text: ${text}`);\n            }\n            for (const [namespace, key, field] of metadata) {\n                const namespaceKey = namespace.join(\":\");\n                if (!this.vectors.has(namespaceKey)) {\n                    this.vectors.set(namespaceKey, new Map());\n                }\n                const namespaceMap = this.vectors.get(namespaceKey);\n                if (!namespaceMap.has(key)) {\n                    namespaceMap.set(key, new Map());\n                }\n                const itemMap = namespaceMap.get(key);\n                itemMap.set(field, embedding);\n            }\n        }\n    }\n    getVectors(item) {\n        const namespaceKey = item.namespace.join(\":\");\n        const itemKey = item.key;\n        if (!this.vectors.has(namespaceKey)) {\n            return [];\n        }\n        const namespaceMap = this.vectors.get(namespaceKey);\n        if (!namespaceMap.has(itemKey)) {\n            return [];\n        }\n        const itemMap = namespaceMap.get(itemKey);\n        const vectors = Array.from(itemMap.values());\n        if (!vectors.length) {\n            return [];\n        }\n        return vectors;\n    }\n    cosineSimilarity(X, Y) {\n        if (!Y.length)\n            return [];\n        // Calculate dot products for all vectors at once\n        const dotProducts = Y.map((vector) => vector.reduce((acc, val, i) => acc + val * X[i], 0));\n        // Calculate magnitudes\n        const magnitude1 = Math.sqrt(X.reduce((acc, val) => acc + val * val, 0));\n        const magnitudes2 = Y.map((vector) => Math.sqrt(vector.reduce((acc, val) => acc + val * val, 0)));\n        // Calculate similarities\n        return dotProducts.map((dot, i) => {\n            const magnitude2 = magnitudes2[i];\n            return magnitude1 && magnitude2 ? dot / (magnitude1 * magnitude2) : 0;\n        });\n    }\n    get indexConfig() {\n        return this._indexConfig;\n    }\n}\n/** @deprecated Alias for InMemoryStore */\nclass MemoryStore extends InMemoryStore {\n}\n//# sourceMappingURL=memory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L3N0b3JlL21lbW9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVDO0FBQ2lDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFDQUFxQztBQUMvRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsdUNBQXVDLHlCQUF5QjtBQUNoRSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQSxrREFBa0QsNkJBQTZCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsK0NBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1REFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QixHQUFHLE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRiwyQkFBMkI7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLDJCQUEyQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHLHdEQUFhO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCLEdBQUcsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QixHQUFHLFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVEQUFZO0FBQzVEO0FBQ0Esa0NBQWtDLHdEQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsS0FBSyxHQUFHLEVBQUU7QUFDdkYsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLEtBQUs7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoLWNoZWNrcG9pbnRcXGRpc3RcXHN0b3JlXFxtZW1vcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZVN0b3JlLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IHRva2VuaXplUGF0aCwgY29tcGFyZVZhbHVlcywgZ2V0VGV4dEF0UGF0aCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKipcbiAqIEluLW1lbW9yeSBrZXktdmFsdWUgc3RvcmUgd2l0aCBvcHRpb25hbCB2ZWN0b3Igc2VhcmNoLlxuICpcbiAqIEEgbGlnaHR3ZWlnaHQgc3RvcmUgaW1wbGVtZW50YXRpb24gdXNpbmcgSmF2YVNjcmlwdCBNYXBzLiBTdXBwb3J0cyBiYXNpY1xuICoga2V5LXZhbHVlIG9wZXJhdGlvbnMgYW5kIHZlY3RvciBzZWFyY2ggd2hlbiBjb25maWd1cmVkIHdpdGggZW1iZWRkaW5ncy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gQmFzaWMga2V5LXZhbHVlIHN0b3JhZ2VcbiAqIGNvbnN0IHN0b3JlID0gbmV3IEluTWVtb3J5U3RvcmUoKTtcbiAqIGF3YWl0IHN0b3JlLnB1dChbXCJ1c2Vyc1wiLCBcIjEyM1wiXSwgXCJwcmVmc1wiLCB7IHRoZW1lOiBcImRhcmtcIiB9KTtcbiAqIGNvbnN0IGl0ZW0gPSBhd2FpdCBzdG9yZS5nZXQoW1widXNlcnNcIiwgXCIxMjNcIl0sIFwicHJlZnNcIik7XG4gKlxuICogLy8gVmVjdG9yIHNlYXJjaCB3aXRoIGVtYmVkZGluZ3NcbiAqIGltcG9ydCB7IE9wZW5BSUVtYmVkZGluZ3MgfSBmcm9tIFwiQGxhbmdjaGFpbi9vcGVuYWlcIjtcbiAqIGNvbnN0IHN0b3JlID0gbmV3IEluTWVtb3J5U3RvcmUoe1xuICogICBpbmRleDoge1xuICogICAgIGRpbXM6IDE1MzYsXG4gKiAgICAgZW1iZWRkaW5nczogbmV3IE9wZW5BSUVtYmVkZGluZ3MoeyBtb2RlbE5hbWU6IFwidGV4dC1lbWJlZGRpbmctMy1zbWFsbFwiIH0pLFxuICogICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBTdG9yZSBkb2N1bWVudHNcbiAqIGF3YWl0IHN0b3JlLnB1dChbXCJkb2NzXCJdLCBcImRvYzFcIiwgeyB0ZXh0OiBcIlB5dGhvbiB0dXRvcmlhbFwiIH0pO1xuICogYXdhaXQgc3RvcmUucHV0KFtcImRvY3NcIl0sIFwiZG9jMlwiLCB7IHRleHQ6IFwiVHlwZVNjcmlwdCBndWlkZVwiIH0pO1xuICpcbiAqIC8vIFNlYXJjaCBieSBzaW1pbGFyaXR5XG4gKiBjb25zdCByZXN1bHRzID0gYXdhaXQgc3RvcmUuc2VhcmNoKFtcImRvY3NcIl0sIHsgcXVlcnk6IFwicHl0aG9uIHByb2dyYW1taW5nXCIgfSk7XG4gKiBgYGBcbiAqXG4gKiBAd2FybmluZyBUaGlzIHN0b3JlIGtlZXBzIGFsbCBkYXRhIGluIG1lbW9yeS4gRGF0YSBpcyBsb3N0IHdoZW4gdGhlIHByb2Nlc3MgZXhpdHMuXG4gKiBGb3IgcGVyc2lzdGVuY2UsIHVzZSBhIGRhdGFiYXNlLWJhY2tlZCBzdG9yZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluTWVtb3J5U3RvcmUgZXh0ZW5kcyBCYXNlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOYW1lc3BhY2UgLT4gS2V5IC0+IFBhdGgvZmllbGQgLT4gVmVjdG9yXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlY3RvcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2luZGV4Q29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRpb25zPy5pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5faW5kZXhDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5pbmRleCxcbiAgICAgICAgICAgICAgICBfX3Rva2VuaXplZEZpZWxkczogKG9wdGlvbnMuaW5kZXguZmllbGRzID8/IFtcIiRcIl0pLm1hcCgocCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICBwLFxuICAgICAgICAgICAgICAgICAgICBwID09PSBcIiRcIiA/IFtwXSA6IHRva2VuaXplUGF0aChwKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYmF0Y2gob3BlcmF0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IHB1dE9wcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3Qgc2VhcmNoT3BzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBGaXJzdCBwYXNzIC0gaGFuZGxlIGdldHMgYW5kIHByZXBhcmUgc2VhcmNoL3B1dCBvcGVyYXRpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3Qgb3AgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKFwia2V5XCIgaW4gb3AgJiYgXCJuYW1lc3BhY2VcIiBpbiBvcCAmJiAhKFwidmFsdWVcIiBpbiBvcCkpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXRPcGVyYXRpb25cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5nZXRPcGVyYXRpb24ob3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwibmFtZXNwYWNlUHJlZml4XCIgaW4gb3ApIHtcbiAgICAgICAgICAgICAgICAvLyBTZWFyY2hPcGVyYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gdGhpcy5maWx0ZXJJdGVtcyhvcCk7XG4gICAgICAgICAgICAgICAgc2VhcmNoT3BzLnNldChpLCBbb3AsIGNhbmRpZGF0ZXNdKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcInZhbHVlXCIgaW4gb3ApIHtcbiAgICAgICAgICAgICAgICAvLyBQdXRPcGVyYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtvcC5uYW1lc3BhY2Uuam9pbihcIjpcIil9OiR7b3Aua2V5fWA7XG4gICAgICAgICAgICAgICAgcHV0T3BzLnNldChrZXksIG9wKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcIm1hdGNoQ29uZGl0aW9uc1wiIGluIG9wKSB7XG4gICAgICAgICAgICAgICAgLy8gTGlzdE5hbWVzcGFjZXNPcGVyYXRpb25cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5saXN0TmFtZXNwYWNlc09wZXJhdGlvbihvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBzZWFyY2ggb3BlcmF0aW9ucyB3aXRoIGVtYmVkZGluZ3NcbiAgICAgICAgaWYgKHNlYXJjaE9wcy5zaXplID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4Q29uZmlnPy5lbWJlZGRpbmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtvcF0gb2Ygc2VhcmNoT3BzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcC5xdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZXMuYWRkKG9wLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR2V0IGVtYmVkZGluZ3MgZm9yIGFsbCBxdWVyaWVzXG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlFbWJlZGRpbmdzID0gcXVlcmllcy5zaXplID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IFByb21pc2UuYWxsKEFycmF5LmZyb20ocXVlcmllcykubWFwKChxKSA9PiB0aGlzLl9pbmRleENvbmZpZy5lbWJlZGRpbmdzLmVtYmVkUXVlcnkocSkpKVxuICAgICAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VmVjdG9ycyA9IE9iamVjdC5mcm9tRW50cmllcyhBcnJheS5mcm9tKHF1ZXJpZXMpLm1hcCgocSwgaSkgPT4gW3EsIHF1ZXJ5RW1iZWRkaW5nc1tpXV0pKTtcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggc2VhcmNoIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ksIFtvcCwgY2FuZGlkYXRlc11dIG9mIHNlYXJjaE9wcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnF1ZXJ5ICYmIHF1ZXJ5VmVjdG9yc1tvcC5xdWVyeV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VmVjdG9yID0gcXVlcnlWZWN0b3JzW29wLnF1ZXJ5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlZFJlc3VsdHMgPSB0aGlzLnNjb3JlUmVzdWx0cyhjYW5kaWRhdGVzLCBxdWVyeVZlY3Rvciwgb3Aub2Zmc2V0ID8/IDAsIG9wLmxpbWl0ID8/IDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBzY29yZWRSZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHRoaXMucGFnaW5hdGVSZXN1bHRzKGNhbmRpZGF0ZXMubWFwKChpdGVtKSA9PiAoeyAuLi5pdGVtLCBzY29yZTogdW5kZWZpbmVkIH0pKSwgb3Aub2Zmc2V0ID8/IDAsIG9wLmxpbWl0ID8/IDEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIGVtYmVkZGluZ3MgLSBqdXN0IHBhZ2luYXRlIHRoZSBmaWx0ZXJlZCByZXN1bHRzXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaSwgW29wLCBjYW5kaWRhdGVzXV0gb2Ygc2VhcmNoT3BzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gdGhpcy5wYWdpbmF0ZVJlc3VsdHMoY2FuZGlkYXRlcy5tYXAoKGl0ZW0pID0+ICh7IC4uLml0ZW0sIHNjb3JlOiB1bmRlZmluZWQgfSkpLCBvcC5vZmZzZXQgPz8gMCwgb3AubGltaXQgPz8gMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgcHV0IG9wZXJhdGlvbnMgd2l0aCBlbWJlZGRpbmdzXG4gICAgICAgIGlmIChwdXRPcHMuc2l6ZSA+IDAgJiYgdGhpcy5faW5kZXhDb25maWc/LmVtYmVkZGluZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvRW1iZWQgPSB0aGlzLmV4dHJhY3RUZXh0cyhBcnJheS5mcm9tKHB1dE9wcy52YWx1ZXMoKSkpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRvRW1iZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzID0gYXdhaXQgdGhpcy5faW5kZXhDb25maWcuZW1iZWRkaW5ncy5lbWJlZERvY3VtZW50cyhPYmplY3Qua2V5cyh0b0VtYmVkKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRWZWN0b3JzKHRvRW1iZWQsIGVtYmVkZGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGx5IGFsbCBwdXQgb3BlcmF0aW9uc1xuICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIHB1dE9wcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdGhpcy5wdXRPcGVyYXRpb24ob3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBnZXRPcGVyYXRpb24ob3ApIHtcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlS2V5ID0gb3AubmFtZXNwYWNlLmpvaW4oXCI6XCIpO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5kYXRhLmdldChuYW1lc3BhY2VLZXkpPy5nZXQob3Aua2V5KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPz8gbnVsbDtcbiAgICB9XG4gICAgcHV0T3BlcmF0aW9uKG9wKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZUtleSA9IG9wLm5hbWVzcGFjZS5qb2luKFwiOlwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGEuaGFzKG5hbWVzcGFjZUtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQobmFtZXNwYWNlS2V5LCBuZXcgTWFwKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZU1hcCA9IHRoaXMuZGF0YS5nZXQobmFtZXNwYWNlS2V5KTtcbiAgICAgICAgaWYgKG9wLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2VNYXAuZGVsZXRlKG9wLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZU1hcC5oYXMob3Aua2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuYW1lc3BhY2VNYXAuZ2V0KG9wLmtleSk7XG4gICAgICAgICAgICAgICAgaXRlbS52YWx1ZSA9IG9wLnZhbHVlO1xuICAgICAgICAgICAgICAgIGl0ZW0udXBkYXRlZEF0ID0gbm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlTWFwLnNldChvcC5rZXksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9wLmtleSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBvcC5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5vdyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsaXN0TmFtZXNwYWNlc09wZXJhdGlvbihvcCkge1xuICAgICAgICBjb25zdCBhbGxOYW1lc3BhY2VzID0gQXJyYXkuZnJvbSh0aGlzLmRhdGEua2V5cygpKS5tYXAoKG5zKSA9PiBucy5zcGxpdChcIjpcIikpO1xuICAgICAgICBsZXQgbmFtZXNwYWNlcyA9IGFsbE5hbWVzcGFjZXM7XG4gICAgICAgIGlmIChvcC5tYXRjaENvbmRpdGlvbnMgJiYgb3AubWF0Y2hDb25kaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzLmZpbHRlcigobnMpID0+IG9wLm1hdGNoQ29uZGl0aW9ucy5ldmVyeSgoY29uZGl0aW9uKSA9PiB0aGlzLmRvZXNNYXRjaChjb25kaXRpb24sIG5zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5tYXhEZXB0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2VzID0gQXJyYXkuZnJvbShuZXcgU2V0KG5hbWVzcGFjZXMubWFwKChucykgPT4gbnMuc2xpY2UoMCwgb3AubWF4RGVwdGgpLmpvaW4oXCI6XCIpKSkpLm1hcCgobnMpID0+IG5zLnNwbGl0KFwiOlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXNwYWNlcy5zb3J0KChhLCBiKSA9PiBhLmpvaW4oXCI6XCIpLmxvY2FsZUNvbXBhcmUoYi5qb2luKFwiOlwiKSkpO1xuICAgICAgICByZXR1cm4gbmFtZXNwYWNlcy5zbGljZShvcC5vZmZzZXQgPz8gMCwgKG9wLm9mZnNldCA/PyAwKSArIChvcC5saW1pdCA/PyBuYW1lc3BhY2VzLmxlbmd0aCkpO1xuICAgIH1cbiAgICBkb2VzTWF0Y2gobWF0Y2hDb25kaXRpb24sIGtleSkge1xuICAgICAgICBjb25zdCB7IG1hdGNoVHlwZSwgcGF0aCB9ID0gbWF0Y2hDb25kaXRpb247XG4gICAgICAgIGlmIChtYXRjaFR5cGUgPT09IFwicHJlZml4XCIpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IGtleS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGguZXZlcnkoKHBFbGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtFbGVtID0ga2V5W2luZGV4XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcEVsZW0gPT09IFwiKlwiIHx8IGtFbGVtID09PSBwRWxlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoVHlwZSA9PT0gXCJzdWZmaXhcIikge1xuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4ga2V5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5ldmVyeSgocEVsZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qga0VsZW0gPSBrZXlba2V5Lmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgaW5kZXhdO1xuICAgICAgICAgICAgICAgIHJldHVybiBwRWxlbSA9PT0gXCIqXCIgfHwga0VsZW0gPT09IHBFbGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtYXRjaCB0eXBlOiAke21hdGNoVHlwZX1gKTtcbiAgICB9XG4gICAgZmlsdGVySXRlbXMob3ApIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lc3BhY2UsIGl0ZW1zXSBvZiB0aGlzLmRhdGEuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlLnN0YXJ0c1dpdGgob3AubmFtZXNwYWNlUHJlZml4LmpvaW4oXCI6XCIpKSkge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5pdGVtcy52YWx1ZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbHRlcmVkQ2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChvcC5maWx0ZXIpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkQ2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKChpdGVtKSA9PiBPYmplY3QuZW50cmllcyhvcC5maWx0ZXIpLmV2ZXJ5KChba2V5LCB2YWx1ZV0pID0+IGNvbXBhcmVWYWx1ZXMoaXRlbS52YWx1ZVtrZXldLCB2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyZWRDYW5kaWRhdGVzO1xuICAgIH1cbiAgICBzY29yZVJlc3VsdHMoY2FuZGlkYXRlcywgcXVlcnlWZWN0b3IsIG9mZnNldCA9IDAsIGxpbWl0ID0gMTApIHtcbiAgICAgICAgY29uc3QgZmxhdEl0ZW1zID0gW107XG4gICAgICAgIGNvbnN0IGZsYXRWZWN0b3JzID0gW107XG4gICAgICAgIGNvbnN0IHNjb3JlbGVzcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2FuZGlkYXRlcykge1xuICAgICAgICAgICAgY29uc3QgdmVjdG9ycyA9IHRoaXMuZ2V0VmVjdG9ycyhpdGVtKTtcbiAgICAgICAgICAgIGlmICh2ZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmVjdG9yIG9mIHZlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhdEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGZsYXRWZWN0b3JzLnB1c2godmVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY29yZWxlc3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY29yZXMgPSB0aGlzLmNvc2luZVNpbWlsYXJpdHkocXVlcnlWZWN0b3IsIGZsYXRWZWN0b3JzKTtcbiAgICAgICAgY29uc3Qgc29ydGVkUmVzdWx0cyA9IHNjb3Jlc1xuICAgICAgICAgICAgLm1hcCgoc2NvcmUsIGkpID0+IFtzY29yZSwgZmxhdEl0ZW1zW2ldXSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSk7XG4gICAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGtlcHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbc2NvcmUsIGl0ZW1dIG9mIHNvcnRlZFJlc3VsdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2l0ZW0ubmFtZXNwYWNlLmpvaW4oXCI6XCIpfToke2l0ZW0ua2V5fWA7XG4gICAgICAgICAgICBpZiAoc2Vlbi5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGl4ID0gc2Vlbi5zaXplO1xuICAgICAgICAgICAgaWYgKGl4ID49IG9mZnNldCArIGxpbWl0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGl4IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgICAgICBrZXB0LnB1c2goW3Njb3JlLCBpdGVtXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3JlbGVzcy5sZW5ndGggJiYga2VwdC5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNjb3JlbGVzcy5zbGljZSgwLCBsaW1pdCAtIGtlcHQubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2l0ZW0ubmFtZXNwYWNlLmpvaW4oXCI6XCIpfToke2l0ZW0ua2V5fWA7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGtlcHQucHVzaChbdW5kZWZpbmVkLCBpdGVtXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXB0Lm1hcCgoW3Njb3JlLCBpdGVtXSkgPT4gKHtcbiAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBwYWdpbmF0ZVJlc3VsdHMocmVzdWx0cywgb2Zmc2V0LCBsaW1pdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGxpbWl0KTtcbiAgICB9XG4gICAgZXh0cmFjdFRleHRzKG9wcykge1xuICAgICAgICBpZiAoIW9wcy5sZW5ndGggfHwgIXRoaXMuX2luZGV4Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9FbWJlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgaWYgKG9wLnZhbHVlICE9PSBudWxsICYmIG9wLmluZGV4ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhzID0gb3AuaW5kZXggPT09IG51bGwgfHwgb3AuaW5kZXggPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX2luZGV4Q29uZmlnLl9fdG9rZW5pemVkRmllbGRzID8/IFtdXG4gICAgICAgICAgICAgICAgICAgIDogb3AuaW5kZXgubWFwKChpeCkgPT4gW2l4LCB0b2tlbml6ZVBhdGgoaXgpXSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbcGF0aCwgZmllbGRdIG9mIHBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRzID0gZ2V0VGV4dEF0UGF0aChvcC52YWx1ZSwgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRzLmZvckVhY2goKHRleHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0b0VtYmVkW3RleHRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9FbWJlZFt0ZXh0XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0VtYmVkW3RleHRdLnB1c2goW29wLm5hbWVzcGFjZSwgb3Aua2V5LCBgJHtwYXRofS4ke2l9YF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0b0VtYmVkW3RleHRzWzBdXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9FbWJlZFt0ZXh0c1swXV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0VtYmVkW3RleHRzWzBdXS5wdXNoKFtvcC5uYW1lc3BhY2UsIG9wLmtleSwgcGF0aF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0VtYmVkO1xuICAgIH1cbiAgICBpbnNlcnRWZWN0b3JzKHRleHRzLCBlbWJlZGRpbmdzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3RleHQsIG1ldGFkYXRhXSBvZiBPYmplY3QuZW50cmllcyh0ZXh0cykpIHtcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZyA9IGVtYmVkZGluZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghZW1iZWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBlbWJlZGRpbmcgZm91bmQgZm9yIHRleHQ6ICR7dGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWVzcGFjZSwga2V5LCBmaWVsZF0gb2YgbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lc3BhY2VLZXkgPSBuYW1lc3BhY2Uuam9pbihcIjpcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZlY3RvcnMuaGFzKG5hbWVzcGFjZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZWN0b3JzLnNldChuYW1lc3BhY2VLZXksIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZU1hcCA9IHRoaXMudmVjdG9ycy5nZXQobmFtZXNwYWNlS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWVzcGFjZU1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VNYXAuc2V0KGtleSwgbmV3IE1hcCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbU1hcCA9IG5hbWVzcGFjZU1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpdGVtTWFwLnNldChmaWVsZCwgZW1iZWRkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRWZWN0b3JzKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlS2V5ID0gaXRlbS5uYW1lc3BhY2Uuam9pbihcIjpcIik7XG4gICAgICAgIGNvbnN0IGl0ZW1LZXkgPSBpdGVtLmtleTtcbiAgICAgICAgaWYgKCF0aGlzLnZlY3RvcnMuaGFzKG5hbWVzcGFjZUtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lc3BhY2VNYXAgPSB0aGlzLnZlY3RvcnMuZ2V0KG5hbWVzcGFjZUtleSk7XG4gICAgICAgIGlmICghbmFtZXNwYWNlTWFwLmhhcyhpdGVtS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1NYXAgPSBuYW1lc3BhY2VNYXAuZ2V0KGl0ZW1LZXkpO1xuICAgICAgICBjb25zdCB2ZWN0b3JzID0gQXJyYXkuZnJvbShpdGVtTWFwLnZhbHVlcygpKTtcbiAgICAgICAgaWYgKCF2ZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZWN0b3JzO1xuICAgIH1cbiAgICBjb3NpbmVTaW1pbGFyaXR5KFgsIFkpIHtcbiAgICAgICAgaWYgKCFZLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRvdCBwcm9kdWN0cyBmb3IgYWxsIHZlY3RvcnMgYXQgb25jZVxuICAgICAgICBjb25zdCBkb3RQcm9kdWN0cyA9IFkubWFwKCh2ZWN0b3IpID0+IHZlY3Rvci5yZWR1Y2UoKGFjYywgdmFsLCBpKSA9PiBhY2MgKyB2YWwgKiBYW2ldLCAwKSk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBtYWduaXR1ZGVzXG4gICAgICAgIGNvbnN0IG1hZ25pdHVkZTEgPSBNYXRoLnNxcnQoWC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbiAgICAgICAgY29uc3QgbWFnbml0dWRlczIgPSBZLm1hcCgodmVjdG9yKSA9PiBNYXRoLnNxcnQodmVjdG9yLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCAqIHZhbCwgMCkpKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNpbWlsYXJpdGllc1xuICAgICAgICByZXR1cm4gZG90UHJvZHVjdHMubWFwKChkb3QsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hZ25pdHVkZTIgPSBtYWduaXR1ZGVzMltpXTtcbiAgICAgICAgICAgIHJldHVybiBtYWduaXR1ZGUxICYmIG1hZ25pdHVkZTIgPyBkb3QgLyAobWFnbml0dWRlMSAqIG1hZ25pdHVkZTIpIDogMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpbmRleENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4Q29uZmlnO1xuICAgIH1cbn1cbi8qKiBAZGVwcmVjYXRlZCBBbGlhcyBmb3IgSW5NZW1vcnlTdG9yZSAqL1xuZXhwb3J0IGNsYXNzIE1lbW9yeVN0b3JlIGV4dGVuZHMgSW5NZW1vcnlTdG9yZSB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/memory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/store/utils.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareValues: () => (/* binding */ compareValues),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   getTextAtPath: () => (/* binding */ getTextAtPath),\n/* harmony export */   tokenizePath: () => (/* binding */ tokenizePath)\n/* harmony export */ });\n/**\n * Tokenize a JSON path into parts.\n * @example\n * tokenizePath(\"metadata.title\") // -> [\"metadata\", \"title\"]\n * tokenizePath(\"chapters[*].content\") // -> [\"chapters[*]\", \"content\"]\n */\nfunction tokenizePath(path) {\n    if (!path) {\n        return [];\n    }\n    const tokens = [];\n    let current = [];\n    let i = 0;\n    while (i < path.length) {\n        const char = path[i];\n        if (char === \"[\") {\n            // Handle array index\n            if (current.length) {\n                tokens.push(current.join(\"\"));\n                current = [];\n            }\n            let bracketCount = 1;\n            const indexChars = [\"[\"];\n            i += 1;\n            while (i < path.length && bracketCount > 0) {\n                if (path[i] === \"[\") {\n                    bracketCount += 1;\n                }\n                else if (path[i] === \"]\") {\n                    bracketCount -= 1;\n                }\n                indexChars.push(path[i]);\n                i += 1;\n            }\n            tokens.push(indexChars.join(\"\"));\n            continue;\n        }\n        else if (char === \"{\") {\n            // Handle multi-field selection\n            if (current.length) {\n                tokens.push(current.join(\"\"));\n                current = [];\n            }\n            let braceCount = 1;\n            const fieldChars = [\"{\"];\n            i += 1;\n            while (i < path.length && braceCount > 0) {\n                if (path[i] === \"{\") {\n                    braceCount += 1;\n                }\n                else if (path[i] === \"}\") {\n                    braceCount -= 1;\n                }\n                fieldChars.push(path[i]);\n                i += 1;\n            }\n            tokens.push(fieldChars.join(\"\"));\n            continue;\n        }\n        else if (char === \".\") {\n            // Handle regular field\n            if (current.length) {\n                tokens.push(current.join(\"\"));\n                current = [];\n            }\n        }\n        else {\n            current.push(char);\n        }\n        i += 1;\n    }\n    if (current.length) {\n        tokens.push(current.join(\"\"));\n    }\n    return tokens;\n}\n/**\n * Type guard to check if an object is a FilterOperators\n */\nfunction isFilterOperators(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        Object.keys(obj).every((key) => key === \"$eq\" ||\n            key === \"$ne\" ||\n            key === \"$gt\" ||\n            key === \"$gte\" ||\n            key === \"$lt\" ||\n            key === \"$lte\" ||\n            key === \"$in\" ||\n            key === \"$nin\"));\n}\n/**\n * Compare values for filtering, supporting operator-based comparisons.\n */\nfunction compareValues(itemValue, filterValue) {\n    if (isFilterOperators(filterValue)) {\n        const operators = Object.keys(filterValue).filter((k) => k.startsWith(\"$\"));\n        return operators.every((op) => {\n            const value = filterValue[op];\n            switch (op) {\n                case \"$eq\":\n                    return itemValue === value;\n                case \"$ne\":\n                    return itemValue !== value;\n                case \"$gt\":\n                    return Number(itemValue) > Number(value);\n                case \"$gte\":\n                    return Number(itemValue) >= Number(value);\n                case \"$lt\":\n                    return Number(itemValue) < Number(value);\n                case \"$lte\":\n                    return Number(itemValue) <= Number(value);\n                case \"$in\":\n                    return Array.isArray(value) ? value.includes(itemValue) : false;\n                case \"$nin\":\n                    return Array.isArray(value) ? !value.includes(itemValue) : true;\n                default:\n                    return false;\n            }\n        });\n    }\n    // If no operators, do a direct comparison\n    return itemValue === filterValue;\n}\n/**\n * Extract text from a value at a specific JSON path.\n *\n * Supports:\n * - Simple paths: \"field1.field2\"\n * - Array indexing: \"[0]\", \"[*]\", \"[-1]\"\n * - Wildcards: \"*\"\n * - Multi-field selection: \"{field1,field2}\"\n * - Nested paths in multi-field: \"{field1,nested.field2}\"\n */\nfunction getTextAtPath(obj, path) {\n    if (!path || path === \"$\") {\n        return [JSON.stringify(obj, null, 2)];\n    }\n    const tokens = Array.isArray(path) ? path : tokenizePath(path);\n    function extractFromObj(obj, tokens, pos) {\n        if (pos >= tokens.length) {\n            if (typeof obj === \"string\" ||\n                typeof obj === \"number\" ||\n                typeof obj === \"boolean\") {\n                return [String(obj)];\n            }\n            if (obj === null || obj === undefined) {\n                return [];\n            }\n            if (Array.isArray(obj) || typeof obj === \"object\") {\n                return [JSON.stringify(obj, null, 2)];\n            }\n            return [];\n        }\n        const token = tokens[pos];\n        const results = [];\n        if (pos === 0 && token === \"$\") {\n            results.push(JSON.stringify(obj, null, 2));\n        }\n        if (token.startsWith(\"[\") && token.endsWith(\"]\")) {\n            if (!Array.isArray(obj))\n                return [];\n            const index = token.slice(1, -1);\n            if (index === \"*\") {\n                for (const item of obj) {\n                    results.push(...extractFromObj(item, tokens, pos + 1));\n                }\n            }\n            else {\n                try {\n                    let idx = parseInt(index, 10);\n                    if (idx < 0) {\n                        idx = obj.length + idx;\n                    }\n                    if (idx >= 0 && idx < obj.length) {\n                        results.push(...extractFromObj(obj[idx], tokens, pos + 1));\n                    }\n                }\n                catch {\n                    return [];\n                }\n            }\n        }\n        else if (token.startsWith(\"{\") && token.endsWith(\"}\")) {\n            if (typeof obj !== \"object\" || obj === null)\n                return [];\n            const fields = token\n                .slice(1, -1)\n                .split(\",\")\n                .map((f) => f.trim());\n            for (const field of fields) {\n                const nestedTokens = tokenizePath(field);\n                if (nestedTokens.length) {\n                    let currentObj = obj;\n                    for (const nestedToken of nestedTokens) {\n                        if (currentObj &&\n                            typeof currentObj === \"object\" &&\n                            nestedToken in currentObj) {\n                            currentObj = currentObj[nestedToken];\n                        }\n                        else {\n                            currentObj = undefined;\n                            break;\n                        }\n                    }\n                    if (currentObj !== undefined) {\n                        if (typeof currentObj === \"string\" ||\n                            typeof currentObj === \"number\" ||\n                            typeof currentObj === \"boolean\") {\n                            results.push(String(currentObj));\n                        }\n                        else if (Array.isArray(currentObj) ||\n                            typeof currentObj === \"object\") {\n                            results.push(JSON.stringify(currentObj, null, 2));\n                        }\n                    }\n                }\n            }\n        }\n        else if (token === \"*\") {\n            if (Array.isArray(obj)) {\n                for (const item of obj) {\n                    results.push(...extractFromObj(item, tokens, pos + 1));\n                }\n            }\n            else if (typeof obj === \"object\" && obj !== null) {\n                for (const value of Object.values(obj)) {\n                    results.push(...extractFromObj(value, tokens, pos + 1));\n                }\n            }\n        }\n        else {\n            if (typeof obj === \"object\" && obj !== null && token in obj) {\n                results.push(...extractFromObj(obj[token], tokens, pos + 1));\n            }\n        }\n        return results;\n    }\n    return extractFromObj(obj, tokens, 0);\n}\n/**\n * Calculate cosine similarity between two vectors.\n */\nfunction cosineSimilarity(vector1, vector2) {\n    if (vector1.length !== vector2.length) {\n        throw new Error(\"Vectors must have the same length\");\n    }\n    const dotProduct = vector1.reduce((acc, val, i) => acc + val * vector2[i], 0);\n    const magnitude1 = Math.sqrt(vector1.reduce((acc, val) => acc + val * val, 0));\n    const magnitude2 = Math.sqrt(vector2.reduce((acc, val) => acc + val * val, 0));\n    if (magnitude1 === 0 || magnitude2 === 0)\n        return 0;\n    return dotProduct / (magnitude1 * magnitude2);\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L3N0b3JlL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGgtY2hlY2twb2ludFxcZGlzdFxcc3RvcmVcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVG9rZW5pemUgYSBKU09OIHBhdGggaW50byBwYXJ0cy5cbiAqIEBleGFtcGxlXG4gKiB0b2tlbml6ZVBhdGgoXCJtZXRhZGF0YS50aXRsZVwiKSAvLyAtPiBbXCJtZXRhZGF0YVwiLCBcInRpdGxlXCJdXG4gKiB0b2tlbml6ZVBhdGgoXCJjaGFwdGVyc1sqXS5jb250ZW50XCIpIC8vIC0+IFtcImNoYXB0ZXJzWypdXCIsIFwiY29udGVudFwiXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5pemVQYXRoKHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgY3VycmVudCA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBwYXRoW2ldO1xuICAgICAgICBpZiAoY2hhciA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhcnJheSBpbmRleFxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goY3VycmVudC5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYnJhY2tldENvdW50ID0gMTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4Q2hhcnMgPSBbXCJbXCJdO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBwYXRoLmxlbmd0aCAmJiBicmFja2V0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhbaV0gPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNrZXRDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXRoW2ldID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICBicmFja2V0Q291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhDaGFycy5wdXNoKHBhdGhbaV0pO1xuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGluZGV4Q2hhcnMuam9pbihcIlwiKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIntcIikge1xuICAgICAgICAgICAgLy8gSGFuZGxlIG11bHRpLWZpZWxkIHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goY3VycmVudC5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYnJhY2VDb3VudCA9IDE7XG4gICAgICAgICAgICBjb25zdCBmaWVsZENoYXJzID0gW1wie1wiXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGggJiYgYnJhY2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aFtpXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXRoW2ldID09PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICBicmFjZUNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpZWxkQ2hhcnMucHVzaChwYXRoW2ldKTtcbiAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbnMucHVzaChmaWVsZENoYXJzLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSByZWd1bGFyIGZpZWxkXG4gICAgICAgICAgICBpZiAoY3VycmVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChjdXJyZW50LmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnQucHVzaChjaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBpICs9IDE7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Lmxlbmd0aCkge1xuICAgICAgICB0b2tlbnMucHVzaChjdXJyZW50LmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xufVxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGFuIG9iamVjdCBpcyBhIEZpbHRlck9wZXJhdG9yc1xuICovXG5mdW5jdGlvbiBpc0ZpbHRlck9wZXJhdG9ycyhvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZXZlcnkoKGtleSkgPT4ga2V5ID09PSBcIiRlcVwiIHx8XG4gICAgICAgICAgICBrZXkgPT09IFwiJG5lXCIgfHxcbiAgICAgICAgICAgIGtleSA9PT0gXCIkZ3RcIiB8fFxuICAgICAgICAgICAga2V5ID09PSBcIiRndGVcIiB8fFxuICAgICAgICAgICAga2V5ID09PSBcIiRsdFwiIHx8XG4gICAgICAgICAgICBrZXkgPT09IFwiJGx0ZVwiIHx8XG4gICAgICAgICAgICBrZXkgPT09IFwiJGluXCIgfHxcbiAgICAgICAgICAgIGtleSA9PT0gXCIkbmluXCIpKTtcbn1cbi8qKlxuICogQ29tcGFyZSB2YWx1ZXMgZm9yIGZpbHRlcmluZywgc3VwcG9ydGluZyBvcGVyYXRvci1iYXNlZCBjb21wYXJpc29ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWYWx1ZXMoaXRlbVZhbHVlLCBmaWx0ZXJWYWx1ZSkge1xuICAgIGlmIChpc0ZpbHRlck9wZXJhdG9ycyhmaWx0ZXJWYWx1ZSkpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3JzID0gT2JqZWN0LmtleXMoZmlsdGVyVmFsdWUpLmZpbHRlcigoaykgPT4gay5zdGFydHNXaXRoKFwiJFwiKSk7XG4gICAgICAgIHJldHVybiBvcGVyYXRvcnMuZXZlcnkoKG9wKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpbHRlclZhbHVlW29wXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiJGVxXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtVmFsdWUgPT09IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIkbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1WYWx1ZSAhPT0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRndFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKGl0ZW1WYWx1ZSkgPiBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIkZ3RlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoaXRlbVZhbHVlKSA+PSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIkbHRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihpdGVtVmFsdWUpIDwgTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiJGx0ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKGl0ZW1WYWx1ZSkgPD0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiJGluXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmluY2x1ZGVzKGl0ZW1WYWx1ZSkgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiJG5pblwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyAhdmFsdWUuaW5jbHVkZXMoaXRlbVZhbHVlKSA6IHRydWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgbm8gb3BlcmF0b3JzLCBkbyBhIGRpcmVjdCBjb21wYXJpc29uXG4gICAgcmV0dXJuIGl0ZW1WYWx1ZSA9PT0gZmlsdGVyVmFsdWU7XG59XG4vKipcbiAqIEV4dHJhY3QgdGV4dCBmcm9tIGEgdmFsdWUgYXQgYSBzcGVjaWZpYyBKU09OIHBhdGguXG4gKlxuICogU3VwcG9ydHM6XG4gKiAtIFNpbXBsZSBwYXRoczogXCJmaWVsZDEuZmllbGQyXCJcbiAqIC0gQXJyYXkgaW5kZXhpbmc6IFwiWzBdXCIsIFwiWypdXCIsIFwiWy0xXVwiXG4gKiAtIFdpbGRjYXJkczogXCIqXCJcbiAqIC0gTXVsdGktZmllbGQgc2VsZWN0aW9uOiBcIntmaWVsZDEsZmllbGQyfVwiXG4gKiAtIE5lc3RlZCBwYXRocyBpbiBtdWx0aS1maWVsZDogXCJ7ZmllbGQxLG5lc3RlZC5maWVsZDJ9XCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHRBdFBhdGgob2JqLCBwYXRoKSB7XG4gICAgaWYgKCFwYXRoIHx8IHBhdGggPT09IFwiJFwiKSB7XG4gICAgICAgIHJldHVybiBbSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKV07XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogdG9rZW5pemVQYXRoKHBhdGgpO1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RGcm9tT2JqKG9iaiwgdG9rZW5zLCBwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA+PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb2JqID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbU3RyaW5nKG9iaildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgfHwgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbcG9zXTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAocG9zID09PSAwICYmIHRva2VuID09PSBcIiRcIikge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5zdGFydHNXaXRoKFwiW1wiKSAmJiB0b2tlbi5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmopKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdG9rZW4uc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKC4uLmV4dHJhY3RGcm9tT2JqKGl0ZW0sIHRva2VucywgcG9zICsgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpZHggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gb2JqLmxlbmd0aCArIGlkeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDwgb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKC4uLmV4dHJhY3RGcm9tT2JqKG9ialtpZHhdLCB0b2tlbnMsIHBvcyArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG9rZW4uc3RhcnRzV2l0aChcIntcIikgJiYgdG9rZW4uZW5kc1dpdGgoXCJ9XCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgY29uc3QgZmllbGRzID0gdG9rZW5cbiAgICAgICAgICAgICAgICAuc2xpY2UoMSwgLTEpXG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgICAgICAgIC5tYXAoKGYpID0+IGYudHJpbSgpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmVzdGVkVG9rZW5zID0gdG9rZW5pemVQYXRoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICBpZiAobmVzdGVkVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudE9iaiA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXN0ZWRUb2tlbiBvZiBuZXN0ZWRUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50T2JqICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJlbnRPYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRUb2tlbiBpbiBjdXJyZW50T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE9iaiA9IGN1cnJlbnRPYmpbbmVzdGVkVG9rZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE9iaiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRPYmogPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY3VycmVudE9iaiA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyZW50T2JqID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChTdHJpbmcoY3VycmVudE9iaikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50T2JqKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyZW50T2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKEpTT04uc3RyaW5naWZ5KGN1cnJlbnRPYmosIG51bGwsIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCguLi5leHRyYWN0RnJvbU9iaihpdGVtLCB0b2tlbnMsIHBvcyArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgT2JqZWN0LnZhbHVlcyhvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCguLi5leHRyYWN0RnJvbU9iaih2YWx1ZSwgdG9rZW5zLCBwb3MgKyAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsICYmIHRva2VuIGluIG9iaikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCguLi5leHRyYWN0RnJvbU9iaihvYmpbdG9rZW5dLCB0b2tlbnMsIHBvcyArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RGcm9tT2JqKG9iaiwgdG9rZW5zLCAwKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGNvc2luZSBzaW1pbGFyaXR5IGJldHdlZW4gdHdvIHZlY3RvcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3NpbmVTaW1pbGFyaXR5KHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgICBpZiAodmVjdG9yMS5sZW5ndGggIT09IHZlY3RvcjIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlY3RvcnMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgY29uc3QgZG90UHJvZHVjdCA9IHZlY3RvcjEucmVkdWNlKChhY2MsIHZhbCwgaSkgPT4gYWNjICsgdmFsICogdmVjdG9yMltpXSwgMCk7XG4gICAgY29uc3QgbWFnbml0dWRlMSA9IE1hdGguc3FydCh2ZWN0b3IxLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCAqIHZhbCwgMCkpO1xuICAgIGNvbnN0IG1hZ25pdHVkZTIgPSBNYXRoLnNxcnQodmVjdG9yMi5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbiAgICBpZiAobWFnbml0dWRlMSA9PT0gMCB8fCBtYWduaXR1ZGUyID09PSAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gZG90UHJvZHVjdCAvIChtYWduaXR1ZGUxICogbWFnbml0dWRlMik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/store/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/dist/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9kaXN0L3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxkaXN0XFx0eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncBatchedStore: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncBatchedStore),
/* harmony export */   BaseCache: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseCache),
/* harmony export */   BaseCheckpointSaver: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseCheckpointSaver),
/* harmony export */   BaseStore: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseStore),
/* harmony export */   ERROR: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.ERROR),
/* harmony export */   INTERRUPT: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT),
/* harmony export */   InMemoryCache: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache),
/* harmony export */   InMemoryStore: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.InMemoryStore),
/* harmony export */   InvalidNamespaceError: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.InvalidNamespaceError),
/* harmony export */   MemorySaver: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.MemorySaver),
/* harmony export */   MemoryStore: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.MemoryStore),
/* harmony export */   RESUME: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RESUME),
/* harmony export */   SCHEDULED: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.SCHEDULED),
/* harmony export */   TASKS: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.TASKS),
/* harmony export */   WRITES_IDX_MAP: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.WRITES_IDX_MAP),
/* harmony export */   compareChannelVersions: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.compareChannelVersions),
/* harmony export */   copyCheckpoint: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.copyCheckpoint),
/* harmony export */   deepCopy: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.deepCopy),
/* harmony export */   emptyCheckpoint: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.emptyCheckpoint),
/* harmony export */   getCheckpointId: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getCheckpointId),
/* harmony export */   getTextAtPath: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getTextAtPath),
/* harmony export */   maxChannelVersion: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.maxChannelVersion),
/* harmony export */   tokenizePath: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.tokenizePath),
/* harmony export */   uuid5: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.uuid5),
/* harmony export */   uuid6: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.uuid6)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/dist/index.js");


/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/parse.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/parse.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Parse ########-....-....-....-............\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff;\n\n  // Parse ........-####-....-....-............\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Parse ........-....-####-....-............\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Parse ........-....-....-####-............\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3BhcnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDO0FBQ3JDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxLQUFLIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1ub2RlXFxwYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG4gIGxldCB2O1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjtcblxuICAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7XG5cbiAgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/regex.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/regex.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JlZ2V4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEdBQUcsOEVBQThFIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1ub2RlXFxyZWdleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLThdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC9pOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/rng.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/rng.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JuZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDakMsdUNBQXVDO0FBQ3ZDO0FBQ2U7QUFDZjtBQUNBLElBQUksaUVBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1ub2RlXFxybmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5jb25zdCBybmRzOFBvb2wgPSBuZXcgVWludDhBcnJheSgyNTYpOyAvLyAjIG9mIHJhbmRvbSB2YWx1ZXMgdG8gcHJlLWFsbG9jYXRlXG5sZXQgcG9vbFB0ciA9IHJuZHM4UG9vbC5sZW5ndGg7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIGlmIChwb29sUHRyID4gcm5kczhQb29sLmxlbmd0aCAtIDE2KSB7XG4gICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHJuZHM4UG9vbCk7XG4gICAgcG9vbFB0ciA9IDA7XG4gIH1cbiAgcmV0dXJuIHJuZHM4UG9vbC5zbGljZShwb29sUHRyLCBwb29sUHRyICs9IDE2KTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/sha1.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/sha1.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3NoYTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUyw2REFBaUI7QUFDMUI7QUFDQSxpRUFBZSxJQUFJIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1ub2RlXFxzaGExLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpO1xufVxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/stringify.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/stringify.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3N0cmluZ2lmeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsU0FBUyIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGgtY2hlY2twb2ludFxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tbm9kZVxcc3RyaW5naWZ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5jb25zdCBieXRlVG9IZXggPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICAvL1xuICAvLyBOb3RlIHRvIGZ1dHVyZS1zZWxmOiBObywgeW91IGNhbid0IHJlbW92ZSB0aGUgYHRvTG93ZXJDYXNlKClgIGNhbGwuXG4gIC8vIFJFRjogaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNjc3I2lzc3VlY29tbWVudC0xNzU3MzUxMzUxXG4gIHJldHVybiAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHV1aWQgPSB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQpO1xuICAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG4gIHJldHVybiB1dWlkO1xufVxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\nlet _clockseq;\n\n// Previous uuid creation time\nlet _lastMSecs = 0;\nlet _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node;\n  let clockseq = options.clockseq;\n\n  // v1 only: Use cached `node` and `clockseq` values\n  if (!options._v6) {\n    if (!node) {\n      node = _nodeId;\n    }\n    if (clockseq == null) {\n      clockseq = _clockseq;\n    }\n  }\n\n  // Handle cases where we need entropy.  We do this lazily to minimize issues\n  // related to insufficient system entropy.  See #189\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    // Randomize node\n    if (node == null) {\n      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n\n      // v1 only: cache node value for reuse\n      if (!_nodeId && !options._v6) {\n        // per RFC4122 4.5: Set MAC multicast bit (v1 only)\n        node[0] |= 0x01; // Set multicast bit\n\n        _nodeId = node;\n      }\n    }\n\n    // Randomize clockseq\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n      if (_clockseq === undefined && !options._v6) {\n        _clockseq = clockseq;\n      }\n    }\n  }\n\n  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is\n  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQjtBQUNzQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwrQ0FBRzs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLGdCQUFnQiw4REFBZTtBQUMvQjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoLWNoZWNrcG9pbnRcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXHYxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbmxldCBfbm9kZUlkO1xubGV0IF9jbG9ja3NlcTtcblxuLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgQXJyYXkoMTYpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGU7XG4gIGxldCBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXE7XG5cbiAgLy8gdjEgb25seTogVXNlIGNhY2hlZCBgbm9kZWAgYW5kIGBjbG9ja3NlcWAgdmFsdWVzXG4gIGlmICghb3B0aW9ucy5fdjYpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIG5vZGUgPSBfbm9kZUlkO1xuICAgIH1cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXE7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIHdlIG5lZWQgZW50cm9weS4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3Vlc1xuICAvLyByZWxhdGVkIHRvIGluc3VmZmljaWVudCBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlZWRCeXRlcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgICAvLyBSYW5kb21pemUgbm9kZVxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBbc2VlZEJ5dGVzWzBdLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG5cbiAgICAgIC8vIHYxIG9ubHk6IGNhY2hlIG5vZGUgdmFsdWUgZm9yIHJldXNlXG4gICAgICBpZiAoIV9ub2RlSWQgJiYgIW9wdGlvbnMuX3Y2KSB7XG4gICAgICAgIC8vIHBlciBSRkM0MTIyIDQuNTogU2V0IE1BQyBtdWx0aWNhc3QgYml0ICh2MSBvbmx5KVxuICAgICAgICBub2RlWzBdIHw9IDB4MDE7IC8vIFNldCBtdWx0aWNhc3QgYml0XG5cbiAgICAgICAgX25vZGVJZCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmFuZG9taXplIGNsb2Nrc2VxXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgICBpZiAoX2Nsb2Nrc2VxID09PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuX3Y2KSB7XG4gICAgICAgIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHYxICYgdjYgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvIHRpbWUgaXNcbiAgLy8gaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICBsZXQgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIGxldCBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIGNvbnN0IGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgY29uc3QgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgY29uc3QgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gIC8vIGBub2RlYFxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuICByZXR1cm4gYnVmIHx8IHVuc2FmZVN0cmluZ2lmeShiKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHYxOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1ToV6.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1ToV6.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v1ToV6)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v1 UUID to a v6 UUID\n *\n * @param {string|Uint8Array} uuid - The v1 UUID to convert to v6\n * @returns {string|Uint8Array} The v6 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v1ToV6(uuid) {\n  const v1Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v6Bytes = _v1ToV6(v1Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v6Bytes) : v6Bytes;\n}\n\n// Do the field transformation needed for v1 -> v6\nfunction _v1ToV6(v1Bytes, randomize = false) {\n  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YxVG9WNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0I7QUFDa0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDZTtBQUNmLDZDQUE2QyxxREFBSztBQUNsRDtBQUNBLG9DQUFvQyw4REFBZTtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGgtY2hlY2twb2ludFxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tbm9kZVxcdjFUb1Y2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGEgdjEgVVVJRCB0byBhIHY2IFVVSURcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSB1dWlkIC0gVGhlIHYxIFVVSUQgdG8gY29udmVydCB0byB2NlxuICogQHJldHVybnMge3N0cmluZ3xVaW50OEFycmF5fSBUaGUgdjYgVVVJRCBhcyB0aGUgc2FtZSB0eXBlIGFzIHRoZSBgdXVpZGAgYXJnXG4gKiAoc3RyaW5nIG9yIFVpbnQ4QXJyYXkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHYxVG9WNih1dWlkKSB7XG4gIGNvbnN0IHYxQnl0ZXMgPSB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyBwYXJzZSh1dWlkKSA6IHV1aWQ7XG4gIGNvbnN0IHY2Qnl0ZXMgPSBfdjFUb1Y2KHYxQnl0ZXMpO1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnID8gdW5zYWZlU3RyaW5naWZ5KHY2Qnl0ZXMpIDogdjZCeXRlcztcbn1cblxuLy8gRG8gdGhlIGZpZWxkIHRyYW5zZm9ybWF0aW9uIG5lZWRlZCBmb3IgdjEgLT4gdjZcbmZ1bmN0aW9uIF92MVRvVjYodjFCeXRlcywgcmFuZG9taXplID0gZmFsc2UpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkub2YoKHYxQnl0ZXNbNl0gJiAweDBmKSA8PCA0IHwgdjFCeXRlc1s3XSA+PiA0ICYgMHgwZiwgKHYxQnl0ZXNbN10gJiAweDBmKSA8PCA0IHwgKHYxQnl0ZXNbNF0gJiAweGYwKSA+PiA0LCAodjFCeXRlc1s0XSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1s1XSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzVdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzBdICYgMHhmMCkgPj4gNCwgKHYxQnl0ZXNbMF0gJiAweDBmKSA8PCA0IHwgKHYxQnl0ZXNbMV0gJiAweGYwKSA+PiA0LCAodjFCeXRlc1sxXSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1syXSAmIDB4ZjApID4+IDQsIDB4NjAgfCB2MUJ5dGVzWzJdICYgMHgwZiwgdjFCeXRlc1szXSwgdjFCeXRlc1s4XSwgdjFCeXRlc1s5XSwgdjFCeXRlc1sxMF0sIHYxQnl0ZXNbMTFdLCB2MUJ5dGVzWzEyXSwgdjFCeXRlc1sxM10sIHYxQnl0ZXNbMTRdLCB2MUJ5dGVzWzE1XSk7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1ToV6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v35.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v35.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/parse.js\");\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n\n    // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    if (buf) {\n      offset = offset || 0;\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n      return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  }\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch (err) {}\n\n  // For CommonJS default export support\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNsQjtBQUMvQjtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQWU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1ub2RlXFx2MzUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0IGNvbnN0IEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjM1KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBfbmFtZXNwYWNlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIGlmICgoKF9uYW1lc3BhY2UgPSBuYW1lc3BhY2UpID09PSBudWxsIHx8IF9uYW1lc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uYW1lc3BhY2UubGVuZ3RoKSAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiB1bnNhZmVTdHJpbmdpZnkoYnl0ZXMpO1xuICB9XG5cbiAgLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lO1xuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v5.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v5.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQjtBQUNFO0FBQzdCLFdBQVcsbURBQUcsYUFBYSxnREFBSTtBQUMvQixpRUFBZSxFQUFFIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaC1jaGVja3BvaW50XFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1ub2RlXFx2NS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBzaGExIGZyb20gJy4vc2hhMS5qcyc7XG5jb25zdCB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v6.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v6.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v1ToV6.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n\n\n\n\n/**\n *\n * @param {object} options\n * @param {Uint8Array=} buf\n * @param {number=} offset\n * @returns\n */\nfunction v6(options = {}, buf, offset = 0) {\n  // v6 is v1 with different field layout, so we start with a v1 UUID, albeit\n  // with slightly different behavior around how the clock_seq and node fields\n  // are randomized, which is why we call v1 with _v6: true.\n  let bytes = (0,_v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ...options,\n    _v6: true\n  }, new Uint8Array(16));\n\n  // Reorder the fields to v6 layout.\n  bytes = (0,_v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n\n  // Return as a byte array if requested\n  if (buf) {\n    for (let i = 0; i < 16; i++) {\n      buf[offset + i] = bytes[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(bytes);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFDeEI7QUFDUTs7QUFFakM7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBRTtBQUNoQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFVBQVUsc0RBQU07O0FBRWhCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQWU7QUFDeEIiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoLWNoZWNrcG9pbnRcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXHY2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCB2MSBmcm9tICcuL3YxLmpzJztcbmltcG9ydCB2MVRvVjYgZnJvbSAnLi92MVRvVjYuanMnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtVaW50OEFycmF5PX0gYnVmXG4gKiBAcGFyYW0ge251bWJlcj19IG9mZnNldFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjYob3B0aW9ucyA9IHt9LCBidWYsIG9mZnNldCA9IDApIHtcbiAgLy8gdjYgaXMgdjEgd2l0aCBkaWZmZXJlbnQgZmllbGQgbGF5b3V0LCBzbyB3ZSBzdGFydCB3aXRoIGEgdjEgVVVJRCwgYWxiZWl0XG4gIC8vIHdpdGggc2xpZ2h0bHkgZGlmZmVyZW50IGJlaGF2aW9yIGFyb3VuZCBob3cgdGhlIGNsb2NrX3NlcSBhbmQgbm9kZSBmaWVsZHNcbiAgLy8gYXJlIHJhbmRvbWl6ZWQsIHdoaWNoIGlzIHdoeSB3ZSBjYWxsIHYxIHdpdGggX3Y2OiB0cnVlLlxuICBsZXQgYnl0ZXMgPSB2MSh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBfdjY6IHRydWVcbiAgfSwgbmV3IFVpbnQ4QXJyYXkoMTYpKTtcblxuICAvLyBSZW9yZGVyIHRoZSBmaWVsZHMgdG8gdjYgbGF5b3V0LlxuICBieXRlcyA9IHYxVG9WNihieXRlcyk7XG5cbiAgLy8gUmV0dXJuIGFzIGEgYnl0ZSBhcnJheSBpZiByZXF1ZXN0ZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShieXRlcyk7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/v6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/validate.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/validate.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZhbGlkYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCO0FBQy9CO0FBQ0EscUNBQXFDLGlEQUFLO0FBQzFDO0FBQ0EsaUVBQWUsUUFBUSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGgtY2hlY2twb2ludFxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tbm9kZVxcdmFsaWRhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-checkpoint/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/channels/base.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/channels/base.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseChannel: () => (/* binding */ BaseChannel),\n/* harmony export */   createCheckpoint: () => (/* binding */ createCheckpoint),\n/* harmony export */   emptyChannels: () => (/* binding */ emptyChannels),\n/* harmony export */   isBaseChannel: () => (/* binding */ isBaseChannel)\n/* harmony export */ });\n/* harmony import */ var _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/langgraph-checkpoint */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n\n\nfunction isBaseChannel(obj) {\n    return obj != null && obj.lg_is_channel === true;\n}\nclass BaseChannel {\n    constructor() {\n        Object.defineProperty(this, \"ValueType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"UpdateType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @ignore */\n        Object.defineProperty(this, \"lg_is_channel\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    /**\n     * Mark the current value of the channel as consumed. By default, no-op.\n     * This is called by Pregel before the start of the next step, for all\n     * channels that triggered a node. If the channel was updated, return true.\n     */\n    consume() {\n        return false;\n    }\n}\nfunction emptyChannels(channels, checkpoint) {\n    const filteredChannels = Object.fromEntries(Object.entries(channels).filter(([, value]) => isBaseChannel(value)));\n    const newChannels = {};\n    for (const k in filteredChannels) {\n        if (Object.prototype.hasOwnProperty.call(filteredChannels, k)) {\n            const channelValue = checkpoint.channel_values[k];\n            newChannels[k] = filteredChannels[k].fromCheckpoint(channelValue);\n        }\n    }\n    return newChannels;\n}\nfunction createCheckpoint(checkpoint, channels, step) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let values;\n    if (channels === undefined) {\n        values = checkpoint.channel_values;\n    }\n    else {\n        values = {};\n        for (const k of Object.keys(channels)) {\n            try {\n                values[k] = channels[k].checkpoint();\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (error) {\n                if (error.name === _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError.unminifiable_name) {\n                    // no-op\n                }\n                else {\n                    throw error; // Rethrow unexpected errors\n                }\n            }\n        }\n    }\n    return {\n        v: 1,\n        id: (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.uuid6)(step),\n        ts: new Date().toISOString(),\n        channel_values: values,\n        channel_versions: { ...checkpoint.channel_versions },\n        versions_seen: (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.deepCopy)(checkpoint.versions_seen),\n        pending_sends: checkpoint.pending_sends ?? [],\n    };\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9jaGFubmVscy9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRTtBQUNsQjtBQUMxQztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBSztBQUNqQjtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RCx1QkFBdUIseUVBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxjaGFubmVsc1xcYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWVwQ29weSwgdXVpZDYsIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoLWNoZWNrcG9pbnRcIjtcbmltcG9ydCB7IEVtcHR5Q2hhbm5lbEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmFzZUNoYW5uZWwob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iai5sZ19pc19jaGFubmVsID09PSB0cnVlO1xufVxuZXhwb3J0IGNsYXNzIEJhc2VDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiVmFsdWVUeXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIlVwZGF0ZVR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGdfaXNfY2hhbm5lbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFyayB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY2hhbm5lbCBhcyBjb25zdW1lZC4gQnkgZGVmYXVsdCwgbm8tb3AuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYnkgUHJlZ2VsIGJlZm9yZSB0aGUgc3RhcnQgb2YgdGhlIG5leHQgc3RlcCwgZm9yIGFsbFxuICAgICAqIGNoYW5uZWxzIHRoYXQgdHJpZ2dlcmVkIGEgbm9kZS4gSWYgdGhlIGNoYW5uZWwgd2FzIHVwZGF0ZWQsIHJldHVybiB0cnVlLlxuICAgICAqL1xuICAgIGNvbnN1bWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZW1wdHlDaGFubmVscyhjaGFubmVscywgY2hlY2twb2ludCkge1xuICAgIGNvbnN0IGZpbHRlcmVkQ2hhbm5lbHMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2hhbm5lbHMpLmZpbHRlcigoWywgdmFsdWVdKSA9PiBpc0Jhc2VDaGFubmVsKHZhbHVlKSkpO1xuICAgIGNvbnN0IG5ld0NoYW5uZWxzID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIGZpbHRlcmVkQ2hhbm5lbHMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmaWx0ZXJlZENoYW5uZWxzLCBrKSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbFZhbHVlID0gY2hlY2twb2ludC5jaGFubmVsX3ZhbHVlc1trXTtcbiAgICAgICAgICAgIG5ld0NoYW5uZWxzW2tdID0gZmlsdGVyZWRDaGFubmVsc1trXS5mcm9tQ2hlY2twb2ludChjaGFubmVsVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdDaGFubmVscztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDaGVja3BvaW50KGNoZWNrcG9pbnQsIGNoYW5uZWxzLCBzdGVwKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBsZXQgdmFsdWVzO1xuICAgIGlmIChjaGFubmVscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlcyA9IGNoZWNrcG9pbnQuY2hhbm5lbF92YWx1ZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKGNoYW5uZWxzKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNba10gPSBjaGFubmVsc1trXS5jaGVja3BvaW50KCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSBFbXB0eUNoYW5uZWxFcnJvci51bm1pbmlmaWFibGVfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFJldGhyb3cgdW5leHBlY3RlZCBlcnJvcnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdjogMSxcbiAgICAgICAgaWQ6IHV1aWQ2KHN0ZXApLFxuICAgICAgICB0czogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBjaGFubmVsX3ZhbHVlczogdmFsdWVzLFxuICAgICAgICBjaGFubmVsX3ZlcnNpb25zOiB7IC4uLmNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucyB9LFxuICAgICAgICB2ZXJzaW9uc19zZWVuOiBkZWVwQ29weShjaGVja3BvaW50LnZlcnNpb25zX3NlZW4pLFxuICAgICAgICBwZW5kaW5nX3NlbmRzOiBjaGVja3BvaW50LnBlbmRpbmdfc2VuZHMgPz8gW10sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/channels/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/channels/binop.js":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/channels/binop.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinaryOperatorAggregate: () => (/* binding */ BinaryOperatorAggregate)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/base.js\");\n\n\n/**\n * Stores the result of applying a binary operator to the current value and each new value.\n */\nclass BinaryOperatorAggregate extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseChannel {\n    constructor(operator, initialValueFactory) {\n        super();\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"BinaryOperatorAggregate\"\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"operator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"initialValueFactory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.operator = operator;\n        this.initialValueFactory = initialValueFactory;\n        this.value = initialValueFactory?.();\n    }\n    fromCheckpoint(checkpoint) {\n        const empty = new BinaryOperatorAggregate(this.operator, this.initialValueFactory);\n        if (typeof checkpoint !== \"undefined\") {\n            empty.value = checkpoint;\n        }\n        return empty;\n    }\n    update(values) {\n        let newValues = values;\n        if (!newValues.length)\n            return false;\n        if (this.value === undefined) {\n            [this.value] = newValues;\n            newValues = newValues.slice(1);\n        }\n        for (const value of newValues) {\n            if (this.value !== undefined) {\n                this.value = this.operator(this.value, value);\n            }\n        }\n        return true;\n    }\n    get() {\n        if (this.value === undefined) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value;\n    }\n    checkpoint() {\n        if (this.value === undefined) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value;\n    }\n}\n//# sourceMappingURL=binop.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9jaGFubmVscy9iaW5vcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUQ7QUFDVDtBQUN4QztBQUNBO0FBQ0E7QUFDTyxzQ0FBc0MsaURBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxjaGFubmVsc1xcYmlub3AuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW1wdHlDaGFubmVsRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBCYXNlQ2hhbm5lbCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbi8qKlxuICogU3RvcmVzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSBiaW5hcnkgb3BlcmF0b3IgdG8gdGhlIGN1cnJlbnQgdmFsdWUgYW5kIGVhY2ggbmV3IHZhbHVlLlxuICovXG5leHBvcnQgY2xhc3MgQmluYXJ5T3BlcmF0b3JBZ2dyZWdhdGUgZXh0ZW5kcyBCYXNlQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3Iob3BlcmF0b3IsIGluaXRpYWxWYWx1ZUZhY3RvcnkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZ3JhcGhfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJCaW5hcnlPcGVyYXRvckFnZ3JlZ2F0ZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcGVyYXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbml0aWFsVmFsdWVGYWN0b3J5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVGYWN0b3J5ID0gaW5pdGlhbFZhbHVlRmFjdG9yeTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGluaXRpYWxWYWx1ZUZhY3Rvcnk/LigpO1xuICAgIH1cbiAgICBmcm9tQ2hlY2twb2ludChjaGVja3BvaW50KSB7XG4gICAgICAgIGNvbnN0IGVtcHR5ID0gbmV3IEJpbmFyeU9wZXJhdG9yQWdncmVnYXRlKHRoaXMub3BlcmF0b3IsIHRoaXMuaW5pdGlhbFZhbHVlRmFjdG9yeSk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2twb2ludCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZW1wdHkudmFsdWUgPSBjaGVja3BvaW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgdXBkYXRlKHZhbHVlcykge1xuICAgICAgICBsZXQgbmV3VmFsdWVzID0gdmFsdWVzO1xuICAgICAgICBpZiAoIW5ld1ZhbHVlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFt0aGlzLnZhbHVlXSA9IG5ld1ZhbHVlcztcbiAgICAgICAgICAgIG5ld1ZhbHVlcyA9IG5ld1ZhbHVlcy5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG5ld1ZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yKHRoaXMudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW1wdHlDaGFubmVsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgY2hlY2twb2ludCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVtcHR5Q2hhbm5lbEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ymlub3AuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/channels/binop.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EphemeralValue: () => (/* binding */ EphemeralValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/index.js\");\n\n\n/**\n * Stores the value received in the step immediately preceding, clears after.\n * @internal\n */\nclass EphemeralValue extends _index_js__WEBPACK_IMPORTED_MODULE_1__.BaseChannel {\n    constructor(guard = true) {\n        super();\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"EphemeralValue\"\n        });\n        Object.defineProperty(this, \"guard\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // value is an array so we don't misinterpret an update to undefined as no write\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.guard = guard;\n    }\n    fromCheckpoint(checkpoint) {\n        const empty = new EphemeralValue(this.guard);\n        if (typeof checkpoint !== \"undefined\") {\n            empty.value = [checkpoint];\n        }\n        return empty;\n    }\n    update(values) {\n        if (values.length === 0) {\n            const updated = this.value.length > 0;\n            // If there are no updates for this specific channel at the end of the step, wipe it.\n            this.value = [];\n            return updated;\n        }\n        if (values.length !== 1 && this.guard) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUpdateError(\"EphemeralValue can only receive one value per step.\");\n        }\n        // eslint-disable-next-line prefer-destructuring\n        this.value = [values[values.length - 1]];\n        return true;\n    }\n    get() {\n        if (this.value.length === 0) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value[0];\n    }\n    checkpoint() {\n        if (this.value.length === 0) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value[0];\n    }\n}\n//# sourceMappingURL=ephemeral_value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9jaGFubmVscy9lcGhlbWVyYWxfdmFsdWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFFO0FBQzVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLGtEQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlEQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlEQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxcY2hhbm5lbHNcXGVwaGVtZXJhbF92YWx1ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbXB0eUNoYW5uZWxFcnJvciwgSW52YWxpZFVwZGF0ZUVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgQmFzZUNoYW5uZWwgfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuLyoqXG4gKiBTdG9yZXMgdGhlIHZhbHVlIHJlY2VpdmVkIGluIHRoZSBzdGVwIGltbWVkaWF0ZWx5IHByZWNlZGluZywgY2xlYXJzIGFmdGVyLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBFcGhlbWVyYWxWYWx1ZSBleHRlbmRzIEJhc2VDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3RvcihndWFyZCA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZ3JhcGhfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJFcGhlbWVyYWxWYWx1ZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJndWFyZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyB2YWx1ZSBpcyBhbiBhcnJheSBzbyB3ZSBkb24ndCBtaXNpbnRlcnByZXQgYW4gdXBkYXRlIHRvIHVuZGVmaW5lZCBhcyBubyB3cml0ZVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ3VhcmQgPSBndWFyZDtcbiAgICB9XG4gICAgZnJvbUNoZWNrcG9pbnQoY2hlY2twb2ludCkge1xuICAgICAgICBjb25zdCBlbXB0eSA9IG5ldyBFcGhlbWVyYWxWYWx1ZSh0aGlzLmd1YXJkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja3BvaW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBlbXB0eS52YWx1ZSA9IFtjaGVja3BvaW50XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfVxuICAgIHVwZGF0ZSh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB0aGlzLnZhbHVlLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gdXBkYXRlcyBmb3IgdGhpcyBzcGVjaWZpYyBjaGFubmVsIGF0IHRoZSBlbmQgb2YgdGhlIHN0ZXAsIHdpcGUgaXQuXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gMSAmJiB0aGlzLmd1YXJkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKFwiRXBoZW1lcmFsVmFsdWUgY2FuIG9ubHkgcmVjZWl2ZSBvbmUgdmFsdWUgcGVyIHN0ZXAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB0aGlzLnZhbHVlID0gW3ZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFbXB0eUNoYW5uZWxFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlWzBdO1xuICAgIH1cbiAgICBjaGVja3BvaW50KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFbXB0eUNoYW5uZWxFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlWzBdO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVwaGVtZXJhbF92YWx1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/channels/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/channels/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseChannel: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseChannel),\n/* harmony export */   BinaryOperatorAggregate: () => (/* reexport safe */ _binop_js__WEBPACK_IMPORTED_MODULE_1__.BinaryOperatorAggregate),\n/* harmony export */   createCheckpoint: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.createCheckpoint),\n/* harmony export */   empty: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.emptyChannels)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/base.js\");\n/* harmony import */ var _binop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binop.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/binop.js\");\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9jaGFubmVscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBbUY7QUFDOUI7QUFDckQiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxjaGFubmVsc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQmFzZUNoYW5uZWwsIGNyZWF0ZUNoZWNrcG9pbnQsIGVtcHR5Q2hhbm5lbHMgYXMgZW1wdHksIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuZXhwb3J0IHsgQmluYXJ5T3BlcmF0b3JBZ2dyZWdhdGUgfSBmcm9tIFwiLi9iaW5vcC5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/channels/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/channels/last_value.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/channels/last_value.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LastValue: () => (/* binding */ LastValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/base.js\");\n\n\n/**\n * Stores the last value received, can receive at most one value per step.\n *\n * Since `update` is only called once per step and value can only be of length 1,\n * LastValue always stores the last value of a single node. If multiple nodes attempt to\n * write to this channel in a single step, an error will be thrown.\n * @internal\n */\nclass LastValue extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseChannel {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"LastValue\"\n        });\n        // value is an array so we don't misinterpret an update to undefined as no write\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    fromCheckpoint(checkpoint) {\n        const empty = new LastValue();\n        if (typeof checkpoint !== \"undefined\") {\n            empty.value = [checkpoint];\n        }\n        return empty;\n    }\n    update(values) {\n        if (values.length === 0) {\n            return false;\n        }\n        if (values.length !== 1) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUpdateError(\"LastValue can only receive one value per step.\", {\n                lc_error_code: \"INVALID_CONCURRENT_GRAPH_UPDATE\",\n            });\n        }\n        // eslint-disable-next-line prefer-destructuring\n        this.value = [values[values.length - 1]];\n        return true;\n    }\n    get() {\n        if (this.value.length === 0) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value[0];\n    }\n    checkpoint() {\n        if (this.value.length === 0) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value[0];\n    }\n}\n//# sourceMappingURL=last_value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9jaGFubmVscy9sYXN0X3ZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRTtBQUM3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLGlEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBa0I7QUFDeEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxjaGFubmVsc1xcbGFzdF92YWx1ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbXB0eUNoYW5uZWxFcnJvciwgSW52YWxpZFVwZGF0ZUVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgQmFzZUNoYW5uZWwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG4vKipcbiAqIFN0b3JlcyB0aGUgbGFzdCB2YWx1ZSByZWNlaXZlZCwgY2FuIHJlY2VpdmUgYXQgbW9zdCBvbmUgdmFsdWUgcGVyIHN0ZXAuXG4gKlxuICogU2luY2UgYHVwZGF0ZWAgaXMgb25seSBjYWxsZWQgb25jZSBwZXIgc3RlcCBhbmQgdmFsdWUgY2FuIG9ubHkgYmUgb2YgbGVuZ3RoIDEsXG4gKiBMYXN0VmFsdWUgYWx3YXlzIHN0b3JlcyB0aGUgbGFzdCB2YWx1ZSBvZiBhIHNpbmdsZSBub2RlLiBJZiBtdWx0aXBsZSBub2RlcyBhdHRlbXB0IHRvXG4gKiB3cml0ZSB0byB0aGlzIGNoYW5uZWwgaW4gYSBzaW5nbGUgc3RlcCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIExhc3RWYWx1ZSBleHRlbmRzIEJhc2VDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZ3JhcGhfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJMYXN0VmFsdWVcIlxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdmFsdWUgaXMgYW4gYXJyYXkgc28gd2UgZG9uJ3QgbWlzaW50ZXJwcmV0IGFuIHVwZGF0ZSB0byB1bmRlZmluZWQgYXMgbm8gd3JpdGVcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmcm9tQ2hlY2twb2ludChjaGVja3BvaW50KSB7XG4gICAgICAgIGNvbnN0IGVtcHR5ID0gbmV3IExhc3RWYWx1ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrcG9pbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGVtcHR5LnZhbHVlID0gW2NoZWNrcG9pbnRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgdXBkYXRlKHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKFwiTGFzdFZhbHVlIGNhbiBvbmx5IHJlY2VpdmUgb25lIHZhbHVlIHBlciBzdGVwLlwiLCB7XG4gICAgICAgICAgICAgICAgbGNfZXJyb3JfY29kZTogXCJJTlZBTElEX0NPTkNVUlJFTlRfR1JBUEhfVVBEQVRFXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdGhpcy52YWx1ZSA9IFt2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW1wdHlDaGFubmVsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVswXTtcbiAgICB9XG4gICAgY2hlY2twb2ludCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW1wdHlDaGFubmVsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVswXTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXN0X3ZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/channels/last_value.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/channels/named_barrier_value.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/channels/named_barrier_value.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NamedBarrierValue: () => (/* binding */ NamedBarrierValue),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/base.js\");\n\n\nconst areSetsEqual = (a, b) => a.size === b.size && [...a].every((value) => b.has(value));\n/**\n * A channel that waits until all named values are received before making the value available.\n *\n * This ensures that if node N and node M both write to channel C, the value of C will not be updated\n * until N and M have completed updating.\n * @internal\n */\nclass NamedBarrierValue extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseChannel {\n    constructor(names) {\n        super();\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"NamedBarrierValue\"\n        });\n        Object.defineProperty(this, \"names\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        }); // Names of nodes that we want to wait for.\n        Object.defineProperty(this, \"seen\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.names = names;\n        this.seen = new Set();\n    }\n    fromCheckpoint(checkpoint) {\n        const empty = new NamedBarrierValue(this.names);\n        if (typeof checkpoint !== \"undefined\") {\n            empty.seen = new Set(checkpoint);\n        }\n        return empty;\n    }\n    update(values) {\n        let updated = false;\n        for (const nodeName of values) {\n            if (this.names.has(nodeName)) {\n                if (!this.seen.has(nodeName)) {\n                    this.seen.add(nodeName);\n                    updated = true;\n                }\n            }\n            else {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUpdateError(`Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(this.names)}`);\n            }\n        }\n        return updated;\n    }\n    // If we have not yet seen all the node names we want to wait for,\n    // throw an error to prevent continuing.\n    get() {\n        if (!areSetsEqual(this.names, this.seen)) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return undefined;\n    }\n    checkpoint() {\n        return [...this.seen];\n    }\n    consume() {\n        if (this.seen && this.names && areSetsEqual(this.seen, this.names)) {\n            this.seen = new Set();\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=named_barrier_value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9jaGFubmVscy9uYW1lZF9iYXJyaWVyX3ZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBcUU7QUFDN0I7QUFDakM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxpREFBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFrQixVQUFVLDBCQUEwQixlQUFlLDJCQUEyQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlEQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxjaGFubmVsc1xcbmFtZWRfYmFycmllcl92YWx1ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbXB0eUNoYW5uZWxFcnJvciwgSW52YWxpZFVwZGF0ZUVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgQmFzZUNoYW5uZWwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgY29uc3QgYXJlU2V0c0VxdWFsID0gKGEsIGIpID0+IGEuc2l6ZSA9PT0gYi5zaXplICYmIFsuLi5hXS5ldmVyeSgodmFsdWUpID0+IGIuaGFzKHZhbHVlKSk7XG4vKipcbiAqIEEgY2hhbm5lbCB0aGF0IHdhaXRzIHVudGlsIGFsbCBuYW1lZCB2YWx1ZXMgYXJlIHJlY2VpdmVkIGJlZm9yZSBtYWtpbmcgdGhlIHZhbHVlIGF2YWlsYWJsZS5cbiAqXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCBpZiBub2RlIE4gYW5kIG5vZGUgTSBib3RoIHdyaXRlIHRvIGNoYW5uZWwgQywgdGhlIHZhbHVlIG9mIEMgd2lsbCBub3QgYmUgdXBkYXRlZFxuICogdW50aWwgTiBhbmQgTSBoYXZlIGNvbXBsZXRlZCB1cGRhdGluZy5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgTmFtZWRCYXJyaWVyVmFsdWUgZXh0ZW5kcyBCYXNlQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IobmFtZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZ3JhcGhfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJOYW1lZEJhcnJpZXJWYWx1ZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pOyAvLyBOYW1lcyBvZiBub2RlcyB0aGF0IHdlIHdhbnQgdG8gd2FpdCBmb3IuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlZW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lcyA9IG5hbWVzO1xuICAgICAgICB0aGlzLnNlZW4gPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGZyb21DaGVja3BvaW50KGNoZWNrcG9pbnQpIHtcbiAgICAgICAgY29uc3QgZW1wdHkgPSBuZXcgTmFtZWRCYXJyaWVyVmFsdWUodGhpcy5uYW1lcyk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2twb2ludCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZW1wdHkuc2VlbiA9IG5ldyBTZXQoY2hlY2twb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cbiAgICB1cGRhdGUodmFsdWVzKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZU5hbWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lcy5oYXMobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlZW4uaGFzKG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlZW4uYWRkKG5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcGRhdGVFcnJvcihgVmFsdWUgJHtKU09OLnN0cmluZ2lmeShub2RlTmFtZSl9IG5vdCBpbiBuYW1lcyAke0pTT04uc3RyaW5naWZ5KHRoaXMubmFtZXMpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIG5vdCB5ZXQgc2VlbiBhbGwgdGhlIG5vZGUgbmFtZXMgd2Ugd2FudCB0byB3YWl0IGZvcixcbiAgICAvLyB0aHJvdyBhbiBlcnJvciB0byBwcmV2ZW50IGNvbnRpbnVpbmcuXG4gICAgZ2V0KCkge1xuICAgICAgICBpZiAoIWFyZVNldHNFcXVhbCh0aGlzLm5hbWVzLCB0aGlzLnNlZW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW1wdHlDaGFubmVsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjaGVja3BvaW50KCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuc2Vlbl07XG4gICAgfVxuICAgIGNvbnN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlZW4gJiYgdGhpcy5uYW1lcyAmJiBhcmVTZXRzRXF1YWwodGhpcy5zZWVuLCB0aGlzLm5hbWVzKSkge1xuICAgICAgICAgICAgdGhpcy5zZWVuID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVkX2JhcnJpZXJfdmFsdWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/channels/named_barrier_value.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHECKPOINT_NAMESPACE_END: () => (/* binding */ CHECKPOINT_NAMESPACE_END),\n/* harmony export */   CHECKPOINT_NAMESPACE_SEPARATOR: () => (/* binding */ CHECKPOINT_NAMESPACE_SEPARATOR),\n/* harmony export */   CONFIG_KEY_ABORT_SIGNALS: () => (/* binding */ CONFIG_KEY_ABORT_SIGNALS),\n/* harmony export */   CONFIG_KEY_CALL: () => (/* binding */ CONFIG_KEY_CALL),\n/* harmony export */   CONFIG_KEY_CHECKPOINTER: () => (/* binding */ CONFIG_KEY_CHECKPOINTER),\n/* harmony export */   CONFIG_KEY_CHECKPOINT_ID: () => (/* binding */ CONFIG_KEY_CHECKPOINT_ID),\n/* harmony export */   CONFIG_KEY_CHECKPOINT_MAP: () => (/* binding */ CONFIG_KEY_CHECKPOINT_MAP),\n/* harmony export */   CONFIG_KEY_CHECKPOINT_NS: () => (/* binding */ CONFIG_KEY_CHECKPOINT_NS),\n/* harmony export */   CONFIG_KEY_NODE_FINISHED: () => (/* binding */ CONFIG_KEY_NODE_FINISHED),\n/* harmony export */   CONFIG_KEY_PREVIOUS_STATE: () => (/* binding */ CONFIG_KEY_PREVIOUS_STATE),\n/* harmony export */   CONFIG_KEY_READ: () => (/* binding */ CONFIG_KEY_READ),\n/* harmony export */   CONFIG_KEY_RESUME_VALUE: () => (/* binding */ CONFIG_KEY_RESUME_VALUE),\n/* harmony export */   CONFIG_KEY_RESUMING: () => (/* binding */ CONFIG_KEY_RESUMING),\n/* harmony export */   CONFIG_KEY_SCRATCHPAD: () => (/* binding */ CONFIG_KEY_SCRATCHPAD),\n/* harmony export */   CONFIG_KEY_SEND: () => (/* binding */ CONFIG_KEY_SEND),\n/* harmony export */   CONFIG_KEY_STREAM: () => (/* binding */ CONFIG_KEY_STREAM),\n/* harmony export */   CONFIG_KEY_TASK_ID: () => (/* binding */ CONFIG_KEY_TASK_ID),\n/* harmony export */   COPY: () => (/* binding */ COPY),\n/* harmony export */   Command: () => (/* binding */ Command),\n/* harmony export */   END: () => (/* binding */ END),\n/* harmony export */   ERROR: () => (/* binding */ ERROR),\n/* harmony export */   INPUT: () => (/* binding */ INPUT),\n/* harmony export */   INTERRUPT: () => (/* binding */ INTERRUPT),\n/* harmony export */   NO_WRITES: () => (/* binding */ NO_WRITES),\n/* harmony export */   NULL_TASK_ID: () => (/* binding */ NULL_TASK_ID),\n/* harmony export */   PREVIOUS: () => (/* binding */ PREVIOUS),\n/* harmony export */   PULL: () => (/* binding */ PULL),\n/* harmony export */   PUSH: () => (/* binding */ PUSH),\n/* harmony export */   RECURSION_LIMIT_DEFAULT: () => (/* binding */ RECURSION_LIMIT_DEFAULT),\n/* harmony export */   RESERVED: () => (/* binding */ RESERVED),\n/* harmony export */   RESUME: () => (/* binding */ RESUME),\n/* harmony export */   RETURN: () => (/* binding */ RETURN),\n/* harmony export */   RUNTIME_PLACEHOLDER: () => (/* binding */ RUNTIME_PLACEHOLDER),\n/* harmony export */   SELF: () => (/* binding */ SELF),\n/* harmony export */   START: () => (/* binding */ START),\n/* harmony export */   Send: () => (/* binding */ Send),\n/* harmony export */   TAG_HIDDEN: () => (/* binding */ TAG_HIDDEN),\n/* harmony export */   TAG_NOSTREAM: () => (/* binding */ TAG_NOSTREAM),\n/* harmony export */   TASKS: () => (/* binding */ TASKS),\n/* harmony export */   TASK_NAMESPACE: () => (/* binding */ TASK_NAMESPACE),\n/* harmony export */   _deserializeCommandSendObjectGraph: () => (/* binding */ _deserializeCommandSendObjectGraph),\n/* harmony export */   _isSend: () => (/* binding */ _isSend),\n/* harmony export */   _isSendInterface: () => (/* binding */ _isSendInterface),\n/* harmony export */   isCommand: () => (/* binding */ isCommand)\n/* harmony export */ });\n/** Special reserved node name denoting the start of a graph. */\nconst START = \"__start__\";\n/** Special reserved node name denoting the end of a graph. */\nconst END = \"__end__\";\nconst INPUT = \"__input__\";\nconst COPY = \"__copy__\";\nconst ERROR = \"__error__\";\nconst CONFIG_KEY_SEND = \"__pregel_send\";\n/** config key containing function used to call a node (push task) */\nconst CONFIG_KEY_CALL = \"__pregel_call\";\nconst CONFIG_KEY_READ = \"__pregel_read\";\nconst CONFIG_KEY_CHECKPOINTER = \"__pregel_checkpointer\";\nconst CONFIG_KEY_RESUMING = \"__pregel_resuming\";\nconst CONFIG_KEY_TASK_ID = \"__pregel_task_id\";\nconst CONFIG_KEY_STREAM = \"__pregel_stream\";\nconst CONFIG_KEY_RESUME_VALUE = \"__pregel_resume_value\";\nconst CONFIG_KEY_SCRATCHPAD = \"__pregel_scratchpad\";\n/** config key containing state from previous invocation of graph for the given thread */\nconst CONFIG_KEY_PREVIOUS_STATE = \"__pregel_previous\";\nconst CONFIG_KEY_CHECKPOINT_ID = \"checkpoint_id\";\nconst CONFIG_KEY_CHECKPOINT_NS = \"checkpoint_ns\";\nconst CONFIG_KEY_NODE_FINISHED = \"__pregel_node_finished\";\n// this one is part of public API\nconst CONFIG_KEY_CHECKPOINT_MAP = \"checkpoint_map\";\nconst CONFIG_KEY_ABORT_SIGNALS = \"__pregel_abort_signals\";\n/** Special channel reserved for graph interrupts */\nconst INTERRUPT = \"__interrupt__\";\n/** Special channel reserved for graph resume */\nconst RESUME = \"__resume__\";\n/** Special channel reserved for cases when a task exits without any writes */\nconst NO_WRITES = \"__no_writes__\";\n/** Special channel reserved for graph return */\nconst RETURN = \"__return__\";\n/** Special channel reserved for graph previous state */\nconst PREVIOUS = \"__previous__\";\nconst RUNTIME_PLACEHOLDER = \"__pregel_runtime_placeholder__\";\nconst RECURSION_LIMIT_DEFAULT = 25;\nconst TAG_HIDDEN = \"langsmith:hidden\";\nconst TAG_NOSTREAM = \"langsmith:nostream\";\nconst SELF = \"__self__\";\nconst TASKS = \"__pregel_tasks\";\nconst PUSH = \"__pregel_push\";\nconst PULL = \"__pregel_pull\";\nconst TASK_NAMESPACE = \"6ba7b831-9dad-11d1-80b4-00c04fd430c8\";\nconst NULL_TASK_ID = \"00000000-0000-0000-0000-000000000000\";\nconst RESERVED = [\n    TAG_HIDDEN,\n    INPUT,\n    INTERRUPT,\n    RESUME,\n    ERROR,\n    NO_WRITES,\n    TASKS,\n    // reserved config.configurable keys\n    CONFIG_KEY_SEND,\n    CONFIG_KEY_READ,\n    CONFIG_KEY_CHECKPOINTER,\n    CONFIG_KEY_STREAM,\n    CONFIG_KEY_RESUMING,\n    CONFIG_KEY_TASK_ID,\n    CONFIG_KEY_CALL,\n    CONFIG_KEY_RESUME_VALUE,\n    CONFIG_KEY_SCRATCHPAD,\n    CONFIG_KEY_PREVIOUS_STATE,\n    CONFIG_KEY_CHECKPOINT_MAP,\n    CONFIG_KEY_CHECKPOINT_NS,\n    CONFIG_KEY_CHECKPOINT_ID,\n];\nconst CHECKPOINT_NAMESPACE_SEPARATOR = \"|\";\nconst CHECKPOINT_NAMESPACE_END = \":\";\nfunction _isSendInterface(x) {\n    const operation = x;\n    return (operation !== null &&\n        operation !== undefined &&\n        typeof operation.node === \"string\" &&\n        operation.args !== undefined);\n}\n/**\n *\n * A message or packet to send to a specific node in the graph.\n *\n * The `Send` class is used within a `StateGraph`'s conditional edges to\n * dynamically invoke a node with a custom state at the next step.\n *\n * Importantly, the sent state can differ from the core graph's state,\n * allowing for flexible and dynamic workflow management.\n *\n * One such example is a \"map-reduce\" workflow where your graph invokes\n * the same node multiple times in parallel with different states,\n * before aggregating the results back into the main graph's state.\n *\n * @example\n * ```typescript\n * import { Annotation, Send, StateGraph } from \"@langchain/langgraph\";\n *\n * const ChainState = Annotation.Root({\n *   subjects: Annotation<string[]>,\n *   jokes: Annotation<string[]>({\n *     reducer: (a, b) => a.concat(b),\n *   }),\n * });\n *\n * const continueToJokes = async (state: typeof ChainState.State) => {\n *   return state.subjects.map((subject) => {\n *     return new Send(\"generate_joke\", { subjects: [subject] });\n *   });\n * };\n *\n * const graph = new StateGraph(ChainState)\n *   .addNode(\"generate_joke\", (state) => ({\n *     jokes: [`Joke about ${state.subjects}`],\n *   }))\n *   .addConditionalEdges(\"__start__\", continueToJokes)\n *   .addEdge(\"generate_joke\", \"__end__\")\n *   .compile();\n *\n * const res = await graph.invoke({ subjects: [\"cats\", \"dogs\"] });\n * console.log(res);\n *\n * // Invoking with two subjects results in a generated joke for each\n * // { subjects: [\"cats\", \"dogs\"], jokes: [`Joke about cats`, `Joke about dogs`] }\n * ```\n */\nclass Send {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(node, args) {\n        Object.defineProperty(this, \"lg_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Send\"\n        });\n        Object.defineProperty(this, \"node\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"args\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.node = node;\n        this.args = _deserializeCommandSendObjectGraph(args);\n    }\n    toJSON() {\n        return {\n            lg_name: this.lg_name,\n            node: this.node,\n            args: this.args,\n        };\n    }\n}\nfunction _isSend(x) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    return x instanceof Send;\n}\n/**\n * One or more commands to update the graph's state and send messages to nodes.\n * Can be used to combine routing logic with state updates in lieu of conditional edges\n *\n * @example\n * ```ts\n * import { Annotation, Command } from \"@langchain/langgraph\";\n *\n * // Define graph state\n * const StateAnnotation = Annotation.Root({\n *   foo: Annotation<string>,\n * });\n *\n * // Define the nodes\n * const nodeA = async (_state: typeof StateAnnotation.State) => {\n *   console.log(\"Called A\");\n *   // this is a replacement for a real conditional edge function\n *   const goto = Math.random() > .5 ? \"nodeB\" : \"nodeC\";\n *   // note how Command allows you to BOTH update the graph state AND route to the next node\n *   return new Command({\n *     // this is the state update\n *     update: {\n *       foo: \"a\",\n *     },\n *     // this is a replacement for an edge\n *     goto,\n *   });\n * };\n *\n * // Nodes B and C are unchanged\n * const nodeB = async (state: typeof StateAnnotation.State) => {\n *   console.log(\"Called B\");\n *   return {\n *     foo: state.foo + \"|b\",\n *   };\n * }\n *\n * const nodeC = async (state: typeof StateAnnotation.State) => {\n *   console.log(\"Called C\");\n *   return {\n *     foo: state.foo + \"|c\",\n *   };\n * }\n *\n * import { StateGraph } from \"@langchain/langgraph\";\n\n * // NOTE: there are no edges between nodes A, B and C!\n * const graph = new StateGraph(StateAnnotation)\n *   .addNode(\"nodeA\", nodeA, {\n *     ends: [\"nodeB\", \"nodeC\"],\n *   })\n *   .addNode(\"nodeB\", nodeB)\n *   .addNode(\"nodeC\", nodeC)\n *   .addEdge(\"__start__\", \"nodeA\")\n *   .compile();\n *\n * await graph.invoke({ foo: \"\" });\n *\n * // Randomly oscillates between\n * // { foo: 'a|c' } and { foo: 'a|b' }\n * ```\n */\nclass Command {\n    constructor(args) {\n        Object.defineProperty(this, \"lg_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Command\"\n        });\n        Object.defineProperty(this, \"lc_direct_tool_output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * Graph to send the command to. Supported values are:\n         *   - None: the current graph (default)\n         *   - The specific name of the graph to send the command to\n         *   - {@link Command.PARENT}: closest parent graph (only supported when returned from a node in a subgraph)\n         */\n        Object.defineProperty(this, \"graph\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Update to apply to the graph's state as a result of executing the node that is returning the command.\n         * Written to the state as if the node had simply returned this value instead of the Command object.\n         */\n        Object.defineProperty(this, \"update\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Value to resume execution with. To be used together with {@link interrupt}.\n         */\n        Object.defineProperty(this, \"resume\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Can be one of the following:\n         *   - name of the node to navigate to next (any node that belongs to the specified `graph`)\n         *   - sequence of node names to navigate to next\n         *   - {@link Send} object (to execute a node with the exact input provided in the {@link Send} object)\n         *   - sequence of {@link Send} objects\n         */\n        Object.defineProperty(this, \"goto\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.resume = args.resume;\n        this.graph = args.graph;\n        this.update = args.update;\n        if (args.goto) {\n            this.goto = Array.isArray(args.goto)\n                ? _deserializeCommandSendObjectGraph(args.goto)\n                : [_deserializeCommandSendObjectGraph(args.goto)];\n        }\n    }\n    /**\n     * Convert the update field to a list of {@link PendingWrite} tuples\n     * @returns List of {@link PendingWrite} tuples of the form `[channelKey, value]`.\n     * @internal\n     */\n    _updateAsTuples() {\n        if (this.update &&\n            typeof this.update === \"object\" &&\n            !Array.isArray(this.update)) {\n            return Object.entries(this.update);\n        }\n        else if (Array.isArray(this.update) &&\n            this.update.every((t) => Array.isArray(t) && t.length === 2 && typeof t[0] === \"string\")) {\n            return this.update;\n        }\n        else {\n            return [[\"__root__\", this.update]];\n        }\n    }\n    toJSON() {\n        let serializedGoto;\n        if (typeof this.goto === \"string\") {\n            serializedGoto = this.goto;\n        }\n        else if (_isSend(this.goto)) {\n            serializedGoto = this.goto.toJSON();\n        }\n        else {\n            serializedGoto = this.goto?.map((innerGoto) => {\n                if (typeof innerGoto === \"string\") {\n                    return innerGoto;\n                }\n                else {\n                    return innerGoto.toJSON();\n                }\n            });\n        }\n        return {\n            lg_name: this.lg_name,\n            update: this.update,\n            resume: this.resume,\n            goto: serializedGoto,\n        };\n    }\n}\nObject.defineProperty(Command, \"PARENT\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"__parent__\"\n});\n/**\n * A type guard to check if the given value is a {@link Command}.\n *\n * Useful for type narrowing when working with the {@link Command} object.\n *\n * @param x - The value to check.\n * @returns `true` if the value is a {@link Command}, `false` otherwise.\n */\nfunction isCommand(x) {\n    if (typeof x !== \"object\") {\n        return false;\n    }\n    if (x === null || x === undefined) {\n        return false;\n    }\n    if (\"lg_name\" in x && x.lg_name === \"Command\") {\n        return true;\n    }\n    return false;\n}\n/**\n * Reconstructs Command and Send objects from a deeply nested tree of anonymous objects\n * matching their interfaces.\n *\n * This is only exported for testing purposes. It is NOT intended to be used outside of\n * the Command and Send classes.\n *\n * @internal\n *\n * @param x - The command send tree to convert.\n * @param seen - A map of seen objects to avoid infinite loops.\n * @returns The converted command send tree.\n */\nfunction _deserializeCommandSendObjectGraph(x, seen = new Map()) {\n    if (x !== undefined && x !== null && typeof x === \"object\") {\n        // If we've already processed this object, return the transformed version\n        if (seen.has(x)) {\n            return seen.get(x);\n        }\n        let result;\n        if (Array.isArray(x)) {\n            // Create the array first, then populate it\n            result = [];\n            // Add to seen map before processing elements to handle self-references\n            seen.set(x, result);\n            // Now populate the array\n            x.forEach((item, index) => {\n                result[index] = _deserializeCommandSendObjectGraph(item, seen);\n            });\n            // eslint-disable-next-line no-instanceof/no-instanceof\n        }\n        else if (isCommand(x) && !(x instanceof Command)) {\n            result = new Command(x);\n            seen.set(x, result);\n            // eslint-disable-next-line no-instanceof/no-instanceof\n        }\n        else if (_isSendInterface(x) && !(x instanceof Send)) {\n            result = new Send(x.node, x.args);\n            seen.set(x, result);\n        }\n        else if (isCommand(x) || _isSend(x)) {\n            result = x;\n            seen.set(x, result);\n        }\n        else if (\"lc_serializable\" in x && x.lc_serializable) {\n            result = x;\n            seen.set(x, result);\n        }\n        else {\n            // Create empty object first\n            result = {};\n            // Add to seen map before processing properties to handle self-references\n            seen.set(x, result);\n            // Now populate the object\n            for (const [key, value] of Object.entries(x)) {\n                result[key] =\n                    _deserializeCommandSendObjectGraph(value, seen);\n            }\n        }\n        return result;\n    }\n    return x;\n}\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9ELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBLFFBQVEsYUFBYSxNQUFNO0FBQzNCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWSxnRUFBZ0UsWUFBWTtBQUN4Ryw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0JBQW9CO0FBQ2xFLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBTcGVjaWFsIHJlc2VydmVkIG5vZGUgbmFtZSBkZW5vdGluZyB0aGUgc3RhcnQgb2YgYSBncmFwaC4gKi9cbmV4cG9ydCBjb25zdCBTVEFSVCA9IFwiX19zdGFydF9fXCI7XG4vKiogU3BlY2lhbCByZXNlcnZlZCBub2RlIG5hbWUgZGVub3RpbmcgdGhlIGVuZCBvZiBhIGdyYXBoLiAqL1xuZXhwb3J0IGNvbnN0IEVORCA9IFwiX19lbmRfX1wiO1xuZXhwb3J0IGNvbnN0IElOUFVUID0gXCJfX2lucHV0X19cIjtcbmV4cG9ydCBjb25zdCBDT1BZID0gXCJfX2NvcHlfX1wiO1xuZXhwb3J0IGNvbnN0IEVSUk9SID0gXCJfX2Vycm9yX19cIjtcbmV4cG9ydCBjb25zdCBDT05GSUdfS0VZX1NFTkQgPSBcIl9fcHJlZ2VsX3NlbmRcIjtcbi8qKiBjb25maWcga2V5IGNvbnRhaW5pbmcgZnVuY3Rpb24gdXNlZCB0byBjYWxsIGEgbm9kZSAocHVzaCB0YXNrKSAqL1xuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfQ0FMTCA9IFwiX19wcmVnZWxfY2FsbFwiO1xuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfUkVBRCA9IFwiX19wcmVnZWxfcmVhZFwiO1xuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSID0gXCJfX3ByZWdlbF9jaGVja3BvaW50ZXJcIjtcbmV4cG9ydCBjb25zdCBDT05GSUdfS0VZX1JFU1VNSU5HID0gXCJfX3ByZWdlbF9yZXN1bWluZ1wiO1xuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfVEFTS19JRCA9IFwiX19wcmVnZWxfdGFza19pZFwiO1xuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfU1RSRUFNID0gXCJfX3ByZWdlbF9zdHJlYW1cIjtcbmV4cG9ydCBjb25zdCBDT05GSUdfS0VZX1JFU1VNRV9WQUxVRSA9IFwiX19wcmVnZWxfcmVzdW1lX3ZhbHVlXCI7XG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9TQ1JBVENIUEFEID0gXCJfX3ByZWdlbF9zY3JhdGNocGFkXCI7XG4vKiogY29uZmlnIGtleSBjb250YWluaW5nIHN0YXRlIGZyb20gcHJldmlvdXMgaW52b2NhdGlvbiBvZiBncmFwaCBmb3IgdGhlIGdpdmVuIHRocmVhZCAqL1xuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfUFJFVklPVVNfU1RBVEUgPSBcIl9fcHJlZ2VsX3ByZXZpb3VzXCI7XG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9DSEVDS1BPSU5UX0lEID0gXCJjaGVja3BvaW50X2lkXCI7XG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9DSEVDS1BPSU5UX05TID0gXCJjaGVja3BvaW50X25zXCI7XG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9OT0RFX0ZJTklTSEVEID0gXCJfX3ByZWdlbF9ub2RlX2ZpbmlzaGVkXCI7XG4vLyB0aGlzIG9uZSBpcyBwYXJ0IG9mIHB1YmxpYyBBUElcbmV4cG9ydCBjb25zdCBDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQID0gXCJjaGVja3BvaW50X21hcFwiO1xuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfQUJPUlRfU0lHTkFMUyA9IFwiX19wcmVnZWxfYWJvcnRfc2lnbmFsc1wiO1xuLyoqIFNwZWNpYWwgY2hhbm5lbCByZXNlcnZlZCBmb3IgZ3JhcGggaW50ZXJydXB0cyAqL1xuZXhwb3J0IGNvbnN0IElOVEVSUlVQVCA9IFwiX19pbnRlcnJ1cHRfX1wiO1xuLyoqIFNwZWNpYWwgY2hhbm5lbCByZXNlcnZlZCBmb3IgZ3JhcGggcmVzdW1lICovXG5leHBvcnQgY29uc3QgUkVTVU1FID0gXCJfX3Jlc3VtZV9fXCI7XG4vKiogU3BlY2lhbCBjaGFubmVsIHJlc2VydmVkIGZvciBjYXNlcyB3aGVuIGEgdGFzayBleGl0cyB3aXRob3V0IGFueSB3cml0ZXMgKi9cbmV4cG9ydCBjb25zdCBOT19XUklURVMgPSBcIl9fbm9fd3JpdGVzX19cIjtcbi8qKiBTcGVjaWFsIGNoYW5uZWwgcmVzZXJ2ZWQgZm9yIGdyYXBoIHJldHVybiAqL1xuZXhwb3J0IGNvbnN0IFJFVFVSTiA9IFwiX19yZXR1cm5fX1wiO1xuLyoqIFNwZWNpYWwgY2hhbm5lbCByZXNlcnZlZCBmb3IgZ3JhcGggcHJldmlvdXMgc3RhdGUgKi9cbmV4cG9ydCBjb25zdCBQUkVWSU9VUyA9IFwiX19wcmV2aW91c19fXCI7XG5leHBvcnQgY29uc3QgUlVOVElNRV9QTEFDRUhPTERFUiA9IFwiX19wcmVnZWxfcnVudGltZV9wbGFjZWhvbGRlcl9fXCI7XG5leHBvcnQgY29uc3QgUkVDVVJTSU9OX0xJTUlUX0RFRkFVTFQgPSAyNTtcbmV4cG9ydCBjb25zdCBUQUdfSElEREVOID0gXCJsYW5nc21pdGg6aGlkZGVuXCI7XG5leHBvcnQgY29uc3QgVEFHX05PU1RSRUFNID0gXCJsYW5nc21pdGg6bm9zdHJlYW1cIjtcbmV4cG9ydCBjb25zdCBTRUxGID0gXCJfX3NlbGZfX1wiO1xuZXhwb3J0IGNvbnN0IFRBU0tTID0gXCJfX3ByZWdlbF90YXNrc1wiO1xuZXhwb3J0IGNvbnN0IFBVU0ggPSBcIl9fcHJlZ2VsX3B1c2hcIjtcbmV4cG9ydCBjb25zdCBQVUxMID0gXCJfX3ByZWdlbF9wdWxsXCI7XG5leHBvcnQgY29uc3QgVEFTS19OQU1FU1BBQ0UgPSBcIjZiYTdiODMxLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOFwiO1xuZXhwb3J0IGNvbnN0IE5VTExfVEFTS19JRCA9IFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCI7XG5leHBvcnQgY29uc3QgUkVTRVJWRUQgPSBbXG4gICAgVEFHX0hJRERFTixcbiAgICBJTlBVVCxcbiAgICBJTlRFUlJVUFQsXG4gICAgUkVTVU1FLFxuICAgIEVSUk9SLFxuICAgIE5PX1dSSVRFUyxcbiAgICBUQVNLUyxcbiAgICAvLyByZXNlcnZlZCBjb25maWcuY29uZmlndXJhYmxlIGtleXNcbiAgICBDT05GSUdfS0VZX1NFTkQsXG4gICAgQ09ORklHX0tFWV9SRUFELFxuICAgIENPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSLFxuICAgIENPTkZJR19LRVlfU1RSRUFNLFxuICAgIENPTkZJR19LRVlfUkVTVU1JTkcsXG4gICAgQ09ORklHX0tFWV9UQVNLX0lELFxuICAgIENPTkZJR19LRVlfQ0FMTCxcbiAgICBDT05GSUdfS0VZX1JFU1VNRV9WQUxVRSxcbiAgICBDT05GSUdfS0VZX1NDUkFUQ0hQQUQsXG4gICAgQ09ORklHX0tFWV9QUkVWSU9VU19TVEFURSxcbiAgICBDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQLFxuICAgIENPTkZJR19LRVlfQ0hFQ0tQT0lOVF9OUyxcbiAgICBDT05GSUdfS0VZX0NIRUNLUE9JTlRfSUQsXG5dO1xuZXhwb3J0IGNvbnN0IENIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUiA9IFwifFwiO1xuZXhwb3J0IGNvbnN0IENIRUNLUE9JTlRfTkFNRVNQQUNFX0VORCA9IFwiOlwiO1xuZXhwb3J0IGZ1bmN0aW9uIF9pc1NlbmRJbnRlcmZhY2UoeCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHg7XG4gICAgcmV0dXJuIChvcGVyYXRpb24gIT09IG51bGwgJiZcbiAgICAgICAgb3BlcmF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9wZXJhdGlvbi5ub2RlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIG9wZXJhdGlvbi5hcmdzICE9PSB1bmRlZmluZWQpO1xufVxuLyoqXG4gKlxuICogQSBtZXNzYWdlIG9yIHBhY2tldCB0byBzZW5kIHRvIGEgc3BlY2lmaWMgbm9kZSBpbiB0aGUgZ3JhcGguXG4gKlxuICogVGhlIGBTZW5kYCBjbGFzcyBpcyB1c2VkIHdpdGhpbiBhIGBTdGF0ZUdyYXBoYCdzIGNvbmRpdGlvbmFsIGVkZ2VzIHRvXG4gKiBkeW5hbWljYWxseSBpbnZva2UgYSBub2RlIHdpdGggYSBjdXN0b20gc3RhdGUgYXQgdGhlIG5leHQgc3RlcC5cbiAqXG4gKiBJbXBvcnRhbnRseSwgdGhlIHNlbnQgc3RhdGUgY2FuIGRpZmZlciBmcm9tIHRoZSBjb3JlIGdyYXBoJ3Mgc3RhdGUsXG4gKiBhbGxvd2luZyBmb3IgZmxleGlibGUgYW5kIGR5bmFtaWMgd29ya2Zsb3cgbWFuYWdlbWVudC5cbiAqXG4gKiBPbmUgc3VjaCBleGFtcGxlIGlzIGEgXCJtYXAtcmVkdWNlXCIgd29ya2Zsb3cgd2hlcmUgeW91ciBncmFwaCBpbnZva2VzXG4gKiB0aGUgc2FtZSBub2RlIG11bHRpcGxlIHRpbWVzIGluIHBhcmFsbGVsIHdpdGggZGlmZmVyZW50IHN0YXRlcyxcbiAqIGJlZm9yZSBhZ2dyZWdhdGluZyB0aGUgcmVzdWx0cyBiYWNrIGludG8gdGhlIG1haW4gZ3JhcGgncyBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgQW5ub3RhdGlvbiwgU2VuZCwgU3RhdGVHcmFwaCB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICpcbiAqIGNvbnN0IENoYWluU3RhdGUgPSBBbm5vdGF0aW9uLlJvb3Qoe1xuICogICBzdWJqZWN0czogQW5ub3RhdGlvbjxzdHJpbmdbXT4sXG4gKiAgIGpva2VzOiBBbm5vdGF0aW9uPHN0cmluZ1tdPih7XG4gKiAgICAgcmVkdWNlcjogKGEsIGIpID0+IGEuY29uY2F0KGIpLFxuICogICB9KSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNvbnRpbnVlVG9Kb2tlcyA9IGFzeW5jIChzdGF0ZTogdHlwZW9mIENoYWluU3RhdGUuU3RhdGUpID0+IHtcbiAqICAgcmV0dXJuIHN0YXRlLnN1YmplY3RzLm1hcCgoc3ViamVjdCkgPT4ge1xuICogICAgIHJldHVybiBuZXcgU2VuZChcImdlbmVyYXRlX2pva2VcIiwgeyBzdWJqZWN0czogW3N1YmplY3RdIH0pO1xuICogICB9KTtcbiAqIH07XG4gKlxuICogY29uc3QgZ3JhcGggPSBuZXcgU3RhdGVHcmFwaChDaGFpblN0YXRlKVxuICogICAuYWRkTm9kZShcImdlbmVyYXRlX2pva2VcIiwgKHN0YXRlKSA9PiAoe1xuICogICAgIGpva2VzOiBbYEpva2UgYWJvdXQgJHtzdGF0ZS5zdWJqZWN0c31gXSxcbiAqICAgfSkpXG4gKiAgIC5hZGRDb25kaXRpb25hbEVkZ2VzKFwiX19zdGFydF9fXCIsIGNvbnRpbnVlVG9Kb2tlcylcbiAqICAgLmFkZEVkZ2UoXCJnZW5lcmF0ZV9qb2tlXCIsIFwiX19lbmRfX1wiKVxuICogICAuY29tcGlsZSgpO1xuICpcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IGdyYXBoLmludm9rZSh7IHN1YmplY3RzOiBbXCJjYXRzXCIsIFwiZG9nc1wiXSB9KTtcbiAqIGNvbnNvbGUubG9nKHJlcyk7XG4gKlxuICogLy8gSW52b2tpbmcgd2l0aCB0d28gc3ViamVjdHMgcmVzdWx0cyBpbiBhIGdlbmVyYXRlZCBqb2tlIGZvciBlYWNoXG4gKiAvLyB7IHN1YmplY3RzOiBbXCJjYXRzXCIsIFwiZG9nc1wiXSwgam9rZXM6IFtgSm9rZSBhYm91dCBjYXRzYCwgYEpva2UgYWJvdXQgZG9nc2BdIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2VuZCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBhcmdzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxnX25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiU2VuZFwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5hcmdzID0gX2Rlc2VyaWFsaXplQ29tbWFuZFNlbmRPYmplY3RHcmFwaChhcmdzKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGdfbmFtZTogdGhpcy5sZ19uYW1lLFxuICAgICAgICAgICAgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgICAgICAgYXJnczogdGhpcy5hcmdzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBfaXNTZW5kKHgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiBTZW5kO1xufVxuLyoqXG4gKiBPbmUgb3IgbW9yZSBjb21tYW5kcyB0byB1cGRhdGUgdGhlIGdyYXBoJ3Mgc3RhdGUgYW5kIHNlbmQgbWVzc2FnZXMgdG8gbm9kZXMuXG4gKiBDYW4gYmUgdXNlZCB0byBjb21iaW5lIHJvdXRpbmcgbG9naWMgd2l0aCBzdGF0ZSB1cGRhdGVzIGluIGxpZXUgb2YgY29uZGl0aW9uYWwgZWRnZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFubm90YXRpb24sIENvbW1hbmQgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGhcIjtcbiAqXG4gKiAvLyBEZWZpbmUgZ3JhcGggc3RhdGVcbiAqIGNvbnN0IFN0YXRlQW5ub3RhdGlvbiA9IEFubm90YXRpb24uUm9vdCh7XG4gKiAgIGZvbzogQW5ub3RhdGlvbjxzdHJpbmc+LFxuICogfSk7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBub2Rlc1xuICogY29uc3Qgbm9kZUEgPSBhc3luYyAoX3N0YXRlOiB0eXBlb2YgU3RhdGVBbm5vdGF0aW9uLlN0YXRlKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKFwiQ2FsbGVkIEFcIik7XG4gKiAgIC8vIHRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYSByZWFsIGNvbmRpdGlvbmFsIGVkZ2UgZnVuY3Rpb25cbiAqICAgY29uc3QgZ290byA9IE1hdGgucmFuZG9tKCkgPiAuNSA/IFwibm9kZUJcIiA6IFwibm9kZUNcIjtcbiAqICAgLy8gbm90ZSBob3cgQ29tbWFuZCBhbGxvd3MgeW91IHRvIEJPVEggdXBkYXRlIHRoZSBncmFwaCBzdGF0ZSBBTkQgcm91dGUgdG8gdGhlIG5leHQgbm9kZVxuICogICByZXR1cm4gbmV3IENvbW1hbmQoe1xuICogICAgIC8vIHRoaXMgaXMgdGhlIHN0YXRlIHVwZGF0ZVxuICogICAgIHVwZGF0ZToge1xuICogICAgICAgZm9vOiBcImFcIixcbiAqICAgICB9LFxuICogICAgIC8vIHRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYW4gZWRnZVxuICogICAgIGdvdG8sXG4gKiAgIH0pO1xuICogfTtcbiAqXG4gKiAvLyBOb2RlcyBCIGFuZCBDIGFyZSB1bmNoYW5nZWRcbiAqIGNvbnN0IG5vZGVCID0gYXN5bmMgKHN0YXRlOiB0eXBlb2YgU3RhdGVBbm5vdGF0aW9uLlN0YXRlKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKFwiQ2FsbGVkIEJcIik7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgZm9vOiBzdGF0ZS5mb28gKyBcInxiXCIsXG4gKiAgIH07XG4gKiB9XG4gKlxuICogY29uc3Qgbm9kZUMgPSBhc3luYyAoc3RhdGU6IHR5cGVvZiBTdGF0ZUFubm90YXRpb24uU3RhdGUpID0+IHtcbiAqICAgY29uc29sZS5sb2coXCJDYWxsZWQgQ1wiKTtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBmb286IHN0YXRlLmZvbyArIFwifGNcIixcbiAqICAgfTtcbiAqIH1cbiAqXG4gKiBpbXBvcnQgeyBTdGF0ZUdyYXBoIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoXCI7XG5cbiAqIC8vIE5PVEU6IHRoZXJlIGFyZSBubyBlZGdlcyBiZXR3ZWVuIG5vZGVzIEEsIEIgYW5kIEMhXG4gKiBjb25zdCBncmFwaCA9IG5ldyBTdGF0ZUdyYXBoKFN0YXRlQW5ub3RhdGlvbilcbiAqICAgLmFkZE5vZGUoXCJub2RlQVwiLCBub2RlQSwge1xuICogICAgIGVuZHM6IFtcIm5vZGVCXCIsIFwibm9kZUNcIl0sXG4gKiAgIH0pXG4gKiAgIC5hZGROb2RlKFwibm9kZUJcIiwgbm9kZUIpXG4gKiAgIC5hZGROb2RlKFwibm9kZUNcIiwgbm9kZUMpXG4gKiAgIC5hZGRFZGdlKFwiX19zdGFydF9fXCIsIFwibm9kZUFcIilcbiAqICAgLmNvbXBpbGUoKTtcbiAqXG4gKiBhd2FpdCBncmFwaC5pbnZva2UoeyBmb286IFwiXCIgfSk7XG4gKlxuICogLy8gUmFuZG9tbHkgb3NjaWxsYXRlcyBiZXR3ZWVuXG4gKiAvLyB7IGZvbzogJ2F8YycgfSBhbmQgeyBmb286ICdhfGInIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZ19uYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIkNvbW1hbmRcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZGlyZWN0X3Rvb2xfb3V0cHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGggdG8gc2VuZCB0aGUgY29tbWFuZCB0by4gU3VwcG9ydGVkIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICAgLSBOb25lOiB0aGUgY3VycmVudCBncmFwaCAoZGVmYXVsdClcbiAgICAgICAgICogICAtIFRoZSBzcGVjaWZpYyBuYW1lIG9mIHRoZSBncmFwaCB0byBzZW5kIHRoZSBjb21tYW5kIHRvXG4gICAgICAgICAqICAgLSB7QGxpbmsgQ29tbWFuZC5QQVJFTlR9OiBjbG9zZXN0IHBhcmVudCBncmFwaCAob25seSBzdXBwb3J0ZWQgd2hlbiByZXR1cm5lZCBmcm9tIGEgbm9kZSBpbiBhIHN1YmdyYXBoKVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ3JhcGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0byBhcHBseSB0byB0aGUgZ3JhcGgncyBzdGF0ZSBhcyBhIHJlc3VsdCBvZiBleGVjdXRpbmcgdGhlIG5vZGUgdGhhdCBpcyByZXR1cm5pbmcgdGhlIGNvbW1hbmQuXG4gICAgICAgICAqIFdyaXR0ZW4gdG8gdGhlIHN0YXRlIGFzIGlmIHRoZSBub2RlIGhhZCBzaW1wbHkgcmV0dXJuZWQgdGhpcyB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBDb21tYW5kIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVwZGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgdG8gcmVzdW1lIGV4ZWN1dGlvbiB3aXRoLiBUbyBiZSB1c2VkIHRvZ2V0aGVyIHdpdGgge0BsaW5rIGludGVycnVwdH0uXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXN1bWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICogICAtIG5hbWUgb2YgdGhlIG5vZGUgdG8gbmF2aWdhdGUgdG8gbmV4dCAoYW55IG5vZGUgdGhhdCBiZWxvbmdzIHRvIHRoZSBzcGVjaWZpZWQgYGdyYXBoYClcbiAgICAgICAgICogICAtIHNlcXVlbmNlIG9mIG5vZGUgbmFtZXMgdG8gbmF2aWdhdGUgdG8gbmV4dFxuICAgICAgICAgKiAgIC0ge0BsaW5rIFNlbmR9IG9iamVjdCAodG8gZXhlY3V0ZSBhIG5vZGUgd2l0aCB0aGUgZXhhY3QgaW5wdXQgcHJvdmlkZWQgaW4gdGhlIHtAbGluayBTZW5kfSBvYmplY3QpXG4gICAgICAgICAqICAgLSBzZXF1ZW5jZSBvZiB7QGxpbmsgU2VuZH0gb2JqZWN0c1xuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ290b1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzdW1lID0gYXJncy5yZXN1bWU7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBhcmdzLmdyYXBoO1xuICAgICAgICB0aGlzLnVwZGF0ZSA9IGFyZ3MudXBkYXRlO1xuICAgICAgICBpZiAoYXJncy5nb3RvKSB7XG4gICAgICAgICAgICB0aGlzLmdvdG8gPSBBcnJheS5pc0FycmF5KGFyZ3MuZ290bylcbiAgICAgICAgICAgICAgICA/IF9kZXNlcmlhbGl6ZUNvbW1hbmRTZW5kT2JqZWN0R3JhcGgoYXJncy5nb3RvKVxuICAgICAgICAgICAgICAgIDogW19kZXNlcmlhbGl6ZUNvbW1hbmRTZW5kT2JqZWN0R3JhcGgoYXJncy5nb3RvKV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgdXBkYXRlIGZpZWxkIHRvIGEgbGlzdCBvZiB7QGxpbmsgUGVuZGluZ1dyaXRlfSB0dXBsZXNcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIHtAbGluayBQZW5kaW5nV3JpdGV9IHR1cGxlcyBvZiB0aGUgZm9ybSBgW2NoYW5uZWxLZXksIHZhbHVlXWAuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3VwZGF0ZUFzVHVwbGVzKCkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLnVwZGF0ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodGhpcy51cGRhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy51cGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy51cGRhdGUpICYmXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5ldmVyeSgodCkgPT4gQXJyYXkuaXNBcnJheSh0KSAmJiB0Lmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgdFswXSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbW1wiX19yb290X19cIiwgdGhpcy51cGRhdGVdXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkR290bztcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdvdG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRHb3RvID0gdGhpcy5nb3RvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9pc1NlbmQodGhpcy5nb3RvKSkge1xuICAgICAgICAgICAgc2VyaWFsaXplZEdvdG8gPSB0aGlzLmdvdG8udG9KU09OKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkR290byA9IHRoaXMuZ290bz8ubWFwKChpbm5lckdvdG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlubmVyR290byA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJHb3RvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyR290by50b0pTT04oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGdfbmFtZTogdGhpcy5sZ19uYW1lLFxuICAgICAgICAgICAgdXBkYXRlOiB0aGlzLnVwZGF0ZSxcbiAgICAgICAgICAgIHJlc3VtZTogdGhpcy5yZXN1bWUsXG4gICAgICAgICAgICBnb3RvOiBzZXJpYWxpemVkR290byxcbiAgICAgICAgfTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tbWFuZCwgXCJQQVJFTlRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBcIl9fcGFyZW50X19cIlxufSk7XG4vKipcbiAqIEEgdHlwZSBndWFyZCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ29tbWFuZH0uXG4gKlxuICogVXNlZnVsIGZvciB0eXBlIG5hcnJvd2luZyB3aGVuIHdvcmtpbmcgd2l0aCB0aGUge0BsaW5rIENvbW1hbmR9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geCAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgQ29tbWFuZH0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDb21tYW5kKHgpIHtcbiAgICBpZiAodHlwZW9mIHggIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoeCA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoXCJsZ19uYW1lXCIgaW4geCAmJiB4LmxnX25hbWUgPT09IFwiQ29tbWFuZFwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJlY29uc3RydWN0cyBDb21tYW5kIGFuZCBTZW5kIG9iamVjdHMgZnJvbSBhIGRlZXBseSBuZXN0ZWQgdHJlZSBvZiBhbm9ueW1vdXMgb2JqZWN0c1xuICogbWF0Y2hpbmcgdGhlaXIgaW50ZXJmYWNlcy5cbiAqXG4gKiBUaGlzIGlzIG9ubHkgZXhwb3J0ZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuIEl0IGlzIE5PVCBpbnRlbmRlZCB0byBiZSB1c2VkIG91dHNpZGUgb2ZcbiAqIHRoZSBDb21tYW5kIGFuZCBTZW5kIGNsYXNzZXMuXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQHBhcmFtIHggLSBUaGUgY29tbWFuZCBzZW5kIHRyZWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSBzZWVuIC0gQSBtYXAgb2Ygc2VlbiBvYmplY3RzIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzLlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBjb21tYW5kIHNlbmQgdHJlZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXNlcmlhbGl6ZUNvbW1hbmRTZW5kT2JqZWN0R3JhcGgoeCwgc2VlbiA9IG5ldyBNYXAoKSkge1xuICAgIGlmICh4ICE9PSB1bmRlZmluZWQgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGlzIG9iamVjdCwgcmV0dXJuIHRoZSB0cmFuc2Zvcm1lZCB2ZXJzaW9uXG4gICAgICAgIGlmIChzZWVuLmhhcyh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlZW4uZ2V0KHgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGFycmF5IGZpcnN0LCB0aGVuIHBvcHVsYXRlIGl0XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIC8vIEFkZCB0byBzZWVuIG1hcCBiZWZvcmUgcHJvY2Vzc2luZyBlbGVtZW50cyB0byBoYW5kbGUgc2VsZi1yZWZlcmVuY2VzXG4gICAgICAgICAgICBzZWVuLnNldCh4LCByZXN1bHQpO1xuICAgICAgICAgICAgLy8gTm93IHBvcHVsYXRlIHRoZSBhcnJheVxuICAgICAgICAgICAgeC5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBfZGVzZXJpYWxpemVDb21tYW5kU2VuZE9iamVjdEdyYXBoKGl0ZW0sIHNlZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb21tYW5kKHgpICYmICEoeCBpbnN0YW5jZW9mIENvbW1hbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQ29tbWFuZCh4KTtcbiAgICAgICAgICAgIHNlZW4uc2V0KHgsIHJlc3VsdCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX2lzU2VuZEludGVyZmFjZSh4KSAmJiAhKHggaW5zdGFuY2VvZiBTZW5kKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFNlbmQoeC5ub2RlLCB4LmFyZ3MpO1xuICAgICAgICAgICAgc2Vlbi5zZXQoeCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NvbW1hbmQoeCkgfHwgX2lzU2VuZCh4KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0geDtcbiAgICAgICAgICAgIHNlZW4uc2V0KHgsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJsY19zZXJpYWxpemFibGVcIiBpbiB4ICYmIHgubGNfc2VyaWFsaXphYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB4O1xuICAgICAgICAgICAgc2Vlbi5zZXQoeCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBlbXB0eSBvYmplY3QgZmlyc3RcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgLy8gQWRkIHRvIHNlZW4gbWFwIGJlZm9yZSBwcm9jZXNzaW5nIHByb3BlcnRpZXMgdG8gaGFuZGxlIHNlbGYtcmVmZXJlbmNlc1xuICAgICAgICAgICAgc2Vlbi5zZXQoeCwgcmVzdWx0KTtcbiAgICAgICAgICAgIC8vIE5vdyBwb3B1bGF0ZSB0aGUgb2JqZWN0XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh4KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID1cbiAgICAgICAgICAgICAgICAgICAgX2Rlc2VyaWFsaXplQ29tbWFuZFNlbmRPYmplY3RHcmFwaCh2YWx1ZSwgc2Vlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseLangGraphError: () => (/* binding */ BaseLangGraphError),\n/* harmony export */   EmptyChannelError: () => (/* binding */ EmptyChannelError),\n/* harmony export */   EmptyInputError: () => (/* binding */ EmptyInputError),\n/* harmony export */   GraphBubbleUp: () => (/* binding */ GraphBubbleUp),\n/* harmony export */   GraphInterrupt: () => (/* binding */ GraphInterrupt),\n/* harmony export */   GraphRecursionError: () => (/* binding */ GraphRecursionError),\n/* harmony export */   GraphValueError: () => (/* binding */ GraphValueError),\n/* harmony export */   InvalidUpdateError: () => (/* binding */ InvalidUpdateError),\n/* harmony export */   MultipleSubgraphsError: () => (/* binding */ MultipleSubgraphsError),\n/* harmony export */   NodeInterrupt: () => (/* binding */ NodeInterrupt),\n/* harmony export */   ParentCommand: () => (/* binding */ ParentCommand),\n/* harmony export */   RemoteException: () => (/* binding */ RemoteException),\n/* harmony export */   UnreachableNodeError: () => (/* binding */ UnreachableNodeError),\n/* harmony export */   getSubgraphsSeenSet: () => (/* binding */ getSubgraphsSeenSet),\n/* harmony export */   isGraphBubbleUp: () => (/* binding */ isGraphBubbleUp),\n/* harmony export */   isGraphInterrupt: () => (/* binding */ isGraphInterrupt),\n/* harmony export */   isParentCommand: () => (/* binding */ isParentCommand)\n/* harmony export */ });\n// TODO: Merge with base LangChain error class when we drop support for core@0.2.0\nclass BaseLangGraphError extends Error {\n    constructor(message, fields) {\n        let finalMessage = message ?? \"\";\n        if (fields?.lc_error_code) {\n            finalMessage = `${finalMessage}\\n\\nTroubleshooting URL: https://langchain-ai.github.io/langgraphjs/troubleshooting/errors/${fields.lc_error_code}/\\n`;\n        }\n        super(finalMessage);\n        Object.defineProperty(this, \"lc_error_code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.lc_error_code = fields?.lc_error_code;\n    }\n}\nclass GraphBubbleUp extends BaseLangGraphError {\n    get is_bubble_up() {\n        return true;\n    }\n}\nclass GraphRecursionError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"GraphRecursionError\";\n    }\n    static get unminifiable_name() {\n        return \"GraphRecursionError\";\n    }\n}\nclass GraphValueError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"GraphValueError\";\n    }\n    static get unminifiable_name() {\n        return \"GraphValueError\";\n    }\n}\nclass GraphInterrupt extends GraphBubbleUp {\n    constructor(interrupts, fields) {\n        super(JSON.stringify(interrupts, null, 2), fields);\n        Object.defineProperty(this, \"interrupts\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"GraphInterrupt\";\n        this.interrupts = interrupts ?? [];\n    }\n    static get unminifiable_name() {\n        return \"GraphInterrupt\";\n    }\n}\n/** Raised by a node to interrupt execution. */\nclass NodeInterrupt extends GraphInterrupt {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(message, fields) {\n        super([\n            {\n                value: message,\n                when: \"during\",\n            },\n        ], fields);\n        this.name = \"NodeInterrupt\";\n    }\n    static get unminifiable_name() {\n        return \"NodeInterrupt\";\n    }\n}\nclass ParentCommand extends GraphBubbleUp {\n    constructor(command) {\n        super();\n        Object.defineProperty(this, \"command\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"ParentCommand\";\n        this.command = command;\n    }\n    static get unminifiable_name() {\n        return \"ParentCommand\";\n    }\n}\nfunction isParentCommand(e) {\n    return (e !== undefined &&\n        e.name === ParentCommand.unminifiable_name);\n}\nfunction isGraphBubbleUp(e) {\n    return e !== undefined && e.is_bubble_up === true;\n}\nfunction isGraphInterrupt(e) {\n    return (e !== undefined &&\n        [\n            GraphInterrupt.unminifiable_name,\n            NodeInterrupt.unminifiable_name,\n        ].includes(e.name));\n}\nclass EmptyInputError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"EmptyInputError\";\n    }\n    static get unminifiable_name() {\n        return \"EmptyInputError\";\n    }\n}\nclass EmptyChannelError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"EmptyChannelError\";\n    }\n    static get unminifiable_name() {\n        return \"EmptyChannelError\";\n    }\n}\nclass InvalidUpdateError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"InvalidUpdateError\";\n    }\n    static get unminifiable_name() {\n        return \"InvalidUpdateError\";\n    }\n}\n/**\n * @deprecated This exception type is no longer thrown.\n */\nclass MultipleSubgraphsError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"MultipleSubgraphError\";\n    }\n    static get unminifiable_name() {\n        return \"MultipleSubgraphError\";\n    }\n}\nclass UnreachableNodeError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"UnreachableNodeError\";\n    }\n    static get unminifiable_name() {\n        return \"UnreachableNodeError\";\n    }\n}\n/**\n * Exception raised when an error occurs in the remote graph.\n */\nclass RemoteException extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"RemoteException\";\n    }\n    static get unminifiable_name() {\n        return \"RemoteException\";\n    }\n}\n/**\n * Used for subgraph detection.\n */\nconst getSubgraphsSeenSet = () => {\n    if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    globalThis[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")] === undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        globalThis[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")] = new Set();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return globalThis[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")];\n};\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWEsNkZBQTZGLHFCQUFxQjtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxlcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogTWVyZ2Ugd2l0aCBiYXNlIExhbmdDaGFpbiBlcnJvciBjbGFzcyB3aGVuIHdlIGRyb3Agc3VwcG9ydCBmb3IgY29yZUAwLjIuMFxuZXhwb3J0IGNsYXNzIEJhc2VMYW5nR3JhcGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmaWVsZHMpIHtcbiAgICAgICAgbGV0IGZpbmFsTWVzc2FnZSA9IG1lc3NhZ2UgPz8gXCJcIjtcbiAgICAgICAgaWYgKGZpZWxkcz8ubGNfZXJyb3JfY29kZSkge1xuICAgICAgICAgICAgZmluYWxNZXNzYWdlID0gYCR7ZmluYWxNZXNzYWdlfVxcblxcblRyb3VibGVzaG9vdGluZyBVUkw6IGh0dHBzOi8vbGFuZ2NoYWluLWFpLmdpdGh1Yi5pby9sYW5nZ3JhcGhqcy90cm91Ymxlc2hvb3RpbmcvZXJyb3JzLyR7ZmllbGRzLmxjX2Vycm9yX2NvZGV9L1xcbmA7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmluYWxNZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZXJyb3JfY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxjX2Vycm9yX2NvZGUgPSBmaWVsZHM/LmxjX2Vycm9yX2NvZGU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEdyYXBoQnViYmxlVXAgZXh0ZW5kcyBCYXNlTGFuZ0dyYXBoRXJyb3Ige1xuICAgIGdldCBpc19idWJibGVfdXAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBHcmFwaFJlY3Vyc2lvbkVycm9yIGV4dGVuZHMgQmFzZUxhbmdHcmFwaEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgZmllbGRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJHcmFwaFJlY3Vyc2lvbkVycm9yXCI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdW5taW5pZmlhYmxlX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkdyYXBoUmVjdXJzaW9uRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR3JhcGhWYWx1ZUVycm9yIGV4dGVuZHMgQmFzZUxhbmdHcmFwaEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgZmllbGRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJHcmFwaFZhbHVlRXJyb3JcIjtcbiAgICB9XG4gICAgc3RhdGljIGdldCB1bm1pbmlmaWFibGVfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiR3JhcGhWYWx1ZUVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEdyYXBoSW50ZXJydXB0IGV4dGVuZHMgR3JhcGhCdWJibGVVcCB7XG4gICAgY29uc3RydWN0b3IoaW50ZXJydXB0cywgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKEpTT04uc3RyaW5naWZ5KGludGVycnVwdHMsIG51bGwsIDIpLCBmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcnJ1cHRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiR3JhcGhJbnRlcnJ1cHRcIjtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRzID0gaW50ZXJydXB0cyA/PyBbXTtcbiAgICB9XG4gICAgc3RhdGljIGdldCB1bm1pbmlmaWFibGVfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiR3JhcGhJbnRlcnJ1cHRcIjtcbiAgICB9XG59XG4vKiogUmFpc2VkIGJ5IGEgbm9kZSB0byBpbnRlcnJ1cHQgZXhlY3V0aW9uLiAqL1xuZXhwb3J0IGNsYXNzIE5vZGVJbnRlcnJ1cHQgZXh0ZW5kcyBHcmFwaEludGVycnVwdCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHdoZW46IFwiZHVyaW5nXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLCBmaWVsZHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk5vZGVJbnRlcnJ1cHRcIjtcbiAgICB9XG4gICAgc3RhdGljIGdldCB1bm1pbmlmaWFibGVfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiTm9kZUludGVycnVwdFwiO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQYXJlbnRDb21tYW5kIGV4dGVuZHMgR3JhcGhCdWJibGVVcCB7XG4gICAgY29uc3RydWN0b3IoY29tbWFuZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb21tYW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUGFyZW50Q29tbWFuZFwiO1xuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHVubWluaWZpYWJsZV9uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJQYXJlbnRDb21tYW5kXCI7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUGFyZW50Q29tbWFuZChlKSB7XG4gICAgcmV0dXJuIChlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZS5uYW1lID09PSBQYXJlbnRDb21tYW5kLnVubWluaWZpYWJsZV9uYW1lKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0dyYXBoQnViYmxlVXAoZSkge1xuICAgIHJldHVybiBlICE9PSB1bmRlZmluZWQgJiYgZS5pc19idWJibGVfdXAgPT09IHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNHcmFwaEludGVycnVwdChlKSB7XG4gICAgcmV0dXJuIChlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgW1xuICAgICAgICAgICAgR3JhcGhJbnRlcnJ1cHQudW5taW5pZmlhYmxlX25hbWUsXG4gICAgICAgICAgICBOb2RlSW50ZXJydXB0LnVubWluaWZpYWJsZV9uYW1lLFxuICAgICAgICBdLmluY2x1ZGVzKGUubmFtZSkpO1xufVxuZXhwb3J0IGNsYXNzIEVtcHR5SW5wdXRFcnJvciBleHRlbmRzIEJhc2VMYW5nR3JhcGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRW1wdHlJbnB1dEVycm9yXCI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdW5taW5pZmlhYmxlX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkVtcHR5SW5wdXRFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFbXB0eUNoYW5uZWxFcnJvciBleHRlbmRzIEJhc2VMYW5nR3JhcGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRW1wdHlDaGFubmVsRXJyb3JcIjtcbiAgICB9XG4gICAgc3RhdGljIGdldCB1bm1pbmlmaWFibGVfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiRW1wdHlDaGFubmVsRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW52YWxpZFVwZGF0ZUVycm9yIGV4dGVuZHMgQmFzZUxhbmdHcmFwaEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgZmllbGRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkVXBkYXRlRXJyb3JcIjtcbiAgICB9XG4gICAgc3RhdGljIGdldCB1bm1pbmlmaWFibGVfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSW52YWxpZFVwZGF0ZUVycm9yXCI7XG4gICAgfVxufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGV4Y2VwdGlvbiB0eXBlIGlzIG5vIGxvbmdlciB0aHJvd24uXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aXBsZVN1YmdyYXBoc0Vycm9yIGV4dGVuZHMgQmFzZUxhbmdHcmFwaEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgZmllbGRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJNdWx0aXBsZVN1YmdyYXBoRXJyb3JcIjtcbiAgICB9XG4gICAgc3RhdGljIGdldCB1bm1pbmlmaWFibGVfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiTXVsdGlwbGVTdWJncmFwaEVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFVucmVhY2hhYmxlTm9kZUVycm9yIGV4dGVuZHMgQmFzZUxhbmdHcmFwaEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgZmllbGRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJVbnJlYWNoYWJsZU5vZGVFcnJvclwiO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHVubWluaWZpYWJsZV9uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJVbnJlYWNoYWJsZU5vZGVFcnJvclwiO1xuICAgIH1cbn1cbi8qKlxuICogRXhjZXB0aW9uIHJhaXNlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBpbiB0aGUgcmVtb3RlIGdyYXBoLlxuICovXG5leHBvcnQgY2xhc3MgUmVtb3RlRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUxhbmdHcmFwaEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgZmllbGRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSZW1vdGVFeGNlcHRpb25cIjtcbiAgICB9XG4gICAgc3RhdGljIGdldCB1bm1pbmlmaWFibGVfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVtb3RlRXhjZXB0aW9uXCI7XG4gICAgfVxufVxuLyoqXG4gKiBVc2VkIGZvciBzdWJncmFwaCBkZXRlY3Rpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTdWJncmFwaHNTZWVuU2V0ID0gKCkgPT4ge1xuICAgIGlmIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGdsb2JhbFRoaXNbU3ltYm9sLmZvcihcIkxHX0NIRUNLUE9JTlRfU0VFTl9OU19TRVRcIildID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZ2xvYmFsVGhpc1tTeW1ib2wuZm9yKFwiTEdfQ0hFQ0tQT0lOVF9TRUVOX05TX1NFVFwiKV0gPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIGdsb2JhbFRoaXNbU3ltYm9sLmZvcihcIkxHX0NIRUNLUE9JTlRfU0VFTl9OU19TRVRcIildO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/func/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/func/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   entrypoint: () => (/* binding */ entrypoint),\n/* harmony export */   getPreviousState: () => (/* binding */ getPreviousState),\n/* harmony export */   task: () => (/* binding */ task)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/singletons */ \"(rsc)/./node_modules/@langchain/core/singletons.js\");\n/* harmony import */ var _pregel_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pregel/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/index.js\");\n/* harmony import */ var _pregel_read_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pregel/read.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/read.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../channels/ephemeral_value.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js\");\n/* harmony import */ var _pregel_call_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../pregel/call.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/call.js\");\n/* harmony import */ var _channels_last_value_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../channels/last_value.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/last_value.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _pregel_write_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pregel/write.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/write.js\");\n\n\n\n\n\n\n\n\n\n/**\n * Define a LangGraph task using the `task` function.\n *\n * Tasks can only be called from within an {@link entrypoint} or from within a StateGraph.\n * A task can be called like a regular function with the following differences:\n *\n * - When a checkpointer is enabled, the function inputs and outputs must be serializable.\n * - The wrapped function can only be called from within an entrypoint or StateGraph.\n * - Calling the function produces a promise. This makes it easy to parallelize tasks.\n *\n * @typeParam ArgsT - The type of arguments the task function accepts\n * @typeParam OutputT - The type of value the task function returns\n * @param optionsOrName - Either an {@link TaskOptions} object, or a string for the name of the task\n * @param func - The function that executes this task\n * @returns A proxy function that accepts the same arguments as the original and always returns the result as a Promise\n *\n * @example basic example\n * ```typescript\n * const addOne = task(\"add\", async (a: number) => a + 1);\n *\n * const workflow = entrypoint(\"example\", async (numbers: number[]) => {\n *   const promises = numbers.map(n => addOne(n));\n *   const results = await Promise.all(promises);\n *   return results;\n * });\n *\n * // Call the entrypoint\n * await workflow.invoke([1, 2, 3]); // Returns [2, 3, 4]\n * ```\n *\n * @example using a retry policy\n * ```typescript\n * const addOne = task({\n *     name: \"add\",\n *     retry: { maxAttempts: 3 }\n *   },\n *   async (a: number) => a + 1\n * );\n *\n * const workflow = entrypoint(\"example\", async (numbers: number[]) => {\n *   const promises = numbers.map(n => addOne(n));\n *   const results = await Promise.all(promises);\n *   return results;\n * });\n * ```\n */\nfunction task(optionsOrName, func) {\n    const { name, retry } = typeof optionsOrName === \"string\"\n        ? { name: optionsOrName, retry: undefined }\n        : optionsOrName;\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isAsyncGeneratorFunction)(func) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isGeneratorFunction)(func)) {\n        throw new Error(\"Generators are disallowed as tasks. For streaming responses, use config.write.\");\n    }\n    return (...args) => {\n        return (0,_pregel_call_js__WEBPACK_IMPORTED_MODULE_5__.call)({ func, name, retry }, ...args);\n    };\n}\n/**\n * Define a LangGraph workflow using the `entrypoint` function.\n *\n * ### Function signature\n *\n * The wrapped function must accept at most **two parameters**. The first parameter\n * is the input to the function. The second (optional) parameter is a\n * {@link LangGraphRunnableConfig} object. If you wish to pass multiple parameters to\n * the function, you can pass them as an object.\n *\n * ### Helper functions\n *\n * #### Streaming\n * To write data to the \"custom\" stream, use the {@link getWriter} function, or the\n * {@link LangGraphRunnableConfig.writer} property.\n *\n * #### State management\n * The {@link getPreviousState} function can be used to access the previous state\n * that was returned from the last invocation of the entrypoint on the same thread id.\n *\n * If you wish to save state other than the return value, you can use the\n * {@link entrypoint.final} function.\n *\n * @typeParam InputT - The type of input the entrypoint accepts\n * @typeParam OutputT - The type of output the entrypoint produces\n * @param optionsOrName - Either an {@link EntrypointOptions} object, or a string for the name of the entrypoint\n * @param func - The function that executes this entrypoint\n * @returns A {@link Pregel} instance that can be run to execute the workflow\n *\n * @example Using entrypoint and tasks\n * ```typescript\n * import { task, entrypoint } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n * import { interrupt, Command } from \"@langchain/langgraph\";\n *\n * const composeEssay = task(\"compose\", async (topic: string) => {\n *   await new Promise(r => setTimeout(r, 1000)); // Simulate slow operation\n *   return `An essay about ${topic}`;\n * });\n *\n * const reviewWorkflow = entrypoint({\n *   name: \"review\",\n *   checkpointer: new MemorySaver()\n * }, async (topic: string) => {\n *   const essay = await composeEssay(topic);\n *   const humanReview = await interrupt({\n *     question: \"Please provide a review\",\n *     essay\n *   });\n *   return {\n *     essay,\n *     review: humanReview\n *   };\n * });\n *\n * // Example configuration for the workflow\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n *\n * // Topic for the essay\n * const topic = \"cats\";\n *\n * // Stream the workflow to generate the essay and await human review\n * for await (const result of reviewWorkflow.stream(topic, config)) {\n *   console.log(result);\n * }\n *\n * // Example human review provided after the interrupt\n * const humanReview = \"This essay is great.\";\n *\n * // Resume the workflow with the provided human review\n * for await (const result of reviewWorkflow.stream(new Command({ resume: humanReview }), config)) {\n *   console.log(result);\n * }\n * ```\n *\n * @example Accessing the previous return value\n * ```typescript\n * import { entrypoint, getPreviousState } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * const accumulator = entrypoint({\n *   name: \"accumulator\",\n *   checkpointer: new MemorySaver()\n * }, async (input: string) => {\n *   const previous = getPreviousState<number>();\n *   return previous !== undefined ? `${previous } ${input}` : input;\n * });\n *\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n * await accumulator.invoke(\"hello\", config); // returns \"hello\"\n * await accumulator.invoke(\"world\", config); // returns \"hello world\"\n * ```\n *\n * @example Using entrypoint.final to save a value\n * ```typescript\n * import { entrypoint, getPreviousState } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * const myWorkflow = entrypoint({\n *   name: \"accumulator\",\n *   checkpointer: new MemorySaver()\n * }, async (num: number) => {\n *   const previous = getPreviousState<number>();\n *\n *   // This will return the previous value to the caller, saving\n *   // 2 * num to the checkpoint, which will be used in the next invocation\n *   // for the `previous` parameter.\n *   return entrypoint.final({\n *     value: previous ?? 0,\n *     save: 2 * num\n *   });\n * });\n *\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n *\n * await myWorkflow.invoke(3, config); // 0 (previous was undefined)\n * await myWorkflow.invoke(1, config); // 6 (previous was 3 * 2 from the previous invocation)\n * ```\n */\nconst entrypoint = function entrypoint(optionsOrName, func) {\n    const { name, checkpointer, store } = typeof optionsOrName === \"string\"\n        ? { name: optionsOrName, checkpointer: undefined, store: undefined }\n        : optionsOrName;\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isAsyncGeneratorFunction)(func) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isGeneratorFunction)(func)) {\n        throw new Error(\"Generators are disallowed as entrypoints. For streaming responses, use config.write.\");\n    }\n    const streamMode = \"updates\";\n    const bound = (0,_pregel_call_js__WEBPACK_IMPORTED_MODULE_5__.getRunnableForEntrypoint)(name, func);\n    // Helper to check if a value is an EntrypointFinal\n    function isEntrypointFinal(value) {\n        return (typeof value === \"object\" &&\n            value !== null &&\n            \"__lg_type\" in value &&\n            value.__lg_type === \"__pregel_final\");\n    }\n    // Helper function to pluck the return value from EntrypointFinal or passthrough\n    const pluckReturnValue = new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n        name: \"pluckReturnValue\",\n        func: (value) => {\n            return isEntrypointFinal(value) ? value.value : value;\n        },\n    });\n    // Helper function to pluck the save value from EntrypointFinal or passthrough\n    const pluckSaveValue = new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n        name: \"pluckSaveValue\",\n        func: (value) => {\n            return isEntrypointFinal(value) ? value.save : value;\n        },\n    });\n    const entrypointNode = new _pregel_read_js__WEBPACK_IMPORTED_MODULE_2__.PregelNode({\n        bound,\n        triggers: [_constants_js__WEBPACK_IMPORTED_MODULE_3__.START],\n        channels: [_constants_js__WEBPACK_IMPORTED_MODULE_3__.START],\n        writers: [\n            new _pregel_write_js__WEBPACK_IMPORTED_MODULE_8__.ChannelWrite([\n                { channel: _constants_js__WEBPACK_IMPORTED_MODULE_3__.END, value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_8__.PASSTHROUGH, mapper: pluckReturnValue },\n                { channel: _constants_js__WEBPACK_IMPORTED_MODULE_3__.PREVIOUS, value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_8__.PASSTHROUGH, mapper: pluckSaveValue },\n            ], [_constants_js__WEBPACK_IMPORTED_MODULE_3__.TAG_HIDDEN]),\n        ],\n    });\n    return new _pregel_index_js__WEBPACK_IMPORTED_MODULE_1__.Pregel({\n        name,\n        checkpointer,\n        nodes: {\n            [name]: entrypointNode,\n        },\n        channels: {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_3__.START]: new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__.EphemeralValue(),\n            [_constants_js__WEBPACK_IMPORTED_MODULE_3__.END]: new _channels_last_value_js__WEBPACK_IMPORTED_MODULE_6__.LastValue(),\n            [_constants_js__WEBPACK_IMPORTED_MODULE_3__.PREVIOUS]: new _channels_last_value_js__WEBPACK_IMPORTED_MODULE_6__.LastValue(),\n        },\n        inputChannels: _constants_js__WEBPACK_IMPORTED_MODULE_3__.START,\n        outputChannels: _constants_js__WEBPACK_IMPORTED_MODULE_3__.END,\n        streamChannels: _constants_js__WEBPACK_IMPORTED_MODULE_3__.END,\n        streamMode,\n        store,\n    });\n};\n// documented by the EntrypointFunction interface\nentrypoint.final = function final({ value, save, }) {\n    return { value, save, __lg_type: \"__pregel_final\" };\n};\n/**\n * A helper utility function for use with the functional API that returns the previous\n * state from the checkpoint from the last invocation of the current thread.\n *\n * This function allows workflows to access state that was saved in previous runs\n * using {@link entrypoint.final}.\n *\n * @typeParam StateT - The type of the state that was previously saved\n * @returns The previous saved state from the last invocation of the current thread\n *\n * @example\n * ```typescript\n * const previousState = getPreviousState<{ counter: number }>();\n * const newCount = (previousState?.counter ?? 0) + 1;\n * ```\n */\nfunction getPreviousState() {\n    const config = _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    return config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_3__.CONFIG_KEY_PREVIOUS_STATE];\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9mdW5jL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFnRjtBQUNwQztBQUNHO0FBQ2dEO0FBQy9CO0FBQ0c7QUFDYjtBQUN5QztBQUNoQztBQUMvRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0JBQWtCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDTztBQUNQLFlBQVksY0FBYztBQUMxQixZQUFZO0FBQ1o7QUFDQSxRQUFRLG1FQUF3QixVQUFVLDhEQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFJLEdBQUcsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FLElBQUksc0NBQXNDO0FBQzFDO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUJBQXlCO0FBQzlEO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksY0FBYztBQUMxQixZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDhCQUE4QixNQUFNO0FBQ3BDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHFCQUFxQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQyxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFLE1BQU07QUFDM0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQyxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDTztBQUNQLFlBQVksNEJBQTRCO0FBQ3hDLFlBQVk7QUFDWjtBQUNBLFFBQVEsbUVBQXdCLFVBQVUsOERBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5RUFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1REFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLCtCQUErQix1REFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCwrQkFBK0IsdURBQVU7QUFDekM7QUFDQSxtQkFBbUIsZ0RBQUs7QUFDeEIsbUJBQW1CLGdEQUFLO0FBQ3hCO0FBQ0EsZ0JBQWdCLDBEQUFZO0FBQzVCLGtCQUFrQixTQUFTLDhDQUFHLFNBQVMseURBQVcsNEJBQTRCO0FBQzlFLGtCQUFrQixTQUFTLG1EQUFRLFNBQVMseURBQVcsMEJBQTBCO0FBQ2pGLGdCQUFnQixxREFBVTtBQUMxQjtBQUNBLEtBQUs7QUFDTCxlQUFlLG9EQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsYUFBYSxnREFBSyxPQUFPLHdFQUFjO0FBQ3ZDLGFBQWEsOENBQUcsT0FBTyw4REFBUztBQUNoQyxhQUFhLG1EQUFRLE9BQU8sOERBQVM7QUFDckMsU0FBUztBQUNULHVCQUF1QixnREFBSztBQUM1Qix3QkFBd0IsOENBQUc7QUFDM0Isd0JBQXdCLDhDQUFHO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUJBQW1CLDBGQUFrQztBQUNyRCxpQ0FBaUMsb0VBQXlCO0FBQzFEO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxmdW5jXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9zaW5nbGV0b25zXCI7XG5pbXBvcnQgeyBQcmVnZWwgfSBmcm9tIFwiLi4vcHJlZ2VsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBQcmVnZWxOb2RlIH0gZnJvbSBcIi4uL3ByZWdlbC9yZWFkLmpzXCI7XG5pbXBvcnQgeyBDT05GSUdfS0VZX1BSRVZJT1VTX1NUQVRFLCBFTkQsIFBSRVZJT1VTLCBTVEFSVCwgVEFHX0hJRERFTiwgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBFcGhlbWVyYWxWYWx1ZSB9IGZyb20gXCIuLi9jaGFubmVscy9lcGhlbWVyYWxfdmFsdWUuanNcIjtcbmltcG9ydCB7IGNhbGwsIGdldFJ1bm5hYmxlRm9yRW50cnlwb2ludCB9IGZyb20gXCIuLi9wcmVnZWwvY2FsbC5qc1wiO1xuaW1wb3J0IHsgTGFzdFZhbHVlIH0gZnJvbSBcIi4uL2NoYW5uZWxzL2xhc3RfdmFsdWUuanNcIjtcbmltcG9ydCB7IFJ1bm5hYmxlQ2FsbGFibGUsIGlzQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiwgaXNHZW5lcmF0b3JGdW5jdGlvbiwgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IENoYW5uZWxXcml0ZSwgUEFTU1RIUk9VR0ggfSBmcm9tIFwiLi4vcHJlZ2VsL3dyaXRlLmpzXCI7XG4vKipcbiAqIERlZmluZSBhIExhbmdHcmFwaCB0YXNrIHVzaW5nIHRoZSBgdGFza2AgZnVuY3Rpb24uXG4gKlxuICogVGFza3MgY2FuIG9ubHkgYmUgY2FsbGVkIGZyb20gd2l0aGluIGFuIHtAbGluayBlbnRyeXBvaW50fSBvciBmcm9tIHdpdGhpbiBhIFN0YXRlR3JhcGguXG4gKiBBIHRhc2sgY2FuIGJlIGNhbGxlZCBsaWtlIGEgcmVndWxhciBmdW5jdGlvbiB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXM6XG4gKlxuICogLSBXaGVuIGEgY2hlY2twb2ludGVyIGlzIGVuYWJsZWQsIHRoZSBmdW5jdGlvbiBpbnB1dHMgYW5kIG91dHB1dHMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gKiAtIFRoZSB3cmFwcGVkIGZ1bmN0aW9uIGNhbiBvbmx5IGJlIGNhbGxlZCBmcm9tIHdpdGhpbiBhbiBlbnRyeXBvaW50IG9yIFN0YXRlR3JhcGguXG4gKiAtIENhbGxpbmcgdGhlIGZ1bmN0aW9uIHByb2R1Y2VzIGEgcHJvbWlzZS4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIHBhcmFsbGVsaXplIHRhc2tzLlxuICpcbiAqIEB0eXBlUGFyYW0gQXJnc1QgLSBUaGUgdHlwZSBvZiBhcmd1bWVudHMgdGhlIHRhc2sgZnVuY3Rpb24gYWNjZXB0c1xuICogQHR5cGVQYXJhbSBPdXRwdXRUIC0gVGhlIHR5cGUgb2YgdmFsdWUgdGhlIHRhc2sgZnVuY3Rpb24gcmV0dXJuc1xuICogQHBhcmFtIG9wdGlvbnNPck5hbWUgLSBFaXRoZXIgYW4ge0BsaW5rIFRhc2tPcHRpb25zfSBvYmplY3QsIG9yIGEgc3RyaW5nIGZvciB0aGUgbmFtZSBvZiB0aGUgdGFza1xuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB0aGlzIHRhc2tcbiAqIEByZXR1cm5zIEEgcHJveHkgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGUgb3JpZ2luYWwgYW5kIGFsd2F5cyByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBQcm9taXNlXG4gKlxuICogQGV4YW1wbGUgYmFzaWMgZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYWRkT25lID0gdGFzayhcImFkZFwiLCBhc3luYyAoYTogbnVtYmVyKSA9PiBhICsgMSk7XG4gKlxuICogY29uc3Qgd29ya2Zsb3cgPSBlbnRyeXBvaW50KFwiZXhhbXBsZVwiLCBhc3luYyAobnVtYmVyczogbnVtYmVyW10pID0+IHtcbiAqICAgY29uc3QgcHJvbWlzZXMgPSBudW1iZXJzLm1hcChuID0+IGFkZE9uZShuKSk7XG4gKiAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gKiAgIHJldHVybiByZXN1bHRzO1xuICogfSk7XG4gKlxuICogLy8gQ2FsbCB0aGUgZW50cnlwb2ludFxuICogYXdhaXQgd29ya2Zsb3cuaW52b2tlKFsxLCAyLCAzXSk7IC8vIFJldHVybnMgWzIsIDMsIDRdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZSB1c2luZyBhIHJldHJ5IHBvbGljeVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYWRkT25lID0gdGFzayh7XG4gKiAgICAgbmFtZTogXCJhZGRcIixcbiAqICAgICByZXRyeTogeyBtYXhBdHRlbXB0czogMyB9XG4gKiAgIH0sXG4gKiAgIGFzeW5jIChhOiBudW1iZXIpID0+IGEgKyAxXG4gKiApO1xuICpcbiAqIGNvbnN0IHdvcmtmbG93ID0gZW50cnlwb2ludChcImV4YW1wbGVcIiwgYXN5bmMgKG51bWJlcnM6IG51bWJlcltdKSA9PiB7XG4gKiAgIGNvbnN0IHByb21pc2VzID0gbnVtYmVycy5tYXAobiA9PiBhZGRPbmUobikpO1xuICogICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICogICByZXR1cm4gcmVzdWx0cztcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YXNrKG9wdGlvbnNPck5hbWUsIGZ1bmMpIHtcbiAgICBjb25zdCB7IG5hbWUsIHJldHJ5IH0gPSB0eXBlb2Ygb3B0aW9uc09yTmFtZSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICA/IHsgbmFtZTogb3B0aW9uc09yTmFtZSwgcmV0cnk6IHVuZGVmaW5lZCB9XG4gICAgICAgIDogb3B0aW9uc09yTmFtZTtcbiAgICBpZiAoaXNBc3luY0dlbmVyYXRvckZ1bmN0aW9uKGZ1bmMpIHx8IGlzR2VuZXJhdG9yRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9ycyBhcmUgZGlzYWxsb3dlZCBhcyB0YXNrcy4gRm9yIHN0cmVhbWluZyByZXNwb25zZXMsIHVzZSBjb25maWcud3JpdGUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhbGwoeyBmdW5jLCBuYW1lLCByZXRyeSB9LCAuLi5hcmdzKTtcbiAgICB9O1xufVxuLyoqXG4gKiBEZWZpbmUgYSBMYW5nR3JhcGggd29ya2Zsb3cgdXNpbmcgdGhlIGBlbnRyeXBvaW50YCBmdW5jdGlvbi5cbiAqXG4gKiAjIyMgRnVuY3Rpb24gc2lnbmF0dXJlXG4gKlxuICogVGhlIHdyYXBwZWQgZnVuY3Rpb24gbXVzdCBhY2NlcHQgYXQgbW9zdCAqKnR3byBwYXJhbWV0ZXJzKiouIFRoZSBmaXJzdCBwYXJhbWV0ZXJcbiAqIGlzIHRoZSBpbnB1dCB0byB0aGUgZnVuY3Rpb24uIFRoZSBzZWNvbmQgKG9wdGlvbmFsKSBwYXJhbWV0ZXIgaXMgYVxuICoge0BsaW5rIExhbmdHcmFwaFJ1bm5hYmxlQ29uZmlnfSBvYmplY3QuIElmIHlvdSB3aXNoIHRvIHBhc3MgbXVsdGlwbGUgcGFyYW1ldGVycyB0b1xuICogdGhlIGZ1bmN0aW9uLCB5b3UgY2FuIHBhc3MgdGhlbSBhcyBhbiBvYmplY3QuXG4gKlxuICogIyMjIEhlbHBlciBmdW5jdGlvbnNcbiAqXG4gKiAjIyMjIFN0cmVhbWluZ1xuICogVG8gd3JpdGUgZGF0YSB0byB0aGUgXCJjdXN0b21cIiBzdHJlYW0sIHVzZSB0aGUge0BsaW5rIGdldFdyaXRlcn0gZnVuY3Rpb24sIG9yIHRoZVxuICoge0BsaW5rIExhbmdHcmFwaFJ1bm5hYmxlQ29uZmlnLndyaXRlcn0gcHJvcGVydHkuXG4gKlxuICogIyMjIyBTdGF0ZSBtYW5hZ2VtZW50XG4gKiBUaGUge0BsaW5rIGdldFByZXZpb3VzU3RhdGV9IGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGFjY2VzcyB0aGUgcHJldmlvdXMgc3RhdGVcbiAqIHRoYXQgd2FzIHJldHVybmVkIGZyb20gdGhlIGxhc3QgaW52b2NhdGlvbiBvZiB0aGUgZW50cnlwb2ludCBvbiB0aGUgc2FtZSB0aHJlYWQgaWQuXG4gKlxuICogSWYgeW91IHdpc2ggdG8gc2F2ZSBzdGF0ZSBvdGhlciB0aGFuIHRoZSByZXR1cm4gdmFsdWUsIHlvdSBjYW4gdXNlIHRoZVxuICoge0BsaW5rIGVudHJ5cG9pbnQuZmluYWx9IGZ1bmN0aW9uLlxuICpcbiAqIEB0eXBlUGFyYW0gSW5wdXRUIC0gVGhlIHR5cGUgb2YgaW5wdXQgdGhlIGVudHJ5cG9pbnQgYWNjZXB0c1xuICogQHR5cGVQYXJhbSBPdXRwdXRUIC0gVGhlIHR5cGUgb2Ygb3V0cHV0IHRoZSBlbnRyeXBvaW50IHByb2R1Y2VzXG4gKiBAcGFyYW0gb3B0aW9uc09yTmFtZSAtIEVpdGhlciBhbiB7QGxpbmsgRW50cnlwb2ludE9wdGlvbnN9IG9iamVjdCwgb3IgYSBzdHJpbmcgZm9yIHRoZSBuYW1lIG9mIHRoZSBlbnRyeXBvaW50XG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHRoaXMgZW50cnlwb2ludFxuICogQHJldHVybnMgQSB7QGxpbmsgUHJlZ2VsfSBpbnN0YW5jZSB0aGF0IGNhbiBiZSBydW4gdG8gZXhlY3V0ZSB0aGUgd29ya2Zsb3dcbiAqXG4gKiBAZXhhbXBsZSBVc2luZyBlbnRyeXBvaW50IGFuZCB0YXNrc1xuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgdGFzaywgZW50cnlwb2ludCB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICogaW1wb3J0IHsgTWVtb3J5U2F2ZXIgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludFwiO1xuICogaW1wb3J0IHsgaW50ZXJydXB0LCBDb21tYW5kIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoXCI7XG4gKlxuICogY29uc3QgY29tcG9zZUVzc2F5ID0gdGFzayhcImNvbXBvc2VcIiwgYXN5bmMgKHRvcGljOiBzdHJpbmcpID0+IHtcbiAqICAgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDEwMDApKTsgLy8gU2ltdWxhdGUgc2xvdyBvcGVyYXRpb25cbiAqICAgcmV0dXJuIGBBbiBlc3NheSBhYm91dCAke3RvcGljfWA7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCByZXZpZXdXb3JrZmxvdyA9IGVudHJ5cG9pbnQoe1xuICogICBuYW1lOiBcInJldmlld1wiLFxuICogICBjaGVja3BvaW50ZXI6IG5ldyBNZW1vcnlTYXZlcigpXG4gKiB9LCBhc3luYyAodG9waWM6IHN0cmluZykgPT4ge1xuICogICBjb25zdCBlc3NheSA9IGF3YWl0IGNvbXBvc2VFc3NheSh0b3BpYyk7XG4gKiAgIGNvbnN0IGh1bWFuUmV2aWV3ID0gYXdhaXQgaW50ZXJydXB0KHtcbiAqICAgICBxdWVzdGlvbjogXCJQbGVhc2UgcHJvdmlkZSBhIHJldmlld1wiLFxuICogICAgIGVzc2F5XG4gKiAgIH0pO1xuICogICByZXR1cm4ge1xuICogICAgIGVzc2F5LFxuICogICAgIHJldmlldzogaHVtYW5SZXZpZXdcbiAqICAgfTtcbiAqIH0pO1xuICpcbiAqIC8vIEV4YW1wbGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIHdvcmtmbG93XG4gKiBjb25zdCBjb25maWcgPSB7XG4gKiAgIGNvbmZpZ3VyYWJsZToge1xuICogICAgIHRocmVhZF9pZDogXCJzb21lX3RocmVhZFwiXG4gKiAgIH1cbiAqIH07XG4gKlxuICogLy8gVG9waWMgZm9yIHRoZSBlc3NheVxuICogY29uc3QgdG9waWMgPSBcImNhdHNcIjtcbiAqXG4gKiAvLyBTdHJlYW0gdGhlIHdvcmtmbG93IHRvIGdlbmVyYXRlIHRoZSBlc3NheSBhbmQgYXdhaXQgaHVtYW4gcmV2aWV3XG4gKiBmb3IgYXdhaXQgKGNvbnN0IHJlc3VsdCBvZiByZXZpZXdXb3JrZmxvdy5zdHJlYW0odG9waWMsIGNvbmZpZykpIHtcbiAqICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIH1cbiAqXG4gKiAvLyBFeGFtcGxlIGh1bWFuIHJldmlldyBwcm92aWRlZCBhZnRlciB0aGUgaW50ZXJydXB0XG4gKiBjb25zdCBodW1hblJldmlldyA9IFwiVGhpcyBlc3NheSBpcyBncmVhdC5cIjtcbiAqXG4gKiAvLyBSZXN1bWUgdGhlIHdvcmtmbG93IHdpdGggdGhlIHByb3ZpZGVkIGh1bWFuIHJldmlld1xuICogZm9yIGF3YWl0IChjb25zdCByZXN1bHQgb2YgcmV2aWV3V29ya2Zsb3cuc3RyZWFtKG5ldyBDb21tYW5kKHsgcmVzdW1lOiBodW1hblJldmlldyB9KSwgY29uZmlnKSkge1xuICogICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGUgQWNjZXNzaW5nIHRoZSBwcmV2aW91cyByZXR1cm4gdmFsdWVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVudHJ5cG9pbnQsIGdldFByZXZpb3VzU3RhdGUgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGhcIjtcbiAqIGltcG9ydCB7IE1lbW9yeVNhdmVyIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoLWNoZWNrcG9pbnRcIjtcbiAqXG4gKiBjb25zdCBhY2N1bXVsYXRvciA9IGVudHJ5cG9pbnQoe1xuICogICBuYW1lOiBcImFjY3VtdWxhdG9yXCIsXG4gKiAgIGNoZWNrcG9pbnRlcjogbmV3IE1lbW9yeVNhdmVyKClcbiAqIH0sIGFzeW5jIChpbnB1dDogc3RyaW5nKSA9PiB7XG4gKiAgIGNvbnN0IHByZXZpb3VzID0gZ2V0UHJldmlvdXNTdGF0ZTxudW1iZXI+KCk7XG4gKiAgIHJldHVybiBwcmV2aW91cyAhPT0gdW5kZWZpbmVkID8gYCR7cHJldmlvdXMgfSAke2lucHV0fWAgOiBpbnB1dDtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNvbmZpZyA9IHtcbiAqICAgY29uZmlndXJhYmxlOiB7XG4gKiAgICAgdGhyZWFkX2lkOiBcInNvbWVfdGhyZWFkXCJcbiAqICAgfVxuICogfTtcbiAqIGF3YWl0IGFjY3VtdWxhdG9yLmludm9rZShcImhlbGxvXCIsIGNvbmZpZyk7IC8vIHJldHVybnMgXCJoZWxsb1wiXG4gKiBhd2FpdCBhY2N1bXVsYXRvci5pbnZva2UoXCJ3b3JsZFwiLCBjb25maWcpOyAvLyByZXR1cm5zIFwiaGVsbG8gd29ybGRcIlxuICogYGBgXG4gKlxuICogQGV4YW1wbGUgVXNpbmcgZW50cnlwb2ludC5maW5hbCB0byBzYXZlIGEgdmFsdWVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVudHJ5cG9pbnQsIGdldFByZXZpb3VzU3RhdGUgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGhcIjtcbiAqIGltcG9ydCB7IE1lbW9yeVNhdmVyIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoLWNoZWNrcG9pbnRcIjtcbiAqXG4gKiBjb25zdCBteVdvcmtmbG93ID0gZW50cnlwb2ludCh7XG4gKiAgIG5hbWU6IFwiYWNjdW11bGF0b3JcIixcbiAqICAgY2hlY2twb2ludGVyOiBuZXcgTWVtb3J5U2F2ZXIoKVxuICogfSwgYXN5bmMgKG51bTogbnVtYmVyKSA9PiB7XG4gKiAgIGNvbnN0IHByZXZpb3VzID0gZ2V0UHJldmlvdXNTdGF0ZTxudW1iZXI+KCk7XG4gKlxuICogICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBwcmV2aW91cyB2YWx1ZSB0byB0aGUgY2FsbGVyLCBzYXZpbmdcbiAqICAgLy8gMiAqIG51bSB0byB0aGUgY2hlY2twb2ludCwgd2hpY2ggd2lsbCBiZSB1c2VkIGluIHRoZSBuZXh0IGludm9jYXRpb25cbiAqICAgLy8gZm9yIHRoZSBgcHJldmlvdXNgIHBhcmFtZXRlci5cbiAqICAgcmV0dXJuIGVudHJ5cG9pbnQuZmluYWwoe1xuICogICAgIHZhbHVlOiBwcmV2aW91cyA/PyAwLFxuICogICAgIHNhdmU6IDIgKiBudW1cbiAqICAgfSk7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjb25maWcgPSB7XG4gKiAgIGNvbmZpZ3VyYWJsZToge1xuICogICAgIHRocmVhZF9pZDogXCJzb21lX3RocmVhZFwiXG4gKiAgIH1cbiAqIH07XG4gKlxuICogYXdhaXQgbXlXb3JrZmxvdy5pbnZva2UoMywgY29uZmlnKTsgLy8gMCAocHJldmlvdXMgd2FzIHVuZGVmaW5lZClcbiAqIGF3YWl0IG15V29ya2Zsb3cuaW52b2tlKDEsIGNvbmZpZyk7IC8vIDYgKHByZXZpb3VzIHdhcyAzICogMiBmcm9tIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBlbnRyeXBvaW50ID0gZnVuY3Rpb24gZW50cnlwb2ludChvcHRpb25zT3JOYW1lLCBmdW5jKSB7XG4gICAgY29uc3QgeyBuYW1lLCBjaGVja3BvaW50ZXIsIHN0b3JlIH0gPSB0eXBlb2Ygb3B0aW9uc09yTmFtZSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICA/IHsgbmFtZTogb3B0aW9uc09yTmFtZSwgY2hlY2twb2ludGVyOiB1bmRlZmluZWQsIHN0b3JlOiB1bmRlZmluZWQgfVxuICAgICAgICA6IG9wdGlvbnNPck5hbWU7XG4gICAgaWYgKGlzQXN5bmNHZW5lcmF0b3JGdW5jdGlvbihmdW5jKSB8fCBpc0dlbmVyYXRvckZ1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvcnMgYXJlIGRpc2FsbG93ZWQgYXMgZW50cnlwb2ludHMuIEZvciBzdHJlYW1pbmcgcmVzcG9uc2VzLCB1c2UgY29uZmlnLndyaXRlLlwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyZWFtTW9kZSA9IFwidXBkYXRlc1wiO1xuICAgIGNvbnN0IGJvdW5kID0gZ2V0UnVubmFibGVGb3JFbnRyeXBvaW50KG5hbWUsIGZ1bmMpO1xuICAgIC8vIEhlbHBlciB0byBjaGVjayBpZiBhIHZhbHVlIGlzIGFuIEVudHJ5cG9pbnRGaW5hbFxuICAgIGZ1bmN0aW9uIGlzRW50cnlwb2ludEZpbmFsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgXCJfX2xnX3R5cGVcIiBpbiB2YWx1ZSAmJlxuICAgICAgICAgICAgdmFsdWUuX19sZ190eXBlID09PSBcIl9fcHJlZ2VsX2ZpbmFsXCIpO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gcGx1Y2sgdGhlIHJldHVybiB2YWx1ZSBmcm9tIEVudHJ5cG9pbnRGaW5hbCBvciBwYXNzdGhyb3VnaFxuICAgIGNvbnN0IHBsdWNrUmV0dXJuVmFsdWUgPSBuZXcgUnVubmFibGVDYWxsYWJsZSh7XG4gICAgICAgIG5hbWU6IFwicGx1Y2tSZXR1cm5WYWx1ZVwiLFxuICAgICAgICBmdW5jOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpc0VudHJ5cG9pbnRGaW5hbCh2YWx1ZSkgPyB2YWx1ZS52YWx1ZSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBwbHVjayB0aGUgc2F2ZSB2YWx1ZSBmcm9tIEVudHJ5cG9pbnRGaW5hbCBvciBwYXNzdGhyb3VnaFxuICAgIGNvbnN0IHBsdWNrU2F2ZVZhbHVlID0gbmV3IFJ1bm5hYmxlQ2FsbGFibGUoe1xuICAgICAgICBuYW1lOiBcInBsdWNrU2F2ZVZhbHVlXCIsXG4gICAgICAgIGZ1bmM6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzRW50cnlwb2ludEZpbmFsKHZhbHVlKSA/IHZhbHVlLnNhdmUgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBlbnRyeXBvaW50Tm9kZSA9IG5ldyBQcmVnZWxOb2RlKHtcbiAgICAgICAgYm91bmQsXG4gICAgICAgIHRyaWdnZXJzOiBbU1RBUlRdLFxuICAgICAgICBjaGFubmVsczogW1NUQVJUXSxcbiAgICAgICAgd3JpdGVyczogW1xuICAgICAgICAgICAgbmV3IENoYW5uZWxXcml0ZShbXG4gICAgICAgICAgICAgICAgeyBjaGFubmVsOiBFTkQsIHZhbHVlOiBQQVNTVEhST1VHSCwgbWFwcGVyOiBwbHVja1JldHVyblZhbHVlIH0sXG4gICAgICAgICAgICAgICAgeyBjaGFubmVsOiBQUkVWSU9VUywgdmFsdWU6IFBBU1NUSFJPVUdILCBtYXBwZXI6IHBsdWNrU2F2ZVZhbHVlIH0sXG4gICAgICAgICAgICBdLCBbVEFHX0hJRERFTl0pLFxuICAgICAgICBdLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJlZ2VsKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2twb2ludGVyLFxuICAgICAgICBub2Rlczoge1xuICAgICAgICAgICAgW25hbWVdOiBlbnRyeXBvaW50Tm9kZSxcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgICAgIFtTVEFSVF06IG5ldyBFcGhlbWVyYWxWYWx1ZSgpLFxuICAgICAgICAgICAgW0VORF06IG5ldyBMYXN0VmFsdWUoKSxcbiAgICAgICAgICAgIFtQUkVWSU9VU106IG5ldyBMYXN0VmFsdWUoKSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXRDaGFubmVsczogU1RBUlQsXG4gICAgICAgIG91dHB1dENoYW5uZWxzOiBFTkQsXG4gICAgICAgIHN0cmVhbUNoYW5uZWxzOiBFTkQsXG4gICAgICAgIHN0cmVhbU1vZGUsXG4gICAgICAgIHN0b3JlLFxuICAgIH0pO1xufTtcbi8vIGRvY3VtZW50ZWQgYnkgdGhlIEVudHJ5cG9pbnRGdW5jdGlvbiBpbnRlcmZhY2VcbmVudHJ5cG9pbnQuZmluYWwgPSBmdW5jdGlvbiBmaW5hbCh7IHZhbHVlLCBzYXZlLCB9KSB7XG4gICAgcmV0dXJuIHsgdmFsdWUsIHNhdmUsIF9fbGdfdHlwZTogXCJfX3ByZWdlbF9maW5hbFwiIH07XG59O1xuLyoqXG4gKiBBIGhlbHBlciB1dGlsaXR5IGZ1bmN0aW9uIGZvciB1c2Ugd2l0aCB0aGUgZnVuY3Rpb25hbCBBUEkgdGhhdCByZXR1cm5zIHRoZSBwcmV2aW91c1xuICogc3RhdGUgZnJvbSB0aGUgY2hlY2twb2ludCBmcm9tIHRoZSBsYXN0IGludm9jYXRpb24gb2YgdGhlIGN1cnJlbnQgdGhyZWFkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHdvcmtmbG93cyB0byBhY2Nlc3Mgc3RhdGUgdGhhdCB3YXMgc2F2ZWQgaW4gcHJldmlvdXMgcnVuc1xuICogdXNpbmcge0BsaW5rIGVudHJ5cG9pbnQuZmluYWx9LlxuICpcbiAqIEB0eXBlUGFyYW0gU3RhdGVUIC0gVGhlIHR5cGUgb2YgdGhlIHN0YXRlIHRoYXQgd2FzIHByZXZpb3VzbHkgc2F2ZWRcbiAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyBzYXZlZCBzdGF0ZSBmcm9tIHRoZSBsYXN0IGludm9jYXRpb24gb2YgdGhlIGN1cnJlbnQgdGhyZWFkXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBnZXRQcmV2aW91c1N0YXRlPHsgY291bnRlcjogbnVtYmVyIH0+KCk7XG4gKiBjb25zdCBuZXdDb3VudCA9IChwcmV2aW91c1N0YXRlPy5jb3VudGVyID8/IDApICsgMTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJldmlvdXNTdGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLmdldFJ1bm5hYmxlQ29uZmlnKCk7XG4gICAgcmV0dXJuIGNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX1BSRVZJT1VTX1NUQVRFXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/func/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/graph/annotation.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/graph/annotation.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationRoot: () => (/* binding */ AnnotationRoot),\n/* harmony export */   getChannel: () => (/* binding */ getChannel)\n/* harmony export */ });\n/* harmony import */ var _channels_binop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../channels/binop.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/binop.js\");\n/* harmony import */ var _channels_last_value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../channels/last_value.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/last_value.js\");\n/* harmony import */ var _managed_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../managed/base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/managed/base.js\");\n\n\n\n/**\n * Should not be instantiated directly. See {@link Annotation}.\n */\nclass AnnotationRoot {\n    constructor(s) {\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AnnotationRoot\"\n        });\n        Object.defineProperty(this, \"spec\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.spec = s;\n    }\n}\n/**\n * Helper that instantiates channels within a StateGraph state.\n *\n * Can be used as a field in an {@link Annotation.Root} wrapper in one of two ways:\n * 1. **Directly**: Creates a channel that stores the most recent value returned from a node.\n * 2. **With a reducer**: Creates a channel that applies the reducer on a node's return value.\n *\n * @example\n * ```ts\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single string key named \"currentOutput\"\n * const SimpleAnnotation = Annotation.Root({\n *   currentOutput: Annotation<string>,\n * });\n *\n * const graphBuilder = new StateGraph(SimpleAnnotation);\n *\n * // A node in the graph that returns an object with a \"currentOutput\" key\n * // replaces the value in the state. You can get the state type as shown below:\n * const myNode = (state: typeof SimpleAnnotation.State) => {\n *   return {\n *     currentOutput: \"some_new_value\",\n *   };\n * }\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   ...\n *   .compile();\n * ```\n *\n * @example\n * ```ts\n * import { type BaseMessage, AIMessage } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const AnnotationWithReducer = Annotation.Root({\n *   messages: Annotation<BaseMessage[]>({\n *     // Different types are allowed for updates\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(AnnotationWithReducer);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof AnnotationWithReducer.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   ...\n *   .compile();\n * ```\n * @namespace\n * @property Root\n * Helper function that instantiates a StateGraph state. See {@link Annotation} for usage.\n */\nconst Annotation = function (annotation) {\n    if ((0,_managed_base_js__WEBPACK_IMPORTED_MODULE_2__.isConfiguredManagedValue)(annotation)) {\n        return annotation;\n    }\n    else if (annotation) {\n        return getChannel(annotation);\n    }\n    else {\n        // @ts-expect-error - Annotation without reducer\n        return new _channels_last_value_js__WEBPACK_IMPORTED_MODULE_1__.LastValue();\n    }\n};\nAnnotation.Root = (sd) => new AnnotationRoot(sd);\nfunction getChannel(reducer) {\n    if (typeof reducer === \"object\" &&\n        reducer &&\n        \"reducer\" in reducer &&\n        reducer.reducer) {\n        return new _channels_binop_js__WEBPACK_IMPORTED_MODULE_0__.BinaryOperatorAggregate(reducer.reducer, reducer.default);\n    }\n    if (typeof reducer === \"object\" &&\n        reducer &&\n        \"value\" in reducer &&\n        reducer.value) {\n        return new _channels_binop_js__WEBPACK_IMPORTED_MODULE_0__.BinaryOperatorAggregate(reducer.value, reducer.default);\n    }\n    // @ts-expect-error - Annotation without reducer\n    return new _channels_last_value_js__WEBPACK_IMPORTED_MODULE_1__.LastValue();\n}\n//# sourceMappingURL=annotation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9ncmFwaC9hbm5vdGF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErRDtBQUNUO0FBQ1M7QUFDL0Q7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxrQkFBa0I7QUFDaEY7QUFDTztBQUNQLFFBQVEsMEVBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUVBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUVBQXVCO0FBQzFDO0FBQ0E7QUFDQSxlQUFlLDhEQUFTO0FBQ3hCO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxncmFwaFxcYW5ub3RhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCaW5hcnlPcGVyYXRvckFnZ3JlZ2F0ZSB9IGZyb20gXCIuLi9jaGFubmVscy9iaW5vcC5qc1wiO1xuaW1wb3J0IHsgTGFzdFZhbHVlIH0gZnJvbSBcIi4uL2NoYW5uZWxzL2xhc3RfdmFsdWUuanNcIjtcbmltcG9ydCB7IGlzQ29uZmlndXJlZE1hbmFnZWRWYWx1ZSwgfSBmcm9tIFwiLi4vbWFuYWdlZC9iYXNlLmpzXCI7XG4vKipcbiAqIFNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBTZWUge0BsaW5rIEFubm90YXRpb259LlxuICovXG5leHBvcnQgY2xhc3MgQW5ub3RhdGlvblJvb3Qge1xuICAgIGNvbnN0cnVjdG9yKHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZ3JhcGhfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJBbm5vdGF0aW9uUm9vdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzcGVjXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3BlYyA9IHM7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdGhhdCBpbnN0YW50aWF0ZXMgY2hhbm5lbHMgd2l0aGluIGEgU3RhdGVHcmFwaCBzdGF0ZS5cbiAqXG4gKiBDYW4gYmUgdXNlZCBhcyBhIGZpZWxkIGluIGFuIHtAbGluayBBbm5vdGF0aW9uLlJvb3R9IHdyYXBwZXIgaW4gb25lIG9mIHR3byB3YXlzOlxuICogMS4gKipEaXJlY3RseSoqOiBDcmVhdGVzIGEgY2hhbm5lbCB0aGF0IHN0b3JlcyB0aGUgbW9zdCByZWNlbnQgdmFsdWUgcmV0dXJuZWQgZnJvbSBhIG5vZGUuXG4gKiAyLiAqKldpdGggYSByZWR1Y2VyKio6IENyZWF0ZXMgYSBjaGFubmVsIHRoYXQgYXBwbGllcyB0aGUgcmVkdWNlciBvbiBhIG5vZGUncyByZXR1cm4gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdGF0ZUdyYXBoLCBBbm5vdGF0aW9uIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoXCI7XG4gKlxuICogLy8gRGVmaW5lIGEgc3RhdGUgd2l0aCBhIHNpbmdsZSBzdHJpbmcga2V5IG5hbWVkIFwiY3VycmVudE91dHB1dFwiXG4gKiBjb25zdCBTaW1wbGVBbm5vdGF0aW9uID0gQW5ub3RhdGlvbi5Sb290KHtcbiAqICAgY3VycmVudE91dHB1dDogQW5ub3RhdGlvbjxzdHJpbmc+LFxuICogfSk7XG4gKlxuICogY29uc3QgZ3JhcGhCdWlsZGVyID0gbmV3IFN0YXRlR3JhcGgoU2ltcGxlQW5ub3RhdGlvbik7XG4gKlxuICogLy8gQSBub2RlIGluIHRoZSBncmFwaCB0aGF0IHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBcImN1cnJlbnRPdXRwdXRcIiBrZXlcbiAqIC8vIHJlcGxhY2VzIHRoZSB2YWx1ZSBpbiB0aGUgc3RhdGUuIFlvdSBjYW4gZ2V0IHRoZSBzdGF0ZSB0eXBlIGFzIHNob3duIGJlbG93OlxuICogY29uc3QgbXlOb2RlID0gKHN0YXRlOiB0eXBlb2YgU2ltcGxlQW5ub3RhdGlvbi5TdGF0ZSkgPT4ge1xuICogICByZXR1cm4ge1xuICogICAgIGN1cnJlbnRPdXRwdXQ6IFwic29tZV9uZXdfdmFsdWVcIixcbiAqICAgfTtcbiAqIH1cbiAqXG4gKiBjb25zdCBncmFwaCA9IGdyYXBoQnVpbGRlclxuICogICAuYWRkTm9kZShcIm15Tm9kZVwiLCBteU5vZGUpXG4gKiAgIC4uLlxuICogICAuY29tcGlsZSgpO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyB0eXBlIEJhc2VNZXNzYWdlLCBBSU1lc3NhZ2UgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzXCI7XG4gKiBpbXBvcnQgeyBTdGF0ZUdyYXBoLCBBbm5vdGF0aW9uIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoXCI7XG4gKlxuICogLy8gRGVmaW5lIGEgc3RhdGUgd2l0aCBhIHNpbmdsZSBrZXkgbmFtZWQgXCJtZXNzYWdlc1wiIHRoYXQgd2lsbFxuICogLy8gY29tYmluZSBhIHJldHVybmVkIEJhc2VNZXNzYWdlIG9yIGFycmF5cyBvZiBCYXNlTWVzc2FnZXNcbiAqIGNvbnN0IEFubm90YXRpb25XaXRoUmVkdWNlciA9IEFubm90YXRpb24uUm9vdCh7XG4gKiAgIG1lc3NhZ2VzOiBBbm5vdGF0aW9uPEJhc2VNZXNzYWdlW10+KHtcbiAqICAgICAvLyBEaWZmZXJlbnQgdHlwZXMgYXJlIGFsbG93ZWQgZm9yIHVwZGF0ZXNcbiAqICAgICByZWR1Y2VyOiAobGVmdDogQmFzZU1lc3NhZ2VbXSwgcmlnaHQ6IEJhc2VNZXNzYWdlIHwgQmFzZU1lc3NhZ2VbXSkgPT4ge1xuICogICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmlnaHQpKSB7XG4gKiAgICAgICAgIHJldHVybiBsZWZ0LmNvbmNhdChyaWdodCk7XG4gKiAgICAgICB9XG4gKiAgICAgICByZXR1cm4gbGVmdC5jb25jYXQoW3JpZ2h0XSk7XG4gKiAgICAgfSxcbiAqICAgICBkZWZhdWx0OiAoKSA9PiBbXSxcbiAqICAgfSksXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBncmFwaEJ1aWxkZXIgPSBuZXcgU3RhdGVHcmFwaChBbm5vdGF0aW9uV2l0aFJlZHVjZXIpO1xuICpcbiAqIC8vIEEgbm9kZSBpbiB0aGUgZ3JhcGggdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgXCJtZXNzYWdlc1wiIGtleVxuICogLy8gd2lsbCB1cGRhdGUgdGhlIHN0YXRlIGJ5IGNvbWJpbmluZyB0aGUgZXhpc3RpbmcgdmFsdWUgd2l0aCB0aGUgcmV0dXJuZWQgb25lLlxuICogY29uc3QgbXlOb2RlID0gKHN0YXRlOiB0eXBlb2YgQW5ub3RhdGlvbldpdGhSZWR1Y2VyLlN0YXRlKSA9PiB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgbWVzc2FnZXM6IFtuZXcgQUlNZXNzYWdlKFwiU29tZSBuZXcgcmVzcG9uc2VcIildLFxuICogICB9O1xuICogfTtcbiAqXG4gKiBjb25zdCBncmFwaCA9IGdyYXBoQnVpbGRlclxuICogICAuYWRkTm9kZShcIm15Tm9kZVwiLCBteU5vZGUpXG4gKiAgIC4uLlxuICogICAuY29tcGlsZSgpO1xuICogYGBgXG4gKiBAbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkgUm9vdFxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaW5zdGFudGlhdGVzIGEgU3RhdGVHcmFwaCBzdGF0ZS4gU2VlIHtAbGluayBBbm5vdGF0aW9ufSBmb3IgdXNhZ2UuXG4gKi9cbmV4cG9ydCBjb25zdCBBbm5vdGF0aW9uID0gZnVuY3Rpb24gKGFubm90YXRpb24pIHtcbiAgICBpZiAoaXNDb25maWd1cmVkTWFuYWdlZFZhbHVlKGFubm90YXRpb24pKSB7XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGFubm90YXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIEFubm90YXRpb24gd2l0aG91dCByZWR1Y2VyXG4gICAgICAgIHJldHVybiBuZXcgTGFzdFZhbHVlKCk7XG4gICAgfVxufTtcbkFubm90YXRpb24uUm9vdCA9IChzZCkgPT4gbmV3IEFubm90YXRpb25Sb290KHNkKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFubmVsKHJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXIgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgcmVkdWNlciAmJlxuICAgICAgICBcInJlZHVjZXJcIiBpbiByZWR1Y2VyICYmXG4gICAgICAgIHJlZHVjZXIucmVkdWNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yQWdncmVnYXRlKHJlZHVjZXIucmVkdWNlciwgcmVkdWNlci5kZWZhdWx0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHJlZHVjZXIgJiZcbiAgICAgICAgXCJ2YWx1ZVwiIGluIHJlZHVjZXIgJiZcbiAgICAgICAgcmVkdWNlci52YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yQWdncmVnYXRlKHJlZHVjZXIudmFsdWUsIHJlZHVjZXIuZGVmYXVsdCk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBBbm5vdGF0aW9uIHdpdGhvdXQgcmVkdWNlclxuICAgIHJldHVybiBuZXcgTGFzdFZhbHVlKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbm5vdGF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/graph/annotation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/graph/graph.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/graph/graph.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Branch: () => (/* binding */ Branch),\n/* harmony export */   CompiledGraph: () => (/* binding */ CompiledGraph),\n/* harmony export */   Graph: () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _langchain_core_runnables_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/runnables/graph */ \"(rsc)/./node_modules/@langchain/core/runnables/graph.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _pregel_read_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pregel/read.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/read.js\");\n/* harmony import */ var _pregel_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pregel/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/index.js\");\n/* harmony import */ var _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../channels/ephemeral_value.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js\");\n/* harmony import */ var _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../pregel/write.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/write.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _pregel_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../pregel/utils/subgraph.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js\");\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\n\n\n\n\n\n\n\n\n\n\n\nclass Branch {\n    constructor(options) {\n        Object.defineProperty(this, \"path\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ends\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(options.path)) {\n            this.path = options.path;\n        }\n        else {\n            this.path = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(options.path).withConfig({\n                runName: `Branch`,\n            });\n        }\n        this.ends = Array.isArray(options.pathMap)\n            ? options.pathMap.reduce((acc, n) => {\n                acc[n] = n;\n                return acc;\n            }, {})\n            : options.pathMap;\n    }\n    run(writer, reader) {\n        return _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.ChannelWrite.registerWriter(new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n            name: \"<branch_run>\",\n            trace: false,\n            func: async (input, config) => {\n                try {\n                    return await this._route(input, config, writer, reader);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (e) {\n                    // Detect & warn if NodeInterrupt is thrown in a conditional edge\n                    if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_8__.NodeInterrupt.unminifiable_name) {\n                        console.warn(\"[WARN]: 'NodeInterrupt' thrown in conditional edge. This is likely a bug in your graph implementation.\\n\" +\n                            \"NodeInterrupt should only be thrown inside a node, not in edge conditions.\");\n                    }\n                    throw e;\n                }\n            },\n        }));\n    }\n    async _route(input, config, writer, reader\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        let result = await this.path.invoke(reader ? reader(config) : input, config);\n        if (!Array.isArray(result)) {\n            result = [result];\n        }\n        let destinations;\n        if (this.ends) {\n            destinations = result.map((r) => ((0,_constants_js__WEBPACK_IMPORTED_MODULE_6__._isSend)(r) ? r : this.ends[r]));\n        }\n        else {\n            destinations = result;\n        }\n        if (destinations.some((dest) => !dest)) {\n            throw new Error(\"Branch condition returned unknown or null destination\");\n        }\n        if (destinations.filter(_constants_js__WEBPACK_IMPORTED_MODULE_6__._isSend).some((packet) => packet.node === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END)) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.InvalidUpdateError(\"Cannot send a packet to the END node\");\n        }\n        const writeResult = await writer(destinations, config);\n        return writeResult ?? input;\n    }\n}\nclass Graph {\n    constructor() {\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"edges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"branches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"entryPoint\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"compiled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.nodes = {};\n        this.edges = new Set();\n        this.branches = {};\n    }\n    warnIfCompiled(message) {\n        if (this.compiled) {\n            console.warn(message);\n        }\n    }\n    get allEdges() {\n        return this.edges;\n    }\n    addNode(...args) {\n        function isMutlipleNodes(args) {\n            return args.length >= 1 && typeof args[0] !== \"string\";\n        }\n        const nodes = (isMutlipleNodes(args) // eslint-disable-line no-nested-ternary\n            ? Array.isArray(args[0])\n                ? args[0]\n                : Object.entries(args[0])\n            : [[args[0], args[1], args[2]]]);\n        if (nodes.length === 0) {\n            throw new Error(\"No nodes provided in `addNode`\");\n        }\n        for (const [key, action, options] of nodes) {\n            for (const reservedChar of [\n                _constants_js__WEBPACK_IMPORTED_MODULE_6__.CHECKPOINT_NAMESPACE_SEPARATOR,\n                _constants_js__WEBPACK_IMPORTED_MODULE_6__.CHECKPOINT_NAMESPACE_END,\n            ]) {\n                if (key.includes(reservedChar)) {\n                    throw new Error(`\"${reservedChar}\" is a reserved character and is not allowed in node names.`);\n                }\n            }\n            this.warnIfCompiled(`Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`);\n            if (key in this.nodes) {\n                throw new Error(`Node \\`${key}\\` already present.`);\n            }\n            if (key === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END) {\n                throw new Error(`Node \\`${key}\\` is reserved.`);\n            }\n            const runnable = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(\n            // Account for arbitrary state due to Send API\n            action);\n            this.nodes[key] = {\n                runnable,\n                metadata: options?.metadata,\n                subgraphs: (0,_pregel_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_9__.isPregelLike)(runnable) ? [runnable] : options?.subgraphs,\n                ends: options?.ends,\n            };\n        }\n        return this;\n    }\n    addEdge(startKey, endKey) {\n        this.warnIfCompiled(`Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.`);\n        if (startKey === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END) {\n            throw new Error(\"END cannot be a start node\");\n        }\n        if (endKey === _constants_js__WEBPACK_IMPORTED_MODULE_6__.START) {\n            throw new Error(\"START cannot be an end node\");\n        }\n        if (Array.from(this.edges).some(([start]) => start === startKey) &&\n            !(\"channels\" in this)) {\n            throw new Error(`Already found path for ${startKey}. For multiple edges, use StateGraph.`);\n        }\n        this.edges.add([startKey, endKey]);\n        return this;\n    }\n    addConditionalEdges(source, path, pathMap) {\n        const options = typeof source === \"object\" ? source : { source, path: path, pathMap };\n        this.warnIfCompiled(\"Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.\");\n        if (!_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(options.path)) {\n            const pathDisplayValues = Array.isArray(options.pathMap)\n                ? options.pathMap.join(\",\")\n                : Object.keys(options.pathMap ?? {}).join(\",\");\n            options.path = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(options.path).withConfig({\n                runName: `Branch<${options.source}${pathDisplayValues !== \"\" ? `,${pathDisplayValues}` : \"\"}>`.slice(0, 63),\n            });\n        }\n        // find a name for condition\n        const name = options.path.getName() === \"RunnableLambda\"\n            ? \"condition\"\n            : options.path.getName();\n        // validate condition\n        if (this.branches[options.source] && this.branches[options.source][name]) {\n            throw new Error(`Condition \\`${name}\\` already present for node \\`${source}\\``);\n        }\n        // save it\n        this.branches[options.source] ??= {};\n        this.branches[options.source][name] = new Branch(options);\n        return this;\n    }\n    /**\n     * @deprecated use `addEdge(START, key)` instead\n     */\n    setEntryPoint(key) {\n        this.warnIfCompiled(\"Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph.\");\n        return this.addEdge(_constants_js__WEBPACK_IMPORTED_MODULE_6__.START, key);\n    }\n    /**\n     * @deprecated use `addEdge(key, END)` instead\n     */\n    setFinishPoint(key) {\n        this.warnIfCompiled(\"Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph.\");\n        return this.addEdge(key, _constants_js__WEBPACK_IMPORTED_MODULE_6__.END);\n    }\n    compile({ checkpointer, interruptBefore, interruptAfter, name, } = {}) {\n        // validate the graph\n        this.validate([\n            ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n            ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n        ]);\n        // create empty compiled graph\n        const compiled = new CompiledGraph({\n            builder: this,\n            checkpointer,\n            interruptAfter,\n            interruptBefore,\n            autoValidate: false,\n            nodes: {},\n            channels: {\n                [_constants_js__WEBPACK_IMPORTED_MODULE_6__.START]: new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__.EphemeralValue(),\n                [_constants_js__WEBPACK_IMPORTED_MODULE_6__.END]: new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__.EphemeralValue(),\n            },\n            inputChannels: _constants_js__WEBPACK_IMPORTED_MODULE_6__.START,\n            outputChannels: _constants_js__WEBPACK_IMPORTED_MODULE_6__.END,\n            streamChannels: [],\n            streamMode: \"values\",\n            name,\n        });\n        // attach nodes, edges and branches\n        for (const [key, node] of Object.entries(this.nodes)) {\n            compiled.attachNode(key, node);\n        }\n        for (const [start, end] of this.edges) {\n            compiled.attachEdge(start, end);\n        }\n        for (const [start, branches] of Object.entries(this.branches)) {\n            for (const [name, branch] of Object.entries(branches)) {\n                compiled.attachBranch(start, name, branch);\n            }\n        }\n        return compiled.validate();\n    }\n    validate(interrupt) {\n        // assemble sources\n        const allSources = new Set([...this.allEdges].map(([src, _]) => src));\n        for (const [start] of Object.entries(this.branches)) {\n            allSources.add(start);\n        }\n        // validate sources\n        for (const source of allSources) {\n            if (source !== _constants_js__WEBPACK_IMPORTED_MODULE_6__.START && !(source in this.nodes)) {\n                throw new Error(`Found edge starting at unknown node \\`${source}\\``);\n            }\n        }\n        // assemble targets\n        const allTargets = new Set([...this.allEdges].map(([_, target]) => target));\n        for (const [start, branches] of Object.entries(this.branches)) {\n            for (const branch of Object.values(branches)) {\n                if (branch.ends != null) {\n                    for (const end of Object.values(branch.ends)) {\n                        allTargets.add(end);\n                    }\n                }\n                else {\n                    allTargets.add(_constants_js__WEBPACK_IMPORTED_MODULE_6__.END);\n                    for (const node of Object.keys(this.nodes)) {\n                        if (node !== start) {\n                            allTargets.add(node);\n                        }\n                    }\n                }\n            }\n        }\n        for (const node of Object.values(this.nodes)) {\n            for (const target of node.ends ?? []) {\n                allTargets.add(target);\n            }\n        }\n        // validate targets\n        for (const node of Object.keys(this.nodes)) {\n            if (!allTargets.has(node)) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.UnreachableNodeError([\n                    `Node \\`${node}\\` is not reachable.`,\n                    \"\",\n                    \"If you are returning Command objects from your node,\",\n                    'make sure you are passing names of potential destination nodes as an \"ends\" array',\n                    'into \".addNode(..., { ends: [\"node1\", \"node2\"] })\".',\n                ].join(\"\\n\"), {\n                    lc_error_code: \"UNREACHABLE_NODE\",\n                });\n            }\n        }\n        for (const target of allTargets) {\n            if (target !== _constants_js__WEBPACK_IMPORTED_MODULE_6__.END && !(target in this.nodes)) {\n                throw new Error(`Found edge ending at unknown node \\`${target}\\``);\n            }\n        }\n        // validate interrupts\n        if (interrupt) {\n            for (const node of interrupt) {\n                if (!(node in this.nodes)) {\n                    throw new Error(`Interrupt node \\`${node}\\` is not present`);\n                }\n            }\n        }\n        this.compiled = true;\n    }\n}\nclass CompiledGraph extends _pregel_index_js__WEBPACK_IMPORTED_MODULE_3__.Pregel {\n    constructor({ builder, ...rest }) {\n        super(rest);\n        Object.defineProperty(this, \"builder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.builder = builder;\n    }\n    attachNode(key, node) {\n        this.channels[key] = new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__.EphemeralValue();\n        this.nodes[key] = new _pregel_read_js__WEBPACK_IMPORTED_MODULE_2__.PregelNode({\n            channels: [],\n            triggers: [],\n            metadata: node.metadata,\n            subgraphs: node.subgraphs,\n            ends: node.ends,\n        })\n            .pipe(node.runnable)\n            .pipe(new _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.ChannelWrite([{ channel: key, value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.PASSTHROUGH }], [_constants_js__WEBPACK_IMPORTED_MODULE_6__.TAG_HIDDEN]));\n        this.streamChannels.push(key);\n    }\n    attachEdge(start, end) {\n        if (end === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END) {\n            if (start === _constants_js__WEBPACK_IMPORTED_MODULE_6__.START) {\n                throw new Error(\"Cannot have an edge from START to END\");\n            }\n            this.nodes[start].writers.push(new _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.ChannelWrite([{ channel: _constants_js__WEBPACK_IMPORTED_MODULE_6__.END, value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.PASSTHROUGH }], [_constants_js__WEBPACK_IMPORTED_MODULE_6__.TAG_HIDDEN]));\n        }\n        else {\n            this.nodes[end].triggers.push(start);\n            this.nodes[end].channels.push(start);\n        }\n    }\n    attachBranch(start, name, branch) {\n        // add hidden start node\n        if (start === _constants_js__WEBPACK_IMPORTED_MODULE_6__.START && !this.nodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.START]) {\n            this.nodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.START] = _pregel_index_js__WEBPACK_IMPORTED_MODULE_3__.Channel.subscribeTo(_constants_js__WEBPACK_IMPORTED_MODULE_6__.START, { tags: [_constants_js__WEBPACK_IMPORTED_MODULE_6__.TAG_HIDDEN] });\n        }\n        // attach branch writer\n        this.nodes[start].pipe(branch.run((dests) => {\n            const writes = dests.map((dest) => {\n                if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_6__._isSend)(dest)) {\n                    return dest;\n                }\n                return {\n                    channel: dest === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END ? _constants_js__WEBPACK_IMPORTED_MODULE_6__.END : `branch:${start}:${name}:${dest}`,\n                    value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.PASSTHROUGH,\n                };\n            });\n            return new _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.ChannelWrite(writes, [_constants_js__WEBPACK_IMPORTED_MODULE_6__.TAG_HIDDEN]);\n        }));\n        // attach branch readers\n        const ends = branch.ends\n            ? Object.values(branch.ends)\n            : Object.keys(this.nodes);\n        for (const end of ends) {\n            if (end !== _constants_js__WEBPACK_IMPORTED_MODULE_6__.END) {\n                const channelName = `branch:${start}:${name}:${end}`;\n                this.channels[channelName] =\n                    new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__.EphemeralValue();\n                this.nodes[end].triggers.push(channelName);\n                this.nodes[end].channels.push(channelName);\n            }\n        }\n    }\n    /**\n     * Returns a drawable representation of the computation graph.\n     */\n    async getGraphAsync(config) {\n        const xray = config?.xray;\n        const graph = new _langchain_core_runnables_graph__WEBPACK_IMPORTED_MODULE_1__.Graph();\n        const startNodes = {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_6__.START]: graph.addNode({\n                schema: zod__WEBPACK_IMPORTED_MODULE_10__.any(),\n            }, _constants_js__WEBPACK_IMPORTED_MODULE_6__.START),\n        };\n        const endNodes = {};\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let subgraphs = {};\n        if (xray) {\n            subgraphs = Object.fromEntries((await (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.gatherIterator)(this.getSubgraphsAsync())).filter(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (x) => isCompiledGraph(x[1])));\n        }\n        function addEdge(start, end, label, conditional = false) {\n            if (end === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END && endNodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.END] === undefined) {\n                endNodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.END] = graph.addNode({ schema: zod__WEBPACK_IMPORTED_MODULE_10__.any() }, _constants_js__WEBPACK_IMPORTED_MODULE_6__.END);\n            }\n            if (startNodes[start] === undefined) {\n                return;\n            }\n            if (endNodes[end] === undefined) {\n                throw new Error(`End node ${end} not found!`);\n            }\n            return graph.addEdge(startNodes[start], endNodes[end], label !== end ? label : undefined, conditional);\n        }\n        for (const [key, nodeSpec] of Object.entries(this.builder.nodes)) {\n            const displayKey = _escapeMermaidKeywords(key);\n            const node = nodeSpec.runnable;\n            const metadata = nodeSpec.metadata ?? {};\n            if (this.interruptBefore?.includes(key) &&\n                this.interruptAfter?.includes(key)) {\n                metadata.__interrupt = \"before,after\";\n            }\n            else if (this.interruptBefore?.includes(key)) {\n                metadata.__interrupt = \"before\";\n            }\n            else if (this.interruptAfter?.includes(key)) {\n                metadata.__interrupt = \"after\";\n            }\n            if (xray) {\n                const newXrayValue = typeof xray === \"number\" ? xray - 1 : xray;\n                const drawableSubgraph = subgraphs[key] !== undefined\n                    ? await subgraphs[key].getGraphAsync({\n                        ...config,\n                        xray: newXrayValue,\n                    })\n                    : node.getGraph(config);\n                drawableSubgraph.trimFirstNode();\n                drawableSubgraph.trimLastNode();\n                if (Object.keys(drawableSubgraph.nodes).length > 1) {\n                    const [e, s] = graph.extend(drawableSubgraph, displayKey);\n                    if (e === undefined) {\n                        throw new Error(`Could not extend subgraph \"${key}\" due to missing entrypoint.`);\n                    }\n                    // TODO: Remove default name once we stop supporting core 0.2.0\n                    // eslint-disable-next-line no-inner-declarations\n                    function _isRunnableInterface(\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    thing) {\n                        return thing ? thing.lc_runnable : false;\n                    }\n                    // eslint-disable-next-line no-inner-declarations\n                    function _nodeDataStr(id, data) {\n                        if (id !== undefined && !(0,uuid__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(id)) {\n                            return id;\n                        }\n                        else if (_isRunnableInterface(data)) {\n                            try {\n                                let dataStr = data.getName();\n                                dataStr = dataStr.startsWith(\"Runnable\")\n                                    ? dataStr.slice(\"Runnable\".length)\n                                    : dataStr;\n                                return dataStr;\n                            }\n                            catch (error) {\n                                return data.getName();\n                            }\n                        }\n                        else {\n                            return data.name ?? \"UnknownSchema\";\n                        }\n                    }\n                    // TODO: Remove casts when we stop supporting core 0.2.0\n                    if (s !== undefined) {\n                        startNodes[displayKey] = {\n                            name: _nodeDataStr(s.id, s.data),\n                            ...s,\n                        };\n                    }\n                    endNodes[displayKey] = {\n                        name: _nodeDataStr(e.id, e.data),\n                        ...e,\n                    };\n                }\n                else {\n                    // TODO: Remove when we stop supporting core 0.2.0\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    const newNode = graph.addNode(node, displayKey, metadata);\n                    startNodes[displayKey] = newNode;\n                    endNodes[displayKey] = newNode;\n                }\n            }\n            else {\n                // TODO: Remove when we stop supporting core 0.2.0\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                const newNode = graph.addNode(node, displayKey, metadata);\n                startNodes[displayKey] = newNode;\n                endNodes[displayKey] = newNode;\n            }\n        }\n        const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {\n            if (a < b) {\n                return -1;\n            }\n            else if (b > a) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n        for (const [start, end] of sortedEdges) {\n            addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));\n        }\n        for (const [start, branches] of Object.entries(this.builder.branches)) {\n            const defaultEnds = {\n                ...Object.fromEntries(Object.keys(this.builder.nodes)\n                    .filter((k) => k !== start)\n                    .map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])),\n                [_constants_js__WEBPACK_IMPORTED_MODULE_6__.END]: _constants_js__WEBPACK_IMPORTED_MODULE_6__.END,\n            };\n            for (const branch of Object.values(branches)) {\n                let ends;\n                if (branch.ends !== undefined) {\n                    ends = branch.ends;\n                }\n                else {\n                    ends = defaultEnds;\n                }\n                for (const [label, end] of Object.entries(ends)) {\n                    addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end), label, true);\n                }\n            }\n        }\n        for (const [key, node] of Object.entries(this.builder.nodes)) {\n            if (node.ends !== undefined) {\n                for (const end of node.ends) {\n                    addEdge(_escapeMermaidKeywords(key), _escapeMermaidKeywords(end), undefined, true);\n                }\n            }\n        }\n        return graph;\n    }\n    /**\n     * Returns a drawable representation of the computation graph.\n     *\n     * @deprecated Use getGraphAsync instead. The async method will be the default in the next minor core release.\n     */\n    getGraph(config) {\n        const xray = config?.xray;\n        const graph = new _langchain_core_runnables_graph__WEBPACK_IMPORTED_MODULE_1__.Graph();\n        const startNodes = {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_6__.START]: graph.addNode({\n                schema: zod__WEBPACK_IMPORTED_MODULE_10__.any(),\n            }, _constants_js__WEBPACK_IMPORTED_MODULE_6__.START),\n        };\n        const endNodes = {};\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let subgraphs = {};\n        if (xray) {\n            subgraphs = Object.fromEntries((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.gatherIteratorSync)(this.getSubgraphs()).filter(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (x) => isCompiledGraph(x[1])));\n        }\n        function addEdge(start, end, label, conditional = false) {\n            if (end === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END && endNodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.END] === undefined) {\n                endNodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.END] = graph.addNode({ schema: zod__WEBPACK_IMPORTED_MODULE_10__.any() }, _constants_js__WEBPACK_IMPORTED_MODULE_6__.END);\n            }\n            return graph.addEdge(startNodes[start], endNodes[end], label !== end ? label : undefined, conditional);\n        }\n        for (const [key, nodeSpec] of Object.entries(this.builder.nodes)) {\n            const displayKey = _escapeMermaidKeywords(key);\n            const node = nodeSpec.runnable;\n            const metadata = nodeSpec.metadata ?? {};\n            if (this.interruptBefore?.includes(key) &&\n                this.interruptAfter?.includes(key)) {\n                metadata.__interrupt = \"before,after\";\n            }\n            else if (this.interruptBefore?.includes(key)) {\n                metadata.__interrupt = \"before\";\n            }\n            else if (this.interruptAfter?.includes(key)) {\n                metadata.__interrupt = \"after\";\n            }\n            if (xray) {\n                const newXrayValue = typeof xray === \"number\" ? xray - 1 : xray;\n                const drawableSubgraph = subgraphs[key] !== undefined\n                    ? subgraphs[key].getGraph({\n                        ...config,\n                        xray: newXrayValue,\n                    })\n                    : node.getGraph(config);\n                drawableSubgraph.trimFirstNode();\n                drawableSubgraph.trimLastNode();\n                if (Object.keys(drawableSubgraph.nodes).length > 1) {\n                    const [e, s] = graph.extend(drawableSubgraph, displayKey);\n                    if (e === undefined) {\n                        throw new Error(`Could not extend subgraph \"${key}\" due to missing entrypoint.`);\n                    }\n                    // TODO: Remove default name once we stop supporting core 0.2.0\n                    // eslint-disable-next-line no-inner-declarations\n                    function _isRunnableInterface(\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    thing) {\n                        return thing ? thing.lc_runnable : false;\n                    }\n                    // eslint-disable-next-line no-inner-declarations\n                    function _nodeDataStr(id, data) {\n                        if (id !== undefined && !(0,uuid__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(id)) {\n                            return id;\n                        }\n                        else if (_isRunnableInterface(data)) {\n                            try {\n                                let dataStr = data.getName();\n                                dataStr = dataStr.startsWith(\"Runnable\")\n                                    ? dataStr.slice(\"Runnable\".length)\n                                    : dataStr;\n                                return dataStr;\n                            }\n                            catch (error) {\n                                return data.getName();\n                            }\n                        }\n                        else {\n                            return data.name ?? \"UnknownSchema\";\n                        }\n                    }\n                    // TODO: Remove casts when we stop supporting core 0.2.0\n                    if (s !== undefined) {\n                        startNodes[displayKey] = {\n                            name: _nodeDataStr(s.id, s.data),\n                            ...s,\n                        };\n                    }\n                    endNodes[displayKey] = {\n                        name: _nodeDataStr(e.id, e.data),\n                        ...e,\n                    };\n                }\n                else {\n                    // TODO: Remove when we stop supporting core 0.2.0\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    const newNode = graph.addNode(node, displayKey, metadata);\n                    startNodes[displayKey] = newNode;\n                    endNodes[displayKey] = newNode;\n                }\n            }\n            else {\n                // TODO: Remove when we stop supporting core 0.2.0\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                const newNode = graph.addNode(node, displayKey, metadata);\n                startNodes[displayKey] = newNode;\n                endNodes[displayKey] = newNode;\n            }\n        }\n        const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {\n            if (a < b) {\n                return -1;\n            }\n            else if (b > a) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n        for (const [start, end] of sortedEdges) {\n            addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));\n        }\n        for (const [start, branches] of Object.entries(this.builder.branches)) {\n            const defaultEnds = {\n                ...Object.fromEntries(Object.keys(this.builder.nodes)\n                    .filter((k) => k !== start)\n                    .map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])),\n                [_constants_js__WEBPACK_IMPORTED_MODULE_6__.END]: _constants_js__WEBPACK_IMPORTED_MODULE_6__.END,\n            };\n            for (const branch of Object.values(branches)) {\n                let ends;\n                if (branch.ends !== undefined) {\n                    ends = branch.ends;\n                }\n                else {\n                    ends = defaultEnds;\n                }\n                for (const [label, end] of Object.entries(ends)) {\n                    addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end), label, true);\n                }\n            }\n        }\n        return graph;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isCompiledGraph(x) {\n    return (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof x.attachNode === \"function\" &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof x.attachEdge === \"function\");\n}\nfunction _escapeMermaidKeywords(key) {\n    if (key === \"subgraph\") {\n        return `\"${key}\"`;\n    }\n    return key;\n}\n//# sourceMappingURL=graph.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9ncmFwaC9ncmFwaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5RTtBQUNDO0FBQ2xEO0FBQ2tCO0FBQ0s7QUFDTTtBQUNXO0FBQ0Q7QUFDOEQ7QUFDekM7QUFDSTtBQUM3QjtBQUNwRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFlBQVksK0RBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRFQUFpQjtBQUN6QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQVksb0JBQW9CLHVEQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscURBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0RBQU8sbUNBQW1DLDhDQUFHO0FBQzdFLHNCQUFzQiwwREFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlFQUE4QjtBQUM5QyxnQkFBZ0IsbUVBQXdCO0FBQ3hDO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0Esd0JBQXdCLDhDQUFHO0FBQzNCLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0EsNkJBQTZCLDRFQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUFHO0FBQzVCO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsYUFBYSwrREFBUTtBQUNyQjtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELDJCQUEyQiw0RUFBaUI7QUFDNUMsbUNBQW1DLGVBQWUsRUFBRSwrQkFBK0Isa0JBQWtCLE9BQU87QUFDNUcsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUssZ0NBQWdDLE9BQU87QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOENBQUc7QUFDcEM7QUFDQSxjQUFjLHVEQUF1RCxJQUFJO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQixnREFBSyxPQUFPLHdFQUFjO0FBQzNDLGlCQUFpQiw4Q0FBRyxPQUFPLHdFQUFjO0FBQ3pDLGFBQWE7QUFDYiwyQkFBMkIsZ0RBQUs7QUFDaEMsNEJBQTRCLDhDQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnREFBSztBQUNoQyx5RUFBeUUsT0FBTztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOENBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNERBQW9CO0FBQzlDLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQUc7QUFDOUIsdUVBQXVFLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLG9EQUFNO0FBQ3pDLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3RUFBYztBQUMvQyw4QkFBOEIsdURBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQiwwREFBWSxJQUFJLHFCQUFxQix5REFBVyxFQUFFLElBQUkscURBQVU7QUFDdEY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFHO0FBQ3ZCLDBCQUEwQixnREFBSztBQUMvQjtBQUNBO0FBQ0EsK0NBQStDLDBEQUFZLElBQUksU0FBUyw4Q0FBRyxTQUFTLHlEQUFXLEVBQUUsSUFBSSxxREFBVTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFLLGdCQUFnQixnREFBSztBQUNoRCx1QkFBdUIsZ0RBQUssSUFBSSxxREFBTyxhQUFhLGdEQUFLLElBQUksT0FBTyxxREFBVSxHQUFHO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw4Q0FBRyxHQUFHLDhDQUFHLGFBQWEsTUFBTSxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ2xGLDJCQUEyQix5REFBVztBQUN0QztBQUNBLGFBQWE7QUFDYix1QkFBdUIsMERBQVksVUFBVSxxREFBVTtBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBRztBQUMzQiw4Q0FBOEMsTUFBTSxHQUFHLEtBQUssR0FBRyxJQUFJO0FBQ25FO0FBQ0Esd0JBQXdCLHdFQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUFhO0FBQ3ZDO0FBQ0EsYUFBYSxnREFBSztBQUNsQix3QkFBd0IscUNBQUs7QUFDN0IsYUFBYSxFQUFFLGdEQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseURBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQUcsYUFBYSw4Q0FBRztBQUMzQyx5QkFBeUIsOENBQUcsb0JBQW9CLFFBQVEscUNBQUssSUFBSSxFQUFFLDhDQUFHO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlEQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQUcsR0FBRyw4Q0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0VBQWE7QUFDdkM7QUFDQSxhQUFhLGdEQUFLO0FBQ2xCLHdCQUF3QixxQ0FBSztBQUM3QixhQUFhLEVBQUUsZ0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw2REFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQUcsYUFBYSw4Q0FBRztBQUMzQyx5QkFBeUIsOENBQUcsb0JBQW9CLFFBQVEscUNBQUssSUFBSSxFQUFFLDhDQUFHO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaURBQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBRyxHQUFHLDhDQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxcZ3JhcGhcXGdyYXBoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL1xuaW1wb3J0IHsgX2NvZXJjZVRvUnVubmFibGUsIFJ1bm5hYmxlLCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG5pbXBvcnQgeyBHcmFwaCBhcyBEcmF3YWJsZUdyYXBoLCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzL2dyYXBoXCI7XG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xuaW1wb3J0IHsgdmFsaWRhdGUgYXMgaXNVdWlkIH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IFByZWdlbE5vZGUgfSBmcm9tIFwiLi4vcHJlZ2VsL3JlYWQuanNcIjtcbmltcG9ydCB7IENoYW5uZWwsIFByZWdlbCB9IGZyb20gXCIuLi9wcmVnZWwvaW5kZXguanNcIjtcbmltcG9ydCB7IEVwaGVtZXJhbFZhbHVlIH0gZnJvbSBcIi4uL2NoYW5uZWxzL2VwaGVtZXJhbF92YWx1ZS5qc1wiO1xuaW1wb3J0IHsgQ2hhbm5lbFdyaXRlLCBQQVNTVEhST1VHSCB9IGZyb20gXCIuLi9wcmVnZWwvd3JpdGUuanNcIjtcbmltcG9ydCB7IF9pc1NlbmQsIENIRUNLUE9JTlRfTkFNRVNQQUNFX0VORCwgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SLCBFTkQsIFNUQVJULCBUQUdfSElEREVOLCB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IGdhdGhlckl0ZXJhdG9yLCBnYXRoZXJJdGVyYXRvclN5bmMsIFJ1bm5hYmxlQ2FsbGFibGUsIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBJbnZhbGlkVXBkYXRlRXJyb3IsIE5vZGVJbnRlcnJ1cHQsIFVucmVhY2hhYmxlTm9kZUVycm9yLCB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGlzUHJlZ2VsTGlrZSB9IGZyb20gXCIuLi9wcmVnZWwvdXRpbHMvc3ViZ3JhcGguanNcIjtcbmV4cG9ydCBjbGFzcyBCcmFuY2gge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChSdW5uYWJsZS5pc1J1bm5hYmxlKG9wdGlvbnMucGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IF9jb2VyY2VUb1J1bm5hYmxlKG9wdGlvbnMucGF0aCkud2l0aENvbmZpZyh7XG4gICAgICAgICAgICAgICAgcnVuTmFtZTogYEJyYW5jaGAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZHMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMucGF0aE1hcClcbiAgICAgICAgICAgID8gb3B0aW9ucy5wYXRoTWFwLnJlZHVjZSgoYWNjLCBuKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW25dID0gbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pXG4gICAgICAgICAgICA6IG9wdGlvbnMucGF0aE1hcDtcbiAgICB9XG4gICAgcnVuKHdyaXRlciwgcmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBDaGFubmVsV3JpdGUucmVnaXN0ZXJXcml0ZXIobmV3IFJ1bm5hYmxlQ2FsbGFibGUoe1xuICAgICAgICAgICAgbmFtZTogXCI8YnJhbmNoX3J1bj5cIixcbiAgICAgICAgICAgIHRyYWNlOiBmYWxzZSxcbiAgICAgICAgICAgIGZ1bmM6IGFzeW5jIChpbnB1dCwgY29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JvdXRlKGlucHV0LCBjb25maWcsIHdyaXRlciwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0ICYgd2FybiBpZiBOb2RlSW50ZXJydXB0IGlzIHRocm93biBpbiBhIGNvbmRpdGlvbmFsIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gTm9kZUludGVycnVwdC51bm1pbmlmaWFibGVfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5dOiAnTm9kZUludGVycnVwdCcgdGhyb3duIGluIGNvbmRpdGlvbmFsIGVkZ2UuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIHlvdXIgZ3JhcGggaW1wbGVtZW50YXRpb24uXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTm9kZUludGVycnVwdCBzaG91bGQgb25seSBiZSB0aHJvd24gaW5zaWRlIGEgbm9kZSwgbm90IGluIGVkZ2UgY29uZGl0aW9ucy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIF9yb3V0ZShpbnB1dCwgY29uZmlnLCB3cml0ZXIsIHJlYWRlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLnBhdGguaW52b2tlKHJlYWRlciA/IHJlYWRlcihjb25maWcpIDogaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVzdGluYXRpb25zO1xuICAgICAgICBpZiAodGhpcy5lbmRzKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbnMgPSByZXN1bHQubWFwKChyKSA9PiAoX2lzU2VuZChyKSA/IHIgOiB0aGlzLmVuZHNbcl0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9ucyA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzdGluYXRpb25zLnNvbWUoKGRlc3QpID0+ICFkZXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnJhbmNoIGNvbmRpdGlvbiByZXR1cm5lZCB1bmtub3duIG9yIG51bGwgZGVzdGluYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc3RpbmF0aW9ucy5maWx0ZXIoX2lzU2VuZCkuc29tZSgocGFja2V0KSA9PiBwYWNrZXQubm9kZSA9PT0gRU5EKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcGRhdGVFcnJvcihcIkNhbm5vdCBzZW5kIGEgcGFja2V0IHRvIHRoZSBFTkQgbm9kZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cml0ZVJlc3VsdCA9IGF3YWl0IHdyaXRlcihkZXN0aW5hdGlvbnMsIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB3cml0ZVJlc3VsdCA/PyBpbnB1dDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR3JhcGgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2Rlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlZGdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJicmFuY2hlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbnRyeVBvaW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbXBpbGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLmVkZ2VzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmJyYW5jaGVzID0ge307XG4gICAgfVxuICAgIHdhcm5JZkNvbXBpbGVkKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYWxsRWRnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkZ2VzO1xuICAgIH1cbiAgICBhZGROb2RlKC4uLmFyZ3MpIHtcbiAgICAgICAgZnVuY3Rpb24gaXNNdXRsaXBsZU5vZGVzKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA+PSAxICYmIHR5cGVvZiBhcmdzWzBdICE9PSBcInN0cmluZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVzID0gKGlzTXV0bGlwbGVOb2RlcyhhcmdzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoYXJnc1swXSlcbiAgICAgICAgICAgICAgICA/IGFyZ3NbMF1cbiAgICAgICAgICAgICAgICA6IE9iamVjdC5lbnRyaWVzKGFyZ3NbMF0pXG4gICAgICAgICAgICA6IFtbYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXV1dKTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbm9kZXMgcHJvdmlkZWQgaW4gYGFkZE5vZGVgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgYWN0aW9uLCBvcHRpb25zXSBvZiBub2Rlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXNlcnZlZENoYXIgb2YgW1xuICAgICAgICAgICAgICAgIENIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUixcbiAgICAgICAgICAgICAgICBDSEVDS1BPSU5UX05BTUVTUEFDRV9FTkQsXG4gICAgICAgICAgICBdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5pbmNsdWRlcyhyZXNlcnZlZENoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3Jlc2VydmVkQ2hhcn1cIiBpcyBhIHJlc2VydmVkIGNoYXJhY3RlciBhbmQgaXMgbm90IGFsbG93ZWQgaW4gbm9kZSBuYW1lcy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndhcm5JZkNvbXBpbGVkKGBBZGRpbmcgYSBub2RlIHRvIGEgZ3JhcGggdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBpbGVkLiBUaGlzIHdpbGwgbm90IGJlIHJlZmxlY3RlZCBpbiB0aGUgY29tcGlsZWQgZ3JhcGguYCk7XG4gICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgXFxgJHtrZXl9XFxgIGFscmVhZHkgcHJlc2VudC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgPT09IEVORCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBcXGAke2tleX1cXGAgaXMgcmVzZXJ2ZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydW5uYWJsZSA9IF9jb2VyY2VUb1J1bm5hYmxlKFxuICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgYXJiaXRyYXJ5IHN0YXRlIGR1ZSB0byBTZW5kIEFQSVxuICAgICAgICAgICAgYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBydW5uYWJsZSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogb3B0aW9ucz8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgc3ViZ3JhcGhzOiBpc1ByZWdlbExpa2UocnVubmFibGUpID8gW3J1bm5hYmxlXSA6IG9wdGlvbnM/LnN1YmdyYXBocyxcbiAgICAgICAgICAgICAgICBlbmRzOiBvcHRpb25zPy5lbmRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkRWRnZShzdGFydEtleSwgZW5kS2V5KSB7XG4gICAgICAgIHRoaXMud2FybklmQ29tcGlsZWQoYEFkZGluZyBhbiBlZGdlIHRvIGEgZ3JhcGggdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBpbGVkLiBUaGlzIHdpbGwgbm90IGJlIHJlZmxlY3RlZCBpbiB0aGUgY29tcGlsZWQgZ3JhcGguYCk7XG4gICAgICAgIGlmIChzdGFydEtleSA9PT0gRU5EKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFTkQgY2Fubm90IGJlIGEgc3RhcnQgbm9kZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kS2V5ID09PSBTVEFSVCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1RBUlQgY2Fubm90IGJlIGFuIGVuZCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5mcm9tKHRoaXMuZWRnZXMpLnNvbWUoKFtzdGFydF0pID0+IHN0YXJ0ID09PSBzdGFydEtleSkgJiZcbiAgICAgICAgICAgICEoXCJjaGFubmVsc1wiIGluIHRoaXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFscmVhZHkgZm91bmQgcGF0aCBmb3IgJHtzdGFydEtleX0uIEZvciBtdWx0aXBsZSBlZGdlcywgdXNlIFN0YXRlR3JhcGguYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGdlcy5hZGQoW3N0YXJ0S2V5LCBlbmRLZXldKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZENvbmRpdGlvbmFsRWRnZXMoc291cmNlLCBwYXRoLCBwYXRoTWFwKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygc291cmNlID09PSBcIm9iamVjdFwiID8gc291cmNlIDogeyBzb3VyY2UsIHBhdGg6IHBhdGgsIHBhdGhNYXAgfTtcbiAgICAgICAgdGhpcy53YXJuSWZDb21waWxlZChcIkFkZGluZyBhbiBlZGdlIHRvIGEgZ3JhcGggdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBpbGVkLiBUaGlzIHdpbGwgbm90IGJlIHJlZmxlY3RlZCBpbiB0aGUgY29tcGlsZWQgZ3JhcGguXCIpO1xuICAgICAgICBpZiAoIVJ1bm5hYmxlLmlzUnVubmFibGUob3B0aW9ucy5wYXRoKSkge1xuICAgICAgICAgICAgY29uc3QgcGF0aERpc3BsYXlWYWx1ZXMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMucGF0aE1hcClcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMucGF0aE1hcC5qb2luKFwiLFwiKVxuICAgICAgICAgICAgICAgIDogT2JqZWN0LmtleXMob3B0aW9ucy5wYXRoTWFwID8/IHt9KS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIG9wdGlvbnMucGF0aCA9IF9jb2VyY2VUb1J1bm5hYmxlKG9wdGlvbnMucGF0aCkud2l0aENvbmZpZyh7XG4gICAgICAgICAgICAgICAgcnVuTmFtZTogYEJyYW5jaDwke29wdGlvbnMuc291cmNlfSR7cGF0aERpc3BsYXlWYWx1ZXMgIT09IFwiXCIgPyBgLCR7cGF0aERpc3BsYXlWYWx1ZXN9YCA6IFwiXCJ9PmAuc2xpY2UoMCwgNjMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCBhIG5hbWUgZm9yIGNvbmRpdGlvblxuICAgICAgICBjb25zdCBuYW1lID0gb3B0aW9ucy5wYXRoLmdldE5hbWUoKSA9PT0gXCJSdW5uYWJsZUxhbWJkYVwiXG4gICAgICAgICAgICA/IFwiY29uZGl0aW9uXCJcbiAgICAgICAgICAgIDogb3B0aW9ucy5wYXRoLmdldE5hbWUoKTtcbiAgICAgICAgLy8gdmFsaWRhdGUgY29uZGl0aW9uXG4gICAgICAgIGlmICh0aGlzLmJyYW5jaGVzW29wdGlvbnMuc291cmNlXSAmJiB0aGlzLmJyYW5jaGVzW29wdGlvbnMuc291cmNlXVtuYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25kaXRpb24gXFxgJHtuYW1lfVxcYCBhbHJlYWR5IHByZXNlbnQgZm9yIG5vZGUgXFxgJHtzb3VyY2V9XFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2F2ZSBpdFxuICAgICAgICB0aGlzLmJyYW5jaGVzW29wdGlvbnMuc291cmNlXSA/Pz0ge307XG4gICAgICAgIHRoaXMuYnJhbmNoZXNbb3B0aW9ucy5zb3VyY2VdW25hbWVdID0gbmV3IEJyYW5jaChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSBgYWRkRWRnZShTVEFSVCwga2V5KWAgaW5zdGVhZFxuICAgICAqL1xuICAgIHNldEVudHJ5UG9pbnQoa2V5KSB7XG4gICAgICAgIHRoaXMud2FybklmQ29tcGlsZWQoXCJTZXR0aW5nIHRoZSBlbnRyeSBwb2ludCBvZiBhIGdyYXBoIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb21waWxlZC4gVGhpcyB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW4gdGhlIGNvbXBpbGVkIGdyYXBoLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkRWRnZShTVEFSVCwga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGBhZGRFZGdlKGtleSwgRU5EKWAgaW5zdGVhZFxuICAgICAqL1xuICAgIHNldEZpbmlzaFBvaW50KGtleSkge1xuICAgICAgICB0aGlzLndhcm5JZkNvbXBpbGVkKFwiU2V0dGluZyBhIGZpbmlzaCBwb2ludCBvZiBhIGdyYXBoIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb21waWxlZC4gVGhpcyB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW4gdGhlIGNvbXBpbGVkIGdyYXBoLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkRWRnZShrZXksIEVORCk7XG4gICAgfVxuICAgIGNvbXBpbGUoeyBjaGVja3BvaW50ZXIsIGludGVycnVwdEJlZm9yZSwgaW50ZXJydXB0QWZ0ZXIsIG5hbWUsIH0gPSB7fSkge1xuICAgICAgICAvLyB2YWxpZGF0ZSB0aGUgZ3JhcGhcbiAgICAgICAgdGhpcy52YWxpZGF0ZShbXG4gICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShpbnRlcnJ1cHRCZWZvcmUpID8gaW50ZXJydXB0QmVmb3JlIDogW10pLFxuICAgICAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoaW50ZXJydXB0QWZ0ZXIpID8gaW50ZXJydXB0QWZ0ZXIgOiBbXSksXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBjcmVhdGUgZW1wdHkgY29tcGlsZWQgZ3JhcGhcbiAgICAgICAgY29uc3QgY29tcGlsZWQgPSBuZXcgQ29tcGlsZWRHcmFwaCh7XG4gICAgICAgICAgICBidWlsZGVyOiB0aGlzLFxuICAgICAgICAgICAgY2hlY2twb2ludGVyLFxuICAgICAgICAgICAgaW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICBpbnRlcnJ1cHRCZWZvcmUsXG4gICAgICAgICAgICBhdXRvVmFsaWRhdGU6IGZhbHNlLFxuICAgICAgICAgICAgbm9kZXM6IHt9LFxuICAgICAgICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgICAgICAgICBbU1RBUlRdOiBuZXcgRXBoZW1lcmFsVmFsdWUoKSxcbiAgICAgICAgICAgICAgICBbRU5EXTogbmV3IEVwaGVtZXJhbFZhbHVlKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXRDaGFubmVsczogU1RBUlQsXG4gICAgICAgICAgICBvdXRwdXRDaGFubmVsczogRU5ELFxuICAgICAgICAgICAgc3RyZWFtQ2hhbm5lbHM6IFtdLFxuICAgICAgICAgICAgc3RyZWFtTW9kZTogXCJ2YWx1ZXNcIixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhdHRhY2ggbm9kZXMsIGVkZ2VzIGFuZCBicmFuY2hlc1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMubm9kZXMpKSB7XG4gICAgICAgICAgICBjb21waWxlZC5hdHRhY2hOb2RlKGtleSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbc3RhcnQsIGVuZF0gb2YgdGhpcy5lZGdlcykge1xuICAgICAgICAgICAgY29tcGlsZWQuYXR0YWNoRWRnZShzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydCwgYnJhbmNoZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYnJhbmNoZXMpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBicmFuY2hdIG9mIE9iamVjdC5lbnRyaWVzKGJyYW5jaGVzKSkge1xuICAgICAgICAgICAgICAgIGNvbXBpbGVkLmF0dGFjaEJyYW5jaChzdGFydCwgbmFtZSwgYnJhbmNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGlsZWQudmFsaWRhdGUoKTtcbiAgICB9XG4gICAgdmFsaWRhdGUoaW50ZXJydXB0KSB7XG4gICAgICAgIC8vIGFzc2VtYmxlIHNvdXJjZXNcbiAgICAgICAgY29uc3QgYWxsU291cmNlcyA9IG5ldyBTZXQoWy4uLnRoaXMuYWxsRWRnZXNdLm1hcCgoW3NyYywgX10pID0+IHNyYykpO1xuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5icmFuY2hlcykpIHtcbiAgICAgICAgICAgIGFsbFNvdXJjZXMuYWRkKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YWxpZGF0ZSBzb3VyY2VzXG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGFsbFNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IFNUQVJUICYmICEoc291cmNlIGluIHRoaXMubm9kZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBlZGdlIHN0YXJ0aW5nIGF0IHVua25vd24gbm9kZSBcXGAke3NvdXJjZX1cXGBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhc3NlbWJsZSB0YXJnZXRzXG4gICAgICAgIGNvbnN0IGFsbFRhcmdldHMgPSBuZXcgU2V0KFsuLi50aGlzLmFsbEVkZ2VzXS5tYXAoKFtfLCB0YXJnZXRdKSA9PiB0YXJnZXQpKTtcbiAgICAgICAgZm9yIChjb25zdCBbc3RhcnQsIGJyYW5jaGVzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmJyYW5jaGVzKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBicmFuY2ggb2YgT2JqZWN0LnZhbHVlcyhicmFuY2hlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnJhbmNoLmVuZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVuZCBvZiBPYmplY3QudmFsdWVzKGJyYW5jaC5lbmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsVGFyZ2V0cy5hZGQoZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsVGFyZ2V0cy5hZGQoRU5EKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIE9iamVjdC5rZXlzKHRoaXMubm9kZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxUYXJnZXRzLmFkZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2Ygbm9kZS5lbmRzID8/IFtdKSB7XG4gICAgICAgICAgICAgICAgYWxsVGFyZ2V0cy5hZGQodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB2YWxpZGF0ZSB0YXJnZXRzXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBPYmplY3Qua2V5cyh0aGlzLm5vZGVzKSkge1xuICAgICAgICAgICAgaWYgKCFhbGxUYXJnZXRzLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnJlYWNoYWJsZU5vZGVFcnJvcihbXG4gICAgICAgICAgICAgICAgICAgIGBOb2RlIFxcYCR7bm9kZX1cXGAgaXMgbm90IHJlYWNoYWJsZS5gLFxuICAgICAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBcIklmIHlvdSBhcmUgcmV0dXJuaW5nIENvbW1hbmQgb2JqZWN0cyBmcm9tIHlvdXIgbm9kZSxcIixcbiAgICAgICAgICAgICAgICAgICAgJ21ha2Ugc3VyZSB5b3UgYXJlIHBhc3NpbmcgbmFtZXMgb2YgcG90ZW50aWFsIGRlc3RpbmF0aW9uIG5vZGVzIGFzIGFuIFwiZW5kc1wiIGFycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2ludG8gXCIuYWRkTm9kZSguLi4sIHsgZW5kczogW1wibm9kZTFcIiwgXCJub2RlMlwiXSB9KVwiLicsXG4gICAgICAgICAgICAgICAgXS5qb2luKFwiXFxuXCIpLCB7XG4gICAgICAgICAgICAgICAgICAgIGxjX2Vycm9yX2NvZGU6IFwiVU5SRUFDSEFCTEVfTk9ERVwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIGFsbFRhcmdldHMpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IEVORCAmJiAhKHRhcmdldCBpbiB0aGlzLm5vZGVzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgZWRnZSBlbmRpbmcgYXQgdW5rbm93biBub2RlIFxcYCR7dGFyZ2V0fVxcYGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHZhbGlkYXRlIGludGVycnVwdHNcbiAgICAgICAgaWYgKGludGVycnVwdCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGludGVycnVwdCkge1xuICAgICAgICAgICAgICAgIGlmICghKG5vZGUgaW4gdGhpcy5ub2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcnJ1cHQgbm9kZSBcXGAke25vZGV9XFxgIGlzIG5vdCBwcmVzZW50YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb21waWxlZEdyYXBoIGV4dGVuZHMgUHJlZ2VsIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGJ1aWxkZXIsIC4uLnJlc3QgfSkge1xuICAgICAgICBzdXBlcihyZXN0KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYnVpbGRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgIH1cbiAgICBhdHRhY2hOb2RlKGtleSwgbm9kZSkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzW2tleV0gPSBuZXcgRXBoZW1lcmFsVmFsdWUoKTtcbiAgICAgICAgdGhpcy5ub2Rlc1trZXldID0gbmV3IFByZWdlbE5vZGUoe1xuICAgICAgICAgICAgY2hhbm5lbHM6IFtdLFxuICAgICAgICAgICAgdHJpZ2dlcnM6IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5vZGUubWV0YWRhdGEsXG4gICAgICAgICAgICBzdWJncmFwaHM6IG5vZGUuc3ViZ3JhcGhzLFxuICAgICAgICAgICAgZW5kczogbm9kZS5lbmRzLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnBpcGUobm9kZS5ydW5uYWJsZSlcbiAgICAgICAgICAgIC5waXBlKG5ldyBDaGFubmVsV3JpdGUoW3sgY2hhbm5lbDoga2V5LCB2YWx1ZTogUEFTU1RIUk9VR0ggfV0sIFtUQUdfSElEREVOXSkpO1xuICAgICAgICB0aGlzLnN0cmVhbUNoYW5uZWxzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgYXR0YWNoRWRnZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChlbmQgPT09IEVORCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBTVEFSVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYXZlIGFuIGVkZ2UgZnJvbSBTVEFSVCB0byBFTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vZGVzW3N0YXJ0XS53cml0ZXJzLnB1c2gobmV3IENoYW5uZWxXcml0ZShbeyBjaGFubmVsOiBFTkQsIHZhbHVlOiBQQVNTVEhST1VHSCB9XSwgW1RBR19ISURERU5dKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2VuZF0udHJpZ2dlcnMucHVzaChzdGFydCk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2VuZF0uY2hhbm5lbHMucHVzaChzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoQnJhbmNoKHN0YXJ0LCBuYW1lLCBicmFuY2gpIHtcbiAgICAgICAgLy8gYWRkIGhpZGRlbiBzdGFydCBub2RlXG4gICAgICAgIGlmIChzdGFydCA9PT0gU1RBUlQgJiYgIXRoaXMubm9kZXNbU1RBUlRdKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW1NUQVJUXSA9IENoYW5uZWwuc3Vic2NyaWJlVG8oU1RBUlQsIHsgdGFnczogW1RBR19ISURERU5dIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGFjaCBicmFuY2ggd3JpdGVyXG4gICAgICAgIHRoaXMubm9kZXNbc3RhcnRdLnBpcGUoYnJhbmNoLnJ1bigoZGVzdHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlcyA9IGRlc3RzLm1hcCgoZGVzdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChfaXNTZW5kKGRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiBkZXN0ID09PSBFTkQgPyBFTkQgOiBgYnJhbmNoOiR7c3RhcnR9OiR7bmFtZX06JHtkZXN0fWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBQQVNTVEhST1VHSCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYW5uZWxXcml0ZSh3cml0ZXMsIFtUQUdfSElEREVOXSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gYXR0YWNoIGJyYW5jaCByZWFkZXJzXG4gICAgICAgIGNvbnN0IGVuZHMgPSBicmFuY2guZW5kc1xuICAgICAgICAgICAgPyBPYmplY3QudmFsdWVzKGJyYW5jaC5lbmRzKVxuICAgICAgICAgICAgOiBPYmplY3Qua2V5cyh0aGlzLm5vZGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBlbmQgb2YgZW5kcykge1xuICAgICAgICAgICAgaWYgKGVuZCAhPT0gRU5EKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgYnJhbmNoOiR7c3RhcnR9OiR7bmFtZX06JHtlbmR9YDtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxzW2NoYW5uZWxOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcGhlbWVyYWxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbZW5kXS50cmlnZ2Vycy5wdXNoKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW2VuZF0uY2hhbm5lbHMucHVzaChjaGFubmVsTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRyYXdhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21wdXRhdGlvbiBncmFwaC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRHcmFwaEFzeW5jKGNvbmZpZykge1xuICAgICAgICBjb25zdCB4cmF5ID0gY29uZmlnPy54cmF5O1xuICAgICAgICBjb25zdCBncmFwaCA9IG5ldyBEcmF3YWJsZUdyYXBoKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZXMgPSB7XG4gICAgICAgICAgICBbU1RBUlRdOiBncmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHouYW55KCksXG4gICAgICAgICAgICB9LCBTVEFSVCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuZE5vZGVzID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBzdWJncmFwaHMgPSB7fTtcbiAgICAgICAgaWYgKHhyYXkpIHtcbiAgICAgICAgICAgIHN1YmdyYXBocyA9IE9iamVjdC5mcm9tRW50cmllcygoYXdhaXQgZ2F0aGVySXRlcmF0b3IodGhpcy5nZXRTdWJncmFwaHNBc3luYygpKSkuZmlsdGVyKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICh4KSA9PiBpc0NvbXBpbGVkR3JhcGgoeFsxXSkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRFZGdlKHN0YXJ0LCBlbmQsIGxhYmVsLCBjb25kaXRpb25hbCA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoZW5kID09PSBFTkQgJiYgZW5kTm9kZXNbRU5EXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZW5kTm9kZXNbRU5EXSA9IGdyYXBoLmFkZE5vZGUoeyBzY2hlbWE6IHouYW55KCkgfSwgRU5EKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydE5vZGVzW3N0YXJ0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZE5vZGVzW2VuZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRW5kIG5vZGUgJHtlbmR9IG5vdCBmb3VuZCFgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBncmFwaC5hZGRFZGdlKHN0YXJ0Tm9kZXNbc3RhcnRdLCBlbmROb2Rlc1tlbmRdLCBsYWJlbCAhPT0gZW5kID8gbGFiZWwgOiB1bmRlZmluZWQsIGNvbmRpdGlvbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVTcGVjXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmJ1aWxkZXIubm9kZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5S2V5ID0gX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhrZXkpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVTcGVjLnJ1bm5hYmxlO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBub2RlU3BlYy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVycnVwdEJlZm9yZT8uaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJydXB0QWZ0ZXI/LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5fX2ludGVycnVwdCA9IFwiYmVmb3JlLGFmdGVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmludGVycnVwdEJlZm9yZT8uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLl9faW50ZXJydXB0ID0gXCJiZWZvcmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW50ZXJydXB0QWZ0ZXI/LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5fX2ludGVycnVwdCA9IFwiYWZ0ZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4cmF5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3WHJheVZhbHVlID0gdHlwZW9mIHhyYXkgPT09IFwibnVtYmVyXCIgPyB4cmF5IC0gMSA6IHhyYXk7XG4gICAgICAgICAgICAgICAgY29uc3QgZHJhd2FibGVTdWJncmFwaCA9IHN1YmdyYXBoc1trZXldICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBzdWJncmFwaHNba2V5XS5nZXRHcmFwaEFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhyYXk6IG5ld1hyYXlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlLmdldEdyYXBoKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgZHJhd2FibGVTdWJncmFwaC50cmltRmlyc3ROb2RlKCk7XG4gICAgICAgICAgICAgICAgZHJhd2FibGVTdWJncmFwaC50cmltTGFzdE5vZGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZHJhd2FibGVTdWJncmFwaC5ub2RlcykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZSwgc10gPSBncmFwaC5leHRlbmQoZHJhd2FibGVTdWJncmFwaCwgZGlzcGxheUtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGV4dGVuZCBzdWJncmFwaCBcIiR7a2V5fVwiIGR1ZSB0byBtaXNzaW5nIGVudHJ5cG9pbnQuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGRlZmF1bHQgbmFtZSBvbmNlIHdlIHN0b3Agc3VwcG9ydGluZyBjb3JlIDAuMi4wXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbm5lci1kZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2lzUnVubmFibGVJbnRlcmZhY2UoXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIHRoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpbmcgPyB0aGluZy5sY19ydW5uYWJsZSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbm5lci1kZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gX25vZGVEYXRhU3RyKGlkLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiAhaXNVdWlkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pc1J1bm5hYmxlSW50ZXJmYWNlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFTdHIgPSBkYXRhLmdldE5hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVN0ciA9IGRhdGFTdHIuc3RhcnRzV2l0aChcIlJ1bm5hYmxlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGFTdHIuc2xpY2UoXCJSdW5uYWJsZVwiLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGF0YVN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFTdHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5nZXROYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubmFtZSA/PyBcIlVua25vd25TY2hlbWFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgY2FzdHMgd2hlbiB3ZSBzdG9wIHN1cHBvcnRpbmcgY29yZSAwLjIuMFxuICAgICAgICAgICAgICAgICAgICBpZiAocyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGVzW2Rpc3BsYXlLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IF9ub2RlRGF0YVN0cihzLmlkLCBzLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuZE5vZGVzW2Rpc3BsYXlLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogX25vZGVEYXRhU3RyKGUuaWQsIGUuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHdoZW4gd2Ugc3RvcCBzdXBwb3J0aW5nIGNvcmUgMC4yLjBcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSBncmFwaC5hZGROb2RlKG5vZGUsIGRpc3BsYXlLZXksIG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnROb2Rlc1tkaXNwbGF5S2V5XSA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgICAgIGVuZE5vZGVzW2Rpc3BsYXlLZXldID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgd2hlbiB3ZSBzdG9wIHN1cHBvcnRpbmcgY29yZSAwLjIuMFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IGdyYXBoLmFkZE5vZGUobm9kZSwgZGlzcGxheUtleSwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZXNbZGlzcGxheUtleV0gPSBuZXdOb2RlO1xuICAgICAgICAgICAgICAgIGVuZE5vZGVzW2Rpc3BsYXlLZXldID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3J0ZWRFZGdlcyA9IFsuLi50aGlzLmJ1aWxkZXIuYWxsRWRnZXNdLnNvcnQoKFthXSwgW2JdKSA9PiB7XG4gICAgICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID4gYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydCwgZW5kXSBvZiBzb3J0ZWRFZGdlcykge1xuICAgICAgICAgICAgYWRkRWRnZShfZXNjYXBlTWVybWFpZEtleXdvcmRzKHN0YXJ0KSwgX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydCwgYnJhbmNoZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYnVpbGRlci5icmFuY2hlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFbmRzID0ge1xuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyh0aGlzLmJ1aWxkZXIubm9kZXMpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGspID0+IGsgIT09IHN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAubWFwKChrKSA9PiBbX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhrKSwgX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhrKV0pKSxcbiAgICAgICAgICAgICAgICBbRU5EXTogRU5ELFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnJhbmNoIG9mIE9iamVjdC52YWx1ZXMoYnJhbmNoZXMpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZHM7XG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaC5lbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcyA9IGJyYW5jaC5lbmRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcyA9IGRlZmF1bHRFbmRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtsYWJlbCwgZW5kXSBvZiBPYmplY3QuZW50cmllcyhlbmRzKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRFZGdlKF9lc2NhcGVNZXJtYWlkS2V5d29yZHMoc3RhcnQpLCBfZXNjYXBlTWVybWFpZEtleXdvcmRzKGVuZCksIGxhYmVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmJ1aWxkZXIubm9kZXMpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5lbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVuZCBvZiBub2RlLmVuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkRWRnZShfZXNjYXBlTWVybWFpZEtleXdvcmRzKGtleSksIF9lc2NhcGVNZXJtYWlkS2V5d29yZHMoZW5kKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZHJhd2FibGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXB1dGF0aW9uIGdyYXBoLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGdldEdyYXBoQXN5bmMgaW5zdGVhZC4gVGhlIGFzeW5jIG1ldGhvZCB3aWxsIGJlIHRoZSBkZWZhdWx0IGluIHRoZSBuZXh0IG1pbm9yIGNvcmUgcmVsZWFzZS5cbiAgICAgKi9cbiAgICBnZXRHcmFwaChjb25maWcpIHtcbiAgICAgICAgY29uc3QgeHJheSA9IGNvbmZpZz8ueHJheTtcbiAgICAgICAgY29uc3QgZ3JhcGggPSBuZXcgRHJhd2FibGVHcmFwaCgpO1xuICAgICAgICBjb25zdCBzdGFydE5vZGVzID0ge1xuICAgICAgICAgICAgW1NUQVJUXTogZ3JhcGguYWRkTm9kZSh7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiB6LmFueSgpLFxuICAgICAgICAgICAgfSwgU1RBUlQpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbmROb2RlcyA9IHt9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgc3ViZ3JhcGhzID0ge307XG4gICAgICAgIGlmICh4cmF5KSB7XG4gICAgICAgICAgICBzdWJncmFwaHMgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2F0aGVySXRlcmF0b3JTeW5jKHRoaXMuZ2V0U3ViZ3JhcGhzKCkpLmZpbHRlcihcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAoeCkgPT4gaXNDb21waWxlZEdyYXBoKHhbMV0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkRWRnZShzdGFydCwgZW5kLCBsYWJlbCwgY29uZGl0aW9uYWwgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGVuZCA9PT0gRU5EICYmIGVuZE5vZGVzW0VORF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVuZE5vZGVzW0VORF0gPSBncmFwaC5hZGROb2RlKHsgc2NoZW1hOiB6LmFueSgpIH0sIEVORCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JhcGguYWRkRWRnZShzdGFydE5vZGVzW3N0YXJ0XSwgZW5kTm9kZXNbZW5kXSwgbGFiZWwgIT09IGVuZCA/IGxhYmVsIDogdW5kZWZpbmVkLCBjb25kaXRpb25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBub2RlU3BlY10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5idWlsZGVyLm5vZGVzKSkge1xuICAgICAgICAgICAgY29uc3QgZGlzcGxheUtleSA9IF9lc2NhcGVNZXJtYWlkS2V5d29yZHMoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlU3BlYy5ydW5uYWJsZTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbm9kZVNwZWMubWV0YWRhdGEgPz8ge307XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcnJ1cHRCZWZvcmU/LmluY2x1ZGVzKGtleSkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmludGVycnVwdEFmdGVyPy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuX19pbnRlcnJ1cHQgPSBcImJlZm9yZSxhZnRlclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pbnRlcnJ1cHRCZWZvcmU/LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5fX2ludGVycnVwdCA9IFwiYmVmb3JlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmludGVycnVwdEFmdGVyPy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuX19pbnRlcnJ1cHQgPSBcImFmdGVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeHJheSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1hyYXlWYWx1ZSA9IHR5cGVvZiB4cmF5ID09PSBcIm51bWJlclwiID8geHJheSAtIDEgOiB4cmF5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRyYXdhYmxlU3ViZ3JhcGggPSBzdWJncmFwaHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gc3ViZ3JhcGhzW2tleV0uZ2V0R3JhcGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeHJheTogbmV3WHJheVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IG5vZGUuZ2V0R3JhcGgoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBkcmF3YWJsZVN1YmdyYXBoLnRyaW1GaXJzdE5vZGUoKTtcbiAgICAgICAgICAgICAgICBkcmF3YWJsZVN1YmdyYXBoLnRyaW1MYXN0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhkcmF3YWJsZVN1YmdyYXBoLm5vZGVzKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtlLCBzXSA9IGdyYXBoLmV4dGVuZChkcmF3YWJsZVN1YmdyYXBoLCBkaXNwbGF5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZXh0ZW5kIHN1YmdyYXBoIFwiJHtrZXl9XCIgZHVlIHRvIG1pc3NpbmcgZW50cnlwb2ludC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgZGVmYXVsdCBuYW1lIG9uY2Ugd2Ugc3RvcCBzdXBwb3J0aW5nIGNvcmUgMC4yLjBcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWlubmVyLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfaXNSdW5uYWJsZUludGVyZmFjZShcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgdGhpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGluZyA/IHRoaW5nLmxjX3J1bm5hYmxlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWlubmVyLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfbm9kZURhdGFTdHIoaWQsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmICFpc1V1aWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX2lzUnVubmFibGVJbnRlcmZhY2UoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVN0ciA9IGRhdGEuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhU3RyID0gZGF0YVN0ci5zdGFydHNXaXRoKFwiUnVubmFibGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YVN0ci5zbGljZShcIlJ1bm5hYmxlXCIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhU3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmdldE5hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lID8/IFwiVW5rbm93blNjaGVtYVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBjYXN0cyB3aGVuIHdlIHN0b3Agc3VwcG9ydGluZyBjb3JlIDAuMi4wXG4gICAgICAgICAgICAgICAgICAgIGlmIChzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZXNbZGlzcGxheUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogX25vZGVEYXRhU3RyKHMuaWQsIHMuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5kTm9kZXNbZGlzcGxheUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBfbm9kZURhdGFTdHIoZS5pZCwgZS5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgd2hlbiB3ZSBzdG9wIHN1cHBvcnRpbmcgY29yZSAwLjIuMFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IGdyYXBoLmFkZE5vZGUobm9kZSwgZGlzcGxheUtleSwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGVzW2Rpc3BsYXlLZXldID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZW5kTm9kZXNbZGlzcGxheUtleV0gPSBuZXdOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB3aGVuIHdlIHN0b3Agc3VwcG9ydGluZyBjb3JlIDAuMi4wXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gZ3JhcGguYWRkTm9kZShub2RlLCBkaXNwbGF5S2V5LCBtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgc3RhcnROb2Rlc1tkaXNwbGF5S2V5XSA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgZW5kTm9kZXNbZGlzcGxheUtleV0gPSBuZXdOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvcnRlZEVkZ2VzID0gWy4uLnRoaXMuYnVpbGRlci5hbGxFZGdlc10uc29ydCgoW2FdLCBbYl0pID0+IHtcbiAgICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPiBhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIHNvcnRlZEVkZ2VzKSB7XG4gICAgICAgICAgICBhZGRFZGdlKF9lc2NhcGVNZXJtYWlkS2V5d29yZHMoc3RhcnQpLCBfZXNjYXBlTWVybWFpZEtleXdvcmRzKGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBicmFuY2hlc10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5idWlsZGVyLmJyYW5jaGVzKSkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVuZHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKHRoaXMuYnVpbGRlci5ub2RlcylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaykgPT4gayAhPT0gc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGspID0+IFtfZXNjYXBlTWVybWFpZEtleXdvcmRzKGspLCBfZXNjYXBlTWVybWFpZEtleXdvcmRzKGspXSkpLFxuICAgICAgICAgICAgICAgIFtFTkRdOiBFTkQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBicmFuY2ggb2YgT2JqZWN0LnZhbHVlcyhicmFuY2hlcykpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kcztcbiAgICAgICAgICAgICAgICBpZiAoYnJhbmNoLmVuZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBlbmRzID0gYnJhbmNoLmVuZHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmRzID0gZGVmYXVsdEVuZHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2xhYmVsLCBlbmRdIG9mIE9iamVjdC5lbnRyaWVzKGVuZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEVkZ2UoX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhzdGFydCksIF9lc2NhcGVNZXJtYWlkS2V5d29yZHMoZW5kKSwgbGFiZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JhcGg7XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGlzQ29tcGlsZWRHcmFwaCh4KSB7XG4gICAgcmV0dXJuIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHR5cGVvZiB4LmF0dGFjaE5vZGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0eXBlb2YgeC5hdHRhY2hFZGdlID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBcInN1YmdyYXBoXCIpIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7a2V5fVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/graph/graph.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/graph/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/graph/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* reexport safe */ _annotation_js__WEBPACK_IMPORTED_MODULE_0__.Annotation),\n/* harmony export */   AnnotationRoot: () => (/* reexport safe */ _annotation_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationRoot),\n/* harmony export */   CompiledStateGraph: () => (/* reexport safe */ _state_js__WEBPACK_IMPORTED_MODULE_2__.CompiledStateGraph),\n/* harmony export */   Graph: () => (/* reexport safe */ _graph_js__WEBPACK_IMPORTED_MODULE_1__.Graph),\n/* harmony export */   MessageGraph: () => (/* reexport safe */ _message_js__WEBPACK_IMPORTED_MODULE_3__.MessageGraph),\n/* harmony export */   REMOVE_ALL_MESSAGES: () => (/* reexport safe */ _message_js__WEBPACK_IMPORTED_MODULE_3__.REMOVE_ALL_MESSAGES),\n/* harmony export */   StateGraph: () => (/* reexport safe */ _state_js__WEBPACK_IMPORTED_MODULE_2__.StateGraph),\n/* harmony export */   messagesStateReducer: () => (/* reexport safe */ _message_js__WEBPACK_IMPORTED_MODULE_3__.messagesStateReducer)\n/* harmony export */ });\n/* harmony import */ var _annotation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotation.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/annotation.js\");\n/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graph.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/graph.js\");\n/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./state.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/state.js\");\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/message.js\");\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9ncmFwaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBOEQ7QUFDM0I7QUFDMEI7QUFDMkI7QUFDeEYiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxncmFwaFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQW5ub3RhdGlvbiwgQW5ub3RhdGlvblJvb3QsIH0gZnJvbSBcIi4vYW5ub3RhdGlvbi5qc1wiO1xuZXhwb3J0IHsgR3JhcGggfSBmcm9tIFwiLi9ncmFwaC5qc1wiO1xuZXhwb3J0IHsgU3RhdGVHcmFwaCwgQ29tcGlsZWRTdGF0ZUdyYXBoLCB9IGZyb20gXCIuL3N0YXRlLmpzXCI7XG5leHBvcnQgeyBNZXNzYWdlR3JhcGgsIG1lc3NhZ2VzU3RhdGVSZWR1Y2VyLCBSRU1PVkVfQUxMX01FU1NBR0VTLCB9IGZyb20gXCIuL21lc3NhZ2UuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/graph/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/graph/message.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/graph/message.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageGraph: () => (/* binding */ MessageGraph),\n/* harmony export */   REMOVE_ALL_MESSAGES: () => (/* binding */ REMOVE_ALL_MESSAGES),\n/* harmony export */   messagesStateReducer: () => (/* binding */ messagesStateReducer),\n/* harmony export */   pushMessage: () => (/* binding */ pushMessage)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/state.js\");\n\n\n\nconst REMOVE_ALL_MESSAGES = \"__remove_all__\";\n/**\n * Prebuilt reducer that combines returned messages.\n * Can handle standard messages and special modifiers like {@link RemoveMessage}\n * instances.\n */\nfunction messagesStateReducer(left, right) {\n    const leftArray = Array.isArray(left) ? left : [left];\n    const rightArray = Array.isArray(right) ? right : [right];\n    // coerce to message\n    const leftMessages = leftArray.map(_langchain_core_messages__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage);\n    const rightMessages = rightArray.map(_langchain_core_messages__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage);\n    // assign missing ids\n    for (const m of leftMessages) {\n        if (m.id === null || m.id === undefined) {\n            m.id = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n            m.lc_kwargs.id = m.id;\n        }\n    }\n    let removeAllIdx;\n    for (let i = 0; i < rightMessages.length; i += 1) {\n        const m = rightMessages[i];\n        if (m.id === null || m.id === undefined) {\n            m.id = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n            m.lc_kwargs.id = m.id;\n        }\n        if (m.getType() === \"remove\" && m.id === REMOVE_ALL_MESSAGES) {\n            removeAllIdx = i;\n        }\n    }\n    if (removeAllIdx != null)\n        return rightMessages.slice(removeAllIdx + 1);\n    // merge\n    const merged = [...leftMessages];\n    const mergedById = new Map(merged.map((m, i) => [m.id, i]));\n    const idsToRemove = new Set();\n    for (const m of rightMessages) {\n        const existingIdx = mergedById.get(m.id);\n        if (existingIdx !== undefined) {\n            if (m.getType() === \"remove\") {\n                idsToRemove.add(m.id);\n            }\n            else {\n                idsToRemove.delete(m.id);\n                merged[existingIdx] = m;\n            }\n        }\n        else {\n            if (m.getType() === \"remove\") {\n                throw new Error(`Attempting to delete a message with an ID that doesn't exist ('${m.id}')`);\n            }\n            mergedById.set(m.id, merged.length);\n            merged.push(m);\n        }\n    }\n    return merged.filter((m) => !idsToRemove.has(m.id));\n}\n/** @ignore */\nclass MessageGraph extends _state_js__WEBPACK_IMPORTED_MODULE_1__.StateGraph {\n    constructor() {\n        super({\n            channels: {\n                __root__: {\n                    reducer: messagesStateReducer,\n                    default: () => [],\n                },\n            },\n        });\n    }\n}\nfunction pushMessage(message, config, options) {\n    let stateKey = options?.stateKey ?? \"messages\";\n    if (options?.stateKey === null) {\n        stateKey = undefined;\n    }\n    // coerce to message\n    const validMessage = (0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage)(message);\n    if (!validMessage.id)\n        throw new Error(\"Message ID is required.\");\n    const callbacks = (() => {\n        if (Array.isArray(config.callbacks)) {\n            return config.callbacks;\n        }\n        if (typeof config.callbacks !== \"undefined\") {\n            return config.callbacks.handlers;\n        }\n        return [];\n    })();\n    const messagesHandler = callbacks.find((cb) => \"name\" in cb && cb.name === \"StreamMessagesHandler\");\n    if (messagesHandler) {\n        const metadata = config.metadata ?? {};\n        const namespace = (metadata.langgraph_checkpoint_ns ?? \"\").split(\"|\");\n        messagesHandler._emit([namespace, metadata], validMessage, undefined, false);\n    }\n    if (stateKey) {\n        config.configurable?.__pregel_send?.([[stateKey, validMessage]]);\n    }\n    return validMessage;\n}\n//# sourceMappingURL=message.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9ncmFwaC9tZXNzYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBdUU7QUFDN0M7QUFDYztBQUNqQztBQUNQO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdGQUEwQjtBQUNqRSx5Q0FBeUMsZ0ZBQTBCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBLG1CQUFtQixnREFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxLQUFLO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsaURBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvRkFBMEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxcZ3JhcGhcXG1lc3NhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgdjQgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgU3RhdGVHcmFwaCB9IGZyb20gXCIuL3N0YXRlLmpzXCI7XG5leHBvcnQgY29uc3QgUkVNT1ZFX0FMTF9NRVNTQUdFUyA9IFwiX19yZW1vdmVfYWxsX19cIjtcbi8qKlxuICogUHJlYnVpbHQgcmVkdWNlciB0aGF0IGNvbWJpbmVzIHJldHVybmVkIG1lc3NhZ2VzLlxuICogQ2FuIGhhbmRsZSBzdGFuZGFyZCBtZXNzYWdlcyBhbmQgc3BlY2lhbCBtb2RpZmllcnMgbGlrZSB7QGxpbmsgUmVtb3ZlTWVzc2FnZX1cbiAqIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lc3NhZ2VzU3RhdGVSZWR1Y2VyKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgbGVmdEFycmF5ID0gQXJyYXkuaXNBcnJheShsZWZ0KSA/IGxlZnQgOiBbbGVmdF07XG4gICAgY29uc3QgcmlnaHRBcnJheSA9IEFycmF5LmlzQXJyYXkocmlnaHQpID8gcmlnaHQgOiBbcmlnaHRdO1xuICAgIC8vIGNvZXJjZSB0byBtZXNzYWdlXG4gICAgY29uc3QgbGVmdE1lc3NhZ2VzID0gbGVmdEFycmF5Lm1hcChjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSk7XG4gICAgY29uc3QgcmlnaHRNZXNzYWdlcyA9IHJpZ2h0QXJyYXkubWFwKGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKTtcbiAgICAvLyBhc3NpZ24gbWlzc2luZyBpZHNcbiAgICBmb3IgKGNvbnN0IG0gb2YgbGVmdE1lc3NhZ2VzKSB7XG4gICAgICAgIGlmIChtLmlkID09PSBudWxsIHx8IG0uaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbS5pZCA9IHY0KCk7XG4gICAgICAgICAgICBtLmxjX2t3YXJncy5pZCA9IG0uaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlbW92ZUFsbElkeDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJpZ2h0TWVzc2FnZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgbSA9IHJpZ2h0TWVzc2FnZXNbaV07XG4gICAgICAgIGlmIChtLmlkID09PSBudWxsIHx8IG0uaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbS5pZCA9IHY0KCk7XG4gICAgICAgICAgICBtLmxjX2t3YXJncy5pZCA9IG0uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0uZ2V0VHlwZSgpID09PSBcInJlbW92ZVwiICYmIG0uaWQgPT09IFJFTU9WRV9BTExfTUVTU0FHRVMpIHtcbiAgICAgICAgICAgIHJlbW92ZUFsbElkeCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbW92ZUFsbElkeCAhPSBudWxsKVxuICAgICAgICByZXR1cm4gcmlnaHRNZXNzYWdlcy5zbGljZShyZW1vdmVBbGxJZHggKyAxKTtcbiAgICAvLyBtZXJnZVxuICAgIGNvbnN0IG1lcmdlZCA9IFsuLi5sZWZ0TWVzc2FnZXNdO1xuICAgIGNvbnN0IG1lcmdlZEJ5SWQgPSBuZXcgTWFwKG1lcmdlZC5tYXAoKG0sIGkpID0+IFttLmlkLCBpXSkpO1xuICAgIGNvbnN0IGlkc1RvUmVtb3ZlID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbSBvZiByaWdodE1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSWR4ID0gbWVyZ2VkQnlJZC5nZXQobS5pZCk7XG4gICAgICAgIGlmIChleGlzdGluZ0lkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAobS5nZXRUeXBlKCkgPT09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgICAgICBpZHNUb1JlbW92ZS5hZGQobS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZHNUb1JlbW92ZS5kZWxldGUobS5pZCk7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2V4aXN0aW5nSWR4XSA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobS5nZXRUeXBlKCkgPT09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRpbmcgdG8gZGVsZXRlIGEgbWVzc2FnZSB3aXRoIGFuIElEIHRoYXQgZG9lc24ndCBleGlzdCAoJyR7bS5pZH0nKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2VkQnlJZC5zZXQobS5pZCwgbWVyZ2VkLmxlbmd0aCk7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkLmZpbHRlcigobSkgPT4gIWlkc1RvUmVtb3ZlLmhhcyhtLmlkKSk7XG59XG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGNsYXNzIE1lc3NhZ2VHcmFwaCBleHRlbmRzIFN0YXRlR3JhcGgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBjaGFubmVsczoge1xuICAgICAgICAgICAgICAgIF9fcm9vdF9fOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZHVjZXI6IG1lc3NhZ2VzU3RhdGVSZWR1Y2VyLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiBbXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHB1c2hNZXNzYWdlKG1lc3NhZ2UsIGNvbmZpZywgb3B0aW9ucykge1xuICAgIGxldCBzdGF0ZUtleSA9IG9wdGlvbnM/LnN0YXRlS2V5ID8/IFwibWVzc2FnZXNcIjtcbiAgICBpZiAob3B0aW9ucz8uc3RhdGVLZXkgPT09IG51bGwpIHtcbiAgICAgICAgc3RhdGVLZXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIGNvZXJjZSB0byBtZXNzYWdlXG4gICAgY29uc3QgdmFsaWRNZXNzYWdlID0gY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UobWVzc2FnZSk7XG4gICAgaWYgKCF2YWxpZE1lc3NhZ2UuaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2UgSUQgaXMgcmVxdWlyZWQuXCIpO1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5jYWxsYmFja3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLmNhbGxiYWNrcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5jYWxsYmFja3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuY2FsbGJhY2tzLmhhbmRsZXJzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IG1lc3NhZ2VzSGFuZGxlciA9IGNhbGxiYWNrcy5maW5kKChjYikgPT4gXCJuYW1lXCIgaW4gY2IgJiYgY2IubmFtZSA9PT0gXCJTdHJlYW1NZXNzYWdlc0hhbmRsZXJcIik7XG4gICAgaWYgKG1lc3NhZ2VzSGFuZGxlcikge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGNvbmZpZy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gKG1ldGFkYXRhLmxhbmdncmFwaF9jaGVja3BvaW50X25zID8/IFwiXCIpLnNwbGl0KFwifFwiKTtcbiAgICAgICAgbWVzc2FnZXNIYW5kbGVyLl9lbWl0KFtuYW1lc3BhY2UsIG1ldGFkYXRhXSwgdmFsaWRNZXNzYWdlLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlS2V5KSB7XG4gICAgICAgIGNvbmZpZy5jb25maWd1cmFibGU/Ll9fcHJlZ2VsX3NlbmQ/LihbW3N0YXRlS2V5LCB2YWxpZE1lc3NhZ2VdXSk7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZE1lc3NhZ2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/graph/message.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/graph/messages_annotation.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/graph/messages_annotation.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessagesAnnotation: () => (/* binding */ MessagesAnnotation),\n/* harmony export */   MessagesZodState: () => (/* binding */ MessagesZodState)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _annotation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotation.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/annotation.js\");\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/message.js\");\n/* harmony import */ var _zod_state_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zod/state.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/zod/state.js\");\n/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\n\n\n\n/**\n * Prebuilt state annotation that combines returned messages.\n * Can handle standard messages and special modifiers like {@link RemoveMessage}\n * instances.\n *\n * Specifically, importing and using the prebuilt MessagesAnnotation like this:\n *\n * @example\n * ```ts\n * import { MessagesAnnotation, StateGraph } from \"@langchain/langgraph\";\n *\n * const graph = new StateGraph(MessagesAnnotation)\n *   .addNode(...)\n *   ...\n * ```\n *\n * Is equivalent to initializing your state manually like this:\n *\n * @example\n * ```ts\n * import { BaseMessage } from \"@langchain/core/messages\";\n * import { Annotation, StateGraph, messagesStateReducer } from \"@langchain/langgraph\";\n *\n * export const StateAnnotation = Annotation.Root({\n *   messages: Annotation<BaseMessage[]>({\n *     reducer: messagesStateReducer,\n *     default: () => [],\n *   }),\n * });\n *\n * const graph = new StateGraph(StateAnnotation)\n *   .addNode(...)\n *   ...\n * ```\n */\nconst MessagesAnnotation = _annotation_js__WEBPACK_IMPORTED_MODULE_0__.Annotation.Root({\n    messages: (0,_annotation_js__WEBPACK_IMPORTED_MODULE_0__.Annotation)({\n        reducer: _message_js__WEBPACK_IMPORTED_MODULE_1__.messagesStateReducer,\n        default: () => [],\n    }),\n});\n/**\n * Prebuilt state object that uses Zod to combine returned messages.\n * This utility is synonymous with the `MessagesAnnotation` annotation,\n * but uses Zod as the way to express messages state.\n *\n * You can use import and use this prebuilt schema like this:\n *\n * @example\n * ```ts\n * import { MessagesZodState, StateGraph } from \"@langchain/langgraph\";\n *\n * const graph = new StateGraph(MessagesZodState)\n *   .addNode(...)\n *   ...\n * ```\n *\n * Which is equivalent to initializing the schema object manually like this:\n *\n * @example\n * ```ts\n * import { z } from \"zod\";\n * import type { BaseMessage, BaseMessageLike } from \"@langchain/core/messages\";\n * import { StateGraph, messagesStateReducer } from \"@langchain/langgraph\";\n * import \"@langchain/langgraph/zod\";\n *\n * const AgentState = z.object({\n *   messages: z\n *     .custom<BaseMessage[]>()\n *     .default(() => [])\n *     .langgraph.reducer(\n *        messagesStateReducer,\n *        z.custom<BaseMessageLike | BaseMessageLike[]>()\n *     ),\n * });\n * const graph = new StateGraph(AgentState)\n *   .addNode(...)\n *   ...\n * ```\n */\nconst MessagesZodState = zod__WEBPACK_IMPORTED_MODULE_3__.object({\n    messages: (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_2__.withLangGraph)(zod__WEBPACK_IMPORTED_MODULE_3__.custom(), {\n        reducer: {\n            schema: zod__WEBPACK_IMPORTED_MODULE_3__.custom(),\n            fn: _message_js__WEBPACK_IMPORTED_MODULE_1__.messagesStateReducer,\n        },\n        default: () => [],\n    }),\n});\n//# sourceMappingURL=messages_annotation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9ncmFwaC9tZXNzYWdlc19hbm5vdGF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ3FCO0FBQ087QUFDTDtBQUMvQztBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQixzREFBVTtBQUM1QyxjQUFjLDBEQUFVO0FBQ3hCLGlCQUFpQiw2REFBb0I7QUFDckM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCLGlCQUFpQiwrQkFBK0I7QUFDaEQsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5Qix1Q0FBUTtBQUN4QyxjQUFjLDREQUFhLENBQUMsdUNBQVE7QUFDcEM7QUFDQSxvQkFBb0IsdUNBQVE7QUFDNUIsZ0JBQWdCLDZEQUFvQjtBQUNwQyxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxcZ3JhcGhcXG1lc3NhZ2VzX2Fubm90YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogX19MQ19BTExPV19FTlRSWVBPSU5UX1NJREVfRUZGRUNUU19fICovXG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xuaW1wb3J0IHsgQW5ub3RhdGlvbiB9IGZyb20gXCIuL2Fubm90YXRpb24uanNcIjtcbmltcG9ydCB7IG1lc3NhZ2VzU3RhdGVSZWR1Y2VyIH0gZnJvbSBcIi4vbWVzc2FnZS5qc1wiO1xuaW1wb3J0IHsgd2l0aExhbmdHcmFwaCB9IGZyb20gXCIuL3pvZC9zdGF0ZS5qc1wiO1xuLyoqXG4gKiBQcmVidWlsdCBzdGF0ZSBhbm5vdGF0aW9uIHRoYXQgY29tYmluZXMgcmV0dXJuZWQgbWVzc2FnZXMuXG4gKiBDYW4gaGFuZGxlIHN0YW5kYXJkIG1lc3NhZ2VzIGFuZCBzcGVjaWFsIG1vZGlmaWVycyBsaWtlIHtAbGluayBSZW1vdmVNZXNzYWdlfVxuICogaW5zdGFuY2VzLlxuICpcbiAqIFNwZWNpZmljYWxseSwgaW1wb3J0aW5nIGFuZCB1c2luZyB0aGUgcHJlYnVpbHQgTWVzc2FnZXNBbm5vdGF0aW9uIGxpa2UgdGhpczpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE1lc3NhZ2VzQW5ub3RhdGlvbiwgU3RhdGVHcmFwaCB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICpcbiAqIGNvbnN0IGdyYXBoID0gbmV3IFN0YXRlR3JhcGgoTWVzc2FnZXNBbm5vdGF0aW9uKVxuICogICAuYWRkTm9kZSguLi4pXG4gKiAgIC4uLlxuICogYGBgXG4gKlxuICogSXMgZXF1aXZhbGVudCB0byBpbml0aWFsaXppbmcgeW91ciBzdGF0ZSBtYW51YWxseSBsaWtlIHRoaXM6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBCYXNlTWVzc2FnZSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIjtcbiAqIGltcG9ydCB7IEFubm90YXRpb24sIFN0YXRlR3JhcGgsIG1lc3NhZ2VzU3RhdGVSZWR1Y2VyIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoXCI7XG4gKlxuICogZXhwb3J0IGNvbnN0IFN0YXRlQW5ub3RhdGlvbiA9IEFubm90YXRpb24uUm9vdCh7XG4gKiAgIG1lc3NhZ2VzOiBBbm5vdGF0aW9uPEJhc2VNZXNzYWdlW10+KHtcbiAqICAgICByZWR1Y2VyOiBtZXNzYWdlc1N0YXRlUmVkdWNlcixcbiAqICAgICBkZWZhdWx0OiAoKSA9PiBbXSxcbiAqICAgfSksXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBncmFwaCA9IG5ldyBTdGF0ZUdyYXBoKFN0YXRlQW5ub3RhdGlvbilcbiAqICAgLmFkZE5vZGUoLi4uKVxuICogICAuLi5cbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgTWVzc2FnZXNBbm5vdGF0aW9uID0gQW5ub3RhdGlvbi5Sb290KHtcbiAgICBtZXNzYWdlczogQW5ub3RhdGlvbih7XG4gICAgICAgIHJlZHVjZXI6IG1lc3NhZ2VzU3RhdGVSZWR1Y2VyLFxuICAgICAgICBkZWZhdWx0OiAoKSA9PiBbXSxcbiAgICB9KSxcbn0pO1xuLyoqXG4gKiBQcmVidWlsdCBzdGF0ZSBvYmplY3QgdGhhdCB1c2VzIFpvZCB0byBjb21iaW5lIHJldHVybmVkIG1lc3NhZ2VzLlxuICogVGhpcyB1dGlsaXR5IGlzIHN5bm9ueW1vdXMgd2l0aCB0aGUgYE1lc3NhZ2VzQW5ub3RhdGlvbmAgYW5ub3RhdGlvbixcbiAqIGJ1dCB1c2VzIFpvZCBhcyB0aGUgd2F5IHRvIGV4cHJlc3MgbWVzc2FnZXMgc3RhdGUuXG4gKlxuICogWW91IGNhbiB1c2UgaW1wb3J0IGFuZCB1c2UgdGhpcyBwcmVidWlsdCBzY2hlbWEgbGlrZSB0aGlzOlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgTWVzc2FnZXNab2RTdGF0ZSwgU3RhdGVHcmFwaCB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICpcbiAqIGNvbnN0IGdyYXBoID0gbmV3IFN0YXRlR3JhcGgoTWVzc2FnZXNab2RTdGF0ZSlcbiAqICAgLmFkZE5vZGUoLi4uKVxuICogICAuLi5cbiAqIGBgYFxuICpcbiAqIFdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gaW5pdGlhbGl6aW5nIHRoZSBzY2hlbWEgb2JqZWN0IG1hbnVhbGx5IGxpa2UgdGhpczpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG4gKiBpbXBvcnQgdHlwZSB7IEJhc2VNZXNzYWdlLCBCYXNlTWVzc2FnZUxpa2UgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzXCI7XG4gKiBpbXBvcnQgeyBTdGF0ZUdyYXBoLCBtZXNzYWdlc1N0YXRlUmVkdWNlciB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICogaW1wb3J0IFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGgvem9kXCI7XG4gKlxuICogY29uc3QgQWdlbnRTdGF0ZSA9IHoub2JqZWN0KHtcbiAqICAgbWVzc2FnZXM6IHpcbiAqICAgICAuY3VzdG9tPEJhc2VNZXNzYWdlW10+KClcbiAqICAgICAuZGVmYXVsdCgoKSA9PiBbXSlcbiAqICAgICAubGFuZ2dyYXBoLnJlZHVjZXIoXG4gKiAgICAgICAgbWVzc2FnZXNTdGF0ZVJlZHVjZXIsXG4gKiAgICAgICAgei5jdXN0b208QmFzZU1lc3NhZ2VMaWtlIHwgQmFzZU1lc3NhZ2VMaWtlW10+KClcbiAqICAgICApLFxuICogfSk7XG4gKiBjb25zdCBncmFwaCA9IG5ldyBTdGF0ZUdyYXBoKEFnZW50U3RhdGUpXG4gKiAgIC5hZGROb2RlKC4uLilcbiAqICAgLi4uXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IE1lc3NhZ2VzWm9kU3RhdGUgPSB6Lm9iamVjdCh7XG4gICAgbWVzc2FnZXM6IHdpdGhMYW5nR3JhcGgoei5jdXN0b20oKSwge1xuICAgICAgICByZWR1Y2VyOiB7XG4gICAgICAgICAgICBzY2hlbWE6IHouY3VzdG9tKCksXG4gICAgICAgICAgICBmbjogbWVzc2FnZXNTdGF0ZVJlZHVjZXIsXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6ICgpID0+IFtdLFxuICAgIH0pLFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlc19hbm5vdGF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/graph/messages_annotation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/graph/state.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/graph/state.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompiledStateGraph: () => (/* binding */ CompiledStateGraph),\n/* harmony export */   StateGraph: () => (/* binding */ StateGraph)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _channels_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../channels/base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/base.js\");\n/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graph.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/graph.js\");\n/* harmony import */ var _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pregel/write.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/write.js\");\n/* harmony import */ var _pregel_read_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pregel/read.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/read.js\");\n/* harmony import */ var _channels_named_barrier_value_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../channels/named_barrier_value.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/named_barrier_value.js\");\n/* harmony import */ var _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../channels/ephemeral_value.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _annotation_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./annotation.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/annotation.js\");\n/* harmony import */ var _managed_base_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../managed/base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/managed/base.js\");\n/* harmony import */ var _pregel_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../pregel/utils/subgraph.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js\");\n/* harmony import */ var _zod_state_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zod/state.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/zod/state.js\");\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst ROOT = \"__root__\";\n/**\n * A graph whose nodes communicate by reading and writing to a shared state.\n * Each node takes a defined `State` as input and returns a `Partial<State>`.\n *\n * Each state key can optionally be annotated with a reducer function that\n * will be used to aggregate the values of that key received from multiple nodes.\n * The signature of a reducer function is (left: Value, right: UpdateValue) => Value.\n *\n * See {@link Annotation} for more on defining state.\n *\n * After adding nodes and edges to your graph, you must call `.compile()` on it before\n * you can use it.\n *\n * @example\n * ```ts\n * import {\n *   type BaseMessage,\n *   AIMessage,\n *   HumanMessage,\n * } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const StateAnnotation = Annotation.Root({\n *   sentiment: Annotation<string>,\n *   messages: Annotation<BaseMessage[]>({\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(StateAnnotation);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof StateAnnotation.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *     sentiment: \"positive\",\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   .addEdge(\"__start__\", \"myNode\")\n *   .addEdge(\"myNode\", \"__end__\")\n *   .compile();\n *\n * await graph.invoke({ messages: [new HumanMessage(\"how are you?\")] });\n *\n * // {\n * //   messages: [HumanMessage(\"how are you?\"), AIMessage(\"Some new response\")],\n * //   sentiment: \"positive\",\n * // }\n * ```\n */\nclass StateGraph extends _graph_js__WEBPACK_IMPORTED_MODULE_2__.Graph {\n    constructor(fields, configSchema) {\n        super();\n        Object.defineProperty(this, \"channels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        // TODO: this doesn't dedupe edges as in py, so worth fixing at some point\n        Object.defineProperty(this, \"waitingEdges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_schemaDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_schemaRuntimeDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_inputDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_inputRuntimeDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_outputDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_outputRuntimeDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Map schemas to managed values\n         * @internal\n         */\n        Object.defineProperty(this, \"_schemaDefinitions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        /** @internal Used only for typing. */\n        Object.defineProperty(this, \"_configSchema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_configRuntimeSchema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (isZodStateGraphArgsWithStateSchema(fields)) {\n            const stateDef = (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.getChannelsFromZod)(fields.state);\n            const inputDef = fields.input != null ? (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.getChannelsFromZod)(fields.input) : stateDef;\n            const outputDef = fields.output != null ? (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.getChannelsFromZod)(fields.output) : stateDef;\n            this._schemaDefinition = stateDef;\n            this._schemaRuntimeDefinition = fields.state;\n            this._inputDefinition = inputDef;\n            this._inputRuntimeDefinition = fields.input ?? fields.state.partial();\n            this._outputDefinition = outputDef;\n            this._outputRuntimeDefinition = fields.output ?? fields.state;\n        }\n        else if ((0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(fields)) {\n            const stateDef = (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.getChannelsFromZod)(fields);\n            this._schemaDefinition = stateDef;\n            this._schemaRuntimeDefinition = fields;\n            this._inputDefinition = stateDef;\n            this._inputRuntimeDefinition = fields.partial();\n            this._outputDefinition = stateDef;\n            this._outputRuntimeDefinition = fields;\n        }\n        else if (isStateGraphArgsWithInputOutputSchemas(fields)) {\n            this._schemaDefinition = fields.input.spec;\n            this._inputDefinition = fields.input.spec;\n            this._outputDefinition = fields.output.spec;\n        }\n        else if (isStateGraphArgsWithStateSchema(fields)) {\n            this._schemaDefinition = fields.stateSchema.spec;\n            this._inputDefinition = (fields.input?.spec ??\n                this._schemaDefinition);\n            this._outputDefinition = (fields.output?.spec ??\n                this._schemaDefinition);\n        }\n        else if (isStateDefinition(fields) || isAnnotationRoot(fields)) {\n            const spec = isAnnotationRoot(fields) ? fields.spec : fields;\n            this._schemaDefinition = spec;\n        }\n        else if (isStateGraphArgs(fields)) {\n            const spec = _getChannels(fields.channels);\n            this._schemaDefinition = spec;\n        }\n        else {\n            throw new Error(\"Invalid StateGraph input.\");\n        }\n        this._inputDefinition ??= this._schemaDefinition;\n        this._outputDefinition ??= this._schemaDefinition;\n        this._addSchema(this._schemaDefinition);\n        this._addSchema(this._inputDefinition);\n        this._addSchema(this._outputDefinition);\n        if ((0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(configSchema)) {\n            this._configRuntimeSchema = configSchema.passthrough();\n        }\n    }\n    get allEdges() {\n        return new Set([\n            ...this.edges,\n            ...Array.from(this.waitingEdges).flatMap(([starts, end]) => starts.map((start) => [start, end])),\n        ]);\n    }\n    _addSchema(stateDefinition) {\n        if (this._schemaDefinitions.has(stateDefinition)) {\n            return;\n        }\n        // TODO: Support managed values\n        this._schemaDefinitions.set(stateDefinition, stateDefinition);\n        for (const [key, val] of Object.entries(stateDefinition)) {\n            let channel;\n            if (typeof val === \"function\") {\n                channel = val();\n            }\n            else {\n                channel = val;\n            }\n            if (this.channels[key] !== undefined) {\n                if (this.channels[key] !== channel) {\n                    if (!(0,_managed_base_js__WEBPACK_IMPORTED_MODULE_11__.isConfiguredManagedValue)(channel) &&\n                        channel.lc_graph_name !== \"LastValue\") {\n                        throw new Error(`Channel \"${key}\" already exists with a different type.`);\n                    }\n                }\n            }\n            else {\n                this.channels[key] = channel;\n            }\n        }\n    }\n    addNode(...args) {\n        function isMultipleNodes(args) {\n            return args.length >= 1 && typeof args[0] !== \"string\";\n        }\n        const nodes = (isMultipleNodes(args) // eslint-disable-line no-nested-ternary\n            ? Array.isArray(args[0])\n                ? args[0]\n                : Object.entries(args[0])\n            : [[args[0], args[1], args[2]]]);\n        if (nodes.length === 0) {\n            throw new Error(\"No nodes provided in `addNode`\");\n        }\n        for (const [key, action, options] of nodes) {\n            if (key in this.channels) {\n                throw new Error(`${key} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`);\n            }\n            for (const reservedChar of [\n                _constants_js__WEBPACK_IMPORTED_MODULE_8__.CHECKPOINT_NAMESPACE_SEPARATOR,\n                _constants_js__WEBPACK_IMPORTED_MODULE_8__.CHECKPOINT_NAMESPACE_END,\n            ]) {\n                if (key.includes(reservedChar)) {\n                    throw new Error(`\"${reservedChar}\" is a reserved character and is not allowed in node names.`);\n                }\n            }\n            this.warnIfCompiled(`Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`);\n            if (key in this.nodes) {\n                throw new Error(`Node \\`${key}\\` already present.`);\n            }\n            if (key === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END || key === _constants_js__WEBPACK_IMPORTED_MODULE_8__.START) {\n                throw new Error(`Node \\`${key}\\` is reserved.`);\n            }\n            let inputSpec = this._schemaDefinition;\n            if (options?.input !== undefined) {\n                if ((0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(options.input)) {\n                    inputSpec = (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.getChannelsFromZod)(options.input);\n                }\n                else if (options.input.spec !== undefined) {\n                    inputSpec = options.input.spec;\n                }\n            }\n            if (inputSpec !== undefined) {\n                this._addSchema(inputSpec);\n            }\n            let runnable;\n            if (_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(action)) {\n                runnable = action;\n            }\n            else if (typeof action === \"function\") {\n                runnable = new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n                    func: action,\n                    name: key,\n                    trace: false,\n                });\n            }\n            else {\n                runnable = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(action);\n            }\n            const nodeSpec = {\n                runnable: runnable,\n                retryPolicy: options?.retryPolicy,\n                metadata: options?.metadata,\n                input: inputSpec ?? this._schemaDefinition,\n                subgraphs: (0,_pregel_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_12__.isPregelLike)(runnable)\n                    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        [runnable]\n                    : options?.subgraphs,\n                ends: options?.ends,\n            };\n            this.nodes[key] = nodeSpec;\n        }\n        return this;\n    }\n    addEdge(startKey, endKey) {\n        if (typeof startKey === \"string\") {\n            return super.addEdge(startKey, endKey);\n        }\n        if (this.compiled) {\n            console.warn(\"Adding an edge to a graph that has already been compiled. This will \" +\n                \"not be reflected in the compiled graph.\");\n        }\n        for (const start of startKey) {\n            if (start === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END) {\n                throw new Error(\"END cannot be a start node\");\n            }\n            if (!Object.keys(this.nodes).some((node) => node === start)) {\n                throw new Error(`Need to add a node named \"${start}\" first`);\n            }\n        }\n        if (endKey === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END) {\n            throw new Error(\"END cannot be an end node\");\n        }\n        if (!Object.keys(this.nodes).some((node) => node === endKey)) {\n            throw new Error(`Need to add a node named \"${endKey}\" first`);\n        }\n        this.waitingEdges.add([startKey, endKey]);\n        return this;\n    }\n    addSequence(nodes) {\n        const parsedNodes = Array.isArray(nodes)\n            ? nodes\n            : Object.entries(nodes);\n        if (parsedNodes.length === 0) {\n            throw new Error(\"Sequence requires at least one node.\");\n        }\n        let previousNode;\n        for (const [key, action, options] of parsedNodes) {\n            if (key in this.nodes) {\n                throw new Error(`Node names must be unique: node with the name \"${key}\" already exists.`);\n            }\n            const validKey = key;\n            this.addNode(validKey, action, options);\n            if (previousNode != null) {\n                this.addEdge(previousNode, validKey);\n            }\n            previousNode = validKey;\n        }\n        return this;\n    }\n    compile({ checkpointer, store, interruptBefore, interruptAfter, name, } = {}) {\n        // validate the graph\n        this.validate([\n            ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n            ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n        ]);\n        // prepare output channels\n        const outputKeys = Object.keys(this._schemaDefinitions.get(this._outputDefinition));\n        const outputChannels = outputKeys.length === 1 && outputKeys[0] === ROOT ? ROOT : outputKeys;\n        const streamKeys = Object.keys(this.channels);\n        const streamChannels = streamKeys.length === 1 && streamKeys[0] === ROOT ? ROOT : streamKeys;\n        // create empty compiled graph\n        const compiled = new CompiledStateGraph({\n            builder: this,\n            checkpointer,\n            interruptAfter,\n            interruptBefore,\n            autoValidate: false,\n            nodes: {},\n            channels: {\n                ...this.channels,\n                [_constants_js__WEBPACK_IMPORTED_MODULE_8__.START]: new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_6__.EphemeralValue(),\n            },\n            inputChannels: _constants_js__WEBPACK_IMPORTED_MODULE_8__.START,\n            outputChannels,\n            streamChannels,\n            streamMode: \"updates\",\n            store,\n            name,\n        });\n        // attach nodes, edges and branches\n        compiled.attachNode(_constants_js__WEBPACK_IMPORTED_MODULE_8__.START);\n        for (const [key, node] of Object.entries(this.nodes)) {\n            compiled.attachNode(key, node);\n        }\n        compiled.attachBranch(_constants_js__WEBPACK_IMPORTED_MODULE_8__.START, _constants_js__WEBPACK_IMPORTED_MODULE_8__.SELF, _getControlBranch(), {\n            withReader: false,\n        });\n        for (const [key] of Object.entries(this.nodes)) {\n            compiled.attachBranch(key, _constants_js__WEBPACK_IMPORTED_MODULE_8__.SELF, _getControlBranch(), {\n                withReader: false,\n            });\n        }\n        for (const [start, end] of this.edges) {\n            compiled.attachEdge(start, end);\n        }\n        for (const [starts, end] of this.waitingEdges) {\n            compiled.attachEdge(starts, end);\n        }\n        for (const [start, branches] of Object.entries(this.branches)) {\n            for (const [name, branch] of Object.entries(branches)) {\n                compiled.attachBranch(start, name, branch);\n            }\n        }\n        return compiled.validate();\n    }\n}\nfunction _getChannels(schema) {\n    const channels = {};\n    for (const [name, val] of Object.entries(schema)) {\n        if (name === ROOT) {\n            channels[name] = (0,_annotation_js__WEBPACK_IMPORTED_MODULE_10__.getChannel)(val);\n        }\n        else {\n            const key = name;\n            channels[name] = (0,_annotation_js__WEBPACK_IMPORTED_MODULE_10__.getChannel)(val);\n        }\n    }\n    return channels;\n}\n/**\n * Final result from building and compiling a {@link StateGraph}.\n * Should not be instantiated directly, only using the StateGraph `.compile()`\n * instance method.\n */\nclass CompiledStateGraph extends _graph_js__WEBPACK_IMPORTED_MODULE_2__.CompiledGraph {\n    attachNode(key, node) {\n        let outputKeys;\n        if (key === _constants_js__WEBPACK_IMPORTED_MODULE_8__.START) {\n            // Get input schema keys excluding managed values\n            outputKeys = Object.entries(this.builder._schemaDefinitions.get(this.builder._inputDefinition))\n                .filter(([_, v]) => !(0,_managed_base_js__WEBPACK_IMPORTED_MODULE_11__.isConfiguredManagedValue)(v))\n                .map(([k]) => k);\n        }\n        else {\n            outputKeys = Object.keys(this.builder.channels);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function _getRoot(input) {\n            if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(input)) {\n                if (input.graph === _constants_js__WEBPACK_IMPORTED_MODULE_8__.Command.PARENT) {\n                    return null;\n                }\n                return input._updateAsTuples();\n            }\n            else if (Array.isArray(input) &&\n                input.length > 0 &&\n                input.some((i) => (0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(i))) {\n                const updates = [];\n                for (const i of input) {\n                    if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(i)) {\n                        if (i.graph === _constants_js__WEBPACK_IMPORTED_MODULE_8__.Command.PARENT) {\n                            continue;\n                        }\n                        updates.push(...i._updateAsTuples());\n                    }\n                    else {\n                        updates.push([ROOT, i]);\n                    }\n                }\n                return updates;\n            }\n            else if (input != null) {\n                return [[ROOT, input]];\n            }\n            return null;\n        }\n        // to avoid name collision below\n        const nodeKey = key;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function _getUpdates(input) {\n            if (!input) {\n                return null;\n            }\n            else if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(input)) {\n                if (input.graph === _constants_js__WEBPACK_IMPORTED_MODULE_8__.Command.PARENT) {\n                    return null;\n                }\n                return input._updateAsTuples().filter(([k]) => outputKeys.includes(k));\n            }\n            else if (Array.isArray(input) &&\n                input.length > 0 &&\n                input.some(_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)) {\n                const updates = [];\n                for (const item of input) {\n                    if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(item)) {\n                        if (item.graph === _constants_js__WEBPACK_IMPORTED_MODULE_8__.Command.PARENT) {\n                            continue;\n                        }\n                        updates.push(...item._updateAsTuples().filter(([k]) => outputKeys.includes(k)));\n                    }\n                    else {\n                        const itemUpdates = _getUpdates(item);\n                        if (itemUpdates) {\n                            updates.push(...(itemUpdates ?? []));\n                        }\n                    }\n                }\n                return updates;\n            }\n            else if (typeof input === \"object\" && !Array.isArray(input)) {\n                return Object.entries(input).filter(([k]) => outputKeys.includes(k));\n            }\n            else {\n                const typeofInput = Array.isArray(input) ? \"array\" : typeof input;\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Expected node \"${nodeKey.toString()}\" to return an object or an array containing at least one Command object, received ${typeofInput}`, {\n                    lc_error_code: \"INVALID_GRAPH_NODE_RETURN_VALUE\",\n                });\n            }\n        }\n        const stateWriteEntries = [\n            {\n                value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.PASSTHROUGH,\n                mapper: new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n                    func: outputKeys.length && outputKeys[0] === ROOT\n                        ? _getRoot\n                        : _getUpdates,\n                    trace: false,\n                    recurse: false,\n                }),\n            },\n        ];\n        // add node and output channel\n        if (key === _constants_js__WEBPACK_IMPORTED_MODULE_8__.START) {\n            this.nodes[key] = new _pregel_read_js__WEBPACK_IMPORTED_MODULE_4__.PregelNode({\n                tags: [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN],\n                triggers: [_constants_js__WEBPACK_IMPORTED_MODULE_8__.START],\n                channels: [_constants_js__WEBPACK_IMPORTED_MODULE_8__.START],\n                writers: [new _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite(stateWriteEntries, [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN])],\n            });\n        }\n        else {\n            const inputDefinition = node?.input ?? this.builder._schemaDefinition;\n            const inputValues = Object.fromEntries(Object.keys(this.builder._schemaDefinitions.get(inputDefinition)).map((k) => [k, k]));\n            const isSingleInput = Object.keys(inputValues).length === 1 && ROOT in inputValues;\n            const branchChannel = `branch:to:${key}`;\n            this.channels[branchChannel] = new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_6__.EphemeralValue(false);\n            this.nodes[key] = new _pregel_read_js__WEBPACK_IMPORTED_MODULE_4__.PregelNode({\n                triggers: [branchChannel],\n                // read state keys\n                channels: isSingleInput ? Object.keys(inputValues) : inputValues,\n                // publish to state keys\n                writers: [new _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite(stateWriteEntries, [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN])],\n                mapper: isSingleInput\n                    ? undefined\n                    : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        (input) => {\n                            return Object.fromEntries(Object.entries(input).filter(([k]) => k in inputValues));\n                        },\n                bound: node?.runnable,\n                metadata: node?.metadata,\n                retryPolicy: node?.retryPolicy,\n                subgraphs: node?.subgraphs,\n                ends: node?.ends,\n            });\n        }\n    }\n    attachEdge(start, end) {\n        if (end === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END)\n            return;\n        if (typeof start === \"string\") {\n            this.nodes[start].writers.push(new _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite([{ channel: `branch:to:${end}`, value: null }], [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN]));\n        }\n        else if (Array.isArray(start)) {\n            const channelName = `join:${start.join(\"+\")}:${end}`;\n            // register channel\n            this.channels[channelName] =\n                new _channels_named_barrier_value_js__WEBPACK_IMPORTED_MODULE_5__.NamedBarrierValue(new Set(start));\n            // subscribe to channel\n            this.nodes[end].triggers.push(channelName);\n            // publish to channel\n            for (const s of start) {\n                this.nodes[s].writers.push(new _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite([{ channel: channelName, value: s }], [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN]));\n            }\n        }\n    }\n    attachBranch(start, _, branch, options = { withReader: true }) {\n        const branchWriter = async (packets, config) => {\n            const filteredPackets = packets.filter((p) => p !== _constants_js__WEBPACK_IMPORTED_MODULE_8__.END);\n            if (!filteredPackets.length)\n                return;\n            const writes = filteredPackets.map((p) => {\n                if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__._isSend)(p))\n                    return p;\n                return { channel: `branch:to:${p}`, value: start };\n            });\n            await _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite.doWrite({ ...config, tags: (config.tags ?? []).concat([_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN]) }, writes);\n        };\n        // attach branch publisher\n        this.nodes[start].writers.push(branch.run(branchWriter, \n        // reader\n        options.withReader\n            ? (config) => _pregel_read_js__WEBPACK_IMPORTED_MODULE_4__.ChannelRead.doRead(config, this.streamChannels ?? this.outputChannels, true)\n            : undefined));\n    }\n    async _validateInput(input) {\n        const inputSchema = this.builder._inputRuntimeDefinition;\n        if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(input)) {\n            const parsedInput = input;\n            if (input.update && (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(inputSchema))\n                parsedInput.update = inputSchema.parse(input.update);\n            return parsedInput;\n        }\n        if ((0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(inputSchema))\n            return inputSchema.parse(input);\n        return input;\n    }\n    async _validateConfigurable(config) {\n        const configSchema = this.builder._configRuntimeSchema;\n        if ((0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(configSchema))\n            configSchema.parse(config);\n        return config;\n    }\n}\nfunction isStateDefinition(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        !Array.isArray(obj) &&\n        Object.keys(obj).length > 0 &&\n        Object.values(obj).every((v) => typeof v === \"function\" || (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_1__.isBaseChannel)(v)));\n}\nfunction isAnnotationRoot(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        \"lc_graph_name\" in obj &&\n        obj.lc_graph_name === \"AnnotationRoot\");\n}\nfunction isStateGraphArgs(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        obj.channels !== undefined);\n}\nfunction isStateGraphArgsWithStateSchema(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        obj.stateSchema !== undefined);\n}\nfunction isStateGraphArgsWithInputOutputSchemas(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        obj.stateSchema === undefined &&\n        obj.input !== undefined &&\n        obj.output !== undefined);\n}\nfunction isZodStateGraphArgsWithStateSchema(value) {\n    if (typeof value !== \"object\" || value == null) {\n        return false;\n    }\n    if (!(\"state\" in value) || !(0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(value.state)) {\n        return false;\n    }\n    if (\"input\" in value && !(0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(value.input)) {\n        return false;\n    }\n    if (\"output\" in value && !(0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(value.output)) {\n        return false;\n    }\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _controlBranch(value) {\n    if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__._isSend)(value)) {\n        return [value];\n    }\n    const commands = [];\n    if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(value)) {\n        commands.push(value);\n    }\n    else if (Array.isArray(value)) {\n        commands.push(...value.filter(_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand));\n    }\n    const destinations = [];\n    for (const command of commands) {\n        if (command.graph === _constants_js__WEBPACK_IMPORTED_MODULE_8__.Command.PARENT) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.ParentCommand(command);\n        }\n        if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__._isSend)(command.goto)) {\n            destinations.push(command.goto);\n        }\n        else if (typeof command.goto === \"string\") {\n            destinations.push(command.goto);\n        }\n        else {\n            if (Array.isArray(command.goto)) {\n                destinations.push(...command.goto);\n            }\n        }\n    }\n    return destinations;\n}\nfunction _getControlBranch() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const CONTROL_BRANCH_PATH = new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n        func: _controlBranch,\n        tags: [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN],\n        trace: false,\n        recurse: false,\n        name: \"<control_branch>\",\n    });\n    return new _graph_js__WEBPACK_IMPORTED_MODULE_2__.Branch({\n        path: CONTROL_BRANCH_PATH,\n    });\n}\n//# sourceMappingURL=state.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9ncmFwaC9zdGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDeUU7QUFDckI7QUFDTztBQUNLO0FBQ0o7QUFDVztBQUNQO0FBQ2pCO0FBQ3dHO0FBQ3RGO0FBQ25CO0FBQ2dCO0FBQ0g7QUFDVTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQThDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUJBQXlCLDRDQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZCQUE2QixrRUFBa0I7QUFDL0Msb0RBQW9ELGtFQUFrQjtBQUN0RSxzREFBc0Qsa0VBQWtCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhEQUFjO0FBQy9CLDZCQUE2QixrRUFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkVBQXdCO0FBQ2pEO0FBQ0Esb0RBQW9ELElBQUk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0EsZ0JBQWdCLHlFQUE4QjtBQUM5QyxnQkFBZ0IsbUVBQXdCO0FBQ3hDO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0Esd0JBQXdCLDhDQUFHLFlBQVksZ0RBQUs7QUFDNUMsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFjO0FBQ2xDLGdDQUFnQyxrRUFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1REFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyQkFBMkIsNEVBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQUc7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELE1BQU07QUFDbkU7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLElBQUk7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhEQUE4RCxJQUFJO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQixnREFBSyxPQUFPLHdFQUFjO0FBQzNDLGFBQWE7QUFDYiwyQkFBMkIsZ0RBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0QixnREFBSztBQUNqQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQUssRUFBRSwrQ0FBSTtBQUN6QztBQUNBLFNBQVM7QUFDVDtBQUNBLHVDQUF1QywrQ0FBSTtBQUMzQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyREFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkRBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ08saUNBQWlDLG9EQUFhO0FBQ3JEO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQUs7QUFDekI7QUFDQTtBQUNBLHFDQUFxQywyRUFBd0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVM7QUFDekIsb0NBQW9DLGtEQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3REFBUztBQUMzQztBQUNBO0FBQ0Esd0JBQXdCLHdEQUFTO0FBQ2pDLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBUztBQUM5QixvQ0FBb0Msa0RBQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFTO0FBQ3BDO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQVM7QUFDakMsMkNBQTJDLGtEQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwREFBa0IsbUJBQW1CLG1CQUFtQixxRkFBcUYsWUFBWTtBQUNuTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBVztBQUNsQyw0QkFBNEIsdURBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQUs7QUFDekIsa0NBQWtDLHVEQUFVO0FBQzVDLHVCQUF1QixxREFBVTtBQUNqQywyQkFBMkIsZ0RBQUs7QUFDaEMsMkJBQTJCLGdEQUFLO0FBQ2hDLDhCQUE4QiwwREFBWSxxQkFBcUIscURBQVU7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRCwrQ0FBK0Msd0VBQWM7QUFDN0Qsa0NBQWtDLHVEQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUFZLHFCQUFxQixxREFBVTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFHO0FBQ3ZCO0FBQ0E7QUFDQSwrQ0FBK0MsMERBQVksSUFBSSxzQkFBc0IsSUFBSSxnQkFBZ0IsSUFBSSxxREFBVTtBQUN2SDtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQixHQUFHLElBQUk7QUFDL0Q7QUFDQTtBQUNBLG9CQUFvQiwrRUFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMERBQVksSUFBSSxnQ0FBZ0MsSUFBSSxxREFBVTtBQUM3RztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msa0JBQWtCO0FBQ2pFO0FBQ0EsZ0VBQWdFLDhDQUFHO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBTztBQUMzQjtBQUNBLHlCQUF5QixzQkFBc0IsRUFBRTtBQUNqRCxhQUFhO0FBQ2Isa0JBQWtCLDBEQUFZLFdBQVcsNkNBQTZDLHFEQUFVLElBQUk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQVM7QUFDckI7QUFDQSxnQ0FBZ0MsOERBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0VBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4REFBYztBQUM5QztBQUNBO0FBQ0EsNkJBQTZCLDhEQUFjO0FBQzNDO0FBQ0E7QUFDQSw4QkFBOEIsOERBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9EQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBTztBQUNyQyxzQkFBc0IscURBQWE7QUFDbkM7QUFDQSxZQUFZLHNEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1REFBZ0I7QUFDcEQ7QUFDQSxlQUFlLHFEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLDZDQUFNO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxncmFwaFxcc3RhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5pbXBvcnQgeyBfY29lcmNlVG9SdW5uYWJsZSwgUnVubmFibGUsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbmltcG9ydCB7IGlzQmFzZUNoYW5uZWwgfSBmcm9tIFwiLi4vY2hhbm5lbHMvYmFzZS5qc1wiO1xuaW1wb3J0IHsgQ29tcGlsZWRHcmFwaCwgR3JhcGgsIEJyYW5jaCwgfSBmcm9tIFwiLi9ncmFwaC5qc1wiO1xuaW1wb3J0IHsgQ2hhbm5lbFdyaXRlLCBQQVNTVEhST1VHSCwgfSBmcm9tIFwiLi4vcHJlZ2VsL3dyaXRlLmpzXCI7XG5pbXBvcnQgeyBDaGFubmVsUmVhZCwgUHJlZ2VsTm9kZSB9IGZyb20gXCIuLi9wcmVnZWwvcmVhZC5qc1wiO1xuaW1wb3J0IHsgTmFtZWRCYXJyaWVyVmFsdWUgfSBmcm9tIFwiLi4vY2hhbm5lbHMvbmFtZWRfYmFycmllcl92YWx1ZS5qc1wiO1xuaW1wb3J0IHsgRXBoZW1lcmFsVmFsdWUgfSBmcm9tIFwiLi4vY2hhbm5lbHMvZXBoZW1lcmFsX3ZhbHVlLmpzXCI7XG5pbXBvcnQgeyBSdW5uYWJsZUNhbGxhYmxlIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBpc0NvbW1hbmQsIF9pc1NlbmQsIENIRUNLUE9JTlRfTkFNRVNQQUNFX0VORCwgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SLCBDb21tYW5kLCBFTkQsIFNFTEYsIFNUQVJULCBUQUdfSElEREVOLCB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IEludmFsaWRVcGRhdGVFcnJvciwgUGFyZW50Q29tbWFuZCB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGdldENoYW5uZWwsIH0gZnJvbSBcIi4vYW5ub3RhdGlvbi5qc1wiO1xuaW1wb3J0IHsgaXNDb25maWd1cmVkTWFuYWdlZFZhbHVlIH0gZnJvbSBcIi4uL21hbmFnZWQvYmFzZS5qc1wiO1xuaW1wb3J0IHsgaXNQcmVnZWxMaWtlIH0gZnJvbSBcIi4uL3ByZWdlbC91dGlscy9zdWJncmFwaC5qc1wiO1xuaW1wb3J0IHsgZ2V0Q2hhbm5lbHNGcm9tWm9kLCBpc0FueVpvZE9iamVjdCwgfSBmcm9tIFwiLi96b2Qvc3RhdGUuanNcIjtcbmNvbnN0IFJPT1QgPSBcIl9fcm9vdF9fXCI7XG4vKipcbiAqIEEgZ3JhcGggd2hvc2Ugbm9kZXMgY29tbXVuaWNhdGUgYnkgcmVhZGluZyBhbmQgd3JpdGluZyB0byBhIHNoYXJlZCBzdGF0ZS5cbiAqIEVhY2ggbm9kZSB0YWtlcyBhIGRlZmluZWQgYFN0YXRlYCBhcyBpbnB1dCBhbmQgcmV0dXJucyBhIGBQYXJ0aWFsPFN0YXRlPmAuXG4gKlxuICogRWFjaCBzdGF0ZSBrZXkgY2FuIG9wdGlvbmFsbHkgYmUgYW5ub3RhdGVkIHdpdGggYSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXRcbiAqIHdpbGwgYmUgdXNlZCB0byBhZ2dyZWdhdGUgdGhlIHZhbHVlcyBvZiB0aGF0IGtleSByZWNlaXZlZCBmcm9tIG11bHRpcGxlIG5vZGVzLlxuICogVGhlIHNpZ25hdHVyZSBvZiBhIHJlZHVjZXIgZnVuY3Rpb24gaXMgKGxlZnQ6IFZhbHVlLCByaWdodDogVXBkYXRlVmFsdWUpID0+IFZhbHVlLlxuICpcbiAqIFNlZSB7QGxpbmsgQW5ub3RhdGlvbn0gZm9yIG1vcmUgb24gZGVmaW5pbmcgc3RhdGUuXG4gKlxuICogQWZ0ZXIgYWRkaW5nIG5vZGVzIGFuZCBlZGdlcyB0byB5b3VyIGdyYXBoLCB5b3UgbXVzdCBjYWxsIGAuY29tcGlsZSgpYCBvbiBpdCBiZWZvcmVcbiAqIHlvdSBjYW4gdXNlIGl0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgdHlwZSBCYXNlTWVzc2FnZSxcbiAqICAgQUlNZXNzYWdlLFxuICogICBIdW1hbk1lc3NhZ2UsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIjtcbiAqIGltcG9ydCB7IFN0YXRlR3JhcGgsIEFubm90YXRpb24gfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGhcIjtcbiAqXG4gKiAvLyBEZWZpbmUgYSBzdGF0ZSB3aXRoIGEgc2luZ2xlIGtleSBuYW1lZCBcIm1lc3NhZ2VzXCIgdGhhdCB3aWxsXG4gKiAvLyBjb21iaW5lIGEgcmV0dXJuZWQgQmFzZU1lc3NhZ2Ugb3IgYXJyYXlzIG9mIEJhc2VNZXNzYWdlc1xuICogY29uc3QgU3RhdGVBbm5vdGF0aW9uID0gQW5ub3RhdGlvbi5Sb290KHtcbiAqICAgc2VudGltZW50OiBBbm5vdGF0aW9uPHN0cmluZz4sXG4gKiAgIG1lc3NhZ2VzOiBBbm5vdGF0aW9uPEJhc2VNZXNzYWdlW10+KHtcbiAqICAgICByZWR1Y2VyOiAobGVmdDogQmFzZU1lc3NhZ2VbXSwgcmlnaHQ6IEJhc2VNZXNzYWdlIHwgQmFzZU1lc3NhZ2VbXSkgPT4ge1xuICogICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmlnaHQpKSB7XG4gKiAgICAgICAgIHJldHVybiBsZWZ0LmNvbmNhdChyaWdodCk7XG4gKiAgICAgICB9XG4gKiAgICAgICByZXR1cm4gbGVmdC5jb25jYXQoW3JpZ2h0XSk7XG4gKiAgICAgfSxcbiAqICAgICBkZWZhdWx0OiAoKSA9PiBbXSxcbiAqICAgfSksXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBncmFwaEJ1aWxkZXIgPSBuZXcgU3RhdGVHcmFwaChTdGF0ZUFubm90YXRpb24pO1xuICpcbiAqIC8vIEEgbm9kZSBpbiB0aGUgZ3JhcGggdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgXCJtZXNzYWdlc1wiIGtleVxuICogLy8gd2lsbCB1cGRhdGUgdGhlIHN0YXRlIGJ5IGNvbWJpbmluZyB0aGUgZXhpc3RpbmcgdmFsdWUgd2l0aCB0aGUgcmV0dXJuZWQgb25lLlxuICogY29uc3QgbXlOb2RlID0gKHN0YXRlOiB0eXBlb2YgU3RhdGVBbm5vdGF0aW9uLlN0YXRlKSA9PiB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgbWVzc2FnZXM6IFtuZXcgQUlNZXNzYWdlKFwiU29tZSBuZXcgcmVzcG9uc2VcIildLFxuICogICAgIHNlbnRpbWVudDogXCJwb3NpdGl2ZVwiLFxuICogICB9O1xuICogfTtcbiAqXG4gKiBjb25zdCBncmFwaCA9IGdyYXBoQnVpbGRlclxuICogICAuYWRkTm9kZShcIm15Tm9kZVwiLCBteU5vZGUpXG4gKiAgIC5hZGRFZGdlKFwiX19zdGFydF9fXCIsIFwibXlOb2RlXCIpXG4gKiAgIC5hZGRFZGdlKFwibXlOb2RlXCIsIFwiX19lbmRfX1wiKVxuICogICAuY29tcGlsZSgpO1xuICpcbiAqIGF3YWl0IGdyYXBoLmludm9rZSh7IG1lc3NhZ2VzOiBbbmV3IEh1bWFuTWVzc2FnZShcImhvdyBhcmUgeW91P1wiKV0gfSk7XG4gKlxuICogLy8ge1xuICogLy8gICBtZXNzYWdlczogW0h1bWFuTWVzc2FnZShcImhvdyBhcmUgeW91P1wiKSwgQUlNZXNzYWdlKFwiU29tZSBuZXcgcmVzcG9uc2VcIildLFxuICogLy8gICBzZW50aW1lbnQ6IFwicG9zaXRpdmVcIixcbiAqIC8vIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU3RhdGVHcmFwaCBleHRlbmRzIEdyYXBoIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGNvbmZpZ1NjaGVtYSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFubmVsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgZG9lc24ndCBkZWR1cGUgZWRnZXMgYXMgaW4gcHksIHNvIHdvcnRoIGZpeGluZyBhdCBzb21lIHBvaW50XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndhaXRpbmdFZGdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zY2hlbWFEZWZpbml0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NjaGVtYVJ1bnRpbWVEZWZpbml0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2lucHV0RGVmaW5pdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnB1dFJ1bnRpbWVEZWZpbml0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX291dHB1dERlZmluaXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb3V0cHV0UnVudGltZURlZmluaXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBzY2hlbWFzIHRvIG1hbmFnZWQgdmFsdWVzXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NjaGVtYURlZmluaXRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgVXNlZCBvbmx5IGZvciB0eXBpbmcuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb25maWdTY2hlbWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY29uZmlnUnVudGltZVNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNab2RTdGF0ZUdyYXBoQXJnc1dpdGhTdGF0ZVNjaGVtYShmaWVsZHMpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZURlZiA9IGdldENoYW5uZWxzRnJvbVpvZChmaWVsZHMuc3RhdGUpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXREZWYgPSBmaWVsZHMuaW5wdXQgIT0gbnVsbCA/IGdldENoYW5uZWxzRnJvbVpvZChmaWVsZHMuaW5wdXQpIDogc3RhdGVEZWY7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXREZWYgPSBmaWVsZHMub3V0cHV0ICE9IG51bGwgPyBnZXRDaGFubmVsc0Zyb21ab2QoZmllbGRzLm91dHB1dCkgOiBzdGF0ZURlZjtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYURlZmluaXRpb24gPSBzdGF0ZURlZjtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYVJ1bnRpbWVEZWZpbml0aW9uID0gZmllbGRzLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5faW5wdXREZWZpbml0aW9uID0gaW5wdXREZWY7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dFJ1bnRpbWVEZWZpbml0aW9uID0gZmllbGRzLmlucHV0ID8/IGZpZWxkcy5zdGF0ZS5wYXJ0aWFsKCk7XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXREZWZpbml0aW9uID0gb3V0cHV0RGVmO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0UnVudGltZURlZmluaXRpb24gPSBmaWVsZHMub3V0cHV0ID8/IGZpZWxkcy5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FueVpvZE9iamVjdChmaWVsZHMpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZURlZiA9IGdldENoYW5uZWxzRnJvbVpvZChmaWVsZHMpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbiA9IHN0YXRlRGVmO1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hUnVudGltZURlZmluaXRpb24gPSBmaWVsZHM7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dERlZmluaXRpb24gPSBzdGF0ZURlZjtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0UnVudGltZURlZmluaXRpb24gPSBmaWVsZHMucGFydGlhbCgpO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0RGVmaW5pdGlvbiA9IHN0YXRlRGVmO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0UnVudGltZURlZmluaXRpb24gPSBmaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdGF0ZUdyYXBoQXJnc1dpdGhJbnB1dE91dHB1dFNjaGVtYXMoZmllbGRzKSkge1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbiA9IGZpZWxkcy5pbnB1dC5zcGVjO1xuICAgICAgICAgICAgdGhpcy5faW5wdXREZWZpbml0aW9uID0gZmllbGRzLmlucHV0LnNwZWM7XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXREZWZpbml0aW9uID0gZmllbGRzLm91dHB1dC5zcGVjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RhdGVHcmFwaEFyZ3NXaXRoU3RhdGVTY2hlbWEoZmllbGRzKSkge1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbiA9IGZpZWxkcy5zdGF0ZVNjaGVtYS5zcGVjO1xuICAgICAgICAgICAgdGhpcy5faW5wdXREZWZpbml0aW9uID0gKGZpZWxkcy5pbnB1dD8uc3BlYyA/P1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVtYURlZmluaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0RGVmaW5pdGlvbiA9IChmaWVsZHMub3V0cHV0Py5zcGVjID8/XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdGF0ZURlZmluaXRpb24oZmllbGRzKSB8fCBpc0Fubm90YXRpb25Sb290KGZpZWxkcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwZWMgPSBpc0Fubm90YXRpb25Sb290KGZpZWxkcykgPyBmaWVsZHMuc3BlYyA6IGZpZWxkcztcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYURlZmluaXRpb24gPSBzcGVjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RhdGVHcmFwaEFyZ3MoZmllbGRzKSkge1xuICAgICAgICAgICAgY29uc3Qgc3BlYyA9IF9nZXRDaGFubmVscyhmaWVsZHMuY2hhbm5lbHMpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbiA9IHNwZWM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFN0YXRlR3JhcGggaW5wdXQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lucHV0RGVmaW5pdGlvbiA/Pz0gdGhpcy5fc2NoZW1hRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5fb3V0cHV0RGVmaW5pdGlvbiA/Pz0gdGhpcy5fc2NoZW1hRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5fYWRkU2NoZW1hKHRoaXMuX3NjaGVtYURlZmluaXRpb24pO1xuICAgICAgICB0aGlzLl9hZGRTY2hlbWEodGhpcy5faW5wdXREZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5fYWRkU2NoZW1hKHRoaXMuX291dHB1dERlZmluaXRpb24pO1xuICAgICAgICBpZiAoaXNBbnlab2RPYmplY3QoY29uZmlnU2NoZW1hKSkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnUnVudGltZVNjaGVtYSA9IGNvbmZpZ1NjaGVtYS5wYXNzdGhyb3VnaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhbGxFZGdlcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoW1xuICAgICAgICAgICAgLi4udGhpcy5lZGdlcyxcbiAgICAgICAgICAgIC4uLkFycmF5LmZyb20odGhpcy53YWl0aW5nRWRnZXMpLmZsYXRNYXAoKFtzdGFydHMsIGVuZF0pID0+IHN0YXJ0cy5tYXAoKHN0YXJ0KSA9PiBbc3RhcnQsIGVuZF0pKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc3RhdGVEZWZpbml0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9zY2hlbWFEZWZpbml0aW9ucy5oYXMoc3RhdGVEZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFN1cHBvcnQgbWFuYWdlZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbnMuc2V0KHN0YXRlRGVmaW5pdGlvbiwgc3RhdGVEZWZpbml0aW9uKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHN0YXRlRGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIGxldCBjaGFubmVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwgPSB2YWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1trZXldICE9PSBjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDb25maWd1cmVkTWFuYWdlZFZhbHVlKGNoYW5uZWwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmxjX2dyYXBoX25hbWUgIT09IFwiTGFzdFZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhbm5lbCBcIiR7a2V5fVwiIGFscmVhZHkgZXhpc3RzIHdpdGggYSBkaWZmZXJlbnQgdHlwZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNba2V5XSA9IGNoYW5uZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTm9kZSguLi5hcmdzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGlzTXVsdGlwbGVOb2RlcyhhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncy5sZW5ndGggPj0gMSAmJiB0eXBlb2YgYXJnc1swXSAhPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlcyA9IChpc011bHRpcGxlTm9kZXMoYXJncykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgPyBBcnJheS5pc0FycmF5KGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgPyBhcmdzWzBdXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuZW50cmllcyhhcmdzWzBdKVxuICAgICAgICAgICAgOiBbW2FyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl1dXSk7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5vZGVzIHByb3ZpZGVkIGluIGBhZGROb2RlYFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGFjdGlvbiwgb3B0aW9uc10gb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl9IGlzIGFscmVhZHkgYmVpbmcgdXNlZCBhcyBhIHN0YXRlIGF0dHJpYnV0ZSAoYS5rLmEuIGEgY2hhbm5lbCksIGNhbm5vdCBhbHNvIGJlIHVzZWQgYXMgYSBub2RlIG5hbWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc2VydmVkQ2hhciBvZiBbXG4gICAgICAgICAgICAgICAgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SLFxuICAgICAgICAgICAgICAgIENIRUNLUE9JTlRfTkFNRVNQQUNFX0VORCxcbiAgICAgICAgICAgIF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKHJlc2VydmVkQ2hhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7cmVzZXJ2ZWRDaGFyfVwiIGlzIGEgcmVzZXJ2ZWQgY2hhcmFjdGVyIGFuZCBpcyBub3QgYWxsb3dlZCBpbiBub2RlIG5hbWVzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud2FybklmQ29tcGlsZWQoYEFkZGluZyBhIG5vZGUgdG8gYSBncmFwaCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29tcGlsZWQuIFRoaXMgd2lsbCBub3QgYmUgcmVmbGVjdGVkIGluIHRoZSBjb21waWxlZCBncmFwaC5gKTtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBcXGAke2tleX1cXGAgYWxyZWFkeSBwcmVzZW50LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gRU5EIHx8IGtleSA9PT0gU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgXFxgJHtrZXl9XFxgIGlzIHJlc2VydmVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlucHV0U3BlYyA9IHRoaXMuX3NjaGVtYURlZmluaXRpb247XG4gICAgICAgICAgICBpZiAob3B0aW9ucz8uaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FueVpvZE9iamVjdChvcHRpb25zLmlucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFNwZWMgPSBnZXRDaGFubmVsc0Zyb21ab2Qob3B0aW9ucy5pbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaW5wdXQuc3BlYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0U3BlYyA9IG9wdGlvbnMuaW5wdXQuc3BlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRTcGVjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRTY2hlbWEoaW5wdXRTcGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBydW5uYWJsZTtcbiAgICAgICAgICAgIGlmIChSdW5uYWJsZS5pc1J1bm5hYmxlKGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBydW5uYWJsZSA9IGFjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJ1bm5hYmxlID0gbmV3IFJ1bm5hYmxlQ2FsbGFibGUoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVubmFibGUgPSBfY29lcmNlVG9SdW5uYWJsZShhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZVNwZWMgPSB7XG4gICAgICAgICAgICAgICAgcnVubmFibGU6IHJ1bm5hYmxlLFxuICAgICAgICAgICAgICAgIHJldHJ5UG9saWN5OiBvcHRpb25zPy5yZXRyeVBvbGljeSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogb3B0aW9ucz8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0U3BlYyA/PyB0aGlzLl9zY2hlbWFEZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgIHN1YmdyYXBoczogaXNQcmVnZWxMaWtlKHJ1bm5hYmxlKVxuICAgICAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBbcnVubmFibGVdXG4gICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucz8uc3ViZ3JhcGhzLFxuICAgICAgICAgICAgICAgIGVuZHM6IG9wdGlvbnM/LmVuZHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1trZXldID0gbm9kZVNwZWM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEVkZ2Uoc3RhcnRLZXksIGVuZEtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0S2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYWRkRWRnZShzdGFydEtleSwgZW5kS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21waWxlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQWRkaW5nIGFuIGVkZ2UgdG8gYSBncmFwaCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29tcGlsZWQuIFRoaXMgd2lsbCBcIiArXG4gICAgICAgICAgICAgICAgXCJub3QgYmUgcmVmbGVjdGVkIGluIHRoZSBjb21waWxlZCBncmFwaC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzdGFydCBvZiBzdGFydEtleSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBFTkQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFTkQgY2Fubm90IGJlIGEgc3RhcnQgbm9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5ub2Rlcykuc29tZSgobm9kZSkgPT4gbm9kZSA9PT0gc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZWVkIHRvIGFkZCBhIG5vZGUgbmFtZWQgXCIke3N0YXJ0fVwiIGZpcnN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZEtleSA9PT0gRU5EKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFTkQgY2Fubm90IGJlIGFuIGVuZCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5ub2Rlcykuc29tZSgobm9kZSkgPT4gbm9kZSA9PT0gZW5kS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZWVkIHRvIGFkZCBhIG5vZGUgbmFtZWQgXCIke2VuZEtleX1cIiBmaXJzdGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdGluZ0VkZ2VzLmFkZChbc3RhcnRLZXksIGVuZEtleV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkU2VxdWVuY2Uobm9kZXMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkTm9kZXMgPSBBcnJheS5pc0FycmF5KG5vZGVzKVxuICAgICAgICAgICAgPyBub2Rlc1xuICAgICAgICAgICAgOiBPYmplY3QuZW50cmllcyhub2Rlcyk7XG4gICAgICAgIGlmIChwYXJzZWROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlcXVlbmNlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBub2RlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJldmlvdXNOb2RlO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGFjdGlvbiwgb3B0aW9uc10gb2YgcGFyc2VkTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBuYW1lcyBtdXN0IGJlIHVuaXF1ZTogbm9kZSB3aXRoIHRoZSBuYW1lIFwiJHtrZXl9XCIgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWxpZEtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMuYWRkTm9kZSh2YWxpZEtleSwgYWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c05vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWRnZShwcmV2aW91c05vZGUsIHZhbGlkS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHZhbGlkS2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb21waWxlKHsgY2hlY2twb2ludGVyLCBzdG9yZSwgaW50ZXJydXB0QmVmb3JlLCBpbnRlcnJ1cHRBZnRlciwgbmFtZSwgfSA9IHt9KSB7XG4gICAgICAgIC8vIHZhbGlkYXRlIHRoZSBncmFwaFxuICAgICAgICB0aGlzLnZhbGlkYXRlKFtcbiAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGludGVycnVwdEJlZm9yZSkgPyBpbnRlcnJ1cHRCZWZvcmUgOiBbXSksXG4gICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShpbnRlcnJ1cHRBZnRlcikgPyBpbnRlcnJ1cHRBZnRlciA6IFtdKSxcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIHByZXBhcmUgb3V0cHV0IGNoYW5uZWxzXG4gICAgICAgIGNvbnN0IG91dHB1dEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9zY2hlbWFEZWZpbml0aW9ucy5nZXQodGhpcy5fb3V0cHV0RGVmaW5pdGlvbikpO1xuICAgICAgICBjb25zdCBvdXRwdXRDaGFubmVscyA9IG91dHB1dEtleXMubGVuZ3RoID09PSAxICYmIG91dHB1dEtleXNbMF0gPT09IFJPT1QgPyBST09UIDogb3V0cHV0S2V5cztcbiAgICAgICAgY29uc3Qgc3RyZWFtS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuY2hhbm5lbHMpO1xuICAgICAgICBjb25zdCBzdHJlYW1DaGFubmVscyA9IHN0cmVhbUtleXMubGVuZ3RoID09PSAxICYmIHN0cmVhbUtleXNbMF0gPT09IFJPT1QgPyBST09UIDogc3RyZWFtS2V5cztcbiAgICAgICAgLy8gY3JlYXRlIGVtcHR5IGNvbXBpbGVkIGdyYXBoXG4gICAgICAgIGNvbnN0IGNvbXBpbGVkID0gbmV3IENvbXBpbGVkU3RhdGVHcmFwaCh7XG4gICAgICAgICAgICBidWlsZGVyOiB0aGlzLFxuICAgICAgICAgICAgY2hlY2twb2ludGVyLFxuICAgICAgICAgICAgaW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICBpbnRlcnJ1cHRCZWZvcmUsXG4gICAgICAgICAgICBhdXRvVmFsaWRhdGU6IGZhbHNlLFxuICAgICAgICAgICAgbm9kZXM6IHt9LFxuICAgICAgICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmNoYW5uZWxzLFxuICAgICAgICAgICAgICAgIFtTVEFSVF06IG5ldyBFcGhlbWVyYWxWYWx1ZSgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0Q2hhbm5lbHM6IFNUQVJULFxuICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbHMsXG4gICAgICAgICAgICBzdHJlYW1DaGFubmVscyxcbiAgICAgICAgICAgIHN0cmVhbU1vZGU6IFwidXBkYXRlc1wiLFxuICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gYXR0YWNoIG5vZGVzLCBlZGdlcyBhbmQgYnJhbmNoZXNcbiAgICAgICAgY29tcGlsZWQuYXR0YWNoTm9kZShTVEFSVCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5ub2RlcykpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLmF0dGFjaE5vZGUoa2V5LCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb21waWxlZC5hdHRhY2hCcmFuY2goU1RBUlQsIFNFTEYsIF9nZXRDb250cm9sQnJhbmNoKCksIHtcbiAgICAgICAgICAgIHdpdGhSZWFkZXI6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLm5vZGVzKSkge1xuICAgICAgICAgICAgY29tcGlsZWQuYXR0YWNoQnJhbmNoKGtleSwgU0VMRiwgX2dldENvbnRyb2xCcmFuY2goKSwge1xuICAgICAgICAgICAgICAgIHdpdGhSZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbc3RhcnQsIGVuZF0gb2YgdGhpcy5lZGdlcykge1xuICAgICAgICAgICAgY29tcGlsZWQuYXR0YWNoRWRnZShzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydHMsIGVuZF0gb2YgdGhpcy53YWl0aW5nRWRnZXMpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLmF0dGFjaEVkZ2Uoc3RhcnRzLCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBicmFuY2hlc10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5icmFuY2hlcykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGJyYW5jaF0gb2YgT2JqZWN0LmVudHJpZXMoYnJhbmNoZXMpKSB7XG4gICAgICAgICAgICAgICAgY29tcGlsZWQuYXR0YWNoQnJhbmNoKHN0YXJ0LCBuYW1lLCBicmFuY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21waWxlZC52YWxpZGF0ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRDaGFubmVscyhzY2hlbWEpIHtcbiAgICBjb25zdCBjaGFubmVscyA9IHt9O1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hKSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gUk9PVCkge1xuICAgICAgICAgICAgY2hhbm5lbHNbbmFtZV0gPSBnZXRDaGFubmVsKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuYW1lO1xuICAgICAgICAgICAgY2hhbm5lbHNbbmFtZV0gPSBnZXRDaGFubmVsKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxzO1xufVxuLyoqXG4gKiBGaW5hbCByZXN1bHQgZnJvbSBidWlsZGluZyBhbmQgY29tcGlsaW5nIGEge0BsaW5rIFN0YXRlR3JhcGh9LlxuICogU2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHksIG9ubHkgdXNpbmcgdGhlIFN0YXRlR3JhcGggYC5jb21waWxlKClgXG4gKiBpbnN0YW5jZSBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21waWxlZFN0YXRlR3JhcGggZXh0ZW5kcyBDb21waWxlZEdyYXBoIHtcbiAgICBhdHRhY2hOb2RlKGtleSwgbm9kZSkge1xuICAgICAgICBsZXQgb3V0cHV0S2V5cztcbiAgICAgICAgaWYgKGtleSA9PT0gU1RBUlQpIHtcbiAgICAgICAgICAgIC8vIEdldCBpbnB1dCBzY2hlbWEga2V5cyBleGNsdWRpbmcgbWFuYWdlZCB2YWx1ZXNcbiAgICAgICAgICAgIG91dHB1dEtleXMgPSBPYmplY3QuZW50cmllcyh0aGlzLmJ1aWxkZXIuX3NjaGVtYURlZmluaXRpb25zLmdldCh0aGlzLmJ1aWxkZXIuX2lucHV0RGVmaW5pdGlvbikpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW18sIHZdKSA9PiAhaXNDb25maWd1cmVkTWFuYWdlZFZhbHVlKHYpKVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrXSkgPT4gayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRLZXlzID0gT2JqZWN0LmtleXModGhpcy5idWlsZGVyLmNoYW5uZWxzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBmdW5jdGlvbiBfZ2V0Um9vdChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlzQ29tbWFuZChpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZ3JhcGggPT09IENvbW1hbmQuUEFSRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQuX3VwZGF0ZUFzVHVwbGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSAmJlxuICAgICAgICAgICAgICAgIGlucHV0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBpbnB1dC5zb21lKChpKSA9PiBpc0NvbW1hbmQoaSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21tYW5kKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaS5ncmFwaCA9PT0gQ29tbWFuZC5QQVJFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMucHVzaCguLi5pLl91cGRhdGVBc1R1cGxlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChbUk9PVCwgaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbW1JPT1QsIGlucHV0XV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0byBhdm9pZCBuYW1lIGNvbGxpc2lvbiBiZWxvd1xuICAgICAgICBjb25zdCBub2RlS2V5ID0ga2V5O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBmdW5jdGlvbiBfZ2V0VXBkYXRlcyhpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDb21tYW5kKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5ncmFwaCA9PT0gQ29tbWFuZC5QQVJFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dC5fdXBkYXRlQXNUdXBsZXMoKS5maWx0ZXIoKFtrXSkgPT4gb3V0cHV0S2V5cy5pbmNsdWRlcyhrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSAmJlxuICAgICAgICAgICAgICAgIGlucHV0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBpbnB1dC5zb21lKGlzQ29tbWFuZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbW1hbmQoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmdyYXBoID09PSBDb21tYW5kLlBBUkVOVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKC4uLml0ZW0uX3VwZGF0ZUFzVHVwbGVzKCkuZmlsdGVyKChba10pID0+IG91dHB1dEtleXMuaW5jbHVkZXMoaykpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1VcGRhdGVzID0gX2dldFVwZGF0ZXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goLi4uKGl0ZW1VcGRhdGVzID8/IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGlucHV0KS5maWx0ZXIoKFtrXSkgPT4gb3V0cHV0S2V5cy5pbmNsdWRlcyhrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlb2ZJbnB1dCA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gXCJhcnJheVwiIDogdHlwZW9mIGlucHV0O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoYEV4cGVjdGVkIG5vZGUgXCIke25vZGVLZXkudG9TdHJpbmcoKX1cIiB0byByZXR1cm4gYW4gb2JqZWN0IG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgYXQgbGVhc3Qgb25lIENvbW1hbmQgb2JqZWN0LCByZWNlaXZlZCAke3R5cGVvZklucHV0fWAsIHtcbiAgICAgICAgICAgICAgICAgICAgbGNfZXJyb3JfY29kZTogXCJJTlZBTElEX0dSQVBIX05PREVfUkVUVVJOX1ZBTFVFXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGVXcml0ZUVudHJpZXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFBBU1NUSFJPVUdILFxuICAgICAgICAgICAgICAgIG1hcHBlcjogbmV3IFJ1bm5hYmxlQ2FsbGFibGUoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jOiBvdXRwdXRLZXlzLmxlbmd0aCAmJiBvdXRwdXRLZXlzWzBdID09PSBST09UXG4gICAgICAgICAgICAgICAgICAgICAgICA/IF9nZXRSb290XG4gICAgICAgICAgICAgICAgICAgICAgICA6IF9nZXRVcGRhdGVzLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLy8gYWRkIG5vZGUgYW5kIG91dHB1dCBjaGFubmVsXG4gICAgICAgIGlmIChrZXkgPT09IFNUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2tleV0gPSBuZXcgUHJlZ2VsTm9kZSh7XG4gICAgICAgICAgICAgICAgdGFnczogW1RBR19ISURERU5dLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJzOiBbU1RBUlRdLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxzOiBbU1RBUlRdLFxuICAgICAgICAgICAgICAgIHdyaXRlcnM6IFtuZXcgQ2hhbm5lbFdyaXRlKHN0YXRlV3JpdGVFbnRyaWVzLCBbVEFHX0hJRERFTl0pXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5wdXREZWZpbml0aW9uID0gbm9kZT8uaW5wdXQgPz8gdGhpcy5idWlsZGVyLl9zY2hlbWFEZWZpbml0aW9uO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRWYWx1ZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXModGhpcy5idWlsZGVyLl9zY2hlbWFEZWZpbml0aW9ucy5nZXQoaW5wdXREZWZpbml0aW9uKSkubWFwKChrKSA9PiBbaywga10pKTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2luZ2xlSW5wdXQgPSBPYmplY3Qua2V5cyhpbnB1dFZhbHVlcykubGVuZ3RoID09PSAxICYmIFJPT1QgaW4gaW5wdXRWYWx1ZXM7XG4gICAgICAgICAgICBjb25zdCBicmFuY2hDaGFubmVsID0gYGJyYW5jaDp0bzoke2tleX1gO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1ticmFuY2hDaGFubmVsXSA9IG5ldyBFcGhlbWVyYWxWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2tleV0gPSBuZXcgUHJlZ2VsTm9kZSh7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcnM6IFticmFuY2hDaGFubmVsXSxcbiAgICAgICAgICAgICAgICAvLyByZWFkIHN0YXRlIGtleXNcbiAgICAgICAgICAgICAgICBjaGFubmVsczogaXNTaW5nbGVJbnB1dCA/IE9iamVjdC5rZXlzKGlucHV0VmFsdWVzKSA6IGlucHV0VmFsdWVzLFxuICAgICAgICAgICAgICAgIC8vIHB1Ymxpc2ggdG8gc3RhdGUga2V5c1xuICAgICAgICAgICAgICAgIHdyaXRlcnM6IFtuZXcgQ2hhbm5lbFdyaXRlKHN0YXRlV3JpdGVFbnRyaWVzLCBbVEFHX0hJRERFTl0pXSxcbiAgICAgICAgICAgICAgICBtYXBwZXI6IGlzU2luZ2xlSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhpbnB1dCkuZmlsdGVyKChba10pID0+IGsgaW4gaW5wdXRWYWx1ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmQ6IG5vZGU/LnJ1bm5hYmxlLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBub2RlPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICByZXRyeVBvbGljeTogbm9kZT8ucmV0cnlQb2xpY3ksXG4gICAgICAgICAgICAgICAgc3ViZ3JhcGhzOiBub2RlPy5zdWJncmFwaHMsXG4gICAgICAgICAgICAgICAgZW5kczogbm9kZT8uZW5kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaEVkZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoZW5kID09PSBFTkQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbc3RhcnRdLndyaXRlcnMucHVzaChuZXcgQ2hhbm5lbFdyaXRlKFt7IGNoYW5uZWw6IGBicmFuY2g6dG86JHtlbmR9YCwgdmFsdWU6IG51bGwgfV0sIFtUQUdfSElEREVOXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3RhcnQpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsTmFtZSA9IGBqb2luOiR7c3RhcnQuam9pbihcIitcIil9OiR7ZW5kfWA7XG4gICAgICAgICAgICAvLyByZWdpc3RlciBjaGFubmVsXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW2NoYW5uZWxOYW1lXSA9XG4gICAgICAgICAgICAgICAgbmV3IE5hbWVkQmFycmllclZhbHVlKG5ldyBTZXQoc3RhcnQpKTtcbiAgICAgICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGFubmVsXG4gICAgICAgICAgICB0aGlzLm5vZGVzW2VuZF0udHJpZ2dlcnMucHVzaChjaGFubmVsTmFtZSk7XG4gICAgICAgICAgICAvLyBwdWJsaXNoIHRvIGNoYW5uZWxcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBzdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbc10ud3JpdGVycy5wdXNoKG5ldyBDaGFubmVsV3JpdGUoW3sgY2hhbm5lbDogY2hhbm5lbE5hbWUsIHZhbHVlOiBzIH1dLCBbVEFHX0hJRERFTl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2hCcmFuY2goc3RhcnQsIF8sIGJyYW5jaCwgb3B0aW9ucyA9IHsgd2l0aFJlYWRlcjogdHJ1ZSB9KSB7XG4gICAgICAgIGNvbnN0IGJyYW5jaFdyaXRlciA9IGFzeW5jIChwYWNrZXRzLCBjb25maWcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkUGFja2V0cyA9IHBhY2tldHMuZmlsdGVyKChwKSA9PiBwICE9PSBFTkQpO1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJlZFBhY2tldHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlcyA9IGZpbHRlcmVkUGFja2V0cy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoX2lzU2VuZChwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbm5lbDogYGJyYW5jaDp0bzoke3B9YCwgdmFsdWU6IHN0YXJ0IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IENoYW5uZWxXcml0ZS5kb1dyaXRlKHsgLi4uY29uZmlnLCB0YWdzOiAoY29uZmlnLnRhZ3MgPz8gW10pLmNvbmNhdChbVEFHX0hJRERFTl0pIH0sIHdyaXRlcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGF0dGFjaCBicmFuY2ggcHVibGlzaGVyXG4gICAgICAgIHRoaXMubm9kZXNbc3RhcnRdLndyaXRlcnMucHVzaChicmFuY2gucnVuKGJyYW5jaFdyaXRlciwgXG4gICAgICAgIC8vIHJlYWRlclxuICAgICAgICBvcHRpb25zLndpdGhSZWFkZXJcbiAgICAgICAgICAgID8gKGNvbmZpZykgPT4gQ2hhbm5lbFJlYWQuZG9SZWFkKGNvbmZpZywgdGhpcy5zdHJlYW1DaGFubmVscyA/PyB0aGlzLm91dHB1dENoYW5uZWxzLCB0cnVlKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQpKTtcbiAgICB9XG4gICAgYXN5bmMgX3ZhbGlkYXRlSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgaW5wdXRTY2hlbWEgPSB0aGlzLmJ1aWxkZXIuX2lucHV0UnVudGltZURlZmluaXRpb247XG4gICAgICAgIGlmIChpc0NvbW1hbmQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgaWYgKGlucHV0LnVwZGF0ZSAmJiBpc0FueVpvZE9iamVjdChpbnB1dFNjaGVtYSkpXG4gICAgICAgICAgICAgICAgcGFyc2VkSW5wdXQudXBkYXRlID0gaW5wdXRTY2hlbWEucGFyc2UoaW5wdXQudXBkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbnlab2RPYmplY3QoaW5wdXRTY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0U2NoZW1hLnBhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBhc3luYyBfdmFsaWRhdGVDb25maWd1cmFibGUoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ1NjaGVtYSA9IHRoaXMuYnVpbGRlci5fY29uZmlnUnVudGltZVNjaGVtYTtcbiAgICAgICAgaWYgKGlzQW55Wm9kT2JqZWN0KGNvbmZpZ1NjaGVtYSkpXG4gICAgICAgICAgICBjb25maWdTY2hlbWEucGFyc2UoY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0YXRlRGVmaW5pdGlvbihvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KG9iaikgJiZcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPiAwICYmXG4gICAgICAgIE9iamVjdC52YWx1ZXMob2JqKS5ldmVyeSgodikgPT4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIiB8fCBpc0Jhc2VDaGFubmVsKHYpKSk7XG59XG5mdW5jdGlvbiBpc0Fubm90YXRpb25Sb290KG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgICAgXCJsY19ncmFwaF9uYW1lXCIgaW4gb2JqICYmXG4gICAgICAgIG9iai5sY19ncmFwaF9uYW1lID09PSBcIkFubm90YXRpb25Sb290XCIpO1xufVxuZnVuY3Rpb24gaXNTdGF0ZUdyYXBoQXJncyhvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgIG9iai5jaGFubmVscyAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGVHcmFwaEFyZ3NXaXRoU3RhdGVTY2hlbWEob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICBvYmouc3RhdGVTY2hlbWEgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBpc1N0YXRlR3JhcGhBcmdzV2l0aElucHV0T3V0cHV0U2NoZW1hcyhvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIG9iai5zdGF0ZVNjaGVtYSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG9iai5pbnB1dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG9iai5vdXRwdXQgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBpc1pvZFN0YXRlR3JhcGhBcmdzV2l0aFN0YXRlU2NoZW1hKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEoXCJzdGF0ZVwiIGluIHZhbHVlKSB8fCAhaXNBbnlab2RPYmplY3QodmFsdWUuc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFwiaW5wdXRcIiBpbiB2YWx1ZSAmJiAhaXNBbnlab2RPYmplY3QodmFsdWUuaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFwib3V0cHV0XCIgaW4gdmFsdWUgJiYgIWlzQW55Wm9kT2JqZWN0KHZhbHVlLm91dHB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29udHJvbEJyYW5jaCh2YWx1ZSkge1xuICAgIGlmIChfaXNTZW5kKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gICAgY29uc3QgY29tbWFuZHMgPSBbXTtcbiAgICBpZiAoaXNDb21tYW5kKHZhbHVlKSkge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCguLi52YWx1ZS5maWx0ZXIoaXNDb21tYW5kKSk7XG4gICAgfVxuICAgIGNvbnN0IGRlc3RpbmF0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBjb21tYW5kcykge1xuICAgICAgICBpZiAoY29tbWFuZC5ncmFwaCA9PT0gQ29tbWFuZC5QQVJFTlQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJlbnRDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaXNTZW5kKGNvbW1hbmQuZ290bykpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9ucy5wdXNoKGNvbW1hbmQuZ290byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbW1hbmQuZ290byA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVzdGluYXRpb25zLnB1c2goY29tbWFuZC5nb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1hbmQuZ290bykpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbnMucHVzaCguLi5jb21tYW5kLmdvdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbnM7XG59XG5mdW5jdGlvbiBfZ2V0Q29udHJvbEJyYW5jaCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IENPTlRST0xfQlJBTkNIX1BBVEggPSBuZXcgUnVubmFibGVDYWxsYWJsZSh7XG4gICAgICAgIGZ1bmM6IF9jb250cm9sQnJhbmNoLFxuICAgICAgICB0YWdzOiBbVEFHX0hJRERFTl0sXG4gICAgICAgIHRyYWNlOiBmYWxzZSxcbiAgICAgICAgcmVjdXJzZTogZmFsc2UsXG4gICAgICAgIG5hbWU6IFwiPGNvbnRyb2xfYnJhbmNoPlwiLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQnJhbmNoKHtcbiAgICAgICAgcGF0aDogQ09OVFJPTF9CUkFOQ0hfUEFUSCxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/graph/state.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/graph/zod/state.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/graph/zod/state.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extendMeta: () => (/* binding */ extendMeta),\n/* harmony export */   getChannelsFromZod: () => (/* binding */ getChannelsFromZod),\n/* harmony export */   getMeta: () => (/* binding */ getMeta),\n/* harmony export */   isAnyZodObject: () => (/* binding */ isAnyZodObject),\n/* harmony export */   isZodDefault: () => (/* binding */ isZodDefault),\n/* harmony export */   withLangGraph: () => (/* binding */ withLangGraph)\n/* harmony export */ });\n/* harmony import */ var _channels_binop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../channels/binop.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/binop.js\");\n/* harmony import */ var _channels_last_value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../channels/last_value.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/last_value.js\");\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst META_MAP = new WeakMap();\nfunction isZodType(value) {\n    return (typeof value === \"object\" &&\n        value != null &&\n        \"_parse\" in value &&\n        typeof value._parse === \"function\");\n}\n/**\n * @internal\n */\nfunction isZodDefault(value) {\n    return (isZodType(value) &&\n        \"removeDefault\" in value &&\n        typeof value.removeDefault === \"function\");\n}\n/**\n * @internal\n */\nfunction isAnyZodObject(value) {\n    return (isZodType(value) &&\n        \"partial\" in value &&\n        typeof value.partial === \"function\");\n}\nfunction withLangGraph(schema, meta) {\n    if (meta.reducer && !meta.default) {\n        const defaultValue = isZodDefault(schema)\n            ? schema._def.defaultValue\n            : undefined;\n        if (defaultValue != null) {\n            // eslint-disable-next-line no-param-reassign\n            meta.default = defaultValue;\n        }\n    }\n    META_MAP.set(schema, meta);\n    return schema;\n}\nfunction getMeta(schema) {\n    return META_MAP.get(schema);\n}\nfunction extendMeta(schema, update) {\n    const existingMeta = getMeta(schema);\n    const newMeta = update(existingMeta);\n    META_MAP.set(schema, newMeta);\n}\nfunction getChannelsFromZod(schema) {\n    const channels = {};\n    for (const key in schema.shape) {\n        if (Object.prototype.hasOwnProperty.call(schema.shape, key)) {\n            const keySchema = schema.shape[key];\n            const meta = getMeta(keySchema);\n            if (meta?.reducer) {\n                channels[key] = new _channels_binop_js__WEBPACK_IMPORTED_MODULE_0__.BinaryOperatorAggregate(meta.reducer.fn, meta.default);\n            }\n            else {\n                channels[key] = new _channels_last_value_js__WEBPACK_IMPORTED_MODULE_1__.LastValue();\n            }\n        }\n    }\n    return channels;\n}\n//# sourceMappingURL=state.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9ncmFwaC96b2Qvc3RhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0U7QUFDVDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1RUFBdUI7QUFDM0Q7QUFDQTtBQUNBLG9DQUFvQyw4REFBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxncmFwaFxcem9kXFxzdGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCaW5hcnlPcGVyYXRvckFnZ3JlZ2F0ZSB9IGZyb20gXCIuLi8uLi9jaGFubmVscy9iaW5vcC5qc1wiO1xuaW1wb3J0IHsgTGFzdFZhbHVlIH0gZnJvbSBcIi4uLy4uL2NoYW5uZWxzL2xhc3RfdmFsdWUuanNcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBNRVRBX01BUCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBpc1pvZFR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgIFwiX3BhcnNlXCIgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLl9wYXJzZSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1pvZERlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzWm9kVHlwZSh2YWx1ZSkgJiZcbiAgICAgICAgXCJyZW1vdmVEZWZhdWx0XCIgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnJlbW92ZURlZmF1bHQgPT09IFwiZnVuY3Rpb25cIik7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBbnlab2RPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzWm9kVHlwZSh2YWx1ZSkgJiZcbiAgICAgICAgXCJwYXJ0aWFsXCIgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnBhcnRpYWwgPT09IFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aExhbmdHcmFwaChzY2hlbWEsIG1ldGEpIHtcbiAgICBpZiAobWV0YS5yZWR1Y2VyICYmICFtZXRhLmRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gaXNab2REZWZhdWx0KHNjaGVtYSlcbiAgICAgICAgICAgID8gc2NoZW1hLl9kZWYuZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG1ldGEuZGVmYXVsdCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNRVRBX01BUC5zZXQoc2NoZW1hLCBtZXRhKTtcbiAgICByZXR1cm4gc2NoZW1hO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIE1FVEFfTUFQLmdldChzY2hlbWEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZE1ldGEoc2NoZW1hLCB1cGRhdGUpIHtcbiAgICBjb25zdCBleGlzdGluZ01ldGEgPSBnZXRNZXRhKHNjaGVtYSk7XG4gICAgY29uc3QgbmV3TWV0YSA9IHVwZGF0ZShleGlzdGluZ01ldGEpO1xuICAgIE1FVEFfTUFQLnNldChzY2hlbWEsIG5ld01ldGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5uZWxzRnJvbVpvZChzY2hlbWEpIHtcbiAgICBjb25zdCBjaGFubmVscyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYS5zaGFwZSwga2V5KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5U2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCBtZXRhID0gZ2V0TWV0YShrZXlTY2hlbWEpO1xuICAgICAgICAgICAgaWYgKG1ldGE/LnJlZHVjZXIpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsc1trZXldID0gbmV3IEJpbmFyeU9wZXJhdG9yQWdncmVnYXRlKG1ldGEucmVkdWNlci5mbiwgbWV0YS5kZWZhdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzW2tleV0gPSBuZXcgTGFzdFZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/graph/zod/state.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.Annotation),\n/* harmony export */   AsyncBatchedStore: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.AsyncBatchedStore),\n/* harmony export */   BaseChannel: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.BaseChannel),\n/* harmony export */   BaseCheckpointSaver: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.BaseCheckpointSaver),\n/* harmony export */   BaseLangGraphError: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.BaseLangGraphError),\n/* harmony export */   BaseStore: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.BaseStore),\n/* harmony export */   BinaryOperatorAggregate: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.BinaryOperatorAggregate),\n/* harmony export */   ChannelKeyPlaceholder: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.ChannelKeyPlaceholder),\n/* harmony export */   Command: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.Command),\n/* harmony export */   CompiledStateGraph: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.CompiledStateGraph),\n/* harmony export */   END: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.END),\n/* harmony export */   EmptyChannelError: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError),\n/* harmony export */   EmptyInputError: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.EmptyInputError),\n/* harmony export */   Graph: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.Graph),\n/* harmony export */   GraphBubbleUp: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.GraphBubbleUp),\n/* harmony export */   GraphInterrupt: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.GraphInterrupt),\n/* harmony export */   GraphRecursionError: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.GraphRecursionError),\n/* harmony export */   GraphValueError: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.GraphValueError),\n/* harmony export */   InMemoryStore: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.InMemoryStore),\n/* harmony export */   InvalidUpdateError: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.InvalidUpdateError),\n/* harmony export */   IsLastStepManager: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.IsLastStepManager),\n/* harmony export */   ManagedValue: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.ManagedValue),\n/* harmony export */   ManagedValueMapping: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.ManagedValueMapping),\n/* harmony export */   MemorySaver: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.MemorySaver),\n/* harmony export */   MessageGraph: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.MessageGraph),\n/* harmony export */   MessagesAnnotation: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.MessagesAnnotation),\n/* harmony export */   MessagesZodState: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.MessagesZodState),\n/* harmony export */   MultipleSubgraphsError: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.MultipleSubgraphsError),\n/* harmony export */   NodeInterrupt: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.NodeInterrupt),\n/* harmony export */   NoopManagedValue: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.NoopManagedValue),\n/* harmony export */   ParentCommand: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.ParentCommand),\n/* harmony export */   REMOVE_ALL_MESSAGES: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.REMOVE_ALL_MESSAGES),\n/* harmony export */   RemoteException: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.RemoteException),\n/* harmony export */   START: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.START),\n/* harmony export */   Send: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.Send),\n/* harmony export */   SharedValue: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.SharedValue),\n/* harmony export */   StateGraph: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.StateGraph),\n/* harmony export */   UnreachableNodeError: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.UnreachableNodeError),\n/* harmony export */   WritableManagedValue: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.WritableManagedValue),\n/* harmony export */   addMessages: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.addMessages),\n/* harmony export */   copyCheckpoint: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.copyCheckpoint),\n/* harmony export */   emptyCheckpoint: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.emptyCheckpoint),\n/* harmony export */   entrypoint: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.entrypoint),\n/* harmony export */   getConfig: () => (/* reexport safe */ _pregel_utils_config_js__WEBPACK_IMPORTED_MODULE_3__.getConfig),\n/* harmony export */   getCurrentTaskInput: () => (/* reexport safe */ _pregel_utils_config_js__WEBPACK_IMPORTED_MODULE_3__.getCurrentTaskInput),\n/* harmony export */   getPreviousState: () => (/* reexport safe */ _func_index_js__WEBPACK_IMPORTED_MODULE_4__.getPreviousState),\n/* harmony export */   getStore: () => (/* reexport safe */ _pregel_utils_config_js__WEBPACK_IMPORTED_MODULE_3__.getStore),\n/* harmony export */   getSubgraphsSeenSet: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.getSubgraphsSeenSet),\n/* harmony export */   getWriter: () => (/* reexport safe */ _pregel_utils_config_js__WEBPACK_IMPORTED_MODULE_3__.getWriter),\n/* harmony export */   interrupt: () => (/* reexport safe */ _interrupt_js__WEBPACK_IMPORTED_MODULE_2__.interrupt),\n/* harmony export */   isCommand: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.isCommand),\n/* harmony export */   isConfiguredManagedValue: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.isConfiguredManagedValue),\n/* harmony export */   isGraphBubbleUp: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.isGraphBubbleUp),\n/* harmony export */   isGraphInterrupt: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.isGraphInterrupt),\n/* harmony export */   isManagedValue: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.isManagedValue),\n/* harmony export */   isParentCommand: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.isParentCommand),\n/* harmony export */   messagesStateReducer: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.messagesStateReducer),\n/* harmony export */   task: () => (/* reexport safe */ _web_js__WEBPACK_IMPORTED_MODULE_1__.task)\n/* harmony export */ });\n/* harmony import */ var _setup_async_local_storage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setup/async_local_storage.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/setup/async_local_storage.js\");\n/* harmony import */ var _web_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./web.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/web.js\");\n/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interrupt.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/interrupt.js\");\n/* harmony import */ var _pregel_utils_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pregel/utils/config.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/config.js\");\n/* harmony import */ var _func_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./func/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/func/index.js\");\n/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\n// Initialize global async local storage instance for tracing\n(0,_setup_async_local_storage_js__WEBPACK_IMPORTED_MODULE_0__.initializeAsyncLocalStorageSingleton)();\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNzRjtBQUN0RjtBQUNBLG1HQUFvQztBQUNYO0FBQ2tCO0FBQytCO0FBQ3ZCO0FBQ1k7QUFDL0QiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBfX0xDX0FMTE9XX0VOVFJZUE9JTlRfU0lERV9FRkZFQ1RTX18gKi9cbmltcG9ydCB7IGluaXRpYWxpemVBc3luY0xvY2FsU3RvcmFnZVNpbmdsZXRvbiB9IGZyb20gXCIuL3NldHVwL2FzeW5jX2xvY2FsX3N0b3JhZ2UuanNcIjtcbi8vIEluaXRpYWxpemUgZ2xvYmFsIGFzeW5jIGxvY2FsIHN0b3JhZ2UgaW5zdGFuY2UgZm9yIHRyYWNpbmdcbmluaXRpYWxpemVBc3luY0xvY2FsU3RvcmFnZVNpbmdsZXRvbigpO1xuZXhwb3J0ICogZnJvbSBcIi4vd2ViLmpzXCI7XG5leHBvcnQgeyBpbnRlcnJ1cHQgfSBmcm9tIFwiLi9pbnRlcnJ1cHQuanNcIjtcbmV4cG9ydCB7IGdldFN0b3JlLCBnZXRXcml0ZXIsIGdldENvbmZpZyB9IGZyb20gXCIuL3ByZWdlbC91dGlscy9jb25maWcuanNcIjtcbmV4cG9ydCB7IGdldFByZXZpb3VzU3RhdGUgfSBmcm9tIFwiLi9mdW5jL2luZGV4LmpzXCI7XG5leHBvcnQgeyBnZXRDdXJyZW50VGFza0lucHV0IH0gZnJvbSBcIi4vcHJlZ2VsL3V0aWxzL2NvbmZpZy5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/interrupt.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/interrupt.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   interrupt: () => (/* binding */ interrupt)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/singletons */ \"(rsc)/./node_modules/@langchain/core/singletons.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n\n\n\n/**\n * Interrupts the execution of a graph node.\n * This function can be used to pause execution of a node, and return the value of the `resume`\n * input when the graph is re-invoked using `Command`.\n * Multiple interrupts can be called within a single node, and each will be handled sequentially.\n *\n * When an interrupt is called:\n * 1. If there's a `resume` value available (from a previous `Command`), it returns that value.\n * 2. Otherwise, it throws a `GraphInterrupt` with the provided value\n * 3. The graph can be resumed by passing a `Command` with a `resume` value\n *\n * Because the `interrupt` function propagates by throwing a special `GraphInterrupt` error,\n * you should avoid using `try/catch` blocks around the `interrupt` function,\n * or if you do, ensure that the `GraphInterrupt` error is thrown again within your `catch` block.\n *\n * @param value - The value to include in the interrupt. This will be available in task.interrupts[].value\n * @returns The `resume` value provided when the graph is re-invoked with a Command\n *\n * @example\n * ```typescript\n * // Define a node that uses multiple interrupts\n * const nodeWithInterrupts = () => {\n *   // First interrupt - will pause execution and include {value: 1} in task values\n *   const answer1 = interrupt({ value: 1 });\n *\n *   // Second interrupt - only called after first interrupt is resumed\n *   const answer2 = interrupt({ value: 2 });\n *\n *   // Use the resume values\n *   return { myKey: answer1 + \" \" + answer2 };\n * };\n *\n * // Resume the graph after first interrupt\n * await graph.stream(new Command({ resume: \"answer 1\" }));\n *\n * // Resume the graph after second interrupt\n * await graph.stream(new Command({ resume: \"answer 2\" }));\n * // Final result: { myKey: \"answer 1 answer 2\" }\n * ```\n *\n * @throws {Error} If called outside the context of a graph\n * @throws {GraphInterrupt} When no resume value is available\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction interrupt(value) {\n    const config = _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    if (!config) {\n        throw new Error(\"Called interrupt() outside the context of a graph.\");\n    }\n    const conf = config.configurable;\n    if (!conf) {\n        throw new Error(\"No configurable found in config\");\n    }\n    // Track interrupt index\n    const scratchpad = conf[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SCRATCHPAD];\n    scratchpad.interruptCounter += 1;\n    const idx = scratchpad.interruptCounter;\n    // Find previous resume values\n    if (scratchpad.resume.length > 0 && idx < scratchpad.resume.length) {\n        return scratchpad.resume[idx];\n    }\n    // Find current resume value\n    if (scratchpad.nullResume !== undefined) {\n        if (scratchpad.resume.length !== idx) {\n            throw new Error(`Resume length mismatch: ${scratchpad.resume.length} !== ${idx}`);\n        }\n        const v = scratchpad.consumeNullResume();\n        scratchpad.resume.push(v);\n        const send = conf[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SEND];\n        if (send) {\n            send([[_constants_js__WEBPACK_IMPORTED_MODULE_2__.RESUME, scratchpad.resume]]);\n        }\n        return v;\n    }\n    // No resume value found\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.GraphInterrupt([\n        {\n            value,\n            when: \"during\",\n            resumable: true,\n            ns: conf[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_NS]?.split(_constants_js__WEBPACK_IMPORTED_MODULE_2__.CHECKPOINT_NAMESPACE_SEPARATOR),\n        },\n    ]);\n}\n//# sourceMappingURL=interrupt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9pbnRlcnJ1cHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRjtBQUNuQztBQUM4RjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVO0FBQ3RFLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNPO0FBQ1AsbUJBQW1CLDBGQUFrQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEJBQTBCLE1BQU0sSUFBSTtBQUMzRjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMERBQWU7QUFDekM7QUFDQSxtQkFBbUIsaURBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUF3QixTQUFTLHlFQUE4QjtBQUNwRixTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxcaW50ZXJydXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3NpbmdsZXRvbnNcIjtcbmltcG9ydCB7IEdyYXBoSW50ZXJydXB0IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBDT05GSUdfS0VZX0NIRUNLUE9JTlRfTlMsIENPTkZJR19LRVlfU0NSQVRDSFBBRCwgQ09ORklHX0tFWV9TRU5ELCBDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IsIFJFU1VNRSwgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbi8qKlxuICogSW50ZXJydXB0cyB0aGUgZXhlY3V0aW9uIG9mIGEgZ3JhcGggbm9kZS5cbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gcGF1c2UgZXhlY3V0aW9uIG9mIGEgbm9kZSwgYW5kIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGByZXN1bWVgXG4gKiBpbnB1dCB3aGVuIHRoZSBncmFwaCBpcyByZS1pbnZva2VkIHVzaW5nIGBDb21tYW5kYC5cbiAqIE11bHRpcGxlIGludGVycnVwdHMgY2FuIGJlIGNhbGxlZCB3aXRoaW4gYSBzaW5nbGUgbm9kZSwgYW5kIGVhY2ggd2lsbCBiZSBoYW5kbGVkIHNlcXVlbnRpYWxseS5cbiAqXG4gKiBXaGVuIGFuIGludGVycnVwdCBpcyBjYWxsZWQ6XG4gKiAxLiBJZiB0aGVyZSdzIGEgYHJlc3VtZWAgdmFsdWUgYXZhaWxhYmxlIChmcm9tIGEgcHJldmlvdXMgYENvbW1hbmRgKSwgaXQgcmV0dXJucyB0aGF0IHZhbHVlLlxuICogMi4gT3RoZXJ3aXNlLCBpdCB0aHJvd3MgYSBgR3JhcGhJbnRlcnJ1cHRgIHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlXG4gKiAzLiBUaGUgZ3JhcGggY2FuIGJlIHJlc3VtZWQgYnkgcGFzc2luZyBhIGBDb21tYW5kYCB3aXRoIGEgYHJlc3VtZWAgdmFsdWVcbiAqXG4gKiBCZWNhdXNlIHRoZSBgaW50ZXJydXB0YCBmdW5jdGlvbiBwcm9wYWdhdGVzIGJ5IHRocm93aW5nIGEgc3BlY2lhbCBgR3JhcGhJbnRlcnJ1cHRgIGVycm9yLFxuICogeW91IHNob3VsZCBhdm9pZCB1c2luZyBgdHJ5L2NhdGNoYCBibG9ja3MgYXJvdW5kIHRoZSBgaW50ZXJydXB0YCBmdW5jdGlvbixcbiAqIG9yIGlmIHlvdSBkbywgZW5zdXJlIHRoYXQgdGhlIGBHcmFwaEludGVycnVwdGAgZXJyb3IgaXMgdGhyb3duIGFnYWluIHdpdGhpbiB5b3VyIGBjYXRjaGAgYmxvY2suXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluY2x1ZGUgaW4gdGhlIGludGVycnVwdC4gVGhpcyB3aWxsIGJlIGF2YWlsYWJsZSBpbiB0YXNrLmludGVycnVwdHNbXS52YWx1ZVxuICogQHJldHVybnMgVGhlIGByZXN1bWVgIHZhbHVlIHByb3ZpZGVkIHdoZW4gdGhlIGdyYXBoIGlzIHJlLWludm9rZWQgd2l0aCBhIENvbW1hbmRcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gRGVmaW5lIGEgbm9kZSB0aGF0IHVzZXMgbXVsdGlwbGUgaW50ZXJydXB0c1xuICogY29uc3Qgbm9kZVdpdGhJbnRlcnJ1cHRzID0gKCkgPT4ge1xuICogICAvLyBGaXJzdCBpbnRlcnJ1cHQgLSB3aWxsIHBhdXNlIGV4ZWN1dGlvbiBhbmQgaW5jbHVkZSB7dmFsdWU6IDF9IGluIHRhc2sgdmFsdWVzXG4gKiAgIGNvbnN0IGFuc3dlcjEgPSBpbnRlcnJ1cHQoeyB2YWx1ZTogMSB9KTtcbiAqXG4gKiAgIC8vIFNlY29uZCBpbnRlcnJ1cHQgLSBvbmx5IGNhbGxlZCBhZnRlciBmaXJzdCBpbnRlcnJ1cHQgaXMgcmVzdW1lZFxuICogICBjb25zdCBhbnN3ZXIyID0gaW50ZXJydXB0KHsgdmFsdWU6IDIgfSk7XG4gKlxuICogICAvLyBVc2UgdGhlIHJlc3VtZSB2YWx1ZXNcbiAqICAgcmV0dXJuIHsgbXlLZXk6IGFuc3dlcjEgKyBcIiBcIiArIGFuc3dlcjIgfTtcbiAqIH07XG4gKlxuICogLy8gUmVzdW1lIHRoZSBncmFwaCBhZnRlciBmaXJzdCBpbnRlcnJ1cHRcbiAqIGF3YWl0IGdyYXBoLnN0cmVhbShuZXcgQ29tbWFuZCh7IHJlc3VtZTogXCJhbnN3ZXIgMVwiIH0pKTtcbiAqXG4gKiAvLyBSZXN1bWUgdGhlIGdyYXBoIGFmdGVyIHNlY29uZCBpbnRlcnJ1cHRcbiAqIGF3YWl0IGdyYXBoLnN0cmVhbShuZXcgQ29tbWFuZCh7IHJlc3VtZTogXCJhbnN3ZXIgMlwiIH0pKTtcbiAqIC8vIEZpbmFsIHJlc3VsdDogeyBteUtleTogXCJhbnN3ZXIgMSBhbnN3ZXIgMlwiIH1cbiAqIGBgYFxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBjYWxsZWQgb3V0c2lkZSB0aGUgY29udGV4dCBvZiBhIGdyYXBoXG4gKiBAdGhyb3dzIHtHcmFwaEludGVycnVwdH0gV2hlbiBubyByZXN1bWUgdmFsdWUgaXMgYXZhaWxhYmxlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJydXB0KHZhbHVlKSB7XG4gICAgY29uc3QgY29uZmlnID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRSdW5uYWJsZUNvbmZpZygpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBpbnRlcnJ1cHQoKSBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIGEgZ3JhcGguXCIpO1xuICAgIH1cbiAgICBjb25zdCBjb25mID0gY29uZmlnLmNvbmZpZ3VyYWJsZTtcbiAgICBpZiAoIWNvbmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29uZmlndXJhYmxlIGZvdW5kIGluIGNvbmZpZ1wiKTtcbiAgICB9XG4gICAgLy8gVHJhY2sgaW50ZXJydXB0IGluZGV4XG4gICAgY29uc3Qgc2NyYXRjaHBhZCA9IGNvbmZbQ09ORklHX0tFWV9TQ1JBVENIUEFEXTtcbiAgICBzY3JhdGNocGFkLmludGVycnVwdENvdW50ZXIgKz0gMTtcbiAgICBjb25zdCBpZHggPSBzY3JhdGNocGFkLmludGVycnVwdENvdW50ZXI7XG4gICAgLy8gRmluZCBwcmV2aW91cyByZXN1bWUgdmFsdWVzXG4gICAgaWYgKHNjcmF0Y2hwYWQucmVzdW1lLmxlbmd0aCA+IDAgJiYgaWR4IDwgc2NyYXRjaHBhZC5yZXN1bWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzY3JhdGNocGFkLnJlc3VtZVtpZHhdO1xuICAgIH1cbiAgICAvLyBGaW5kIGN1cnJlbnQgcmVzdW1lIHZhbHVlXG4gICAgaWYgKHNjcmF0Y2hwYWQubnVsbFJlc3VtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzY3JhdGNocGFkLnJlc3VtZS5sZW5ndGggIT09IGlkeCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXN1bWUgbGVuZ3RoIG1pc21hdGNoOiAke3NjcmF0Y2hwYWQucmVzdW1lLmxlbmd0aH0gIT09ICR7aWR4fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYgPSBzY3JhdGNocGFkLmNvbnN1bWVOdWxsUmVzdW1lKCk7XG4gICAgICAgIHNjcmF0Y2hwYWQucmVzdW1lLnB1c2godik7XG4gICAgICAgIGNvbnN0IHNlbmQgPSBjb25mW0NPTkZJR19LRVlfU0VORF07XG4gICAgICAgIGlmIChzZW5kKSB7XG4gICAgICAgICAgICBzZW5kKFtbUkVTVU1FLCBzY3JhdGNocGFkLnJlc3VtZV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgLy8gTm8gcmVzdW1lIHZhbHVlIGZvdW5kXG4gICAgdGhyb3cgbmV3IEdyYXBoSW50ZXJydXB0KFtcbiAgICAgICAge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB3aGVuOiBcImR1cmluZ1wiLFxuICAgICAgICAgICAgcmVzdW1hYmxlOiB0cnVlLFxuICAgICAgICAgICAgbnM6IGNvbmZbQ09ORklHX0tFWV9DSEVDS1BPSU5UX05TXT8uc3BsaXQoQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SKSxcbiAgICAgICAgfSxcbiAgICBdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVycnVwdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/interrupt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/managed/base.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/managed/base.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelKeyPlaceholder: () => (/* binding */ ChannelKeyPlaceholder),\n/* harmony export */   ManagedValue: () => (/* binding */ ManagedValue),\n/* harmony export */   ManagedValueMapping: () => (/* binding */ ManagedValueMapping),\n/* harmony export */   NoopManagedValue: () => (/* binding */ NoopManagedValue),\n/* harmony export */   WritableManagedValue: () => (/* binding */ WritableManagedValue),\n/* harmony export */   isConfiguredManagedValue: () => (/* binding */ isConfiguredManagedValue),\n/* harmony export */   isManagedValue: () => (/* binding */ isManagedValue)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass ManagedValue {\n    constructor(config, _params) {\n        Object.defineProperty(this, \"runtime\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_promises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"lg_is_managed_value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.config = config;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static async initialize(_config, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _args) {\n        throw new Error(\"Not implemented\");\n    }\n    async promises() {\n        return Promise.all(this._promises);\n    }\n    addPromise(promise) {\n        this._promises.push(promise);\n    }\n}\nclass WritableManagedValue extends ManagedValue {\n}\nconst ChannelKeyPlaceholder = \"__channel_key_placeholder__\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass ManagedValueMapping extends Map {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(entries) {\n        super(entries ? Array.from(entries) : undefined);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    replaceRuntimeValues(step, values) {\n        if (this.size === 0 || !values) {\n            return;\n        }\n        if (Array.from(this.values()).every((mv) => !mv.runtime)) {\n            return;\n        }\n        if (typeof values === \"object\" && !Array.isArray(values)) {\n            for (const [key, value] of Object.entries(values)) {\n                for (const [chan, mv] of this.entries()) {\n                    if (mv.runtime && mv.call(step) === value) {\n                        // eslint-disable-next-line no-param-reassign\n                        values[key] = { [_constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER]: chan };\n                    }\n                }\n            }\n        }\n        else if (typeof values === \"object\" && \"constructor\" in values) {\n            for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(values))) {\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const value = values[key];\n                    for (const [chan, mv] of this.entries()) {\n                        if (mv.runtime && mv.call(step) === value) {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-param-reassign\n                            values[key] = { [_constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER]: chan };\n                        }\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (error) {\n                    // Ignore if TypeError\n                    if (error.name !== TypeError.name) {\n                        throw error;\n                    }\n                }\n            }\n        }\n    }\n    replaceRuntimePlaceholders(step, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    values) {\n        if (this.size === 0 || !values) {\n            return;\n        }\n        if (Array.from(this.values()).every((mv) => !mv.runtime)) {\n            return;\n        }\n        if (typeof values === \"object\" && !Array.isArray(values)) {\n            for (const [key, value] of Object.entries(values)) {\n                if (typeof value === \"object\" &&\n                    value !== null &&\n                    _constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER in value) {\n                    const placeholder = value[_constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER];\n                    if (typeof placeholder === \"string\") {\n                        // eslint-disable-next-line no-param-reassign\n                        values[key] = this.get(placeholder)?.call(step);\n                    }\n                }\n            }\n        }\n        else if (typeof values === \"object\" && \"constructor\" in values) {\n            for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(values))) {\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const value = values[key];\n                    if (typeof value === \"object\" &&\n                        value !== null &&\n                        _constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER in value) {\n                        const managedValue = this.get(value[_constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER]);\n                        if (managedValue) {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-param-reassign\n                            values[key] = managedValue.call(step);\n                        }\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (error) {\n                    // Ignore if TypeError\n                    if (error.name !== TypeError.name) {\n                        throw error;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction isManagedValue(value) {\n    if (typeof value === \"object\" && value && \"lg_is_managed_value\" in value) {\n        return true;\n    }\n    return false;\n}\nfunction isConfiguredManagedValue(value) {\n    if (typeof value === \"object\" &&\n        value &&\n        \"cls\" in value &&\n        \"params\" in value) {\n        return true;\n    }\n    return false;\n}\n/**\n * No-op class used when getting state values, as managed values should never be returned\n * in get state calls.\n */\nclass NoopManagedValue extends ManagedValue {\n    call() { }\n    static async initialize(config, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _args) {\n        return Promise.resolve(new NoopManagedValue(config));\n    }\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9tYW5hZ2VkL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBc0Q7QUFDdEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxDQUFDLDhEQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsQ0FBQyw4REFBbUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4REFBbUI7QUFDdkMsOENBQThDLDhEQUFtQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFtQjtBQUMzQyw0REFBNEQsOERBQW1CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXGRpc3RcXG1hbmFnZWRcXGJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUlVOVElNRV9QTEFDRUhPTERFUiB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgY2xhc3MgTWFuYWdlZFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIF9wYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVudGltZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcHJvbWlzZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZ19pc19tYW5hZ2VkX3ZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgYXN5bmMgaW5pdGlhbGl6ZShfY29uZmlnLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgYXN5bmMgcHJvbWlzZXMoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLl9wcm9taXNlcyk7XG4gICAgfVxuICAgIGFkZFByb21pc2UocHJvbWlzZSkge1xuICAgICAgICB0aGlzLl9wcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXcml0YWJsZU1hbmFnZWRWYWx1ZSBleHRlbmRzIE1hbmFnZWRWYWx1ZSB7XG59XG5leHBvcnQgY29uc3QgQ2hhbm5lbEtleVBsYWNlaG9sZGVyID0gXCJfX2NoYW5uZWxfa2V5X3BsYWNlaG9sZGVyX19cIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgY2xhc3MgTWFuYWdlZFZhbHVlTWFwcGluZyBleHRlbmRzIE1hcCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzKSB7XG4gICAgICAgIHN1cGVyKGVudHJpZXMgPyBBcnJheS5mcm9tKGVudHJpZXMpIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXBsYWNlUnVudGltZVZhbHVlcyhzdGVwLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCB8fCAhdmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmZyb20odGhpcy52YWx1ZXMoKSkuZXZlcnkoKG12KSA9PiAhbXYucnVudGltZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbY2hhbiwgbXZdIG9mIHRoaXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdi5ydW50aW1lICYmIG12LmNhbGwoc3RlcCkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1trZXldID0geyBbUlVOVElNRV9QTEFDRUhPTERFUl06IGNoYW4gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVzID09PSBcIm9iamVjdFwiICYmIFwiY29uc3RydWN0b3JcIiBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZXMpKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2NoYW4sIG12XSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG12LnJ1bnRpbWUgJiYgbXYuY2FsbChzdGVwKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHsgW1JVTlRJTUVfUExBQ0VIT0xERVJdOiBjaGFuIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBpZiBUeXBlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgIT09IFR5cGVFcnJvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlUnVudGltZVBsYWNlaG9sZGVycyhzdGVwLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5zaXplID09PSAwIHx8ICF2YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKS5ldmVyeSgobXYpID0+ICFtdi5ydW50aW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIFJVTlRJTUVfUExBQ0VIT0xERVIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB2YWx1ZVtSVU5USU1FX1BMQUNFSE9MREVSXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwbGFjZWhvbGRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHRoaXMuZ2V0KHBsYWNlaG9sZGVyKT8uY2FsbChzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVzID09PSBcIm9iamVjdFwiICYmIFwiY29uc3RydWN0b3JcIiBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZXMpKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBSVU5USU1FX1BMQUNFSE9MREVSIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYW5hZ2VkVmFsdWUgPSB0aGlzLmdldCh2YWx1ZVtSVU5USU1FX1BMQUNFSE9MREVSXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFuYWdlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSBtYW5hZ2VkVmFsdWUuY2FsbChzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGlmIFR5cGVFcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSAhPT0gVHlwZUVycm9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTWFuYWdlZFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAmJiBcImxnX2lzX21hbmFnZWRfdmFsdWVcIiBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uZmlndXJlZE1hbmFnZWRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgXCJjbHNcIiBpbiB2YWx1ZSAmJlxuICAgICAgICBcInBhcmFtc1wiIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIE5vLW9wIGNsYXNzIHVzZWQgd2hlbiBnZXR0aW5nIHN0YXRlIHZhbHVlcywgYXMgbWFuYWdlZCB2YWx1ZXMgc2hvdWxkIG5ldmVyIGJlIHJldHVybmVkXG4gKiBpbiBnZXQgc3RhdGUgY2FsbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb29wTWFuYWdlZFZhbHVlIGV4dGVuZHMgTWFuYWdlZFZhbHVlIHtcbiAgICBjYWxsKCkgeyB9XG4gICAgc3RhdGljIGFzeW5jIGluaXRpYWxpemUoY29uZmlnLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9hcmdzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IE5vb3BNYW5hZ2VkVmFsdWUoY29uZmlnKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/managed/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/managed/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/managed/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelKeyPlaceholder: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.ChannelKeyPlaceholder),\n/* harmony export */   IsLastStepManager: () => (/* reexport safe */ _is_last_step_js__WEBPACK_IMPORTED_MODULE_1__.IsLastStepManager),\n/* harmony export */   ManagedValue: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.ManagedValue),\n/* harmony export */   ManagedValueMapping: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.ManagedValueMapping),\n/* harmony export */   NoopManagedValue: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.NoopManagedValue),\n/* harmony export */   SharedValue: () => (/* reexport safe */ _shared_value_js__WEBPACK_IMPORTED_MODULE_2__.SharedValue),\n/* harmony export */   WritableManagedValue: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.WritableManagedValue),\n/* harmony export */   isConfiguredManagedValue: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.isConfiguredManagedValue),\n/* harmony export */   isManagedValue: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.isManagedValue)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/managed/base.js\");\n/* harmony import */ var _is_last_step_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is_last_step.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/managed/is_last_step.js\");\n/* harmony import */ var _shared_value_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared_value.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/managed/shared_value.js\");\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9tYW5hZ2VkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUNRO0FBQ0E7QUFDbEMiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxtYW5hZ2VkXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pc19sYXN0X3N0ZXAuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NoYXJlZF92YWx1ZS5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/managed/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/managed/is_last_step.js":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/managed/is_last_step.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IsLastStepManager: () => (/* binding */ IsLastStepManager)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/managed/base.js\");\n\n\nclass IsLastStepManager extends _base_js__WEBPACK_IMPORTED_MODULE_1__.ManagedValue {\n    call(step) {\n        return step === (this.config.recursionLimit ?? _constants_js__WEBPACK_IMPORTED_MODULE_0__.RECURSION_LIMIT_DEFAULT) - 1;\n    }\n}\n//# sourceMappingURL=is_last_step.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9tYW5hZ2VkL2lzX2xhc3Rfc3RlcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEQ7QUFDakI7QUFDbEMsZ0NBQWdDLGtEQUFZO0FBQ25EO0FBQ0EsdURBQXVELGtFQUF1QjtBQUM5RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxtYW5hZ2VkXFxpc19sYXN0X3N0ZXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUkVDVVJTSU9OX0xJTUlUX0RFRkFVTFQgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBNYW5hZ2VkVmFsdWUgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgY2xhc3MgSXNMYXN0U3RlcE1hbmFnZXIgZXh0ZW5kcyBNYW5hZ2VkVmFsdWUge1xuICAgIGNhbGwoc3RlcCkge1xuICAgICAgICByZXR1cm4gc3RlcCA9PT0gKHRoaXMuY29uZmlnLnJlY3Vyc2lvbkxpbWl0ID8/IFJFQ1VSU0lPTl9MSU1JVF9ERUZBVUxUKSAtIDE7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNfbGFzdF9zdGVwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/managed/is_last_step.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/managed/shared_value.js":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/managed/shared_value.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SharedValue: () => (/* binding */ SharedValue)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/managed/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\nclass SharedValue extends _base_js__WEBPACK_IMPORTED_MODULE_0__.WritableManagedValue {\n    constructor(config, params) {\n        super(config, params);\n        Object.defineProperty(this, \"scope\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ns\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        this.scope = params.scope;\n        this.store = config.store || null;\n        if (!this.store) {\n            this.ns = null;\n        }\n        else if (config.configurable?.[this.scope]) {\n            const scopeValue = config.configurable[this.scope];\n            const scopedValueString = typeof scopeValue === \"string\"\n                ? scopeValue\n                : JSON.stringify(scopeValue);\n            this.ns = [\"scoped\", this.scope, params.key, scopedValueString];\n        }\n        else {\n            throw new Error(`Required scope \"${this.scope}\" for shared state key was not passed in \"config.configurable\".`);\n        }\n    }\n    static async initialize(config, args) {\n        const instance = new this(config, args);\n        await instance.loadStore();\n        return instance;\n    }\n    static on(scope) {\n        return {\n            cls: SharedValue,\n            params: {\n                scope,\n                key: _base_js__WEBPACK_IMPORTED_MODULE_0__.ChannelKeyPlaceholder,\n            },\n        };\n    }\n    call(_step) {\n        return { ...this.value };\n    }\n    processUpdate(values) {\n        const writes = [];\n        for (const vv of values) {\n            for (const [k, v] of Object.entries(vv)) {\n                if (v === null) {\n                    if (k in this.value) {\n                        delete this.value[k];\n                        if (this.ns) {\n                            writes.push({ namespace: this.ns, key: k, value: null });\n                        }\n                    }\n                }\n                else if (typeof v !== \"object\" || v === null) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidUpdateError(\"Received a non-object value\");\n                }\n                else {\n                    this.value[k] = v;\n                    if (this.ns) {\n                        writes.push({ namespace: this.ns, key: k, value: v });\n                    }\n                }\n            }\n        }\n        return writes;\n    }\n    async update(values) {\n        if (!this.store) {\n            this.processUpdate(values);\n        }\n        else {\n            await this.store.batch(this.processUpdate(values));\n        }\n    }\n    async loadStore() {\n        if (this.store && this.ns) {\n            const saved = await this.store.search(this.ns);\n            this.value = saved.reduce((acc, item) => {\n                acc[item.key] = item.value;\n                return acc;\n            }, {});\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=shared_value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9tYW5hZ2VkL3NoYXJlZF92YWx1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUN5RTtBQUN2QjtBQUMzQywwQkFBMEIsMERBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFxQjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx5Q0FBeUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNDQUFzQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxtYW5hZ2VkXFxzaGFyZWRfdmFsdWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuaW1wb3J0IHsgQ2hhbm5lbEtleVBsYWNlaG9sZGVyLCBXcml0YWJsZU1hbmFnZWRWYWx1ZSwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBJbnZhbGlkVXBkYXRlRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5leHBvcnQgY2xhc3MgU2hhcmVkVmFsdWUgZXh0ZW5kcyBXcml0YWJsZU1hbmFnZWRWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBwYXJhbXMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY29wZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBwYXJhbXMuc2NvcGU7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBjb25maWcuc3RvcmUgfHwgbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLnN0b3JlKSB7XG4gICAgICAgICAgICB0aGlzLm5zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcuY29uZmlndXJhYmxlPy5bdGhpcy5zY29wZV0pIHtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlVmFsdWUgPSBjb25maWcuY29uZmlndXJhYmxlW3RoaXMuc2NvcGVdO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVkVmFsdWVTdHJpbmcgPSB0eXBlb2Ygc2NvcGVWYWx1ZSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gc2NvcGVWYWx1ZVxuICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoc2NvcGVWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm5zID0gW1wic2NvcGVkXCIsIHRoaXMuc2NvcGUsIHBhcmFtcy5rZXksIHNjb3BlZFZhbHVlU3RyaW5nXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWlyZWQgc2NvcGUgXCIke3RoaXMuc2NvcGV9XCIgZm9yIHNoYXJlZCBzdGF0ZSBrZXkgd2FzIG5vdCBwYXNzZWQgaW4gXCJjb25maWcuY29uZmlndXJhYmxlXCIuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGluaXRpYWxpemUoY29uZmlnLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IHRoaXMoY29uZmlnLCBhcmdzKTtcbiAgICAgICAgYXdhaXQgaW5zdGFuY2UubG9hZFN0b3JlKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgc3RhdGljIG9uKHNjb3BlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbHM6IFNoYXJlZFZhbHVlLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICAgICAga2V5OiBDaGFubmVsS2V5UGxhY2Vob2xkZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYWxsKF9zdGVwKSB7XG4gICAgICAgIHJldHVybiB7IC4uLnRoaXMudmFsdWUgfTtcbiAgICB9XG4gICAgcHJvY2Vzc1VwZGF0ZSh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3Qgd3JpdGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdnYgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2dikpIHtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoayBpbiB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVzLnB1c2goeyBuYW1lc3BhY2U6IHRoaXMubnMsIGtleTogaywgdmFsdWU6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgIT09IFwib2JqZWN0XCIgfHwgdiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKFwiUmVjZWl2ZWQgYSBub24tb2JqZWN0IHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXMucHVzaCh7IG5hbWVzcGFjZTogdGhpcy5ucywga2V5OiBrLCB2YWx1ZTogdiB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVzO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGUodmFsdWVzKSB7XG4gICAgICAgIGlmICghdGhpcy5zdG9yZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzVXBkYXRlKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3JlLmJhdGNoKHRoaXMucHJvY2Vzc1VwZGF0ZSh2YWx1ZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsb2FkU3RvcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3JlICYmIHRoaXMubnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhdmVkID0gYXdhaXQgdGhpcy5zdG9yZS5zZWFyY2godGhpcy5ucyk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gc2F2ZWQucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2NbaXRlbS5rZXldID0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZWRfdmFsdWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/managed/shared_value.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/algo.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/algo.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _applyWrites: () => (/* binding */ _applyWrites),\n/* harmony export */   _localRead: () => (/* binding */ _localRead),\n/* harmony export */   _localWrite: () => (/* binding */ _localWrite),\n/* harmony export */   _prepareNextTasks: () => (/* binding */ _prepareNextTasks),\n/* harmony export */   _prepareSingleTask: () => (/* binding */ _prepareSingleTask),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   shouldInterrupt: () => (/* binding */ shouldInterrupt)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/langgraph-checkpoint */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/index.js\");\n/* harmony import */ var _channels_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../channels/base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/base.js\");\n/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./io.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/io.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/types.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/index.js\");\n/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./call.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/call.js\");\n/* eslint-disable no-param-reassign */\n\n\n\n\n\n\n\n\n\nconst increment = (current) => {\n    return current !== undefined ? current + 1 : 1;\n};\nfunction shouldInterrupt(checkpoint, interruptNodes, tasks) {\n    const versionValues = Object.values(checkpoint.channel_versions);\n    const versionType = versionValues.length > 0 ? typeof versionValues[0] : undefined;\n    let nullVersion;\n    if (versionType === \"number\") {\n        nullVersion = 0;\n    }\n    else if (versionType === \"string\") {\n        nullVersion = \"\";\n    }\n    const seen = checkpoint.versions_seen[_constants_js__WEBPACK_IMPORTED_MODULE_4__.INTERRUPT] ?? {};\n    const anyChannelUpdated = Object.entries(checkpoint.channel_versions).some(([chan, version]) => {\n        return version > (seen[chan] ?? nullVersion);\n    });\n    const anyTriggeredNodeInInterruptNodes = tasks.some((task) => interruptNodes === \"*\"\n        ? !task.config?.tags?.includes(_constants_js__WEBPACK_IMPORTED_MODULE_4__.TAG_HIDDEN)\n        : interruptNodes.includes(task.name));\n    return anyChannelUpdated && anyTriggeredNodeInInterruptNodes;\n}\nfunction _localRead(step, checkpoint, channels, managed, task, select, fresh = false) {\n    let managedKeys = [];\n    let updated = new Set();\n    if (!Array.isArray(select)) {\n        for (const [c] of task.writes) {\n            if (c === select) {\n                updated = new Set([c]);\n                break;\n            }\n        }\n        updated = updated || new Set();\n    }\n    else {\n        managedKeys = select.filter((k) => managed.get(k));\n        select = select.filter((k) => !managed.get(k));\n        updated = new Set(select.filter((c) => task.writes.some(([key, _]) => key === c)));\n    }\n    let values;\n    if (fresh && updated.size > 0) {\n        const localChannels = Object.fromEntries(Object.entries(channels).filter(([k, _]) => updated.has(k)));\n        const newCheckpoint = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, localChannels, -1);\n        const newChannels = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.emptyChannels)(localChannels, newCheckpoint);\n        _applyWrites((0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.copyCheckpoint)(newCheckpoint), newChannels, [task]);\n        values = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannels)({ ...channels, ...newChannels }, select);\n    }\n    else {\n        values = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannels)(channels, select);\n    }\n    if (managedKeys.length > 0) {\n        for (const k of managedKeys) {\n            const managedValue = managed.get(k);\n            if (managedValue) {\n                const resultOfManagedCall = managedValue.call(step);\n                values[k] = resultOfManagedCall;\n            }\n        }\n    }\n    return values;\n}\nfunction _localWrite(step, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ncommit, processes, managed, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nwrites) {\n    for (const [chan, value] of writes) {\n        if ([_constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH, _constants_js__WEBPACK_IMPORTED_MODULE_4__.TASKS].includes(chan) && value != null) {\n            if (!(0,_constants_js__WEBPACK_IMPORTED_MODULE_4__._isSend)(value)) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidUpdateError(`Invalid packet type, expected SendProtocol, got ${JSON.stringify(value)}`);\n            }\n            if (!(value.node in processes)) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidUpdateError(`Invalid node name \"${value.node}\" in Send packet`);\n            }\n            // replace any runtime values with placeholders\n            managed.replaceRuntimeValues(step, value.args);\n        }\n    }\n    commit(writes);\n}\nconst IGNORE = new Set([\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.NO_WRITES,\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH,\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.RESUME,\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.INTERRUPT,\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.RETURN,\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.ERROR,\n]);\nfunction _applyWrites(checkpoint, channels, tasks, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ngetNextVersion) {\n    // Sort tasks by first 3 path elements for deterministic order\n    // Later path parts (like task IDs) are ignored for sorting\n    tasks.sort((a, b) => {\n        const aPath = a.path?.slice(0, 3) || [];\n        const bPath = b.path?.slice(0, 3) || [];\n        // Compare each path element\n        for (let i = 0; i < Math.min(aPath.length, bPath.length); i += 1) {\n            if (aPath[i] < bPath[i])\n                return -1;\n            if (aPath[i] > bPath[i])\n                return 1;\n        }\n        // If one path is shorter, it comes first\n        return aPath.length - bPath.length;\n    });\n    // if no task has triggers this is applying writes from the null task only\n    // so we don't do anything other than update the channels written to\n    const bumpStep = tasks.some((task) => task.triggers.length > 0);\n    // Filter out non instances of BaseChannel\n    const onlyChannels = Object.fromEntries(Object.entries(channels).filter(([_, value]) => (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.isBaseChannel)(value)));\n    // Update seen versions\n    for (const task of tasks) {\n        if (checkpoint.versions_seen[task.name] === undefined) {\n            checkpoint.versions_seen[task.name] = {};\n        }\n        for (const chan of task.triggers) {\n            if (chan in checkpoint.channel_versions) {\n                checkpoint.versions_seen[task.name][chan] =\n                    checkpoint.channel_versions[chan];\n            }\n        }\n    }\n    // Find the highest version of all channels\n    let maxVersion;\n    if (Object.keys(checkpoint.channel_versions).length > 0) {\n        maxVersion = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.maxChannelVersion)(...Object.values(checkpoint.channel_versions));\n    }\n    // Consume all channels that were read\n    const channelsToConsume = new Set(tasks\n        .flatMap((task) => task.triggers)\n        .filter((chan) => !_constants_js__WEBPACK_IMPORTED_MODULE_4__.RESERVED.includes(chan)));\n    for (const chan of channelsToConsume) {\n        if (chan in onlyChannels && onlyChannels[chan].consume()) {\n            if (getNextVersion !== undefined) {\n                checkpoint.channel_versions[chan] = getNextVersion(maxVersion, onlyChannels[chan]);\n            }\n        }\n    }\n    // Clear pending sends\n    if (checkpoint.pending_sends?.length && bumpStep) {\n        checkpoint.pending_sends = [];\n    }\n    // Group writes by channel\n    const pendingWriteValuesByChannel = {};\n    const pendingWritesByManaged = {};\n    for (const task of tasks) {\n        for (const [chan, val] of task.writes) {\n            if (IGNORE.has(chan)) {\n                // do nothing\n            }\n            else if (chan === _constants_js__WEBPACK_IMPORTED_MODULE_4__.TASKS) {\n                // TODO: remove branch in 1.0\n                checkpoint.pending_sends.push({\n                    node: val.node,\n                    args: val.args,\n                });\n            }\n            else if (chan in onlyChannels) {\n                if (chan in pendingWriteValuesByChannel) {\n                    pendingWriteValuesByChannel[chan].push(val);\n                }\n                else {\n                    pendingWriteValuesByChannel[chan] = [val];\n                }\n            }\n            else {\n                if (chan in pendingWritesByManaged) {\n                    pendingWritesByManaged[chan].push(val);\n                }\n                else {\n                    pendingWritesByManaged[chan] = [val];\n                }\n            }\n        }\n    }\n    // find the highest version of all channels\n    maxVersion = undefined;\n    if (Object.keys(checkpoint.channel_versions).length > 0) {\n        maxVersion = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.maxChannelVersion)(...Object.values(checkpoint.channel_versions));\n    }\n    const updatedChannels = new Set();\n    // Apply writes to channels\n    for (const [chan, vals] of Object.entries(pendingWriteValuesByChannel)) {\n        if (chan in onlyChannels) {\n            let updated;\n            try {\n                updated = onlyChannels[chan].update(vals);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (e) {\n                if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidUpdateError.unminifiable_name) {\n                    const wrappedError = new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidUpdateError(`Invalid update for channel \"${chan}\" with values ${JSON.stringify(vals)}: ${e.message}`);\n                    wrappedError.lc_error_code = e.lc_error_code;\n                    throw wrappedError;\n                }\n                else {\n                    throw e;\n                }\n            }\n            if (updated && getNextVersion !== undefined) {\n                checkpoint.channel_versions[chan] = getNextVersion(maxVersion, onlyChannels[chan]);\n            }\n            updatedChannels.add(chan);\n        }\n    }\n    // Channels that weren't updated in this step are notified of a new step\n    if (bumpStep) {\n        for (const chan of Object.keys(onlyChannels)) {\n            if (!updatedChannels.has(chan)) {\n                const updated = onlyChannels[chan].update([]);\n                if (updated && getNextVersion !== undefined) {\n                    checkpoint.channel_versions[chan] = getNextVersion(maxVersion, onlyChannels[chan]);\n                }\n            }\n        }\n    }\n    // Return managed values writes to be applied externally\n    return pendingWritesByManaged;\n}\n/**\n * Prepare the set of tasks that will make up the next Pregel step.\n * This is the union of all PUSH tasks (Sends) and PULL tasks (nodes triggered\n * by edges).\n */\nfunction _prepareNextTasks(checkpoint, pendingWrites, processes, channels, managed, config, forExecution, extra) {\n    const tasks = {};\n    // Consume pending packets\n    for (let i = 0; i < checkpoint.pending_sends.length; i += 1) {\n        const task = _prepareSingleTask([_constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH, i], checkpoint, pendingWrites, processes, channels, managed, config, forExecution, extra);\n        if (task !== undefined) {\n            tasks[task.id] = task;\n        }\n    }\n    // Check if any processes should be run in next step\n    // If so, prepare the values to be passed to them\n    for (const name of Object.keys(processes)) {\n        const task = _prepareSingleTask([_constants_js__WEBPACK_IMPORTED_MODULE_4__.PULL, name], checkpoint, pendingWrites, processes, channels, managed, config, forExecution, extra);\n        if (task !== undefined) {\n            tasks[task.id] = task;\n        }\n    }\n    return tasks;\n}\n/**\n * Prepares a single task for the next Pregel step, given a task path, which\n * uniquely identifies a PUSH or PULL task within the graph.\n */\nfunction _prepareSingleTask(taskPath, checkpoint, pendingWrites, processes, channels, managed, config, forExecution, extra) {\n    const { step, checkpointer, manager } = extra;\n    const configurable = config.configurable ?? {};\n    const parentNamespace = configurable.checkpoint_ns ?? \"\";\n    if (taskPath[0] === _constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH && (0,_types_js__WEBPACK_IMPORTED_MODULE_5__.isCall)(taskPath[taskPath.length - 1])) {\n        const call = taskPath[taskPath.length - 1];\n        const proc = (0,_call_js__WEBPACK_IMPORTED_MODULE_8__.getRunnableForFunc)(call.name, call.func);\n        const triggers = [_constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH];\n        const checkpointNamespace = parentNamespace === \"\"\n            ? call.name\n            : `${parentNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_SEPARATOR}${call.name}`;\n        const id = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(JSON.stringify([\n            checkpointNamespace,\n            step.toString(),\n            call.name,\n            _constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH,\n            taskPath[1],\n            taskPath[2],\n        ]), checkpoint.id);\n        const taskCheckpointNamespace = `${checkpointNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_END}${id}`;\n        const metadata = {\n            langgraph_step: step,\n            langgraph_node: call.name,\n            langgraph_triggers: triggers,\n            langgraph_path: taskPath.slice(0, 3),\n            langgraph_checkpoint_ns: taskCheckpointNamespace,\n        };\n        if (forExecution) {\n            const writes = [];\n            const task = {\n                name: call.name,\n                input: call.input,\n                proc,\n                writes,\n                config: (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.patchConfig)((0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(config, {\n                    metadata,\n                    store: extra.store ?? config.store,\n                }), {\n                    runName: call.name,\n                    callbacks: manager?.getChild(`graph:step:${step}`),\n                    configurable: {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_TASK_ID]: id,\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SEND]: (writes_) => _localWrite(step, (items) => writes.push(...items), processes, managed, writes_),\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(step, checkpoint, channels, managed, {\n                            name: call.name,\n                            writes: writes,\n                            triggers,\n                            path: taskPath.slice(0, 3),\n                        }, select_, fresh_),\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER],\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP]: {\n                            ...configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP],\n                            [parentNamespace]: checkpoint.id,\n                        },\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                            pendingWrites: pendingWrites ?? [],\n                            taskId: id,\n                            currentTaskInput: call.input,\n                        }),\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[_constants_js__WEBPACK_IMPORTED_MODULE_4__.PREVIOUS],\n                        checkpoint_id: undefined,\n                        checkpoint_ns: taskCheckpointNamespace,\n                    },\n                }),\n                triggers,\n                retry_policy: call.retry,\n                id,\n                path: taskPath.slice(0, 3),\n                writers: [],\n            };\n            return task;\n        }\n        else {\n            return {\n                id,\n                name: call.name,\n                interrupts: [],\n                path: taskPath.slice(0, 3),\n            };\n        }\n    }\n    else if (taskPath[0] === _constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH) {\n        const index = typeof taskPath[1] === \"number\"\n            ? taskPath[1]\n            : parseInt(taskPath[1], 10);\n        if (index >= checkpoint.pending_sends.length) {\n            return undefined;\n        }\n        const packet = (0,_constants_js__WEBPACK_IMPORTED_MODULE_4__._isSendInterface)(checkpoint.pending_sends[index]) &&\n            !(0,_constants_js__WEBPACK_IMPORTED_MODULE_4__._isSend)(checkpoint.pending_sends[index])\n            ? new _constants_js__WEBPACK_IMPORTED_MODULE_4__.Send(checkpoint.pending_sends[index].node, checkpoint.pending_sends[index].args)\n            : checkpoint.pending_sends[index];\n        if (!(0,_constants_js__WEBPACK_IMPORTED_MODULE_4__._isSendInterface)(packet)) {\n            console.warn(`Ignoring invalid packet ${JSON.stringify(packet)} in pending sends.`);\n            return undefined;\n        }\n        if (!(packet.node in processes)) {\n            console.warn(`Ignoring unknown node name ${packet.node} in pending sends.`);\n            return undefined;\n        }\n        const triggers = [_constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH];\n        const checkpointNamespace = parentNamespace === \"\"\n            ? packet.node\n            : `${parentNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_SEPARATOR}${packet.node}`;\n        const taskId = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(JSON.stringify([\n            checkpointNamespace,\n            step.toString(),\n            packet.node,\n            _constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH,\n            index.toString(),\n        ]), checkpoint.id);\n        const taskCheckpointNamespace = `${checkpointNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_END}${taskId}`;\n        let metadata = {\n            langgraph_step: step,\n            langgraph_node: packet.node,\n            langgraph_triggers: triggers,\n            langgraph_path: taskPath.slice(0, 3),\n            langgraph_checkpoint_ns: taskCheckpointNamespace,\n        };\n        if (forExecution) {\n            const proc = processes[packet.node];\n            const node = proc.getNode();\n            if (node !== undefined) {\n                managed.replaceRuntimePlaceholders(step, packet.args);\n                if (proc.metadata !== undefined) {\n                    metadata = { ...metadata, ...proc.metadata };\n                }\n                const writes = [];\n                return {\n                    name: packet.node,\n                    input: packet.args,\n                    proc: node,\n                    subgraphs: proc.subgraphs,\n                    writes,\n                    config: (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.patchConfig)((0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(config, {\n                        metadata,\n                        tags: proc.tags,\n                        store: extra.store ?? config.store,\n                    }), {\n                        runName: packet.node,\n                        callbacks: manager?.getChild(`graph:step:${step}`),\n                        configurable: {\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_TASK_ID]: taskId,\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SEND]: (writes_) => _localWrite(step, (items) => writes.push(...items), processes, managed, writes_),\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(step, checkpoint, channels, managed, {\n                                name: packet.node,\n                                writes: writes,\n                                triggers,\n                                path: taskPath,\n                            }, select_, fresh_),\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER],\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP]: {\n                                ...configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP],\n                                [parentNamespace]: checkpoint.id,\n                            },\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                                pendingWrites: pendingWrites ?? [],\n                                taskId,\n                                currentTaskInput: packet.args,\n                            }),\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[_constants_js__WEBPACK_IMPORTED_MODULE_4__.PREVIOUS],\n                            checkpoint_id: undefined,\n                            checkpoint_ns: taskCheckpointNamespace,\n                        },\n                    }),\n                    triggers,\n                    retry_policy: proc.retryPolicy,\n                    id: taskId,\n                    path: taskPath,\n                    writers: proc.getWriters(),\n                };\n            }\n        }\n        else {\n            return {\n                id: taskId,\n                name: packet.node,\n                interrupts: [],\n                path: taskPath,\n            };\n        }\n    }\n    else if (taskPath[0] === _constants_js__WEBPACK_IMPORTED_MODULE_4__.PULL) {\n        const name = taskPath[1].toString();\n        const proc = processes[name];\n        if (proc === undefined) {\n            return undefined;\n        }\n        // Check if this task already has successful writes in the pending writes\n        if (pendingWrites?.length) {\n            // Find the task ID for this node/path\n            const checkpointNamespace = parentNamespace === \"\"\n                ? name\n                : `${parentNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n            const taskId = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(JSON.stringify([\n                checkpointNamespace,\n                step.toString(),\n                name,\n                _constants_js__WEBPACK_IMPORTED_MODULE_4__.PULL,\n                name,\n            ]), checkpoint.id);\n            // Check if there are successful writes (not ERROR) for this task ID\n            const hasSuccessfulWrites = pendingWrites.some((w) => w[0] === taskId && w[1] !== _constants_js__WEBPACK_IMPORTED_MODULE_4__.ERROR);\n            // If task completed successfully, don't include it in next tasks\n            if (hasSuccessfulWrites) {\n                return undefined;\n            }\n        }\n        const nullVersion = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.getNullChannelVersion)(checkpoint.channel_versions);\n        if (nullVersion === undefined) {\n            return undefined;\n        }\n        const seen = checkpoint.versions_seen[name] ?? {};\n        const triggers = proc.triggers\n            .filter((chan) => {\n            const result = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannel)(channels, chan, false, true);\n            const isEmptyChannelError = \n            // eslint-disable-next-line no-instanceof/no-instanceof\n            result instanceof Error &&\n                result.name === _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyChannelError.unminifiable_name;\n            return (!isEmptyChannelError &&\n                (checkpoint.channel_versions[chan] ?? nullVersion) >\n                    (seen[chan] ?? nullVersion));\n        })\n            .sort();\n        // If any of the channels read by this process were updated\n        if (triggers.length > 0) {\n            const val = _procInput(step, proc, managed, channels, forExecution);\n            if (val === undefined) {\n                return undefined;\n            }\n            const checkpointNamespace = parentNamespace === \"\"\n                ? name\n                : `${parentNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n            const taskId = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(JSON.stringify([\n                checkpointNamespace,\n                step.toString(),\n                name,\n                _constants_js__WEBPACK_IMPORTED_MODULE_4__.PULL,\n                triggers,\n            ]), checkpoint.id);\n            const taskCheckpointNamespace = `${checkpointNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_END}${taskId}`;\n            let metadata = {\n                langgraph_step: step,\n                langgraph_node: name,\n                langgraph_triggers: triggers,\n                langgraph_path: taskPath,\n                langgraph_checkpoint_ns: taskCheckpointNamespace,\n            };\n            if (forExecution) {\n                const node = proc.getNode();\n                if (node !== undefined) {\n                    if (proc.metadata !== undefined) {\n                        metadata = { ...metadata, ...proc.metadata };\n                    }\n                    const writes = [];\n                    return {\n                        name,\n                        input: val,\n                        proc: node,\n                        subgraphs: proc.subgraphs,\n                        writes,\n                        config: (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.patchConfig)((0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(config, {\n                            metadata,\n                            tags: proc.tags,\n                            store: extra.store ?? config.store,\n                        }), {\n                            runName: name,\n                            callbacks: manager?.getChild(`graph:step:${step}`),\n                            configurable: {\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_TASK_ID]: taskId,\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SEND]: (writes_) => _localWrite(step, (items) => {\n                                    writes.push(...items);\n                                }, processes, managed, writes_),\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(step, checkpoint, channels, managed, {\n                                    name,\n                                    writes: writes,\n                                    triggers,\n                                    path: taskPath,\n                                }, select_, fresh_),\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER],\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP]: {\n                                    ...configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP],\n                                    [parentNamespace]: checkpoint.id,\n                                },\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                                    pendingWrites: pendingWrites ?? [],\n                                    taskId,\n                                    currentTaskInput: val,\n                                }),\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[_constants_js__WEBPACK_IMPORTED_MODULE_4__.PREVIOUS],\n                                checkpoint_id: undefined,\n                                checkpoint_ns: taskCheckpointNamespace,\n                            },\n                        }),\n                        triggers,\n                        retry_policy: proc.retryPolicy,\n                        id: taskId,\n                        path: taskPath,\n                        writers: proc.getWriters(),\n                    };\n                }\n            }\n            else {\n                return { id: taskId, name, interrupts: [], path: taskPath };\n            }\n        }\n    }\n    return undefined;\n}\n/**\n *  Function injected under CONFIG_KEY_READ in task config, to read current state.\n *  Used by conditional edges to read a copy of the state with reflecting the writes\n *  from that node only.\n *\n * @internal\n */\nfunction _procInput(step, proc, managed, channels, forExecution) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let val;\n    if (typeof proc.channels === \"object\" && !Array.isArray(proc.channels)) {\n        val = {};\n        for (const [k, chan] of Object.entries(proc.channels)) {\n            if (proc.triggers.includes(chan)) {\n                try {\n                    val[k] = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannel)(channels, chan, false);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (e) {\n                    if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyChannelError.unminifiable_name) {\n                        return undefined;\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            else if (chan in channels) {\n                try {\n                    val[k] = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannel)(channels, chan, false);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (e) {\n                    if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyChannelError.unminifiable_name) {\n                        continue;\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            else {\n                val[k] = managed.get(k)?.call(step);\n            }\n        }\n    }\n    else if (Array.isArray(proc.channels)) {\n        let successfulRead = false;\n        for (const chan of proc.channels) {\n            try {\n                val = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannel)(channels, chan, false);\n                successfulRead = true;\n                break;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (e) {\n                if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyChannelError.unminifiable_name) {\n                    continue;\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        if (!successfulRead) {\n            return undefined;\n        }\n    }\n    else {\n        throw new Error(`Invalid channels type, expected list or dict, got ${proc.channels}`);\n    }\n    // If the process has a mapper, apply it to the value\n    if (forExecution && proc.mapper !== undefined) {\n        val = proc.mapper(val);\n    }\n    return val;\n}\nfunction _scratchpad({ pendingWrites, taskId, currentTaskInput, }) {\n    const nullResume = pendingWrites.find(([writeTaskId, chan]) => writeTaskId === _constants_js__WEBPACK_IMPORTED_MODULE_4__.NULL_TASK_ID && chan === _constants_js__WEBPACK_IMPORTED_MODULE_4__.RESUME)?.[2];\n    const scratchpad = {\n        callCounter: 0,\n        interruptCounter: -1,\n        resume: pendingWrites\n            .filter(([writeTaskId, chan]) => writeTaskId === taskId && chan === _constants_js__WEBPACK_IMPORTED_MODULE_4__.RESUME)\n            .flatMap(([_writeTaskId, _chan, resume]) => resume),\n        nullResume,\n        subgraphCounter: 0,\n        currentTaskInput,\n        consumeNullResume: () => {\n            if (scratchpad.nullResume) {\n                delete scratchpad.nullResume;\n                pendingWrites.splice(pendingWrites.findIndex(([writeTaskId, chan]) => writeTaskId === _constants_js__WEBPACK_IMPORTED_MODULE_4__.NULL_TASK_ID && chan === _constants_js__WEBPACK_IMPORTED_MODULE_4__.RESUME), 1);\n                return nullResume;\n            }\n            return undefined;\n        },\n    };\n    return scratchpad;\n}\n//# sourceMappingURL=algo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvYWxnby5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDdUU7QUFDcUI7QUFDTjtBQUNsQztBQUNtVjtBQUNsVztBQUNnQztBQUNaO0FBQ1Y7QUFDeEM7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0RBQVM7QUFDbkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QyxxREFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1FQUFnQjtBQUM5Qyw0QkFBNEIsZ0VBQWE7QUFDekMscUJBQXFCLCtFQUFjO0FBQ25DLGlCQUFpQixvREFBWSxHQUFHLDZCQUE2QjtBQUM3RDtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0NBQUksRUFBRSxnREFBSztBQUN4QixpQkFBaUIsc0RBQU87QUFDeEIsMEJBQTBCLDBEQUFrQixvREFBb0Qsc0JBQXNCO0FBQ3RIO0FBQ0E7QUFDQSwwQkFBMEIsMERBQWtCLHVCQUF1QixXQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9EQUFTO0FBQ2IsSUFBSSwrQ0FBSTtBQUNSLElBQUksaURBQU07QUFDVixJQUFJLG9EQUFTO0FBQ2IsSUFBSSxpREFBTTtBQUNWLElBQUksZ0RBQUs7QUFDVDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQ0FBMEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsZ0VBQWE7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtGQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnREFBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwREFBa0I7QUFDakQsNkNBQTZDLDBEQUFrQixnQ0FBZ0MsS0FBSyxnQkFBZ0IscUJBQXFCLElBQUksVUFBVTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLHFDQUFxQztBQUN6RCx5Q0FBeUMsK0NBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0NBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQSx3QkFBd0IsK0NBQUksSUFBSSxpREFBTTtBQUN0QztBQUNBLHFCQUFxQiw0REFBa0I7QUFDdkMsMEJBQTBCLCtDQUFJO0FBQzlCO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCLEVBQUUseUVBQThCLENBQUMsRUFBRSxVQUFVO0FBQzlFLG1CQUFtQixzRUFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvQkFBb0IsRUFBRSxtRUFBd0IsQ0FBQyxFQUFFLEdBQUc7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzRUFBVyxDQUFDLHVFQUFZO0FBQ2hEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwrREFBK0QsS0FBSztBQUNwRTtBQUNBLHlCQUF5Qiw2REFBa0I7QUFDM0M7QUFDQSx5QkFBeUIsMERBQWU7QUFDeEMseUJBQXlCLDBEQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QixrRUFBdUIsZ0NBQWdDLGtFQUF1QjtBQUN2Ryx5QkFBeUIsb0VBQXlCO0FBQ2xELDRDQUE0QyxvRUFBeUI7QUFDckU7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCLGdFQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCLG9FQUF5Qiw2QkFBNkIsbURBQVE7QUFDdkY7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQ0FBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0RBQWdCO0FBQ3ZDLGFBQWEsc0RBQU87QUFDcEIsa0JBQWtCLCtDQUFJO0FBQ3RCO0FBQ0EsYUFBYSwrREFBZ0I7QUFDN0Isb0RBQW9ELHdCQUF3QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTtBQUNwRTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFJO0FBQzlCO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCLEVBQUUseUVBQThCLENBQUMsRUFBRSxZQUFZO0FBQ2hGLHVCQUF1QixzRUFBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFJO0FBQ2hCO0FBQ0E7QUFDQSwyQ0FBMkMsb0JBQW9CLEVBQUUsbUVBQXdCLENBQUMsRUFBRSxPQUFPO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0VBQVcsQ0FBQyx1RUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtRUFBbUUsS0FBSztBQUN4RTtBQUNBLDZCQUE2Qiw2REFBa0I7QUFDL0M7QUFDQSw2QkFBNkIsMERBQWU7QUFDNUMsNkJBQTZCLDBEQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QixrRUFBdUIsZ0NBQWdDLGtFQUF1QjtBQUMzRyw2QkFBNkIsb0VBQXlCO0FBQ3RELGdEQUFnRCxvRUFBeUI7QUFDekU7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCLGdFQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCLG9FQUF5Qiw2QkFBNkIsbURBQVE7QUFDM0Y7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQ0FBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0IsRUFBRSx5RUFBOEIsQ0FBQyxFQUFFLEtBQUs7QUFDN0UsMkJBQTJCLHNFQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsZ0RBQUs7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzRUFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5REFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0IsRUFBRSx5RUFBOEIsQ0FBQyxFQUFFLEtBQUs7QUFDN0UsMkJBQTJCLHNFQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBSTtBQUNwQjtBQUNBO0FBQ0EsK0NBQStDLG9CQUFvQixFQUFFLG1FQUF3QixDQUFDLEVBQUUsT0FBTztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0VBQVcsQ0FBQyx1RUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx1RUFBdUUsS0FBSztBQUM1RTtBQUNBLGlDQUFpQyw2REFBa0I7QUFDbkQ7QUFDQSxpQ0FBaUMsMERBQWU7QUFDaEQ7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDLDBEQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGlDQUFpQyxrRUFBdUIsZ0NBQWdDLGtFQUF1QjtBQUMvRyxpQ0FBaUMsb0VBQXlCO0FBQzFELG9EQUFvRCxvRUFBeUI7QUFDN0U7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDLGdFQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDLG9FQUF5Qiw2QkFBNkIsbURBQVE7QUFDL0Y7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbURBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbURBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtREFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlEQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsY0FBYztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBMEM7QUFDakUsbUZBQW1GLHVEQUFZLGFBQWEsaURBQU07QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsaURBQU07QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csdURBQVksYUFBYSxpREFBTTtBQUNySTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxwcmVnZWxcXGFsZ28uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmltcG9ydCB7IG1lcmdlQ29uZmlncywgcGF0Y2hDb25maWcsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbmltcG9ydCB7IGNvcHlDaGVja3BvaW50LCB1dWlkNSwgbWF4Q2hhbm5lbFZlcnNpb24sIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoLWNoZWNrcG9pbnRcIjtcbmltcG9ydCB7IGNyZWF0ZUNoZWNrcG9pbnQsIGVtcHR5Q2hhbm5lbHMsIGlzQmFzZUNoYW5uZWwsIH0gZnJvbSBcIi4uL2NoYW5uZWxzL2Jhc2UuanNcIjtcbmltcG9ydCB7IHJlYWRDaGFubmVsLCByZWFkQ2hhbm5lbHMgfSBmcm9tIFwiLi9pby5qc1wiO1xuaW1wb3J0IHsgX2lzU2VuZCwgX2lzU2VuZEludGVyZmFjZSwgQ09ORklHX0tFWV9DSEVDS1BPSU5UX01BUCwgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SLCBDT05GSUdfS0VZX0NIRUNLUE9JTlRFUiwgQ09ORklHX0tFWV9SRUFELCBDT05GSUdfS0VZX1RBU0tfSUQsIENPTkZJR19LRVlfU0VORCwgSU5URVJSVVBULCBSRVNFUlZFRCwgU2VuZCwgVEFHX0hJRERFTiwgVEFTS1MsIENIRUNLUE9JTlRfTkFNRVNQQUNFX0VORCwgUFVTSCwgUFVMTCwgUkVTVU1FLCBOVUxMX1RBU0tfSUQsIENPTkZJR19LRVlfU0NSQVRDSFBBRCwgUkVUVVJOLCBFUlJPUiwgTk9fV1JJVEVTLCBDT05GSUdfS0VZX1BSRVZJT1VTX1NUQVRFLCBQUkVWSU9VUywgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBpc0NhbGwsIH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcbmltcG9ydCB7IEVtcHR5Q2hhbm5lbEVycm9yLCBJbnZhbGlkVXBkYXRlRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXROdWxsQ2hhbm5lbFZlcnNpb24gfSBmcm9tIFwiLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0UnVubmFibGVGb3JGdW5jIH0gZnJvbSBcIi4vY2FsbC5qc1wiO1xuZXhwb3J0IGNvbnN0IGluY3JlbWVudCA9IChjdXJyZW50KSA9PiB7XG4gICAgcmV0dXJuIGN1cnJlbnQgIT09IHVuZGVmaW5lZCA/IGN1cnJlbnQgKyAxIDogMTtcbn07XG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkSW50ZXJydXB0KGNoZWNrcG9pbnQsIGludGVycnVwdE5vZGVzLCB0YXNrcykge1xuICAgIGNvbnN0IHZlcnNpb25WYWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucyk7XG4gICAgY29uc3QgdmVyc2lvblR5cGUgPSB2ZXJzaW9uVmFsdWVzLmxlbmd0aCA+IDAgPyB0eXBlb2YgdmVyc2lvblZhbHVlc1swXSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgbnVsbFZlcnNpb247XG4gICAgaWYgKHZlcnNpb25UeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG51bGxWZXJzaW9uID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmVyc2lvblR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbnVsbFZlcnNpb24gPSBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBzZWVuID0gY2hlY2twb2ludC52ZXJzaW9uc19zZWVuW0lOVEVSUlVQVF0gPz8ge307XG4gICAgY29uc3QgYW55Q2hhbm5lbFVwZGF0ZWQgPSBPYmplY3QuZW50cmllcyhjaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnMpLnNvbWUoKFtjaGFuLCB2ZXJzaW9uXSkgPT4ge1xuICAgICAgICByZXR1cm4gdmVyc2lvbiA+IChzZWVuW2NoYW5dID8/IG51bGxWZXJzaW9uKTtcbiAgICB9KTtcbiAgICBjb25zdCBhbnlUcmlnZ2VyZWROb2RlSW5JbnRlcnJ1cHROb2RlcyA9IHRhc2tzLnNvbWUoKHRhc2spID0+IGludGVycnVwdE5vZGVzID09PSBcIipcIlxuICAgICAgICA/ICF0YXNrLmNvbmZpZz8udGFncz8uaW5jbHVkZXMoVEFHX0hJRERFTilcbiAgICAgICAgOiBpbnRlcnJ1cHROb2Rlcy5pbmNsdWRlcyh0YXNrLm5hbWUpKTtcbiAgICByZXR1cm4gYW55Q2hhbm5lbFVwZGF0ZWQgJiYgYW55VHJpZ2dlcmVkTm9kZUluSW50ZXJydXB0Tm9kZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gX2xvY2FsUmVhZChzdGVwLCBjaGVja3BvaW50LCBjaGFubmVscywgbWFuYWdlZCwgdGFzaywgc2VsZWN0LCBmcmVzaCA9IGZhbHNlKSB7XG4gICAgbGV0IG1hbmFnZWRLZXlzID0gW107XG4gICAgbGV0IHVwZGF0ZWQgPSBuZXcgU2V0KCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNlbGVjdCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbY10gb2YgdGFzay53cml0ZXMpIHtcbiAgICAgICAgICAgIGlmIChjID09PSBzZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkID0gbmV3IFNldChbY10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWQgPSB1cGRhdGVkIHx8IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hbmFnZWRLZXlzID0gc2VsZWN0LmZpbHRlcigoaykgPT4gbWFuYWdlZC5nZXQoaykpO1xuICAgICAgICBzZWxlY3QgPSBzZWxlY3QuZmlsdGVyKChrKSA9PiAhbWFuYWdlZC5nZXQoaykpO1xuICAgICAgICB1cGRhdGVkID0gbmV3IFNldChzZWxlY3QuZmlsdGVyKChjKSA9PiB0YXNrLndyaXRlcy5zb21lKChba2V5LCBfXSkgPT4ga2V5ID09PSBjKSkpO1xuICAgIH1cbiAgICBsZXQgdmFsdWVzO1xuICAgIGlmIChmcmVzaCAmJiB1cGRhdGVkLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsQ2hhbm5lbHMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2hhbm5lbHMpLmZpbHRlcigoW2ssIF9dKSA9PiB1cGRhdGVkLmhhcyhrKSkpO1xuICAgICAgICBjb25zdCBuZXdDaGVja3BvaW50ID0gY3JlYXRlQ2hlY2twb2ludChjaGVja3BvaW50LCBsb2NhbENoYW5uZWxzLCAtMSk7XG4gICAgICAgIGNvbnN0IG5ld0NoYW5uZWxzID0gZW1wdHlDaGFubmVscyhsb2NhbENoYW5uZWxzLCBuZXdDaGVja3BvaW50KTtcbiAgICAgICAgX2FwcGx5V3JpdGVzKGNvcHlDaGVja3BvaW50KG5ld0NoZWNrcG9pbnQpLCBuZXdDaGFubmVscywgW3Rhc2tdKTtcbiAgICAgICAgdmFsdWVzID0gcmVhZENoYW5uZWxzKHsgLi4uY2hhbm5lbHMsIC4uLm5ld0NoYW5uZWxzIH0sIHNlbGVjdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZXMgPSByZWFkQ2hhbm5lbHMoY2hhbm5lbHMsIHNlbGVjdCk7XG4gICAgfVxuICAgIGlmIChtYW5hZ2VkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBtYW5hZ2VkS2V5cykge1xuICAgICAgICAgICAgY29uc3QgbWFuYWdlZFZhbHVlID0gbWFuYWdlZC5nZXQoayk7XG4gICAgICAgICAgICBpZiAobWFuYWdlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0T2ZNYW5hZ2VkQ2FsbCA9IG1hbmFnZWRWYWx1ZS5jYWxsKHN0ZXApO1xuICAgICAgICAgICAgICAgIHZhbHVlc1trXSA9IHJlc3VsdE9mTWFuYWdlZENhbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBfbG9jYWxXcml0ZShzdGVwLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb21taXQsIHByb2Nlc3NlcywgbWFuYWdlZCwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxud3JpdGVzKSB7XG4gICAgZm9yIChjb25zdCBbY2hhbiwgdmFsdWVdIG9mIHdyaXRlcykge1xuICAgICAgICBpZiAoW1BVU0gsIFRBU0tTXS5pbmNsdWRlcyhjaGFuKSAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIV9pc1NlbmQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcGRhdGVFcnJvcihgSW52YWxpZCBwYWNrZXQgdHlwZSwgZXhwZWN0ZWQgU2VuZFByb3RvY29sLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISh2YWx1ZS5ub2RlIGluIHByb2Nlc3NlcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBJbnZhbGlkIG5vZGUgbmFtZSBcIiR7dmFsdWUubm9kZX1cIiBpbiBTZW5kIHBhY2tldGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVwbGFjZSBhbnkgcnVudGltZSB2YWx1ZXMgd2l0aCBwbGFjZWhvbGRlcnNcbiAgICAgICAgICAgIG1hbmFnZWQucmVwbGFjZVJ1bnRpbWVWYWx1ZXMoc3RlcCwgdmFsdWUuYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tbWl0KHdyaXRlcyk7XG59XG5jb25zdCBJR05PUkUgPSBuZXcgU2V0KFtcbiAgICBOT19XUklURVMsXG4gICAgUFVTSCxcbiAgICBSRVNVTUUsXG4gICAgSU5URVJSVVBULFxuICAgIFJFVFVSTixcbiAgICBFUlJPUixcbl0pO1xuZXhwb3J0IGZ1bmN0aW9uIF9hcHBseVdyaXRlcyhjaGVja3BvaW50LCBjaGFubmVscywgdGFza3MsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmdldE5leHRWZXJzaW9uKSB7XG4gICAgLy8gU29ydCB0YXNrcyBieSBmaXJzdCAzIHBhdGggZWxlbWVudHMgZm9yIGRldGVybWluaXN0aWMgb3JkZXJcbiAgICAvLyBMYXRlciBwYXRoIHBhcnRzIChsaWtlIHRhc2sgSURzKSBhcmUgaWdub3JlZCBmb3Igc29ydGluZ1xuICAgIHRhc2tzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgYVBhdGggPSBhLnBhdGg/LnNsaWNlKDAsIDMpIHx8IFtdO1xuICAgICAgICBjb25zdCBiUGF0aCA9IGIucGF0aD8uc2xpY2UoMCwgMykgfHwgW107XG4gICAgICAgIC8vIENvbXBhcmUgZWFjaCBwYXRoIGVsZW1lbnRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihhUGF0aC5sZW5ndGgsIGJQYXRoLmxlbmd0aCk7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGFQYXRoW2ldIDwgYlBhdGhbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGFQYXRoW2ldID4gYlBhdGhbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgb25lIHBhdGggaXMgc2hvcnRlciwgaXQgY29tZXMgZmlyc3RcbiAgICAgICAgcmV0dXJuIGFQYXRoLmxlbmd0aCAtIGJQYXRoLmxlbmd0aDtcbiAgICB9KTtcbiAgICAvLyBpZiBubyB0YXNrIGhhcyB0cmlnZ2VycyB0aGlzIGlzIGFwcGx5aW5nIHdyaXRlcyBmcm9tIHRoZSBudWxsIHRhc2sgb25seVxuICAgIC8vIHNvIHdlIGRvbid0IGRvIGFueXRoaW5nIG90aGVyIHRoYW4gdXBkYXRlIHRoZSBjaGFubmVscyB3cml0dGVuIHRvXG4gICAgY29uc3QgYnVtcFN0ZXAgPSB0YXNrcy5zb21lKCh0YXNrKSA9PiB0YXNrLnRyaWdnZXJzLmxlbmd0aCA+IDApO1xuICAgIC8vIEZpbHRlciBvdXQgbm9uIGluc3RhbmNlcyBvZiBCYXNlQ2hhbm5lbFxuICAgIGNvbnN0IG9ubHlDaGFubmVscyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhjaGFubmVscykuZmlsdGVyKChbXywgdmFsdWVdKSA9PiBpc0Jhc2VDaGFubmVsKHZhbHVlKSkpO1xuICAgIC8vIFVwZGF0ZSBzZWVuIHZlcnNpb25zXG4gICAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgICAgIGlmIChjaGVja3BvaW50LnZlcnNpb25zX3NlZW5bdGFzay5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGVja3BvaW50LnZlcnNpb25zX3NlZW5bdGFzay5uYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2hhbiBvZiB0YXNrLnRyaWdnZXJzKSB7XG4gICAgICAgICAgICBpZiAoY2hhbiBpbiBjaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50LnZlcnNpb25zX3NlZW5bdGFzay5uYW1lXVtjaGFuXSA9XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9uc1tjaGFuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBoaWdoZXN0IHZlcnNpb24gb2YgYWxsIGNoYW5uZWxzXG4gICAgbGV0IG1heFZlcnNpb247XG4gICAgaWYgKE9iamVjdC5rZXlzKGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICBtYXhWZXJzaW9uID0gbWF4Q2hhbm5lbFZlcnNpb24oLi4uT2JqZWN0LnZhbHVlcyhjaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnMpKTtcbiAgICB9XG4gICAgLy8gQ29uc3VtZSBhbGwgY2hhbm5lbHMgdGhhdCB3ZXJlIHJlYWRcbiAgICBjb25zdCBjaGFubmVsc1RvQ29uc3VtZSA9IG5ldyBTZXQodGFza3NcbiAgICAgICAgLmZsYXRNYXAoKHRhc2spID0+IHRhc2sudHJpZ2dlcnMpXG4gICAgICAgIC5maWx0ZXIoKGNoYW4pID0+ICFSRVNFUlZFRC5pbmNsdWRlcyhjaGFuKSkpO1xuICAgIGZvciAoY29uc3QgY2hhbiBvZiBjaGFubmVsc1RvQ29uc3VtZSkge1xuICAgICAgICBpZiAoY2hhbiBpbiBvbmx5Q2hhbm5lbHMgJiYgb25seUNoYW5uZWxzW2NoYW5dLmNvbnN1bWUoKSkge1xuICAgICAgICAgICAgaWYgKGdldE5leHRWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnNbY2hhbl0gPSBnZXROZXh0VmVyc2lvbihtYXhWZXJzaW9uLCBvbmx5Q2hhbm5lbHNbY2hhbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENsZWFyIHBlbmRpbmcgc2VuZHNcbiAgICBpZiAoY2hlY2twb2ludC5wZW5kaW5nX3NlbmRzPy5sZW5ndGggJiYgYnVtcFN0ZXApIHtcbiAgICAgICAgY2hlY2twb2ludC5wZW5kaW5nX3NlbmRzID0gW107XG4gICAgfVxuICAgIC8vIEdyb3VwIHdyaXRlcyBieSBjaGFubmVsXG4gICAgY29uc3QgcGVuZGluZ1dyaXRlVmFsdWVzQnlDaGFubmVsID0ge307XG4gICAgY29uc3QgcGVuZGluZ1dyaXRlc0J5TWFuYWdlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgdGFzayBvZiB0YXNrcykge1xuICAgICAgICBmb3IgKGNvbnN0IFtjaGFuLCB2YWxdIG9mIHRhc2sud3JpdGVzKSB7XG4gICAgICAgICAgICBpZiAoSUdOT1JFLmhhcyhjaGFuKSkge1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW4gPT09IFRBU0tTKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGJyYW5jaCBpbiAxLjBcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50LnBlbmRpbmdfc2VuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHZhbC5ub2RlLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB2YWwuYXJncyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW4gaW4gb25seUNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW4gaW4gcGVuZGluZ1dyaXRlVmFsdWVzQnlDaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdXcml0ZVZhbHVlc0J5Q2hhbm5lbFtjaGFuXS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nV3JpdGVWYWx1ZXNCeUNoYW5uZWxbY2hhbl0gPSBbdmFsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbiBpbiBwZW5kaW5nV3JpdGVzQnlNYW5hZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdXcml0ZXNCeU1hbmFnZWRbY2hhbl0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dyaXRlc0J5TWFuYWdlZFtjaGFuXSA9IFt2YWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBmaW5kIHRoZSBoaWdoZXN0IHZlcnNpb24gb2YgYWxsIGNoYW5uZWxzXG4gICAgbWF4VmVyc2lvbiA9IHVuZGVmaW5lZDtcbiAgICBpZiAoT2JqZWN0LmtleXMoY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1heFZlcnNpb24gPSBtYXhDaGFubmVsVmVyc2lvbiguLi5PYmplY3QudmFsdWVzKGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucykpO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkQ2hhbm5lbHMgPSBuZXcgU2V0KCk7XG4gICAgLy8gQXBwbHkgd3JpdGVzIHRvIGNoYW5uZWxzXG4gICAgZm9yIChjb25zdCBbY2hhbiwgdmFsc10gb2YgT2JqZWN0LmVudHJpZXMocGVuZGluZ1dyaXRlVmFsdWVzQnlDaGFubmVsKSkge1xuICAgICAgICBpZiAoY2hhbiBpbiBvbmx5Q2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkID0gb25seUNoYW5uZWxzW2NoYW5dLnVwZGF0ZSh2YWxzKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5uYW1lID09PSBJbnZhbGlkVXBkYXRlRXJyb3IudW5taW5pZmlhYmxlX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZEVycm9yID0gbmV3IEludmFsaWRVcGRhdGVFcnJvcihgSW52YWxpZCB1cGRhdGUgZm9yIGNoYW5uZWwgXCIke2NoYW59XCIgd2l0aCB2YWx1ZXMgJHtKU09OLnN0cmluZ2lmeSh2YWxzKX06ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRXJyb3IubGNfZXJyb3JfY29kZSA9IGUubGNfZXJyb3JfY29kZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgd3JhcHBlZEVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlZCAmJiBnZXROZXh0VmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zW2NoYW5dID0gZ2V0TmV4dFZlcnNpb24obWF4VmVyc2lvbiwgb25seUNoYW5uZWxzW2NoYW5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZWRDaGFubmVscy5hZGQoY2hhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hhbm5lbHMgdGhhdCB3ZXJlbid0IHVwZGF0ZWQgaW4gdGhpcyBzdGVwIGFyZSBub3RpZmllZCBvZiBhIG5ldyBzdGVwXG4gICAgaWYgKGJ1bXBTdGVwKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbiBvZiBPYmplY3Qua2V5cyhvbmx5Q2hhbm5lbHMpKSB7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZWRDaGFubmVscy5oYXMoY2hhbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkID0gb25seUNoYW5uZWxzW2NoYW5dLnVwZGF0ZShbXSk7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQgJiYgZ2V0TmV4dFZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnNbY2hhbl0gPSBnZXROZXh0VmVyc2lvbihtYXhWZXJzaW9uLCBvbmx5Q2hhbm5lbHNbY2hhbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm4gbWFuYWdlZCB2YWx1ZXMgd3JpdGVzIHRvIGJlIGFwcGxpZWQgZXh0ZXJuYWxseVxuICAgIHJldHVybiBwZW5kaW5nV3JpdGVzQnlNYW5hZ2VkO1xufVxuLyoqXG4gKiBQcmVwYXJlIHRoZSBzZXQgb2YgdGFza3MgdGhhdCB3aWxsIG1ha2UgdXAgdGhlIG5leHQgUHJlZ2VsIHN0ZXAuXG4gKiBUaGlzIGlzIHRoZSB1bmlvbiBvZiBhbGwgUFVTSCB0YXNrcyAoU2VuZHMpIGFuZCBQVUxMIHRhc2tzIChub2RlcyB0cmlnZ2VyZWRcbiAqIGJ5IGVkZ2VzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9wcmVwYXJlTmV4dFRhc2tzKGNoZWNrcG9pbnQsIHBlbmRpbmdXcml0ZXMsIHByb2Nlc3NlcywgY2hhbm5lbHMsIG1hbmFnZWQsIGNvbmZpZywgZm9yRXhlY3V0aW9uLCBleHRyYSkge1xuICAgIGNvbnN0IHRhc2tzID0ge307XG4gICAgLy8gQ29uc3VtZSBwZW5kaW5nIHBhY2tldHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoZWNrcG9pbnQucGVuZGluZ19zZW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB0YXNrID0gX3ByZXBhcmVTaW5nbGVUYXNrKFtQVVNILCBpXSwgY2hlY2twb2ludCwgcGVuZGluZ1dyaXRlcywgcHJvY2Vzc2VzLCBjaGFubmVscywgbWFuYWdlZCwgY29uZmlnLCBmb3JFeGVjdXRpb24sIGV4dHJhKTtcbiAgICAgICAgaWYgKHRhc2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFza3NbdGFzay5pZF0gPSB0YXNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGFueSBwcm9jZXNzZXMgc2hvdWxkIGJlIHJ1biBpbiBuZXh0IHN0ZXBcbiAgICAvLyBJZiBzbywgcHJlcGFyZSB0aGUgdmFsdWVzIHRvIGJlIHBhc3NlZCB0byB0aGVtXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHByb2Nlc3NlcykpIHtcbiAgICAgICAgY29uc3QgdGFzayA9IF9wcmVwYXJlU2luZ2xlVGFzayhbUFVMTCwgbmFtZV0sIGNoZWNrcG9pbnQsIHBlbmRpbmdXcml0ZXMsIHByb2Nlc3NlcywgY2hhbm5lbHMsIG1hbmFnZWQsIGNvbmZpZywgZm9yRXhlY3V0aW9uLCBleHRyYSk7XG4gICAgICAgIGlmICh0YXNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhc2tzW3Rhc2suaWRdID0gdGFzaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFza3M7XG59XG4vKipcbiAqIFByZXBhcmVzIGEgc2luZ2xlIHRhc2sgZm9yIHRoZSBuZXh0IFByZWdlbCBzdGVwLCBnaXZlbiBhIHRhc2sgcGF0aCwgd2hpY2hcbiAqIHVuaXF1ZWx5IGlkZW50aWZpZXMgYSBQVVNIIG9yIFBVTEwgdGFzayB3aXRoaW4gdGhlIGdyYXBoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX3ByZXBhcmVTaW5nbGVUYXNrKHRhc2tQYXRoLCBjaGVja3BvaW50LCBwZW5kaW5nV3JpdGVzLCBwcm9jZXNzZXMsIGNoYW5uZWxzLCBtYW5hZ2VkLCBjb25maWcsIGZvckV4ZWN1dGlvbiwgZXh0cmEpIHtcbiAgICBjb25zdCB7IHN0ZXAsIGNoZWNrcG9pbnRlciwgbWFuYWdlciB9ID0gZXh0cmE7XG4gICAgY29uc3QgY29uZmlndXJhYmxlID0gY29uZmlnLmNvbmZpZ3VyYWJsZSA/PyB7fTtcbiAgICBjb25zdCBwYXJlbnROYW1lc3BhY2UgPSBjb25maWd1cmFibGUuY2hlY2twb2ludF9ucyA/PyBcIlwiO1xuICAgIGlmICh0YXNrUGF0aFswXSA9PT0gUFVTSCAmJiBpc0NhbGwodGFza1BhdGhbdGFza1BhdGgubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIGNvbnN0IGNhbGwgPSB0YXNrUGF0aFt0YXNrUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgcHJvYyA9IGdldFJ1bm5hYmxlRm9yRnVuYyhjYWxsLm5hbWUsIGNhbGwuZnVuYyk7XG4gICAgICAgIGNvbnN0IHRyaWdnZXJzID0gW1BVU0hdO1xuICAgICAgICBjb25zdCBjaGVja3BvaW50TmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlID09PSBcIlwiXG4gICAgICAgICAgICA/IGNhbGwubmFtZVxuICAgICAgICAgICAgOiBgJHtwYXJlbnROYW1lc3BhY2V9JHtDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1J9JHtjYWxsLm5hbWV9YDtcbiAgICAgICAgY29uc3QgaWQgPSB1dWlkNShKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICBjaGVja3BvaW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgc3RlcC50b1N0cmluZygpLFxuICAgICAgICAgICAgY2FsbC5uYW1lLFxuICAgICAgICAgICAgUFVTSCxcbiAgICAgICAgICAgIHRhc2tQYXRoWzFdLFxuICAgICAgICAgICAgdGFza1BhdGhbMl0sXG4gICAgICAgIF0pLCBjaGVja3BvaW50LmlkKTtcbiAgICAgICAgY29uc3QgdGFza0NoZWNrcG9pbnROYW1lc3BhY2UgPSBgJHtjaGVja3BvaW50TmFtZXNwYWNlfSR7Q0hFQ0tQT0lOVF9OQU1FU1BBQ0VfRU5EfSR7aWR9YDtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBsYW5nZ3JhcGhfc3RlcDogc3RlcCxcbiAgICAgICAgICAgIGxhbmdncmFwaF9ub2RlOiBjYWxsLm5hbWUsXG4gICAgICAgICAgICBsYW5nZ3JhcGhfdHJpZ2dlcnM6IHRyaWdnZXJzLFxuICAgICAgICAgICAgbGFuZ2dyYXBoX3BhdGg6IHRhc2tQYXRoLnNsaWNlKDAsIDMpLFxuICAgICAgICAgICAgbGFuZ2dyYXBoX2NoZWNrcG9pbnRfbnM6IHRhc2tDaGVja3BvaW50TmFtZXNwYWNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZm9yRXhlY3V0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB3cml0ZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0OiBjYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgIHByb2MsXG4gICAgICAgICAgICAgICAgd3JpdGVzLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogcGF0Y2hDb25maWcobWVyZ2VDb25maWdzKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGV4dHJhLnN0b3JlID8/IGNvbmZpZy5zdG9yZSxcbiAgICAgICAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgICAgICAgICBydW5OYW1lOiBjYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogbWFuYWdlcj8uZ2V0Q2hpbGQoYGdyYXBoOnN0ZXA6JHtzdGVwfWApLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1RBU0tfSURdOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9TRU5EXTogKHdyaXRlc18pID0+IF9sb2NhbFdyaXRlKHN0ZXAsIChpdGVtcykgPT4gd3JpdGVzLnB1c2goLi4uaXRlbXMpLCBwcm9jZXNzZXMsIG1hbmFnZWQsIHdyaXRlc18pLFxuICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfUkVBRF06IChzZWxlY3RfLCBmcmVzaF8gPSBmYWxzZSkgPT4gX2xvY2FsUmVhZChzdGVwLCBjaGVja3BvaW50LCBjaGFubmVscywgbWFuYWdlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IHdyaXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB0YXNrUGF0aC5zbGljZSgwLCAzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNlbGVjdF8sIGZyZXNoXyksXG4gICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9DSEVDS1BPSU5URVJdOiBjaGVja3BvaW50ZXIgPz8gY29uZmlndXJhYmxlW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZ3VyYWJsZVtDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyZW50TmFtZXNwYWNlXTogY2hlY2twb2ludC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9TQ1JBVENIUEFEXTogX3NjcmF0Y2hwYWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdXcml0ZXM6IHBlbmRpbmdXcml0ZXMgPz8gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza0lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFza0lucHV0OiBjYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9QUkVWSU9VU19TVEFURV06IGNoZWNrcG9pbnQuY2hhbm5lbF92YWx1ZXNbUFJFVklPVVNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9pZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9uczogdGFza0NoZWNrcG9pbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHJpZ2dlcnMsXG4gICAgICAgICAgICAgICAgcmV0cnlfcG9saWN5OiBjYWxsLnJldHJ5LFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHBhdGg6IHRhc2tQYXRoLnNsaWNlKDAsIDMpLFxuICAgICAgICAgICAgICAgIHdyaXRlcnM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBjYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0czogW10sXG4gICAgICAgICAgICAgICAgcGF0aDogdGFza1BhdGguc2xpY2UoMCwgMyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhc2tQYXRoWzBdID09PSBQVVNIKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdHlwZW9mIHRhc2tQYXRoWzFdID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICA/IHRhc2tQYXRoWzFdXG4gICAgICAgICAgICA6IHBhcnNlSW50KHRhc2tQYXRoWzFdLCAxMCk7XG4gICAgICAgIGlmIChpbmRleCA+PSBjaGVja3BvaW50LnBlbmRpbmdfc2VuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IF9pc1NlbmRJbnRlcmZhY2UoY2hlY2twb2ludC5wZW5kaW5nX3NlbmRzW2luZGV4XSkgJiZcbiAgICAgICAgICAgICFfaXNTZW5kKGNoZWNrcG9pbnQucGVuZGluZ19zZW5kc1tpbmRleF0pXG4gICAgICAgICAgICA/IG5ldyBTZW5kKGNoZWNrcG9pbnQucGVuZGluZ19zZW5kc1tpbmRleF0ubm9kZSwgY2hlY2twb2ludC5wZW5kaW5nX3NlbmRzW2luZGV4XS5hcmdzKVxuICAgICAgICAgICAgOiBjaGVja3BvaW50LnBlbmRpbmdfc2VuZHNbaW5kZXhdO1xuICAgICAgICBpZiAoIV9pc1NlbmRJbnRlcmZhY2UocGFja2V0KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBJZ25vcmluZyBpbnZhbGlkIHBhY2tldCAke0pTT04uc3RyaW5naWZ5KHBhY2tldCl9IGluIHBlbmRpbmcgc2VuZHMuYCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHBhY2tldC5ub2RlIGluIHByb2Nlc3NlcykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgSWdub3JpbmcgdW5rbm93biBub2RlIG5hbWUgJHtwYWNrZXQubm9kZX0gaW4gcGVuZGluZyBzZW5kcy5gKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJpZ2dlcnMgPSBbUFVTSF07XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnROYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2UgPT09IFwiXCJcbiAgICAgICAgICAgID8gcGFja2V0Lm5vZGVcbiAgICAgICAgICAgIDogYCR7cGFyZW50TmFtZXNwYWNlfSR7Q0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SfSR7cGFja2V0Lm5vZGV9YDtcbiAgICAgICAgY29uc3QgdGFza0lkID0gdXVpZDUoSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgICAgY2hlY2twb2ludE5hbWVzcGFjZSxcbiAgICAgICAgICAgIHN0ZXAudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHBhY2tldC5ub2RlLFxuICAgICAgICAgICAgUFVTSCxcbiAgICAgICAgICAgIGluZGV4LnRvU3RyaW5nKCksXG4gICAgICAgIF0pLCBjaGVja3BvaW50LmlkKTtcbiAgICAgICAgY29uc3QgdGFza0NoZWNrcG9pbnROYW1lc3BhY2UgPSBgJHtjaGVja3BvaW50TmFtZXNwYWNlfSR7Q0hFQ0tQT0lOVF9OQU1FU1BBQ0VfRU5EfSR7dGFza0lkfWA7XG4gICAgICAgIGxldCBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIGxhbmdncmFwaF9zdGVwOiBzdGVwLFxuICAgICAgICAgICAgbGFuZ2dyYXBoX25vZGU6IHBhY2tldC5ub2RlLFxuICAgICAgICAgICAgbGFuZ2dyYXBoX3RyaWdnZXJzOiB0cmlnZ2VycyxcbiAgICAgICAgICAgIGxhbmdncmFwaF9wYXRoOiB0YXNrUGF0aC5zbGljZSgwLCAzKSxcbiAgICAgICAgICAgIGxhbmdncmFwaF9jaGVja3BvaW50X25zOiB0YXNrQ2hlY2twb2ludE5hbWVzcGFjZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZvckV4ZWN1dGlvbikge1xuICAgICAgICAgICAgY29uc3QgcHJvYyA9IHByb2Nlc3Nlc1twYWNrZXQubm9kZV07XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcHJvYy5nZXROb2RlKCk7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZC5yZXBsYWNlUnVudGltZVBsYWNlaG9sZGVycyhzdGVwLCBwYWNrZXQuYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2MubWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHsgLi4ubWV0YWRhdGEsIC4uLnByb2MubWV0YWRhdGEgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVzID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFja2V0Lm5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYWNrZXQuYXJncyxcbiAgICAgICAgICAgICAgICAgICAgcHJvYzogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGhzOiBwcm9jLnN1YmdyYXBocyxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVzLFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IHBhdGNoQ29uZmlnKG1lcmdlQ29uZmlncyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogcHJvYy50YWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGV4dHJhLnN0b3JlID8/IGNvbmZpZy5zdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgfSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bk5hbWU6IHBhY2tldC5ub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBtYW5hZ2VyPy5nZXRDaGlsZChgZ3JhcGg6c3RlcDoke3N0ZXB9YCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9UQVNLX0lEXTogdGFza0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfU0VORF06ICh3cml0ZXNfKSA9PiBfbG9jYWxXcml0ZShzdGVwLCAoaXRlbXMpID0+IHdyaXRlcy5wdXNoKC4uLml0ZW1zKSwgcHJvY2Vzc2VzLCBtYW5hZ2VkLCB3cml0ZXNfKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9SRUFEXTogKHNlbGVjdF8sIGZyZXNoXyA9IGZhbHNlKSA9PiBfbG9jYWxSZWFkKHN0ZXAsIGNoZWNrcG9pbnQsIGNoYW5uZWxzLCBtYW5hZ2VkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHBhY2tldC5ub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IHdyaXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHRhc2tQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNlbGVjdF8sIGZyZXNoXyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXTogY2hlY2twb2ludGVyID8/IGNvbmZpZ3VyYWJsZVtDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVBdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZ3VyYWJsZVtDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcmVudE5hbWVzcGFjZV06IGNoZWNrcG9pbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9TQ1JBVENIUEFEXTogX3NjcmF0Y2hwYWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nV3JpdGVzOiBwZW5kaW5nV3JpdGVzID8/IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5wdXQ6IHBhY2tldC5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1BSRVZJT1VTX1NUQVRFXTogY2hlY2twb2ludC5jaGFubmVsX3ZhbHVlc1tQUkVWSU9VU10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9pZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfbnM6IHRhc2tDaGVja3BvaW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJzLFxuICAgICAgICAgICAgICAgICAgICByZXRyeV9wb2xpY3k6IHByb2MucmV0cnlQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0YXNrSWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHRhc2tQYXRoLFxuICAgICAgICAgICAgICAgICAgICB3cml0ZXJzOiBwcm9jLmdldFdyaXRlcnMoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogdGFza0lkLFxuICAgICAgICAgICAgICAgIG5hbWU6IHBhY2tldC5ub2RlLFxuICAgICAgICAgICAgICAgIGludGVycnVwdHM6IFtdLFxuICAgICAgICAgICAgICAgIHBhdGg6IHRhc2tQYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0YXNrUGF0aFswXSA9PT0gUFVMTCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGFza1BhdGhbMV0udG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgcHJvYyA9IHByb2Nlc3Nlc1tuYW1lXTtcbiAgICAgICAgaWYgKHByb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHRhc2sgYWxyZWFkeSBoYXMgc3VjY2Vzc2Z1bCB3cml0ZXMgaW4gdGhlIHBlbmRpbmcgd3JpdGVzXG4gICAgICAgIGlmIChwZW5kaW5nV3JpdGVzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRhc2sgSUQgZm9yIHRoaXMgbm9kZS9wYXRoXG4gICAgICAgICAgICBjb25zdCBjaGVja3BvaW50TmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlID09PSBcIlwiXG4gICAgICAgICAgICAgICAgPyBuYW1lXG4gICAgICAgICAgICAgICAgOiBgJHtwYXJlbnROYW1lc3BhY2V9JHtDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1J9JHtuYW1lfWA7XG4gICAgICAgICAgICBjb25zdCB0YXNrSWQgPSB1dWlkNShKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgY2hlY2twb2ludE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBzdGVwLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBQVUxMLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBdKSwgY2hlY2twb2ludC5pZCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgc3VjY2Vzc2Z1bCB3cml0ZXMgKG5vdCBFUlJPUikgZm9yIHRoaXMgdGFzayBJRFxuICAgICAgICAgICAgY29uc3QgaGFzU3VjY2Vzc2Z1bFdyaXRlcyA9IHBlbmRpbmdXcml0ZXMuc29tZSgodykgPT4gd1swXSA9PT0gdGFza0lkICYmIHdbMV0gIT09IEVSUk9SKTtcbiAgICAgICAgICAgIC8vIElmIHRhc2sgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgZG9uJ3QgaW5jbHVkZSBpdCBpbiBuZXh0IHRhc2tzXG4gICAgICAgICAgICBpZiAoaGFzU3VjY2Vzc2Z1bFdyaXRlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVsbFZlcnNpb24gPSBnZXROdWxsQ2hhbm5lbFZlcnNpb24oY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zKTtcbiAgICAgICAgaWYgKG51bGxWZXJzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlbiA9IGNoZWNrcG9pbnQudmVyc2lvbnNfc2VlbltuYW1lXSA/PyB7fTtcbiAgICAgICAgY29uc3QgdHJpZ2dlcnMgPSBwcm9jLnRyaWdnZXJzXG4gICAgICAgICAgICAuZmlsdGVyKChjaGFuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkQ2hhbm5lbChjaGFubmVscywgY2hhbiwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eUNoYW5uZWxFcnJvciA9IFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9PT0gRW1wdHlDaGFubmVsRXJyb3IudW5taW5pZmlhYmxlX25hbWU7XG4gICAgICAgICAgICByZXR1cm4gKCFpc0VtcHR5Q2hhbm5lbEVycm9yICYmXG4gICAgICAgICAgICAgICAgKGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9uc1tjaGFuXSA/PyBudWxsVmVyc2lvbikgPlxuICAgICAgICAgICAgICAgICAgICAoc2VlbltjaGFuXSA/PyBudWxsVmVyc2lvbikpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNvcnQoKTtcbiAgICAgICAgLy8gSWYgYW55IG9mIHRoZSBjaGFubmVscyByZWFkIGJ5IHRoaXMgcHJvY2VzcyB3ZXJlIHVwZGF0ZWRcbiAgICAgICAgaWYgKHRyaWdnZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IF9wcm9jSW5wdXQoc3RlcCwgcHJvYywgbWFuYWdlZCwgY2hhbm5lbHMsIGZvckV4ZWN1dGlvbik7XG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hlY2twb2ludE5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZSA9PT0gXCJcIlxuICAgICAgICAgICAgICAgID8gbmFtZVxuICAgICAgICAgICAgICAgIDogYCR7cGFyZW50TmFtZXNwYWNlfSR7Q0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SfSR7bmFtZX1gO1xuICAgICAgICAgICAgY29uc3QgdGFza0lkID0gdXVpZDUoSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgc3RlcC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgUFVMTCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VycyxcbiAgICAgICAgICAgIF0pLCBjaGVja3BvaW50LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tDaGVja3BvaW50TmFtZXNwYWNlID0gYCR7Y2hlY2twb2ludE5hbWVzcGFjZX0ke0NIRUNLUE9JTlRfTkFNRVNQQUNFX0VORH0ke3Rhc2tJZH1gO1xuICAgICAgICAgICAgbGV0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIGxhbmdncmFwaF9zdGVwOiBzdGVwLFxuICAgICAgICAgICAgICAgIGxhbmdncmFwaF9ub2RlOiBuYW1lLFxuICAgICAgICAgICAgICAgIGxhbmdncmFwaF90cmlnZ2VyczogdHJpZ2dlcnMsXG4gICAgICAgICAgICAgICAgbGFuZ2dyYXBoX3BhdGg6IHRhc2tQYXRoLFxuICAgICAgICAgICAgICAgIGxhbmdncmFwaF9jaGVja3BvaW50X25zOiB0YXNrQ2hlY2twb2ludE5hbWVzcGFjZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZm9yRXhlY3V0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHByb2MuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2MubWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSB7IC4uLm1ldGFkYXRhLCAuLi5wcm9jLm1ldGFkYXRhIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2M6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaHM6IHByb2Muc3ViZ3JhcGhzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBwYXRjaENvbmZpZyhtZXJnZUNvbmZpZ3MoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogcHJvYy50YWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlOiBleHRyYS5zdG9yZSA/PyBjb25maWcuc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bk5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBtYW5hZ2VyPy5nZXRDaGlsZChgZ3JhcGg6c3RlcDoke3N0ZXB9YCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1RBU0tfSURdOiB0YXNrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1NFTkRdOiAod3JpdGVzXykgPT4gX2xvY2FsV3JpdGUoc3RlcCwgKGl0ZW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXMucHVzaCguLi5pdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHByb2Nlc3NlcywgbWFuYWdlZCwgd3JpdGVzXyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1JFQURdOiAoc2VsZWN0XywgZnJlc2hfID0gZmFsc2UpID0+IF9sb2NhbFJlYWQoc3RlcCwgY2hlY2twb2ludCwgY2hhbm5lbHMsIG1hbmFnZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IHdyaXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogdGFza1BhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNlbGVjdF8sIGZyZXNoXyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl06IGNoZWNrcG9pbnRlciA/PyBjb25maWd1cmFibGVbQ09ORklHX0tFWV9DSEVDS1BPSU5URVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9DSEVDS1BPSU5UX01BUF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZ3VyYWJsZVtDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJlbnROYW1lc3BhY2VdOiBjaGVja3BvaW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9TQ1JBVENIUEFEXTogX3NjcmF0Y2hwYWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dyaXRlczogcGVuZGluZ1dyaXRlcyA/PyBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5wdXQ6IHZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1BSRVZJT1VTX1NUQVRFXTogY2hlY2twb2ludC5jaGFubmVsX3ZhbHVlc1tQUkVWSU9VU10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9uczogdGFza0NoZWNrcG9pbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeV9wb2xpY3k6IHByb2MucmV0cnlQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGFza0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogdGFza1BhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXJzOiBwcm9jLmdldFdyaXRlcnMoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpZDogdGFza0lkLCBuYW1lLCBpbnRlcnJ1cHRzOiBbXSwgcGF0aDogdGFza1BhdGggfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiAgRnVuY3Rpb24gaW5qZWN0ZWQgdW5kZXIgQ09ORklHX0tFWV9SRUFEIGluIHRhc2sgY29uZmlnLCB0byByZWFkIGN1cnJlbnQgc3RhdGUuXG4gKiAgVXNlZCBieSBjb25kaXRpb25hbCBlZGdlcyB0byByZWFkIGEgY29weSBvZiB0aGUgc3RhdGUgd2l0aCByZWZsZWN0aW5nIHRoZSB3cml0ZXNcbiAqICBmcm9tIHRoYXQgbm9kZSBvbmx5LlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfcHJvY0lucHV0KHN0ZXAsIHByb2MsIG1hbmFnZWQsIGNoYW5uZWxzLCBmb3JFeGVjdXRpb24pIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGxldCB2YWw7XG4gICAgaWYgKHR5cGVvZiBwcm9jLmNoYW5uZWxzID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHByb2MuY2hhbm5lbHMpKSB7XG4gICAgICAgIHZhbCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCBjaGFuXSBvZiBPYmplY3QuZW50cmllcyhwcm9jLmNoYW5uZWxzKSkge1xuICAgICAgICAgICAgaWYgKHByb2MudHJpZ2dlcnMuaW5jbHVkZXMoY2hhbikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWxba10gPSByZWFkQ2hhbm5lbChjaGFubmVscywgY2hhbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5uYW1lID09PSBFbXB0eUNoYW5uZWxFcnJvci51bm1pbmlmaWFibGVfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuIGluIGNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsW2tdID0gcmVhZENoYW5uZWwoY2hhbm5lbHMsIGNoYW4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gRW1wdHlDaGFubmVsRXJyb3IudW5taW5pZmlhYmxlX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbFtrXSA9IG1hbmFnZWQuZ2V0KGspPy5jYWxsKHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocHJvYy5jaGFubmVscykpIHtcbiAgICAgICAgbGV0IHN1Y2Nlc3NmdWxSZWFkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbiBvZiBwcm9jLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRDaGFubmVsKGNoYW5uZWxzLCBjaGFuLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc2Z1bFJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLm5hbWUgPT09IEVtcHR5Q2hhbm5lbEVycm9yLnVubWluaWZpYWJsZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdWNjZXNzZnVsUmVhZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYW5uZWxzIHR5cGUsIGV4cGVjdGVkIGxpc3Qgb3IgZGljdCwgZ290ICR7cHJvYy5jaGFubmVsc31gKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHByb2Nlc3MgaGFzIGEgbWFwcGVyLCBhcHBseSBpdCB0byB0aGUgdmFsdWVcbiAgICBpZiAoZm9yRXhlY3V0aW9uICYmIHByb2MubWFwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsID0gcHJvYy5tYXBwZXIodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIF9zY3JhdGNocGFkKHsgcGVuZGluZ1dyaXRlcywgdGFza0lkLCBjdXJyZW50VGFza0lucHV0LCB9KSB7XG4gICAgY29uc3QgbnVsbFJlc3VtZSA9IHBlbmRpbmdXcml0ZXMuZmluZCgoW3dyaXRlVGFza0lkLCBjaGFuXSkgPT4gd3JpdGVUYXNrSWQgPT09IE5VTExfVEFTS19JRCAmJiBjaGFuID09PSBSRVNVTUUpPy5bMl07XG4gICAgY29uc3Qgc2NyYXRjaHBhZCA9IHtcbiAgICAgICAgY2FsbENvdW50ZXI6IDAsXG4gICAgICAgIGludGVycnVwdENvdW50ZXI6IC0xLFxuICAgICAgICByZXN1bWU6IHBlbmRpbmdXcml0ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKFt3cml0ZVRhc2tJZCwgY2hhbl0pID0+IHdyaXRlVGFza0lkID09PSB0YXNrSWQgJiYgY2hhbiA9PT0gUkVTVU1FKVxuICAgICAgICAgICAgLmZsYXRNYXAoKFtfd3JpdGVUYXNrSWQsIF9jaGFuLCByZXN1bWVdKSA9PiByZXN1bWUpLFxuICAgICAgICBudWxsUmVzdW1lLFxuICAgICAgICBzdWJncmFwaENvdW50ZXI6IDAsXG4gICAgICAgIGN1cnJlbnRUYXNrSW5wdXQsXG4gICAgICAgIGNvbnN1bWVOdWxsUmVzdW1lOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NyYXRjaHBhZC5udWxsUmVzdW1lKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjcmF0Y2hwYWQubnVsbFJlc3VtZTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nV3JpdGVzLnNwbGljZShwZW5kaW5nV3JpdGVzLmZpbmRJbmRleCgoW3dyaXRlVGFza0lkLCBjaGFuXSkgPT4gd3JpdGVUYXNrSWQgPT09IE5VTExfVEFTS19JRCAmJiBjaGFuID09PSBSRVNVTUUpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFJlc3VtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gc2NyYXRjaHBhZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsZ28uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/algo.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/call.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/call.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   call: () => (/* binding */ call),\n/* harmony export */   getRunnableForEntrypoint: () => (/* binding */ getRunnableForEntrypoint),\n/* harmony export */   getRunnableForFunc: () => (/* binding */ getRunnableForFunc)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/singletons */ \"(rsc)/./node_modules/@langchain/core/singletons.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _write_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./write.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/write.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/utils.js\");\n\n\n\n\n\n/**\n * Wraps a user function in a Runnable that writes the returned value to the RETURN channel.\n */\nfunction getRunnableForFunc(name, func) {\n    const run = new _utils_js__WEBPACK_IMPORTED_MODULE_4__.RunnableCallable({\n        func: (input) => func(...input),\n        name,\n        trace: false,\n        recurse: false,\n    });\n    return new _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnableSequence({\n        name,\n        first: run,\n        last: new _write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite([{ channel: _constants_js__WEBPACK_IMPORTED_MODULE_2__.RETURN, value: _write_js__WEBPACK_IMPORTED_MODULE_3__.PASSTHROUGH }], [_constants_js__WEBPACK_IMPORTED_MODULE_2__.TAG_HIDDEN]),\n    });\n}\nfunction getRunnableForEntrypoint(name, func) {\n    const run = new _utils_js__WEBPACK_IMPORTED_MODULE_4__.RunnableCallable({\n        func: (input, config) => {\n            return func(input, config);\n        },\n        name,\n        trace: false,\n        recurse: false,\n    });\n    return run;\n}\nfunction call({ func, name, retry }, ...args) {\n    const config = _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    if (typeof config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CALL] === \"function\") {\n        return config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CALL](func, name, args, {\n            retry,\n            callbacks: config.callbacks,\n        });\n    }\n    throw new Error(\"Async local storage not initialized. Please call initializeAsyncLocalStorageSingleton() before using this function.\");\n}\n//# sourceMappingURL=call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvY2FsbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4RDtBQUNrQjtBQUNWO0FBQ2Y7QUFDUjtBQUMvQztBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQix1REFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSx1RUFBZ0I7QUFDL0I7QUFDQTtBQUNBLGtCQUFrQixtREFBWSxJQUFJLFNBQVMsaURBQU0sU0FBUyxrREFBVyxFQUFFLElBQUkscURBQVU7QUFDckYsS0FBSztBQUNMO0FBQ087QUFDUCxvQkFBb0IsdURBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTyxnQkFBZ0IsbUJBQW1CO0FBQzFDLG1CQUFtQiwwRkFBa0M7QUFDckQscUNBQXFDLDBEQUFlO0FBQ3BELG1DQUFtQywwREFBZTtBQUNsRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxccHJlZ2VsXFxjYWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJ1bm5hYmxlU2VxdWVuY2UsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbmltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3NpbmdsZXRvbnNcIjtcbmltcG9ydCB7IENPTkZJR19LRVlfQ0FMTCwgUkVUVVJOLCBUQUdfSElEREVOIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgQ2hhbm5lbFdyaXRlLCBQQVNTVEhST1VHSCB9IGZyb20gXCIuL3dyaXRlLmpzXCI7XG5pbXBvcnQgeyBSdW5uYWJsZUNhbGxhYmxlIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG4vKipcbiAqIFdyYXBzIGEgdXNlciBmdW5jdGlvbiBpbiBhIFJ1bm5hYmxlIHRoYXQgd3JpdGVzIHRoZSByZXR1cm5lZCB2YWx1ZSB0byB0aGUgUkVUVVJOIGNoYW5uZWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdW5uYWJsZUZvckZ1bmMobmFtZSwgZnVuYykge1xuICAgIGNvbnN0IHJ1biA9IG5ldyBSdW5uYWJsZUNhbGxhYmxlKHtcbiAgICAgICAgZnVuYzogKGlucHV0KSA9PiBmdW5jKC4uLmlucHV0KSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHJhY2U6IGZhbHNlLFxuICAgICAgICByZWN1cnNlOiBmYWxzZSxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBmaXJzdDogcnVuLFxuICAgICAgICBsYXN0OiBuZXcgQ2hhbm5lbFdyaXRlKFt7IGNoYW5uZWw6IFJFVFVSTiwgdmFsdWU6IFBBU1NUSFJPVUdIIH1dLCBbVEFHX0hJRERFTl0pLFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bm5hYmxlRm9yRW50cnlwb2ludChuYW1lLCBmdW5jKSB7XG4gICAgY29uc3QgcnVuID0gbmV3IFJ1bm5hYmxlQ2FsbGFibGUoe1xuICAgICAgICBmdW5jOiAoaW5wdXQsIGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIH0sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHRyYWNlOiBmYWxzZSxcbiAgICAgICAgcmVjdXJzZTogZmFsc2UsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJ1bjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWxsKHsgZnVuYywgbmFtZSwgcmV0cnkgfSwgLi4uYXJncykge1xuICAgIGNvbnN0IGNvbmZpZyA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0UnVubmFibGVDb25maWcoKTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX0NBTExdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5jb25maWd1cmFibGVbQ09ORklHX0tFWV9DQUxMXShmdW5jLCBuYW1lLCBhcmdzLCB7XG4gICAgICAgICAgICByZXRyeSxcbiAgICAgICAgICAgIGNhbGxiYWNrczogY29uZmlnLmNhbGxiYWNrcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIGxvY2FsIHN0b3JhZ2Ugbm90IGluaXRpYWxpemVkLiBQbGVhc2UgY2FsbCBpbml0aWFsaXplQXN5bmNMb2NhbFN0b3JhZ2VTaW5nbGV0b24oKSBiZWZvcmUgdXNpbmcgdGhpcyBmdW5jdGlvbi5cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/debug.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/debug.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _readChannels: () => (/* binding */ _readChannels),\n/* harmony export */   mapDebugCheckpoint: () => (/* binding */ mapDebugCheckpoint),\n/* harmony export */   mapDebugTaskResults: () => (/* binding */ mapDebugTaskResults),\n/* harmony export */   mapDebugTasks: () => (/* binding */ mapDebugTasks),\n/* harmony export */   printCheckpoint: () => (/* binding */ printCheckpoint),\n/* harmony export */   printStepCheckpoint: () => (/* binding */ printStepCheckpoint),\n/* harmony export */   printStepTasks: () => (/* binding */ printStepTasks),\n/* harmony export */   printStepWrites: () => (/* binding */ printStepWrites),\n/* harmony export */   tasksWithWrites: () => (/* binding */ tasksWithWrites),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./io.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/io.js\");\n/* harmony import */ var _utils_subgraph_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/subgraph.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js\");\n\n\n\n\nconst COLORS_MAP = {\n    blue: {\n        start: \"\\x1b[34m\",\n        end: \"\\x1b[0m\",\n    },\n    green: {\n        start: \"\\x1b[32m\",\n        end: \"\\x1b[0m\",\n    },\n    yellow: {\n        start: \"\\x1b[33;1m\",\n        end: \"\\x1b[0m\",\n    },\n};\n/**\n * Wrap some text in a color for printing to the console.\n */\nconst wrap = (color, text) => `${color.start}${text}${color.end}`;\nfunction printCheckpoint(step, channels) {\n    console.log([\n        `${wrap(COLORS_MAP.blue, \"[langgraph/checkpoint]\")}`,\n        `Finishing step ${step}. Channel values:\\n`,\n        `\\n${JSON.stringify(Object.fromEntries(_readChannels(channels)), null, 2)}`,\n    ].join(\"\"));\n}\nfunction* _readChannels(channels\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    for (const [name, channel] of Object.entries(channels)) {\n        try {\n            yield [name, channel.get()];\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (error) {\n            if (error.name === _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError.unminifiable_name) {\n                // Skip the channel if it's empty\n                continue;\n            }\n            else {\n                throw error; // Re-throw the error if it's not an EmptyChannelError\n            }\n        }\n    }\n}\nfunction* mapDebugTasks(step, tasks) {\n    const ts = new Date().toISOString();\n    for (const { id, name, input, config, triggers, writes } of tasks) {\n        if (config?.tags?.includes(_constants_js__WEBPACK_IMPORTED_MODULE_0__.TAG_HIDDEN))\n            continue;\n        const interrupts = writes\n            .filter(([writeId, n]) => {\n            return writeId === id && n === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT;\n        })\n            .map(([, v]) => {\n            return v;\n        });\n        yield {\n            type: \"task\",\n            timestamp: ts,\n            step,\n            payload: {\n                id,\n                name,\n                input,\n                triggers,\n                interrupts,\n            },\n        };\n    }\n}\nfunction* mapDebugTaskResults(step, tasks, streamChannels) {\n    const ts = new Date().toISOString();\n    for (const [{ id, name, config }, writes] of tasks) {\n        if (config?.tags?.includes(_constants_js__WEBPACK_IMPORTED_MODULE_0__.TAG_HIDDEN))\n            continue;\n        yield {\n            type: \"task_result\",\n            timestamp: ts,\n            step,\n            payload: {\n                id,\n                name,\n                result: writes.filter(([channel]) => {\n                    return Array.isArray(streamChannels)\n                        ? streamChannels.includes(channel)\n                        : channel === streamChannels;\n                }),\n                interrupts: writes.filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT).map((w) => w[1]),\n            },\n        };\n    }\n}\nfunction* mapDebugCheckpoint(step, config, channels, streamChannels, metadata, tasks, pendingWrites, parentConfig) {\n    function formatConfig(config) {\n        // make sure the config is consistent with Python\n        const pyConfig = {};\n        if (config.callbacks != null)\n            pyConfig.callbacks = config.callbacks;\n        if (config.configurable != null)\n            pyConfig.configurable = config.configurable;\n        if (config.maxConcurrency != null)\n            pyConfig.max_concurrency = config.maxConcurrency;\n        if (config.metadata != null)\n            pyConfig.metadata = config.metadata;\n        if (config.recursionLimit != null)\n            pyConfig.recursion_limit = config.recursionLimit;\n        if (config.runId != null)\n            pyConfig.run_id = config.runId;\n        if (config.runName != null)\n            pyConfig.run_name = config.runName;\n        if (config.tags != null)\n            pyConfig.tags = config.tags;\n        return pyConfig;\n    }\n    const parentNs = config.configurable?.checkpoint_ns;\n    const taskStates = {};\n    for (const task of tasks) {\n        const candidates = task.subgraphs?.length ? task.subgraphs : [task.proc];\n        if (!candidates.find(_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_3__.findSubgraphPregel))\n            continue;\n        let taskNs = `${task.name}:${task.id}`;\n        if (parentNs)\n            taskNs = `${parentNs}|${taskNs}`;\n        taskStates[task.id] = {\n            configurable: {\n                thread_id: config.configurable?.thread_id,\n                checkpoint_ns: taskNs,\n            },\n        };\n    }\n    const ts = new Date().toISOString();\n    yield {\n        type: \"checkpoint\",\n        timestamp: ts,\n        step,\n        payload: {\n            config: formatConfig(config),\n            values: (0,_io_js__WEBPACK_IMPORTED_MODULE_2__.readChannels)(channels, streamChannels),\n            metadata,\n            next: tasks.map((task) => task.name),\n            tasks: tasksWithWrites(tasks, pendingWrites, taskStates),\n            parentConfig: parentConfig ? formatConfig(parentConfig) : undefined,\n        },\n    };\n}\nfunction tasksWithWrites(tasks, pendingWrites, states) {\n    return tasks.map((task) => {\n        const error = pendingWrites.find(([id, n]) => id === task.id && n === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR)?.[2];\n        const interrupts = pendingWrites\n            .filter(([id, n]) => {\n            return id === task.id && n === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT;\n        })\n            .map(([, , v]) => {\n            return v;\n        });\n        if (error) {\n            return {\n                id: task.id,\n                name: task.name,\n                path: task.path,\n                error,\n                interrupts,\n            };\n        }\n        const taskState = states?.[task.id];\n        return {\n            id: task.id,\n            name: task.name,\n            path: task.path,\n            interrupts,\n            ...(taskState !== undefined ? { state: taskState } : {}),\n        };\n    });\n}\nfunction printStepCheckpoint(step, channels, whitelist) {\n    console.log([\n        `${wrap(COLORS_MAP.blue, `[${step}:checkpoint]`)}`,\n        `\\x1b[1m State at the end of step ${step}:\\x1b[0m\\n`,\n        JSON.stringify((0,_io_js__WEBPACK_IMPORTED_MODULE_2__.readChannels)(channels, whitelist), null, 2),\n    ].join(\"\"));\n}\nfunction printStepTasks(step, nextTasks) {\n    const nTasks = nextTasks.length;\n    console.log([\n        `${wrap(COLORS_MAP.blue, `[${step}:tasks]`)}`,\n        `\\x1b[1m Starting step ${step} with ${nTasks} task${nTasks === 1 ? \"\" : \"s\"}:\\x1b[0m\\n`,\n        nextTasks\n            .map((task) => `- ${wrap(COLORS_MAP.green, String(task.name))} -> ${JSON.stringify(task.input, null, 2)}`)\n            .join(\"\\n\"),\n    ].join(\"\"));\n}\nfunction printStepWrites(step, writes, whitelist) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const byChannel = {};\n    for (const [channel, value] of writes) {\n        if (whitelist.includes(channel)) {\n            if (!byChannel[channel]) {\n                byChannel[channel] = [];\n            }\n            byChannel[channel].push(value);\n        }\n    }\n    console.log([\n        `${wrap(COLORS_MAP.blue, `[${step}:writes]`)}`,\n        `\\x1b[1m Finished step ${step} with writes to ${Object.keys(byChannel).length} channel${Object.keys(byChannel).length !== 1 ? \"s\" : \"\"}:\\x1b[0m\\n`,\n        Object.entries(byChannel)\n            .map(([name, vals]) => `- ${wrap(COLORS_MAP.yellow, name)} -> ${vals\n            .map((v) => JSON.stringify(v))\n            .join(\", \")}`)\n            .join(\"\\n\"),\n    ].join(\"\"));\n}\n//# sourceMappingURL=debug.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvZGVidWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0Q7QUFDZDtBQUNWO0FBQ2tCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyxZQUFZLEVBQUUsS0FBSyxFQUFFLFVBQVU7QUFDaEU7QUFDUDtBQUNBLFdBQVcsZ0RBQWdEO0FBQzNELDBCQUEwQixLQUFLO0FBQy9CLGFBQWEscUVBQXFFO0FBQ2xGO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQiw0Q0FBNEM7QUFDN0QsbUNBQW1DLHFEQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvREFBUztBQUNwRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQyxtQ0FBbUMscURBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDBEQUEwRCxvREFBUztBQUNuRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrRUFBa0I7QUFDL0M7QUFDQSx3QkFBd0IsVUFBVSxHQUFHLFFBQVE7QUFDN0M7QUFDQSx3QkFBd0IsU0FBUyxHQUFHLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0EsOEVBQThFLGdEQUFLO0FBQ25GO0FBQ0E7QUFDQSwyQ0FBMkMsb0RBQVM7QUFDcEQsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQixJQUFJO0FBQ25FO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBLFdBQVcsMEJBQTBCLEtBQUssZUFBZTtBQUN6RCw0Q0FBNEMsS0FBSztBQUNqRCx1QkFBdUIsb0RBQVk7QUFDbkM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFdBQVcsMEJBQTBCLEtBQUssVUFBVTtBQUNwRCxpQ0FBaUMsTUFBTSxPQUFPLFFBQVEsTUFBTSx3QkFBd0I7QUFDcEY7QUFDQSxnQ0FBZ0MsMkNBQTJDLEtBQUssb0NBQW9DO0FBQ3BIO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCLEtBQUssV0FBVztBQUNyRCxpQ0FBaUMsTUFBTSxpQkFBaUIsK0JBQStCLFNBQVMsK0NBQStDO0FBQy9JO0FBQ0Esd0NBQXdDLCtCQUErQixLQUFLO0FBQzVFO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxccHJlZ2VsXFxkZWJ1Zy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFUlJPUiwgSU5URVJSVVBULCBUQUdfSElEREVOIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgRW1wdHlDaGFubmVsRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyByZWFkQ2hhbm5lbHMgfSBmcm9tIFwiLi9pby5qc1wiO1xuaW1wb3J0IHsgZmluZFN1YmdyYXBoUHJlZ2VsIH0gZnJvbSBcIi4vdXRpbHMvc3ViZ3JhcGguanNcIjtcbmNvbnN0IENPTE9SU19NQVAgPSB7XG4gICAgYmx1ZToge1xuICAgICAgICBzdGFydDogXCJcXHgxYlszNG1cIixcbiAgICAgICAgZW5kOiBcIlxceDFiWzBtXCIsXG4gICAgfSxcbiAgICBncmVlbjoge1xuICAgICAgICBzdGFydDogXCJcXHgxYlszMm1cIixcbiAgICAgICAgZW5kOiBcIlxceDFiWzBtXCIsXG4gICAgfSxcbiAgICB5ZWxsb3c6IHtcbiAgICAgICAgc3RhcnQ6IFwiXFx4MWJbMzM7MW1cIixcbiAgICAgICAgZW5kOiBcIlxceDFiWzBtXCIsXG4gICAgfSxcbn07XG4vKipcbiAqIFdyYXAgc29tZSB0ZXh0IGluIGEgY29sb3IgZm9yIHByaW50aW5nIHRvIHRoZSBjb25zb2xlLlxuICovXG5leHBvcnQgY29uc3Qgd3JhcCA9IChjb2xvciwgdGV4dCkgPT4gYCR7Y29sb3Iuc3RhcnR9JHt0ZXh0fSR7Y29sb3IuZW5kfWA7XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRDaGVja3BvaW50KHN0ZXAsIGNoYW5uZWxzKSB7XG4gICAgY29uc29sZS5sb2coW1xuICAgICAgICBgJHt3cmFwKENPTE9SU19NQVAuYmx1ZSwgXCJbbGFuZ2dyYXBoL2NoZWNrcG9pbnRdXCIpfWAsXG4gICAgICAgIGBGaW5pc2hpbmcgc3RlcCAke3N0ZXB9LiBDaGFubmVsIHZhbHVlczpcXG5gLFxuICAgICAgICBgXFxuJHtKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXMoX3JlYWRDaGFubmVscyhjaGFubmVscykpLCBudWxsLCAyKX1gLFxuICAgIF0uam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24qIF9yZWFkQ2hhbm5lbHMoY2hhbm5lbHNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBjaGFubmVsXSBvZiBPYmplY3QuZW50cmllcyhjaGFubmVscykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHlpZWxkIFtuYW1lLCBjaGFubmVsLmdldCgpXTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gRW1wdHlDaGFubmVsRXJyb3IudW5taW5pZmlhYmxlX25hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBjaGFubmVsIGlmIGl0J3MgZW1wdHlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yOyAvLyBSZS10aHJvdyB0aGUgZXJyb3IgaWYgaXQncyBub3QgYW4gRW1wdHlDaGFubmVsRXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiogbWFwRGVidWdUYXNrcyhzdGVwLCB0YXNrcykge1xuICAgIGNvbnN0IHRzID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIGZvciAoY29uc3QgeyBpZCwgbmFtZSwgaW5wdXQsIGNvbmZpZywgdHJpZ2dlcnMsIHdyaXRlcyB9IG9mIHRhc2tzKSB7XG4gICAgICAgIGlmIChjb25maWc/LnRhZ3M/LmluY2x1ZGVzKFRBR19ISURERU4pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGludGVycnVwdHMgPSB3cml0ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKFt3cml0ZUlkLCBuXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSWQgPT09IGlkICYmIG4gPT09IElOVEVSUlVQVDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoKFssIHZdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGFza1wiLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0cyxcbiAgICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VycyxcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24qIG1hcERlYnVnVGFza1Jlc3VsdHMoc3RlcCwgdGFza3MsIHN0cmVhbUNoYW5uZWxzKSB7XG4gICAgY29uc3QgdHMgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgZm9yIChjb25zdCBbeyBpZCwgbmFtZSwgY29uZmlnIH0sIHdyaXRlc10gb2YgdGFza3MpIHtcbiAgICAgICAgaWYgKGNvbmZpZz8udGFncz8uaW5jbHVkZXMoVEFHX0hJRERFTikpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgdHlwZTogXCJ0YXNrX3Jlc3VsdFwiLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0cyxcbiAgICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHdyaXRlcy5maWx0ZXIoKFtjaGFubmVsXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzdHJlYW1DaGFubmVscylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3RyZWFtQ2hhbm5lbHMuaW5jbHVkZXMoY2hhbm5lbClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2hhbm5lbCA9PT0gc3RyZWFtQ2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0czogd3JpdGVzLmZpbHRlcigodykgPT4gd1swXSA9PT0gSU5URVJSVVBUKS5tYXAoKHcpID0+IHdbMV0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24qIG1hcERlYnVnQ2hlY2twb2ludChzdGVwLCBjb25maWcsIGNoYW5uZWxzLCBzdHJlYW1DaGFubmVscywgbWV0YWRhdGEsIHRhc2tzLCBwZW5kaW5nV3JpdGVzLCBwYXJlbnRDb25maWcpIHtcbiAgICBmdW5jdGlvbiBmb3JtYXRDb25maWcoY29uZmlnKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgY29uZmlnIGlzIGNvbnNpc3RlbnQgd2l0aCBQeXRob25cbiAgICAgICAgY29uc3QgcHlDb25maWcgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZy5jYWxsYmFja3MgIT0gbnVsbClcbiAgICAgICAgICAgIHB5Q29uZmlnLmNhbGxiYWNrcyA9IGNvbmZpZy5jYWxsYmFja3M7XG4gICAgICAgIGlmIChjb25maWcuY29uZmlndXJhYmxlICE9IG51bGwpXG4gICAgICAgICAgICBweUNvbmZpZy5jb25maWd1cmFibGUgPSBjb25maWcuY29uZmlndXJhYmxlO1xuICAgICAgICBpZiAoY29uZmlnLm1heENvbmN1cnJlbmN5ICE9IG51bGwpXG4gICAgICAgICAgICBweUNvbmZpZy5tYXhfY29uY3VycmVuY3kgPSBjb25maWcubWF4Q29uY3VycmVuY3k7XG4gICAgICAgIGlmIChjb25maWcubWV0YWRhdGEgIT0gbnVsbClcbiAgICAgICAgICAgIHB5Q29uZmlnLm1ldGFkYXRhID0gY29uZmlnLm1ldGFkYXRhO1xuICAgICAgICBpZiAoY29uZmlnLnJlY3Vyc2lvbkxpbWl0ICE9IG51bGwpXG4gICAgICAgICAgICBweUNvbmZpZy5yZWN1cnNpb25fbGltaXQgPSBjb25maWcucmVjdXJzaW9uTGltaXQ7XG4gICAgICAgIGlmIChjb25maWcucnVuSWQgIT0gbnVsbClcbiAgICAgICAgICAgIHB5Q29uZmlnLnJ1bl9pZCA9IGNvbmZpZy5ydW5JZDtcbiAgICAgICAgaWYgKGNvbmZpZy5ydW5OYW1lICE9IG51bGwpXG4gICAgICAgICAgICBweUNvbmZpZy5ydW5fbmFtZSA9IGNvbmZpZy5ydW5OYW1lO1xuICAgICAgICBpZiAoY29uZmlnLnRhZ3MgIT0gbnVsbClcbiAgICAgICAgICAgIHB5Q29uZmlnLnRhZ3MgPSBjb25maWcudGFncztcbiAgICAgICAgcmV0dXJuIHB5Q29uZmlnO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnROcyA9IGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfbnM7XG4gICAgY29uc3QgdGFza1N0YXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdGFzayBvZiB0YXNrcykge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gdGFzay5zdWJncmFwaHM/Lmxlbmd0aCA/IHRhc2suc3ViZ3JhcGhzIDogW3Rhc2sucHJvY107XG4gICAgICAgIGlmICghY2FuZGlkYXRlcy5maW5kKGZpbmRTdWJncmFwaFByZWdlbCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHRhc2tOcyA9IGAke3Rhc2submFtZX06JHt0YXNrLmlkfWA7XG4gICAgICAgIGlmIChwYXJlbnROcylcbiAgICAgICAgICAgIHRhc2tOcyA9IGAke3BhcmVudE5zfXwke3Rhc2tOc31gO1xuICAgICAgICB0YXNrU3RhdGVzW3Rhc2suaWRdID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB7XG4gICAgICAgICAgICAgICAgdGhyZWFkX2lkOiBjb25maWcuY29uZmlndXJhYmxlPy50aHJlYWRfaWQsXG4gICAgICAgICAgICAgICAgY2hlY2twb2ludF9uczogdGFza05zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdHMgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcImNoZWNrcG9pbnRcIixcbiAgICAgICAgdGltZXN0YW1wOiB0cyxcbiAgICAgICAgc3RlcCxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgY29uZmlnOiBmb3JtYXRDb25maWcoY29uZmlnKSxcbiAgICAgICAgICAgIHZhbHVlczogcmVhZENoYW5uZWxzKGNoYW5uZWxzLCBzdHJlYW1DaGFubmVscyksXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIG5leHQ6IHRhc2tzLm1hcCgodGFzaykgPT4gdGFzay5uYW1lKSxcbiAgICAgICAgICAgIHRhc2tzOiB0YXNrc1dpdGhXcml0ZXModGFza3MsIHBlbmRpbmdXcml0ZXMsIHRhc2tTdGF0ZXMpLFxuICAgICAgICAgICAgcGFyZW50Q29uZmlnOiBwYXJlbnRDb25maWcgPyBmb3JtYXRDb25maWcocGFyZW50Q29uZmlnKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRhc2tzV2l0aFdyaXRlcyh0YXNrcywgcGVuZGluZ1dyaXRlcywgc3RhdGVzKSB7XG4gICAgcmV0dXJuIHRhc2tzLm1hcCgodGFzaykgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IHBlbmRpbmdXcml0ZXMuZmluZCgoW2lkLCBuXSkgPT4gaWQgPT09IHRhc2suaWQgJiYgbiA9PT0gRVJST1IpPy5bMl07XG4gICAgICAgIGNvbnN0IGludGVycnVwdHMgPSBwZW5kaW5nV3JpdGVzXG4gICAgICAgICAgICAuZmlsdGVyKChbaWQsIG5dKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09IHRhc2suaWQgJiYgbiA9PT0gSU5URVJSVVBUO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoWywgLCB2XSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IHRhc2suaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogdGFzay5uYW1lLFxuICAgICAgICAgICAgICAgIHBhdGg6IHRhc2sucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXNrU3RhdGUgPSBzdGF0ZXM/Llt0YXNrLmlkXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0YXNrLmlkLFxuICAgICAgICAgICAgbmFtZTogdGFzay5uYW1lLFxuICAgICAgICAgICAgcGF0aDogdGFzay5wYXRoLFxuICAgICAgICAgICAgaW50ZXJydXB0cyxcbiAgICAgICAgICAgIC4uLih0YXNrU3RhdGUgIT09IHVuZGVmaW5lZCA/IHsgc3RhdGU6IHRhc2tTdGF0ZSB9IDoge30pLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByaW50U3RlcENoZWNrcG9pbnQoc3RlcCwgY2hhbm5lbHMsIHdoaXRlbGlzdCkge1xuICAgIGNvbnNvbGUubG9nKFtcbiAgICAgICAgYCR7d3JhcChDT0xPUlNfTUFQLmJsdWUsIGBbJHtzdGVwfTpjaGVja3BvaW50XWApfWAsXG4gICAgICAgIGBcXHgxYlsxbSBTdGF0ZSBhdCB0aGUgZW5kIG9mIHN0ZXAgJHtzdGVwfTpcXHgxYlswbVxcbmAsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHJlYWRDaGFubmVscyhjaGFubmVscywgd2hpdGVsaXN0KSwgbnVsbCwgMiksXG4gICAgXS5qb2luKFwiXCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmludFN0ZXBUYXNrcyhzdGVwLCBuZXh0VGFza3MpIHtcbiAgICBjb25zdCBuVGFza3MgPSBuZXh0VGFza3MubGVuZ3RoO1xuICAgIGNvbnNvbGUubG9nKFtcbiAgICAgICAgYCR7d3JhcChDT0xPUlNfTUFQLmJsdWUsIGBbJHtzdGVwfTp0YXNrc11gKX1gLFxuICAgICAgICBgXFx4MWJbMW0gU3RhcnRpbmcgc3RlcCAke3N0ZXB9IHdpdGggJHtuVGFza3N9IHRhc2ske25UYXNrcyA9PT0gMSA/IFwiXCIgOiBcInNcIn06XFx4MWJbMG1cXG5gLFxuICAgICAgICBuZXh0VGFza3NcbiAgICAgICAgICAgIC5tYXAoKHRhc2spID0+IGAtICR7d3JhcChDT0xPUlNfTUFQLmdyZWVuLCBTdHJpbmcodGFzay5uYW1lKSl9IC0+ICR7SlNPTi5zdHJpbmdpZnkodGFzay5pbnB1dCwgbnVsbCwgMil9YClcbiAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpLFxuICAgIF0uam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRTdGVwV3JpdGVzKHN0ZXAsIHdyaXRlcywgd2hpdGVsaXN0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBieUNoYW5uZWwgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtjaGFubmVsLCB2YWx1ZV0gb2Ygd3JpdGVzKSB7XG4gICAgICAgIGlmICh3aGl0ZWxpc3QuaW5jbHVkZXMoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgIGlmICghYnlDaGFubmVsW2NoYW5uZWxdKSB7XG4gICAgICAgICAgICAgICAgYnlDaGFubmVsW2NoYW5uZWxdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieUNoYW5uZWxbY2hhbm5lbF0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coW1xuICAgICAgICBgJHt3cmFwKENPTE9SU19NQVAuYmx1ZSwgYFske3N0ZXB9OndyaXRlc11gKX1gLFxuICAgICAgICBgXFx4MWJbMW0gRmluaXNoZWQgc3RlcCAke3N0ZXB9IHdpdGggd3JpdGVzIHRvICR7T2JqZWN0LmtleXMoYnlDaGFubmVsKS5sZW5ndGh9IGNoYW5uZWwke09iamVjdC5rZXlzKGJ5Q2hhbm5lbCkubGVuZ3RoICE9PSAxID8gXCJzXCIgOiBcIlwifTpcXHgxYlswbVxcbmAsXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGJ5Q2hhbm5lbClcbiAgICAgICAgICAgIC5tYXAoKFtuYW1lLCB2YWxzXSkgPT4gYC0gJHt3cmFwKENPTE9SU19NQVAueWVsbG93LCBuYW1lKX0gLT4gJHt2YWxzXG4gICAgICAgICAgICAubWFwKCh2KSA9PiBKU09OLnN0cmluZ2lmeSh2KSlcbiAgICAgICAgICAgIC5qb2luKFwiLCBcIil9YClcbiAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpLFxuICAgIF0uam9pbihcIlwiKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJ1Zy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/debug.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Channel: () => (/* binding */ Channel),\n/* harmony export */   Pregel: () => (/* binding */ Pregel)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/langgraph-checkpoint */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/index.js\");\n/* harmony import */ var _channels_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../channels/base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/base.js\");\n/* harmony import */ var _read_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./read.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/read.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/validate.js\");\n/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./io.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/io.js\");\n/* harmony import */ var _debug_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./debug.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/debug.js\");\n/* harmony import */ var _write_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./write.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/write.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _algo_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./algo.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/algo.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/index.js\");\n/* harmony import */ var _utils_subgraph_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/subgraph.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js\");\n/* harmony import */ var _loop_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./loop.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/loop.js\");\n/* harmony import */ var _managed_base_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../managed/base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/managed/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _utils_config_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/config.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/config.js\");\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./messages.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/messages.js\");\n/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./runner.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/runner.js\");\n/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./stream.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/stream.js\");\n/* eslint-disable no-param-reassign */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Utility class for working with channels in the Pregel system.\n * Provides static methods for subscribing to channels and writing to them.\n *\n * Channels are the communication pathways between nodes in a Pregel graph.\n * They enable message passing and state updates between different parts of the graph.\n */\nclass Channel {\n    static subscribeTo(channels, options) {\n        const { key, tags } = {\n            key: undefined,\n            tags: undefined,\n            ...(options ?? {}),\n        };\n        if (Array.isArray(channels) && key !== undefined) {\n            throw new Error(\"Can't specify a key when subscribing to multiple channels\");\n        }\n        let channelMappingOrArray;\n        if (isString(channels)) {\n            if (key) {\n                channelMappingOrArray = { [key]: channels };\n            }\n            else {\n                channelMappingOrArray = [channels];\n            }\n        }\n        else {\n            channelMappingOrArray = Object.fromEntries(channels.map((chan) => [chan, chan]));\n        }\n        const triggers = Array.isArray(channels) ? channels : [channels];\n        return new _read_js__WEBPACK_IMPORTED_MODULE_3__.PregelNode({\n            channels: channelMappingOrArray,\n            triggers,\n            tags,\n        });\n    }\n    /**\n     * Creates a ChannelWrite that specifies how to write values to channels.\n     * This is used to define how nodes send output to channels.\n     *\n     * @example\n     * ```typescript\n     * // Write to multiple channels\n     * const write = Channel.writeTo([\"output\", \"state\"]);\n     *\n     * // Write with specific values\n     * const write = Channel.writeTo([\"output\"], {\n     *   state: \"completed\",\n     *   result: calculateResult()\n     * });\n     *\n     * // Write with a transformation function\n     * const write = Channel.writeTo([\"output\"], {\n     *   result: (x) => processResult(x)\n     * });\n     * ```\n     *\n     * @param channels - Array of channel names to write to\n     * @param writes - Optional map of channel names to values or transformations\n     * @returns A ChannelWrite object that can be used to write to the specified channels\n     */\n    static writeTo(channels, writes) {\n        const channelWriteEntries = [];\n        for (const channel of channels) {\n            channelWriteEntries.push({\n                channel,\n                value: _write_js__WEBPACK_IMPORTED_MODULE_7__.PASSTHROUGH,\n                skipNone: false,\n            });\n        }\n        for (const [key, value] of Object.entries(writes ?? {})) {\n            if (_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(value) || typeof value === \"function\") {\n                channelWriteEntries.push({\n                    channel: key,\n                    value: _write_js__WEBPACK_IMPORTED_MODULE_7__.PASSTHROUGH,\n                    skipNone: true,\n                    mapper: (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(value),\n                });\n            }\n            else {\n                channelWriteEntries.push({\n                    channel: key,\n                    value,\n                    skipNone: false,\n                });\n            }\n        }\n        return new _write_js__WEBPACK_IMPORTED_MODULE_7__.ChannelWrite(channelWriteEntries);\n    }\n}\n/**\n * The Pregel class is the core runtime engine of LangGraph, implementing a message-passing graph computation model\n * inspired by [Google's Pregel system](https://research.google/pubs/pregel-a-system-for-large-scale-graph-processing/).\n * It provides the foundation for building reliable, controllable agent workflows that can evolve state over time.\n *\n * Key features:\n * - Message passing between nodes in discrete \"supersteps\"\n * - Built-in persistence layer through checkpointers\n * - First-class streaming support for values, updates, and events\n * - Human-in-the-loop capabilities via interrupts\n * - Support for parallel node execution within supersteps\n *\n * The Pregel class is not intended to be instantiated directly by consumers. Instead, use the following higher-level APIs:\n * - {@link StateGraph}: The main graph class for building agent workflows\n *   - Compiling a {@link StateGraph} will return a {@link CompiledGraph} instance, which extends `Pregel`\n * - Functional API: A declarative approach using tasks and entrypoints\n *   - A `Pregel` instance is returned by the {@link entrypoint} function\n *\n * @example\n * ```typescript\n * // Using StateGraph API\n * const graph = new StateGraph(annotation)\n *   .addNode(\"nodeA\", myNodeFunction)\n *   .addEdge(\"nodeA\", \"nodeB\")\n *   .compile();\n *\n * // The compiled graph is a Pregel instance\n * const result = await graph.invoke(input);\n * ```\n *\n * @example\n * ```typescript\n * // Using Functional API\n * import { task, entrypoint } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * // Define tasks that can be composed\n * const addOne = task(\"add\", async (x: number) => x + 1);\n *\n * // Create a workflow using the entrypoint function\n * const workflow = entrypoint({\n *   name: \"workflow\",\n *   checkpointer: new MemorySaver()\n * }, async (numbers: number[]) => {\n *   // Tasks can be run in parallel\n *   const results = await Promise.all(numbers.map(n => addOne(n)));\n *   return results;\n * });\n *\n * // The workflow is a Pregel instance\n * const result = await workflow.invoke([1, 2, 3]); // Returns [2, 3, 4]\n * ```\n *\n * @typeParam Nodes - Mapping of node names to their {@link PregelNode} implementations\n * @typeParam Channels - Mapping of channel names to their {@link BaseChannel} or {@link ManagedValueSpec} implementations\n * @typeParam ConfigurableFieldType - Type of configurable fields that can be passed to the graph\n * @typeParam InputType - Type of input values accepted by the graph\n * @typeParam OutputType - Type of output values produced by the graph\n */\nclass Pregel extends _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    /**\n     * Name of the class when serialized\n     * @internal\n     */\n    static lc_name() {\n        return \"LangGraph\";\n    }\n    /**\n     * Constructor for Pregel - meant for internal use only.\n     *\n     * @internal\n     */\n    constructor(fields) {\n        super(fields);\n        /** @internal LangChain namespace for serialization necessary because Pregel extends Runnable */\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langgraph\", \"pregel\"]\n        });\n        /** @internal Flag indicating this is a Pregel instance - necessary for serialization */\n        Object.defineProperty(this, \"lg_is_pregel\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The nodes in the graph, mapping node names to their PregelNode instances */\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The channels in the graph, mapping channel names to their BaseChannel or ManagedValueSpec instances */\n        Object.defineProperty(this, \"channels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The input channels for the graph. These channels receive the initial input when the graph is invoked.\n         * Can be a single channel key or an array of channel keys.\n         */\n        Object.defineProperty(this, \"inputChannels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The output channels for the graph. These channels contain the final output when the graph completes.\n         * Can be a single channel key or an array of channel keys.\n         */\n        Object.defineProperty(this, \"outputChannels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Whether to automatically validate the graph structure when it is compiled. Defaults to true. */\n        Object.defineProperty(this, \"autoValidate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * The streaming modes enabled for this graph. Defaults to [\"values\"].\n         * Supported modes:\n         * - \"values\": Streams the full state after each step\n         * - \"updates\": Streams state updates after each step\n         * - \"messages\": Streams messages from within nodes\n         * - \"custom\": Streams custom events from within nodes\n         * - \"debug\": Streams events related to the execution of the graph - useful for tracing & debugging graph execution\n         */\n        Object.defineProperty(this, \"streamMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"values\"]\n        });\n        /**\n         * Optional channels to stream. If not specified, all channels will be streamed.\n         * Can be a single channel key or an array of channel keys.\n         */\n        Object.defineProperty(this, \"streamChannels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Optional array of node names or \"all\" to interrupt after executing these nodes.\n         * Used for implementing human-in-the-loop workflows.\n         */\n        Object.defineProperty(this, \"interruptAfter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Optional array of node names or \"all\" to interrupt before executing these nodes.\n         * Used for implementing human-in-the-loop workflows.\n         */\n        Object.defineProperty(this, \"interruptBefore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Optional timeout in milliseconds for the execution of each superstep */\n        Object.defineProperty(this, \"stepTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Whether to enable debug logging. Defaults to false. */\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /**\n         * Optional checkpointer for persisting graph state.\n         * When provided, saves a checkpoint of the graph state at every superstep.\n         * When false or undefined, checkpointing is disabled, and the graph will not be able to save or restore state.\n         */\n        Object.defineProperty(this, \"checkpointer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Optional retry policy for handling failures in node execution */\n        Object.defineProperty(this, \"retryPolicy\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The default configuration for graph execution, can be overridden on a per-invocation basis */\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Optional long-term memory store for the graph, allows for persistance & retrieval of data across threads\n         */\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        let { streamMode } = fields;\n        if (streamMode != null && !Array.isArray(streamMode)) {\n            streamMode = [streamMode];\n        }\n        this.nodes = fields.nodes;\n        this.channels = fields.channels;\n        this.autoValidate = fields.autoValidate ?? this.autoValidate;\n        this.streamMode = streamMode ?? this.streamMode;\n        this.inputChannels = fields.inputChannels;\n        this.outputChannels = fields.outputChannels;\n        this.streamChannels = fields.streamChannels ?? this.streamChannels;\n        this.interruptAfter = fields.interruptAfter;\n        this.interruptBefore = fields.interruptBefore;\n        this.stepTimeout = fields.stepTimeout ?? this.stepTimeout;\n        this.debug = fields.debug ?? this.debug;\n        this.checkpointer = fields.checkpointer;\n        this.retryPolicy = fields.retryPolicy;\n        this.config = fields.config;\n        this.store = fields.store;\n        this.name = fields.name;\n        if (this.autoValidate) {\n            this.validate();\n        }\n    }\n    /**\n     * Creates a new instance of the Pregel graph with updated configuration.\n     * This method follows the immutable pattern - instead of modifying the current instance,\n     * it returns a new instance with the merged configuration.\n     *\n     * @example\n     * ```typescript\n     * // Create a new instance with debug enabled\n     * const debugGraph = graph.withConfig({ debug: true });\n     *\n     * // Create a new instance with a specific thread ID\n     * const threadGraph = graph.withConfig({\n     *   configurable: { thread_id: \"123\" }\n     * });\n     * ```\n     *\n     * @param config - The configuration to merge with the current configuration\n     * @returns A new Pregel instance with the merged configuration\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Remove ignore when we remove support for 0.2 versions of core\n    withConfig(config) {\n        const mergedConfig = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(this.config, config);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({ ...this, config: mergedConfig });\n    }\n    /**\n     * Validates the graph structure to ensure it is well-formed.\n     * Checks for:\n     * - No orphaned nodes\n     * - Valid input/output channel configurations\n     * - Valid interrupt configurations\n     *\n     * @returns this - The Pregel instance for method chaining\n     * @throws {GraphValidationError} If the graph structure is invalid\n     */\n    validate() {\n        (0,_validate_js__WEBPACK_IMPORTED_MODULE_4__.validateGraph)({\n            nodes: this.nodes,\n            channels: this.channels,\n            outputChannels: this.outputChannels,\n            inputChannels: this.inputChannels,\n            streamChannels: this.streamChannels,\n            interruptAfterNodes: this.interruptAfter,\n            interruptBeforeNodes: this.interruptBefore,\n        });\n        return this;\n    }\n    /**\n     * Gets a list of all channels that should be streamed.\n     * If streamChannels is specified, returns those channels.\n     * Otherwise, returns all channels in the graph.\n     *\n     * @returns Array of channel keys to stream\n     */\n    get streamChannelsList() {\n        if (Array.isArray(this.streamChannels)) {\n            return this.streamChannels;\n        }\n        else if (this.streamChannels) {\n            return [this.streamChannels];\n        }\n        else {\n            return Object.keys(this.channels);\n        }\n    }\n    /**\n     * Gets the channels to stream in their original format.\n     * If streamChannels is specified, returns it as-is (either single key or array).\n     * Otherwise, returns all channels in the graph as an array.\n     *\n     * @returns Channel keys to stream, either as a single key or array\n     */\n    get streamChannelsAsIs() {\n        if (this.streamChannels) {\n            return this.streamChannels;\n        }\n        else {\n            return Object.keys(this.channels);\n        }\n    }\n    /**\n     * Gets a drawable representation of the graph structure.\n     * This is an async version of getGraph() and is the preferred method to use.\n     *\n     * @param config - Configuration for generating the graph visualization\n     * @returns A representation of the graph that can be visualized\n     */\n    async getGraphAsync(config) {\n        return this.getGraph(config);\n    }\n    /**\n     * Gets all subgraphs within this graph.\n     * A subgraph is a Pregel instance that is nested within a node of this graph.\n     *\n     * @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release.\n     * @param namespace - Optional namespace to filter subgraphs\n     * @param recurse - Whether to recursively get subgraphs of subgraphs\n     * @returns Generator yielding tuples of [name, subgraph]\n     */\n    *getSubgraphs(namespace, recurse\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        for (const [name, node] of Object.entries(this.nodes)) {\n            // filter by prefix\n            if (namespace !== undefined) {\n                if (!namespace.startsWith(name)) {\n                    continue;\n                }\n            }\n            const candidates = node.subgraphs?.length ? node.subgraphs : [node.bound];\n            for (const candidate of candidates) {\n                const graph = (0,_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_12__.findSubgraphPregel)(candidate);\n                if (graph !== undefined) {\n                    if (name === namespace) {\n                        yield [name, graph];\n                        return;\n                    }\n                    if (namespace === undefined) {\n                        yield [name, graph];\n                    }\n                    if (recurse) {\n                        let newNamespace = namespace;\n                        if (namespace !== undefined) {\n                            newNamespace = namespace.slice(name.length + 1);\n                        }\n                        for (const [subgraphName, subgraph] of graph.getSubgraphs(newNamespace, recurse)) {\n                            yield [\n                                `${name}${_constants_js__WEBPACK_IMPORTED_MODULE_8__.CHECKPOINT_NAMESPACE_SEPARATOR}${subgraphName}`,\n                                subgraph,\n                            ];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Gets all subgraphs within this graph asynchronously.\n     * A subgraph is a Pregel instance that is nested within a node of this graph.\n     *\n     * @param namespace - Optional namespace to filter subgraphs\n     * @param recurse - Whether to recursively get subgraphs of subgraphs\n     * @returns AsyncGenerator yielding tuples of [name, subgraph]\n     */\n    async *getSubgraphsAsync(namespace, recurse\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        yield* this.getSubgraphs(namespace, recurse);\n    }\n    /**\n     * Prepares a state snapshot from saved checkpoint data.\n     * This is an internal method used by getState and getStateHistory.\n     *\n     * @param config - Configuration for preparing the snapshot\n     * @param saved - Optional saved checkpoint data\n     * @param subgraphCheckpointer - Optional checkpointer for subgraphs\n     * @param applyPendingWrites - Whether to apply pending writes to tasks and then to channels\n     * @returns A snapshot of the graph state\n     * @internal\n     */\n    async _prepareStateSnapshot({ config, saved, subgraphCheckpointer, applyPendingWrites = false, }) {\n        if (saved === undefined) {\n            return {\n                values: {},\n                next: [],\n                config,\n                tasks: [],\n            };\n        }\n        // Create all channels\n        const { managed } = await this.prepareSpecs(config, {\n            skipManaged: true,\n        });\n        const channels = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.emptyChannels)(this.channels, saved.checkpoint);\n        // Apply null writes first (from NULL_TASK_ID)\n        if (saved.pendingWrites?.length) {\n            const nullWrites = saved.pendingWrites\n                .filter(([taskId, _]) => taskId === _constants_js__WEBPACK_IMPORTED_MODULE_8__.NULL_TASK_ID)\n                .map(([_, channel, value]) => [String(channel), value]);\n            if (nullWrites.length > 0) {\n                (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(saved.checkpoint, channels, [\n                    {\n                        name: _constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT,\n                        writes: nullWrites,\n                        triggers: [],\n                    },\n                ]);\n            }\n        }\n        // Prepare next tasks\n        const nextTasks = Object.values((0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._prepareNextTasks)(saved.checkpoint, saved.pendingWrites, this.nodes, channels, managed, saved.config, true, { step: (saved.metadata?.step ?? -1) + 1, store: this.store }));\n        // Find subgraphs\n        const subgraphs = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.gatherIterator)(this.getSubgraphsAsync());\n        const parentNamespace = saved.config.configurable?.checkpoint_ns ?? \"\";\n        const taskStates = {};\n        // Prepare task states for subgraphs\n        for (const task of nextTasks) {\n            const matchingSubgraph = subgraphs.find(([name]) => name === task.name);\n            if (!matchingSubgraph) {\n                continue;\n            }\n            // assemble checkpoint_ns for this task\n            let taskNs = `${String(task.name)}${_constants_js__WEBPACK_IMPORTED_MODULE_8__.CHECKPOINT_NAMESPACE_END}${task.id}`;\n            if (parentNamespace) {\n                taskNs = `${parentNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_8__.CHECKPOINT_NAMESPACE_SEPARATOR}${taskNs}`;\n            }\n            if (subgraphCheckpointer === undefined) {\n                // set config as signal that subgraph checkpoints exist\n                const config = {\n                    configurable: {\n                        thread_id: saved.config.configurable?.thread_id,\n                        checkpoint_ns: taskNs,\n                    },\n                };\n                taskStates[task.id] = config;\n            }\n            else {\n                // get the state of the subgraph\n                const subgraphConfig = {\n                    configurable: {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER]: subgraphCheckpointer,\n                        thread_id: saved.config.configurable?.thread_id,\n                        checkpoint_ns: taskNs,\n                    },\n                };\n                const pregel = matchingSubgraph[1];\n                taskStates[task.id] = await pregel.getState(subgraphConfig, {\n                    subgraphs: true,\n                });\n            }\n        }\n        // Apply pending writes to tasks and then to channels if applyPendingWrites is true\n        if (applyPendingWrites && saved.pendingWrites?.length) {\n            // Map task IDs to task objects for easy lookup\n            const nextTaskById = Object.fromEntries(nextTasks.map((task) => [task.id, task]));\n            // Apply pending writes to the appropriate tasks\n            for (const [taskId, channel, value] of saved.pendingWrites) {\n                // Skip special channels and tasks not in nextTasks\n                if ([_constants_js__WEBPACK_IMPORTED_MODULE_8__.ERROR, _constants_js__WEBPACK_IMPORTED_MODULE_8__.INTERRUPT, _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.SCHEDULED].includes(channel)) {\n                    continue;\n                }\n                if (!(taskId in nextTaskById)) {\n                    continue;\n                }\n                // Add the write to the task\n                nextTaskById[taskId].writes.push([String(channel), value]);\n            }\n            // Apply writes from tasks that have writes\n            const tasksWithWrites = nextTasks.filter((task) => task.writes.length > 0);\n            if (tasksWithWrites.length > 0) {\n                (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(saved.checkpoint, channels, tasksWithWrites);\n            }\n        }\n        // Preserve thread_id from the config in metadata\n        let metadata = saved?.metadata;\n        if (metadata && saved?.config?.configurable?.thread_id) {\n            metadata = {\n                ...metadata,\n                thread_id: saved.config.configurable.thread_id,\n            };\n        }\n        // Filter next tasks - only include tasks without writes\n        const nextList = nextTasks\n            .filter((task) => task.writes.length === 0)\n            .map((task) => task.name);\n        // assemble the state snapshot\n        return {\n            values: (0,_io_js__WEBPACK_IMPORTED_MODULE_5__.readChannels)(channels, this.streamChannelsAsIs),\n            next: nextList,\n            tasks: (0,_debug_js__WEBPACK_IMPORTED_MODULE_6__.tasksWithWrites)(nextTasks, saved?.pendingWrites ?? [], taskStates),\n            metadata,\n            config: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(saved.config, saved.metadata),\n            createdAt: saved.checkpoint.ts,\n            parentConfig: saved.parentConfig,\n        };\n    }\n    /**\n     * Gets the current state of the graph.\n     * Requires a checkpointer to be configured.\n     *\n     * @param config - Configuration for retrieving the state\n     * @param options - Additional options\n     * @returns A snapshot of the current graph state\n     * @throws {GraphValueError} If no checkpointer is configured\n     */\n    async getState(config, options) {\n        const checkpointer = config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n        if (!checkpointer) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.GraphValueError(\"No checkpointer set\");\n        }\n        const checkpointNamespace = config.configurable?.checkpoint_ns ?? \"\";\n        if (checkpointNamespace !== \"\" &&\n            config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] === undefined) {\n            // remove task_ids from checkpoint_ns\n            const recastNamespace = (0,_utils_config_js__WEBPACK_IMPORTED_MODULE_16__.recastCheckpointNamespace)(checkpointNamespace);\n            for await (const [name, subgraph] of this.getSubgraphsAsync(recastNamespace, true)) {\n                if (name === recastNamespace) {\n                    return await subgraph.getState((0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.patchConfigurable)(config, {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER]: checkpointer,\n                    }), { subgraphs: options?.subgraphs });\n                }\n            }\n            throw new Error(`Subgraph with namespace \"${recastNamespace}\" not found.`);\n        }\n        const mergedConfig = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(this.config, config);\n        const saved = await checkpointer.getTuple(config);\n        const snapshot = await this._prepareStateSnapshot({\n            config: mergedConfig,\n            saved,\n            subgraphCheckpointer: options?.subgraphs ? checkpointer : undefined,\n            applyPendingWrites: !config.configurable?.checkpoint_id,\n        });\n        return snapshot;\n    }\n    /**\n     * Gets the history of graph states.\n     * Requires a checkpointer to be configured.\n     * Useful for:\n     * - Debugging execution history\n     * - Implementing time travel\n     * - Analyzing graph behavior\n     *\n     * @param config - Configuration for retrieving the history\n     * @param options - Options for filtering the history\n     * @returns An async iterator of state snapshots\n     * @throws {Error} If no checkpointer is configured\n     */\n    async *getStateHistory(config, options) {\n        const checkpointer = config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n        if (!checkpointer) {\n            throw new Error(\"No checkpointer set\");\n        }\n        const checkpointNamespace = config.configurable?.checkpoint_ns ?? \"\";\n        if (checkpointNamespace !== \"\" &&\n            config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] === undefined) {\n            const recastNamespace = (0,_utils_config_js__WEBPACK_IMPORTED_MODULE_16__.recastCheckpointNamespace)(checkpointNamespace);\n            // find the subgraph with the matching name\n            for await (const [name, pregel] of this.getSubgraphsAsync(recastNamespace, true)) {\n                if (name === recastNamespace) {\n                    yield* pregel.getStateHistory((0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.patchConfigurable)(config, {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER]: checkpointer,\n                    }), options);\n                    return;\n                }\n            }\n            throw new Error(`Subgraph with namespace \"${recastNamespace}\" not found.`);\n        }\n        const mergedConfig = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(this.config, config, {\n            configurable: { checkpoint_ns: checkpointNamespace },\n        });\n        for await (const checkpointTuple of checkpointer.list(mergedConfig, options)) {\n            yield this._prepareStateSnapshot({\n                config: checkpointTuple.config,\n                saved: checkpointTuple,\n            });\n        }\n    }\n    /**\n     * Apply updates to the graph state in bulk.\n     * Requires a checkpointer to be configured.\n     *\n     * This method is useful for recreating a thread\n     * from a list of updates, especially if a checkpoint\n     * is created as a result of multiple tasks.\n     *\n     * @internal The API might change in the future.\n     *\n     * @param startConfig - Configuration for the update\n     * @param updates - The list of updates to apply to graph state\n     * @returns Updated configuration\n     * @throws {GraphValueError} If no checkpointer is configured\n     * @throws {InvalidUpdateError} If the update cannot be attributed to a node or an update can be only applied in sequence.\n     */\n    async bulkUpdateState(startConfig, supersteps) {\n        const checkpointer = startConfig.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n        if (!checkpointer) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.GraphValueError(\"No checkpointer set\");\n        }\n        if (supersteps.length === 0) {\n            throw new Error(\"No supersteps provided\");\n        }\n        if (supersteps.some((s) => s.updates.length === 0)) {\n            throw new Error(\"No updates provided\");\n        }\n        // delegate to subgraph\n        const checkpointNamespace = startConfig.configurable?.checkpoint_ns ?? \"\";\n        if (checkpointNamespace !== \"\" &&\n            startConfig.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] === undefined) {\n            // remove task_ids from checkpoint_ns\n            const recastNamespace = (0,_utils_config_js__WEBPACK_IMPORTED_MODULE_16__.recastCheckpointNamespace)(checkpointNamespace);\n            // find the subgraph with the matching name\n            // eslint-disable-next-line no-unreachable-loop\n            for await (const [, pregel] of this.getSubgraphsAsync(recastNamespace, true)) {\n                return await pregel.bulkUpdateState((0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.patchConfigurable)(startConfig, {\n                    [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER]: checkpointer,\n                }), supersteps);\n            }\n            throw new Error(`Subgraph \"${recastNamespace}\" not found`);\n        }\n        const updateSuperStep = async (inputConfig, updates) => {\n            // get last checkpoint\n            const config = this.config\n                ? (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(this.config, inputConfig)\n                : inputConfig;\n            const saved = await checkpointer.getTuple(config);\n            const checkpoint = saved !== undefined\n                ? (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.copyCheckpoint)(saved.checkpoint)\n                : (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.emptyCheckpoint)();\n            const checkpointPreviousVersions = {\n                ...saved?.checkpoint.channel_versions,\n            };\n            const step = saved?.metadata?.step ?? -1;\n            // merge configurable fields with previous checkpoint config\n            let checkpointConfig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.patchConfigurable)(config, {\n                checkpoint_ns: config.configurable?.checkpoint_ns ?? \"\",\n            });\n            let checkpointMetadata = config.metadata ?? {};\n            if (saved?.config.configurable) {\n                checkpointConfig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.patchConfigurable)(config, saved.config.configurable);\n                checkpointMetadata = {\n                    ...saved.metadata,\n                    ...checkpointMetadata,\n                };\n            }\n            // Find last node that updated the state, if not provided\n            const { values, asNode } = updates[0];\n            if (values == null && asNode === undefined) {\n                if (updates.length > 1) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Cannot create empty checkpoint with multiple updates`);\n                }\n                const nextConfig = await checkpointer.put(checkpointConfig, (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, undefined, step), {\n                    source: \"update\",\n                    step: step + 1,\n                    writes: {},\n                    parents: saved?.metadata?.parents ?? {},\n                }, {});\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(nextConfig, saved ? saved.metadata : undefined);\n            }\n            // update channels\n            const channels = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.emptyChannels)(this.channels, checkpoint);\n            // Pass `skipManaged: true` as managed values are not used/relevant in update state calls.\n            const { managed } = await this.prepareSpecs(config, {\n                skipManaged: true,\n            });\n            if (values === null && asNode === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END) {\n                if (updates.length > 1) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Cannot apply multiple updates when clearing state`);\n                }\n                if (saved) {\n                    // tasks for this checkpoint\n                    const nextTasks = (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._prepareNextTasks)(checkpoint, saved.pendingWrites || [], this.nodes, channels, managed, saved.config, true, {\n                        step: (saved.metadata?.step ?? -1) + 1,\n                        checkpointer: this.checkpointer || undefined,\n                        store: this.store,\n                    });\n                    // apply null writes\n                    const nullWrites = (saved.pendingWrites || [])\n                        .filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_8__.NULL_TASK_ID)\n                        .map((w) => w.slice(1));\n                    if (nullWrites.length > 0) {\n                        (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(saved.checkpoint, channels, [\n                            {\n                                name: _constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT,\n                                writes: nullWrites,\n                                triggers: [],\n                            },\n                        ]);\n                    }\n                    // apply writes from tasks that already ran\n                    for (const [taskId, k, v] of saved.pendingWrites || []) {\n                        if ([_constants_js__WEBPACK_IMPORTED_MODULE_8__.ERROR, _constants_js__WEBPACK_IMPORTED_MODULE_8__.INTERRUPT, _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.SCHEDULED].includes(k)) {\n                            continue;\n                        }\n                        if (!(taskId in nextTasks)) {\n                            continue;\n                        }\n                        nextTasks[taskId].writes.push([k, v]);\n                    }\n                    // clear all current tasks\n                    (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(checkpoint, channels, Object.values(nextTasks));\n                }\n                // save checkpoint\n                const nextConfig = await checkpointer.put(checkpointConfig, (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, undefined, step), {\n                    ...checkpointMetadata,\n                    source: \"update\",\n                    step: step + 1,\n                    writes: {},\n                    parents: saved?.metadata?.parents ?? {},\n                }, {});\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(nextConfig, saved ? saved.metadata : undefined);\n            }\n            if (values == null && asNode === _constants_js__WEBPACK_IMPORTED_MODULE_8__.COPY) {\n                if (updates.length > 1) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Cannot copy checkpoint with multiple updates`);\n                }\n                const nextConfig = await checkpointer.put(saved?.parentConfig ?? checkpointConfig, (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, undefined, step), {\n                    source: \"fork\",\n                    step: step + 1,\n                    writes: {},\n                    parents: saved?.metadata?.parents ?? {},\n                }, {});\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(nextConfig, saved ? saved.metadata : undefined);\n            }\n            if (asNode === _constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT) {\n                if (updates.length > 1) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Cannot apply multiple updates when updating as input`);\n                }\n                const inputWrites = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.gatherIterator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapInput)(this.inputChannels, values));\n                if (inputWrites.length === 0) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Received no input writes for ${JSON.stringify(this.inputChannels, null, 2)}`);\n                }\n                // apply to checkpoint\n                (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(checkpoint, channels, [\n                    {\n                        name: _constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT,\n                        writes: inputWrites,\n                        triggers: [],\n                    },\n                ], checkpointer.getNextVersion.bind(this.checkpointer));\n                // apply input write to channels\n                const nextStep = saved?.metadata?.step != null ? saved.metadata.step + 1 : -1;\n                const nextConfig = await checkpointer.put(checkpointConfig, (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, channels, nextStep), {\n                    source: \"input\",\n                    step: nextStep,\n                    writes: Object.fromEntries(inputWrites),\n                    parents: saved?.metadata?.parents ?? {},\n                }, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.getNewChannelVersions)(checkpointPreviousVersions, checkpoint.channel_versions));\n                // Store the writes\n                await checkpointer.putWrites(nextConfig, inputWrites, (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(_constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT, checkpoint.id));\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(nextConfig, saved ? saved.metadata : undefined);\n            }\n            // apply pending writes, if not on specific checkpoint\n            if (config.configurable?.checkpoint_id === undefined &&\n                saved?.pendingWrites !== undefined &&\n                saved.pendingWrites.length > 0) {\n                // tasks for this checkpoint\n                const nextTasks = (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._prepareNextTasks)(checkpoint, saved.pendingWrites, this.nodes, channels, managed, saved.config, true, {\n                    store: this.store,\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    checkpointer: this.checkpointer,\n                    step: (saved.metadata?.step ?? -1) + 1,\n                });\n                // apply null writes\n                const nullWrites = (saved.pendingWrites ?? [])\n                    .filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_8__.NULL_TASK_ID)\n                    .map((w) => w.slice(1));\n                if (nullWrites.length > 0) {\n                    (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(saved.checkpoint, channels, [\n                        {\n                            name: _constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT,\n                            writes: nullWrites,\n                            triggers: [],\n                        },\n                    ]);\n                }\n                // apply writes\n                for (const [tid, k, v] of saved.pendingWrites) {\n                    if ([_constants_js__WEBPACK_IMPORTED_MODULE_8__.ERROR, _constants_js__WEBPACK_IMPORTED_MODULE_8__.INTERRUPT, _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.SCHEDULED].includes(k) ||\n                        nextTasks[tid] === undefined) {\n                        continue;\n                    }\n                    nextTasks[tid].writes.push([k, v]);\n                }\n                const tasks = Object.values(nextTasks).filter((task) => {\n                    return task.writes.length > 0;\n                });\n                if (tasks.length > 0) {\n                    (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(checkpoint, channels, tasks);\n                }\n            }\n            const nonNullVersion = Object.values(checkpoint.versions_seen)\n                .map((seenVersions) => {\n                return Object.values(seenVersions);\n            })\n                .flat()\n                .find((v) => !!v);\n            const validUpdates = [];\n            if (updates.length === 1) {\n                // eslint-disable-next-line prefer-const\n                let { values, asNode } = updates[0];\n                if (asNode === undefined && Object.keys(this.nodes).length === 1) {\n                    // if only one node, use it\n                    [asNode] = Object.keys(this.nodes);\n                }\n                else if (asNode === undefined && nonNullVersion === undefined) {\n                    if (typeof this.inputChannels === \"string\" &&\n                        this.nodes[this.inputChannels] !== undefined) {\n                        asNode = this.inputChannels;\n                    }\n                }\n                else if (asNode === undefined) {\n                    const lastSeenByNode = Object.entries(checkpoint.versions_seen)\n                        .map(([n, seen]) => {\n                        return Object.values(seen).map((v) => {\n                            return [v, n];\n                        });\n                    })\n                        .flat()\n                        .sort(([aNumber], [bNumber]) => (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.compareChannelVersions)(aNumber, bNumber));\n                    // if two nodes updated the state at the same time, it's ambiguous\n                    if (lastSeenByNode) {\n                        if (lastSeenByNode.length === 1) {\n                            // eslint-disable-next-line prefer-destructuring\n                            asNode = lastSeenByNode[0][1];\n                        }\n                        else if (lastSeenByNode[lastSeenByNode.length - 1][0] !==\n                            lastSeenByNode[lastSeenByNode.length - 2][0]) {\n                            // eslint-disable-next-line prefer-destructuring\n                            asNode = lastSeenByNode[lastSeenByNode.length - 1][1];\n                        }\n                    }\n                }\n                if (asNode === undefined) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Ambiguous update, specify \"asNode\"`);\n                }\n                validUpdates.push({ values, asNode });\n            }\n            else {\n                for (const { asNode, values } of updates) {\n                    if (asNode == null) {\n                        throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`\"asNode\" is required when applying multiple updates`);\n                    }\n                    validUpdates.push({ values, asNode });\n                }\n            }\n            const tasks = [];\n            for (const { asNode, values } of validUpdates) {\n                if (this.nodes[asNode] === undefined) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Node \"${asNode.toString()}\" does not exist`);\n                }\n                // run all writers of the chosen node\n                const writers = this.nodes[asNode].getWriters();\n                if (!writers.length) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`No writers found for node \"${asNode.toString()}\"`);\n                }\n                tasks.push({\n                    name: asNode,\n                    input: values,\n                    proc: writers.length > 1\n                        ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnableSequence.from(writers, {\n                                omitSequenceTags: true,\n                            })\n                        : writers[0],\n                    writes: [],\n                    triggers: [_constants_js__WEBPACK_IMPORTED_MODULE_8__.INTERRUPT],\n                    id: (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(_constants_js__WEBPACK_IMPORTED_MODULE_8__.INTERRUPT, checkpoint.id),\n                    writers: [],\n                });\n            }\n            for (const task of tasks) {\n                // execute task\n                await task.proc.invoke(task.input, (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.patchConfig)({\n                    ...config,\n                    store: config?.store ?? this.store,\n                }, {\n                    runName: config.runName ?? `${this.getName()}UpdateState`,\n                    configurable: {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_SEND]: (items) => task.writes.push(...items),\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_READ]: (select_, fresh_ = false) => (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._localRead)(step, checkpoint, channels, managed, \n                        // TODO: Why does keyof StrRecord allow number and symbol?\n                        task, select_, fresh_),\n                    },\n                }));\n            }\n            for (const task of tasks) {\n                // channel writes are saved to current checkpoint\n                const channelWrites = task.writes.filter((w) => w[0] !== _constants_js__WEBPACK_IMPORTED_MODULE_8__.PUSH);\n                // save task writes\n                if (saved !== undefined && channelWrites.length > 0) {\n                    await checkpointer.putWrites(checkpointConfig, channelWrites, task.id);\n                }\n            }\n            // apply to checkpoint\n            // TODO: Why does keyof StrRecord allow number and symbol?\n            (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(checkpoint, channels, tasks, checkpointer.getNextVersion.bind(this.checkpointer));\n            const newVersions = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.getNewChannelVersions)(checkpointPreviousVersions, checkpoint.channel_versions);\n            const nextConfig = await checkpointer.put(checkpointConfig, (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, channels, step + 1), {\n                source: \"update\",\n                step: step + 1,\n                writes: Object.fromEntries(validUpdates.map((update) => [update.asNode, update.values])),\n                parents: saved?.metadata?.parents ?? {},\n            }, newVersions);\n            for (const task of tasks) {\n                // push writes are saved to next checkpoint\n                const pushWrites = task.writes.filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_8__.PUSH);\n                if (pushWrites.length > 0) {\n                    await checkpointer.putWrites(nextConfig, pushWrites, task.id);\n                }\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(nextConfig, saved ? saved.metadata : undefined);\n        };\n        let currentConfig = startConfig;\n        for (const { updates } of supersteps) {\n            currentConfig = await updateSuperStep(currentConfig, updates);\n        }\n        return currentConfig;\n    }\n    /**\n     * Updates the state of the graph with new values.\n     * Requires a checkpointer to be configured.\n     *\n     * This method can be used for:\n     * - Implementing human-in-the-loop workflows\n     * - Modifying graph state during breakpoints\n     * - Integrating external inputs into the graph\n     *\n     * @param inputConfig - Configuration for the update\n     * @param values - The values to update the state with\n     * @param asNode - Optional node name to attribute the update to\n     * @returns Updated configuration\n     * @throws {GraphValueError} If no checkpointer is configured\n     * @throws {InvalidUpdateError} If the update cannot be attributed to a node\n     */\n    async updateState(inputConfig, values, asNode) {\n        return this.bulkUpdateState(inputConfig, [\n            { updates: [{ values, asNode }] },\n        ]);\n    }\n    /**\n     * Gets the default values for various graph configuration options.\n     * This is an internal method used to process and normalize configuration options.\n     *\n     * @param config - The input configuration options\n     * @returns A tuple containing normalized values for:\n     * - debug mode\n     * - stream modes\n     * - input keys\n     * - output keys\n     * - remaining config\n     * - interrupt before nodes\n     * - interrupt after nodes\n     * - checkpointer\n     * - store\n     * - whether stream mode is single\n     * @internal\n     */\n    _defaults(config) {\n        const { debug, streamMode, inputKeys, outputKeys, interruptAfter, interruptBefore, ...rest } = config;\n        let streamModeSingle = true;\n        const defaultDebug = debug !== undefined ? debug : this.debug;\n        let defaultOutputKeys = outputKeys;\n        if (defaultOutputKeys === undefined) {\n            defaultOutputKeys = this.streamChannelsAsIs;\n        }\n        else {\n            (0,_validate_js__WEBPACK_IMPORTED_MODULE_4__.validateKeys)(defaultOutputKeys, this.channels);\n        }\n        let defaultInputKeys = inputKeys;\n        if (defaultInputKeys === undefined) {\n            defaultInputKeys = this.inputChannels;\n        }\n        else {\n            (0,_validate_js__WEBPACK_IMPORTED_MODULE_4__.validateKeys)(defaultInputKeys, this.channels);\n        }\n        const defaultInterruptBefore = interruptBefore ?? this.interruptBefore ?? [];\n        const defaultInterruptAfter = interruptAfter ?? this.interruptAfter ?? [];\n        let defaultStreamMode;\n        if (streamMode !== undefined) {\n            defaultStreamMode = Array.isArray(streamMode) ? streamMode : [streamMode];\n            streamModeSingle = typeof streamMode === \"string\";\n        }\n        else {\n            defaultStreamMode = this.streamMode;\n            streamModeSingle = true;\n        }\n        // if being called as a node in another graph, always use values mode\n        if (config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_TASK_ID] !== undefined) {\n            defaultStreamMode = [\"values\"];\n        }\n        let defaultCheckpointer;\n        if (this.checkpointer === false) {\n            defaultCheckpointer = undefined;\n        }\n        else if (config !== undefined &&\n            config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] !== undefined) {\n            defaultCheckpointer = config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER];\n        }\n        else {\n            defaultCheckpointer = this.checkpointer;\n        }\n        const defaultStore = config.store ?? this.store;\n        return [\n            defaultDebug,\n            defaultStreamMode,\n            defaultInputKeys,\n            defaultOutputKeys,\n            rest,\n            defaultInterruptBefore,\n            defaultInterruptAfter,\n            defaultCheckpointer,\n            defaultStore,\n            streamModeSingle,\n        ];\n    }\n    /**\n     * Streams the execution of the graph, emitting state updates as they occur.\n     * This is the primary method for observing graph execution in real-time.\n     *\n     * Stream modes:\n     * - \"values\": Emits complete state after each step\n     * - \"updates\": Emits only state changes after each step\n     * - \"debug\": Emits detailed debug information\n     * - \"messages\": Emits messages from within nodes\n     *\n     * For more details, see the [Streaming how-to guides](../../how-tos/#streaming_1).\n     *\n     * @param input - The input to start graph execution with\n     * @param options - Configuration options for streaming\n     * @returns An async iterable stream of graph state updates\n     */\n    async stream(input, options) {\n        // The ensureConfig method called internally defaults recursionLimit to 25 if not\n        // passed directly in `options`.\n        // There is currently no way in _streamIterator to determine whether this was\n        // set by by ensureConfig or manually by the user, so we specify the bound value here\n        // and override if it is passed as an explicit param in `options`.\n        const abortController = new AbortController();\n        const config = {\n            recursionLimit: this.config?.recursionLimit,\n            ...options,\n            signal: options?.signal\n                ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.combineAbortSignals)(options.signal, abortController.signal)\n                : abortController.signal,\n        };\n        return new _stream_js__WEBPACK_IMPORTED_MODULE_19__.IterableReadableStreamWithAbortSignal(await super.stream(input, config), abortController);\n    }\n    streamEvents(input, options, streamOptions) {\n        const abortController = new AbortController();\n        const config = {\n            recursionLimit: this.config?.recursionLimit,\n            // Similar to `stream`, we need to pass the `config.callbacks` here,\n            // otherwise the user-provided callback will get lost in `ensureLangGraphConfig`.\n            callbacks: this.config?.callbacks,\n            ...options,\n            signal: options?.signal\n                ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.combineAbortSignals)(options.signal, abortController.signal)\n                : abortController.signal,\n        };\n        return new _stream_js__WEBPACK_IMPORTED_MODULE_19__.IterableReadableStreamWithAbortSignal(super.streamEvents(input, config, streamOptions), abortController);\n    }\n    /**\n     * Prepares channel specifications and managed values for graph execution.\n     * This is an internal method used to set up the graph's communication channels\n     * and managed state before execution.\n     *\n     * @param config - Configuration for preparing specs\n     * @param options - Additional options\n     * @param options.skipManaged - Whether to skip initialization of managed values\n     * @returns Object containing channel specs and managed value mapping\n     * @internal\n     */\n    async prepareSpecs(config, options) {\n        const configForManaged = {\n            ...config,\n            store: this.store,\n        };\n        const channelSpecs = {};\n        const managedSpecs = {};\n        for (const [name, spec] of Object.entries(this.channels)) {\n            if ((0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.isBaseChannel)(spec)) {\n                channelSpecs[name] = spec;\n            }\n            else if (options?.skipManaged) {\n                managedSpecs[name] = {\n                    cls: _managed_base_js__WEBPACK_IMPORTED_MODULE_14__.NoopManagedValue,\n                    params: { config: {} },\n                };\n            }\n            else {\n                managedSpecs[name] = spec;\n            }\n        }\n        const managed = new _managed_base_js__WEBPACK_IMPORTED_MODULE_14__.ManagedValueMapping(await Object.entries(managedSpecs).reduce(async (accPromise, [key, value]) => {\n            const acc = await accPromise;\n            let initializedValue;\n            if ((0,_managed_base_js__WEBPACK_IMPORTED_MODULE_14__.isConfiguredManagedValue)(value)) {\n                if (\"key\" in value.params &&\n                    value.params.key === _managed_base_js__WEBPACK_IMPORTED_MODULE_14__.ChannelKeyPlaceholder) {\n                    value.params.key = key;\n                }\n                initializedValue = await value.cls.initialize(configForManaged, value.params);\n            }\n            else {\n                initializedValue = await value.initialize(configForManaged);\n            }\n            if (initializedValue !== undefined) {\n                acc.push([key, initializedValue]);\n            }\n            return acc;\n        }, Promise.resolve([])));\n        return {\n            channelSpecs,\n            managed,\n        };\n    }\n    /**\n     * Validates the input for the graph.\n     * @param input - The input to validate\n     * @returns The validated input\n     * @internal\n     */\n    async _validateInput(input) {\n        return input;\n    }\n    /**\n     * Validates the configurable options for the graph.\n     * @param config - The configurable options to validate\n     * @returns The validated configurable options\n     * @internal\n     */\n    async _validateConfigurable(config) {\n        return config;\n    }\n    /**\n     * Internal iterator used by stream() to generate state updates.\n     * This method handles the core logic of graph execution and streaming.\n     *\n     * @param input - The input to start graph execution with\n     * @param options - Configuration options for streaming\n     * @returns AsyncGenerator yielding state updates\n     * @internal\n     */\n    async *_streamIterator(input, options) {\n        const streamSubgraphs = options?.subgraphs;\n        const inputConfig = (0,_utils_config_js__WEBPACK_IMPORTED_MODULE_16__.ensureLangGraphConfig)(this.config, options);\n        if (inputConfig.recursionLimit === undefined ||\n            inputConfig.recursionLimit < 1) {\n            throw new Error(`Passed \"recursionLimit\" must be at least 1.`);\n        }\n        if (this.checkpointer !== undefined &&\n            this.checkpointer !== false &&\n            inputConfig.configurable === undefined) {\n            throw new Error(`Checkpointer requires one or more of the following \"configurable\" keys: \"thread_id\", \"checkpoint_ns\", \"checkpoint_id\"`);\n        }\n        const validInput = await this._validateInput(input);\n        const { runId, ...restConfig } = inputConfig;\n        // assign defaults\n        const [debug, streamMode, , outputKeys, config, interruptBefore, interruptAfter, checkpointer, store, streamModeSingle,] = this._defaults(restConfig);\n        config.configurable = await this._validateConfigurable(config.configurable);\n        const stream = new _stream_js__WEBPACK_IMPORTED_MODULE_19__.IterableReadableWritableStream({\n            modes: new Set(streamMode),\n        });\n        // set up messages stream mode\n        if (streamMode.includes(\"messages\")) {\n            const messageStreamer = new _messages_js__WEBPACK_IMPORTED_MODULE_17__.StreamMessagesHandler((chunk) => stream.push(chunk));\n            const { callbacks } = config;\n            if (callbacks === undefined) {\n                config.callbacks = [messageStreamer];\n            }\n            else if (Array.isArray(callbacks)) {\n                config.callbacks = callbacks.concat(messageStreamer);\n            }\n            else {\n                const copiedCallbacks = callbacks.copy();\n                copiedCallbacks.addHandler(messageStreamer, true);\n                config.callbacks = copiedCallbacks;\n            }\n        }\n        // setup custom stream mode\n        if (streamMode.includes(\"custom\")) {\n            config.writer = (chunk) => stream.push([[], \"custom\", chunk]);\n        }\n        const callbackManager = await (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager?.handleChainStart(this.toJSON(), // chain\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__._coerceToDict)(input, \"input\"), // inputs\n        runId, // run_id\n        undefined, // run_type\n        undefined, // tags\n        undefined, // metadata\n        config?.runName ?? this.getName() // run_name\n        );\n        const { channelSpecs, managed } = await this.prepareSpecs(config);\n        let loop;\n        let loopError;\n        /**\n         * The PregelLoop will yield events from concurrent tasks as soon as they are\n         * generated. Each task can push multiple events onto the stream in any order.\n         *\n         * We use a separate background method and stream here in order to yield events\n         * from the loop to the main stream and therefore back to the user as soon as\n         * they are available.\n         */\n        const createAndRunLoop = async () => {\n            try {\n                loop = await _loop_js__WEBPACK_IMPORTED_MODULE_13__.PregelLoop.initialize({\n                    input: validInput,\n                    config,\n                    checkpointer,\n                    nodes: this.nodes,\n                    channelSpecs,\n                    managed,\n                    outputKeys,\n                    streamKeys: this.streamChannelsAsIs,\n                    store,\n                    stream,\n                    interruptAfter,\n                    interruptBefore,\n                    manager: runManager,\n                    debug: this.debug,\n                });\n                const runner = new _runner_js__WEBPACK_IMPORTED_MODULE_18__.PregelRunner({\n                    loop,\n                    nodeFinished: config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_NODE_FINISHED],\n                });\n                if (options?.subgraphs) {\n                    loop.config.configurable = {\n                        ...loop.config.configurable,\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_STREAM]: loop.stream,\n                    };\n                }\n                await this._runLoop({ loop, runner, debug, config });\n            }\n            catch (e) {\n                loopError = e;\n            }\n            finally {\n                try {\n                    // Call `.stop()` again incase it was not called in the loop, e.g due to an error.\n                    if (loop) {\n                        await loop.store?.stop();\n                    }\n                    await Promise.all([\n                        ...(loop?.checkpointerPromises ?? []),\n                        ...Array.from(managed.values()).map((mv) => mv.promises()),\n                    ]);\n                }\n                catch (e) {\n                    loopError = loopError ?? e;\n                }\n                if (loopError) {\n                    // \"Causes any future interactions with the associated stream to error\".\n                    // Wraps ReadableStreamDefaultController#error:\n                    // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/error\n                    stream.error(loopError);\n                }\n                else {\n                    // Will end the iterator outside of this method,\n                    // keeping previously enqueued chunks.\n                    // Wraps ReadableStreamDefaultController#close:\n                    // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/close\n                    stream.close();\n                }\n            }\n        };\n        const runLoopPromise = createAndRunLoop();\n        try {\n            for await (const chunk of stream) {\n                if (chunk === undefined) {\n                    throw new Error(\"Data structure error.\");\n                }\n                const [namespace, mode, payload] = chunk;\n                if (streamMode.includes(mode)) {\n                    if (streamSubgraphs && !streamModeSingle) {\n                        yield [namespace, mode, payload];\n                    }\n                    else if (!streamModeSingle) {\n                        yield [mode, payload];\n                    }\n                    else if (streamSubgraphs) {\n                        yield [namespace, payload];\n                    }\n                    else {\n                        yield payload;\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(loopError);\n            throw e;\n        }\n        finally {\n            await runLoopPromise;\n        }\n        await runManager?.handleChainEnd(loop?.output ?? {}, runId, // run_id\n        undefined, // run_type\n        undefined, // tags\n        undefined // metadata\n        );\n    }\n    /**\n     * Run the graph with a single input and config.\n     * @param input The input to the graph.\n     * @param options The configuration to use for the run.\n     */\n    async invoke(input, options) {\n        const streamMode = options?.streamMode ?? \"values\";\n        const config = {\n            ...options,\n            outputKeys: options?.outputKeys ?? this.outputChannels,\n            streamMode,\n        };\n        const chunks = [];\n        const stream = await this.stream(input, config);\n        for await (const chunk of stream) {\n            chunks.push(chunk);\n        }\n        if (streamMode === \"values\") {\n            return chunks[chunks.length - 1];\n        }\n        return chunks;\n    }\n    async _runLoop(params) {\n        const { loop, runner, debug, config } = params;\n        let tickError;\n        try {\n            while (await loop.tick({\n                inputKeys: this.inputChannels,\n            })) {\n                if (debug) {\n                    (0,_debug_js__WEBPACK_IMPORTED_MODULE_6__.printStepCheckpoint)(loop.checkpointMetadata.step, loop.channels, this.streamChannelsList);\n                }\n                if (debug) {\n                    (0,_debug_js__WEBPACK_IMPORTED_MODULE_6__.printStepTasks)(loop.step, Object.values(loop.tasks));\n                }\n                await runner.tick({\n                    timeout: this.stepTimeout,\n                    retryPolicy: this.retryPolicy,\n                    onStepWrite: (step, writes) => {\n                        if (debug) {\n                            (0,_debug_js__WEBPACK_IMPORTED_MODULE_6__.printStepWrites)(step, writes, this.streamChannelsList);\n                        }\n                    },\n                    maxConcurrency: config.maxConcurrency,\n                    signal: config.signal,\n                });\n            }\n            if (loop.status === \"out_of_steps\") {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.GraphRecursionError([\n                    `Recursion limit of ${config.recursionLimit} reached`,\n                    \"without hitting a stop condition. You can increase the\",\n                    `limit by setting the \"recursionLimit\" config key.`,\n                ].join(\" \"), {\n                    lc_error_code: \"GRAPH_RECURSION_LIMIT\",\n                });\n            }\n        }\n        catch (e) {\n            tickError = e;\n            const suppress = await loop.finishAndHandleError(tickError);\n            if (!suppress) {\n                throw e;\n            }\n        }\n        finally {\n            if (tickError === undefined) {\n                await loop.finishAndHandleError();\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ21KO0FBQ3RCO0FBQ3ZDO0FBQy9DO0FBQ3FCO0FBQ1g7QUFDbUQ7QUFDN0M7QUFDeU47QUFDdkw7QUFDaEI7QUFDeUM7QUFDekQ7QUFDbEI7QUFDc0Y7QUFDN0Q7QUFDc0I7QUFDaEM7QUFDWDtBQUMwRDtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFXO0FBQ2xDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOERBQThEO0FBQzlELGdCQUFnQiwrREFBUTtBQUN4QjtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFXO0FBQ3RDO0FBQ0EsNEJBQTRCLDRFQUFpQjtBQUM3QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUIsbURBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQkFBaUI7QUFDdkIsb0JBQW9CLGtCQUFrQixlQUFlLHFCQUFxQjtBQUMxRTtBQUNBLCtDQUErQyxrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RSw0REFBNEQsbUJBQW1CLElBQUksd0JBQXdCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLCtEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUVBQVk7QUFDekM7QUFDQSxzQ0FBc0MsK0JBQStCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLFFBQVEsMkRBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVFQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSyxFQUFFLHlFQUE4QixDQUFDLEVBQUUsYUFBYTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUFrRTtBQUNwRztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0EsU0FBUztBQUNULHlCQUF5QixnRUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdURBQVk7QUFDaEU7QUFDQTtBQUNBLGdCQUFnQix1REFBWTtBQUM1QjtBQUNBLDhCQUE4QixnREFBSztBQUNuQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDREQUFpQiw2RkFBNkYsMkRBQTJEO0FBQ2pOO0FBQ0EsZ0NBQWdDLDBEQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0IsRUFBRSxtRUFBd0IsQ0FBQyxFQUFFLFFBQVE7QUFDbkY7QUFDQSw0QkFBNEIsZ0JBQWdCLEVBQUUseUVBQThCLENBQUMsRUFBRSxPQUFPO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUF1QjtBQUNoRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnREFBSyxFQUFFLG9EQUFTLEVBQUUsc0VBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBWTtBQUNoQztBQUNBLG1CQUFtQiwwREFBZTtBQUNsQztBQUNBLG9CQUFvQixvRUFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLG1EQUFtRCxrRUFBdUI7QUFDMUU7QUFDQSxzQkFBc0IsdURBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUF1QjtBQUN6RDtBQUNBLG9DQUFvQyw0RUFBeUI7QUFDN0Q7QUFDQTtBQUNBLG1EQUFtRCw2REFBaUI7QUFDcEUseUJBQXlCLGtFQUF1QjtBQUNoRCxxQkFBcUIsS0FBSywrQkFBK0I7QUFDekQ7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQSw2QkFBNkIsdUVBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLG1EQUFtRCxrRUFBdUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrRUFBdUI7QUFDekQsb0NBQW9DLDRFQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNkRBQWlCO0FBQ25FLHlCQUF5QixrRUFBdUI7QUFDaEQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQSw2QkFBNkIsdUVBQVk7QUFDekMsNEJBQTRCLG9DQUFvQztBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQSx3REFBd0Qsa0VBQXVCO0FBQy9FO0FBQ0Esc0JBQXNCLHVEQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtFQUF1QjtBQUM5RDtBQUNBLG9DQUFvQyw0RUFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDZEQUFpQjtBQUNyRSxxQkFBcUIsa0VBQXVCO0FBQzVDLGlCQUFpQjtBQUNqQjtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUVBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtFQUFjO0FBQ2hDLGtCQUFrQixnRkFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZEQUFpQjtBQUNwRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLDZEQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSw4QkFBOEIsMERBQWtCO0FBQ2hEO0FBQ0EsNEVBQTRFLG1FQUFnQjtBQUM1RjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDJEQUEyRDtBQUMzRCxpQkFBaUIsSUFBSTtBQUNyQix1QkFBdUIsb0VBQWtCO0FBQ3pDO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWE7QUFDMUM7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBLGFBQWE7QUFDYiw4Q0FBOEMsOENBQUc7QUFDakQ7QUFDQSw4QkFBOEIsMERBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0REFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxnREFBZ0QsdURBQVk7QUFDNUQ7QUFDQTtBQUNBLHdCQUF3Qix1REFBWTtBQUNwQztBQUNBLHNDQUFzQyxnREFBSztBQUMzQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFLLEVBQUUsb0RBQVMsRUFBRSxzRUFBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVEQUFZO0FBQ2hDO0FBQ0E7QUFDQSw0RUFBNEUsbUVBQWdCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwyREFBMkQ7QUFDM0QsaUJBQWlCLElBQUk7QUFDckIsdUJBQXVCLG9FQUFrQjtBQUN6QztBQUNBLDZDQUE2QywrQ0FBSTtBQUNqRDtBQUNBLDhCQUE4QiwwREFBa0I7QUFDaEQ7QUFDQSxtR0FBbUcsbUVBQWdCO0FBQ25IO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMkRBQTJEO0FBQzNELGlCQUFpQixJQUFJO0FBQ3JCLHVCQUF1QixvRUFBa0I7QUFDekM7QUFDQSwyQkFBMkIsZ0RBQUs7QUFDaEM7QUFDQSw4QkFBOEIsMERBQWtCO0FBQ2hEO0FBQ0EsMENBQTBDLDBEQUFjLENBQUMsZ0RBQVE7QUFDakU7QUFDQSw4QkFBOEIsMERBQWtCLGlDQUFpQyw0Q0FBNEM7QUFDN0g7QUFDQTtBQUNBLGdCQUFnQix1REFBWTtBQUM1QjtBQUNBLDhCQUE4QixnREFBSztBQUNuQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxtRUFBZ0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELGlCQUFpQixFQUFFLHVFQUFxQjtBQUN4QztBQUNBLHNFQUFzRSxzRUFBSyxDQUFDLGdEQUFLO0FBQ2pGLHVCQUF1QixvRUFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDREQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNENBQTRDLHVEQUFZO0FBQ3hEO0FBQ0E7QUFDQSxvQkFBb0IsdURBQVk7QUFDaEM7QUFDQSxrQ0FBa0MsZ0RBQUs7QUFDdkM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBSyxFQUFFLG9EQUFTLEVBQUUsc0VBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxvQkFBb0IsdURBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0Esd0RBQXdELHVGQUFzQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUFrQjtBQUNoRDtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQSxrQ0FBa0MsMERBQWtCO0FBQ3BEO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0EsOEJBQThCLDBEQUFrQixVQUFVLGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwREFBa0IsK0JBQStCLGtCQUFrQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUVBQWdCO0FBQzVDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwrQkFBK0Isb0RBQVM7QUFDeEMsd0JBQXdCLHNFQUFLLENBQUMsb0RBQVM7QUFDdkM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNFQUFXO0FBQzlEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsa0RBQWtELGVBQWU7QUFDakU7QUFDQSx5QkFBeUIsMERBQWU7QUFDeEMseUJBQXlCLDBEQUFlLGdDQUFnQyxxREFBVTtBQUNsRjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsK0NBQUk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUFZO0FBQ3hCLGdDQUFnQyx1RUFBcUI7QUFDckQsd0VBQXdFLG1FQUFnQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzRUFBc0UsK0NBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0VBQWtCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWSxnQkFBZ0IsR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUZBQXFGO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZEQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrRUFBdUI7QUFDekQsc0RBQXNELGtFQUF1QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUIsOEVBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFFQUFtQjtBQUNyQztBQUNBO0FBQ0EsbUJBQW1CLDhFQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtEQUFnQjtBQUN6Qyw4QkFBOEIsWUFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQW1CO0FBQy9DO0FBQ0E7QUFDQSxnQkFBZ0IsMkVBQXdCO0FBQ3hDO0FBQ0EseUNBQXlDLG9FQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdFQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVFQUE4QjtBQUN6RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0NBQXdDLGdFQUFxQjtBQUM3RCxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzRkFBMkI7QUFDakU7QUFDQSxRQUFRLCtEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsbUNBQW1DLHFEQUFZO0FBQy9DO0FBQ0Esd0RBQXdELG1FQUF3QjtBQUNoRixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFpQjtBQUMxQztBQUNBO0FBQ0Esc0NBQXNDLDZCQUE2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CLDhEQUFtQjtBQUN2QztBQUNBO0FBQ0Esb0JBQW9CLHlEQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwREFBZTtBQUMzQztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQW1CO0FBQzdDLDBDQUEwQyx1QkFBdUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXGRpc3RcXHByZWdlbFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmltcG9ydCB7IFJ1bm5hYmxlLCBSdW5uYWJsZVNlcXVlbmNlLCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcsIG1lcmdlQ29uZmlncywgcGF0Y2hDb25maWcsIF9jb2VyY2VUb1J1bm5hYmxlLCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG5pbXBvcnQgeyBjb21wYXJlQ2hhbm5lbFZlcnNpb25zLCBjb3B5Q2hlY2twb2ludCwgZW1wdHlDaGVja3BvaW50LCBTQ0hFRFVMRUQsIHV1aWQ1LCB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaC1jaGVja3BvaW50XCI7XG5pbXBvcnQgeyBjcmVhdGVDaGVja3BvaW50LCBlbXB0eUNoYW5uZWxzLCBpc0Jhc2VDaGFubmVsLCB9IGZyb20gXCIuLi9jaGFubmVscy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBQcmVnZWxOb2RlIH0gZnJvbSBcIi4vcmVhZC5qc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVHcmFwaCwgdmFsaWRhdGVLZXlzIH0gZnJvbSBcIi4vdmFsaWRhdGUuanNcIjtcbmltcG9ydCB7IG1hcElucHV0LCByZWFkQ2hhbm5lbHMgfSBmcm9tIFwiLi9pby5qc1wiO1xuaW1wb3J0IHsgcHJpbnRTdGVwQ2hlY2twb2ludCwgcHJpbnRTdGVwVGFza3MsIHByaW50U3RlcFdyaXRlcywgdGFza3NXaXRoV3JpdGVzLCB9IGZyb20gXCIuL2RlYnVnLmpzXCI7XG5pbXBvcnQgeyBDaGFubmVsV3JpdGUsIFBBU1NUSFJPVUdIIH0gZnJvbSBcIi4vd3JpdGUuanNcIjtcbmltcG9ydCB7IENPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSLCBDT05GSUdfS0VZX1JFQUQsIENPTkZJR19LRVlfU0VORCwgQ09ORklHX0tFWV9UQVNLX0lELCBFUlJPUiwgSU5QVVQsIElOVEVSUlVQVCwgUFVTSCwgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SLCBDSEVDS1BPSU5UX05BTUVTUEFDRV9FTkQsIENPTkZJR19LRVlfU1RSRUFNLCBOVUxMX1RBU0tfSUQsIENPUFksIEVORCwgQ09ORklHX0tFWV9OT0RFX0ZJTklTSEVELCB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IEdyYXBoUmVjdXJzaW9uRXJyb3IsIEdyYXBoVmFsdWVFcnJvciwgSW52YWxpZFVwZGF0ZUVycm9yLCB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IF9wcmVwYXJlTmV4dFRhc2tzLCBfbG9jYWxSZWFkLCBfYXBwbHlXcml0ZXMsIH0gZnJvbSBcIi4vYWxnby5qc1wiO1xuaW1wb3J0IHsgX2NvZXJjZVRvRGljdCwgY29tYmluZUFib3J0U2lnbmFscywgZ2V0TmV3Q2hhbm5lbFZlcnNpb25zLCBwYXRjaENoZWNrcG9pbnRNYXAsIH0gZnJvbSBcIi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGZpbmRTdWJncmFwaFByZWdlbCB9IGZyb20gXCIuL3V0aWxzL3N1YmdyYXBoLmpzXCI7XG5pbXBvcnQgeyBQcmVnZWxMb29wIH0gZnJvbSBcIi4vbG9vcC5qc1wiO1xuaW1wb3J0IHsgQ2hhbm5lbEtleVBsYWNlaG9sZGVyLCBpc0NvbmZpZ3VyZWRNYW5hZ2VkVmFsdWUsIE1hbmFnZWRWYWx1ZU1hcHBpbmcsIE5vb3BNYW5hZ2VkVmFsdWUsIH0gZnJvbSBcIi4uL21hbmFnZWQvYmFzZS5qc1wiO1xuaW1wb3J0IHsgZ2F0aGVySXRlcmF0b3IsIHBhdGNoQ29uZmlndXJhYmxlIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBlbnN1cmVMYW5nR3JhcGhDb25maWcsIHJlY2FzdENoZWNrcG9pbnROYW1lc3BhY2UsIH0gZnJvbSBcIi4vdXRpbHMvY29uZmlnLmpzXCI7XG5pbXBvcnQgeyBTdHJlYW1NZXNzYWdlc0hhbmRsZXIgfSBmcm9tIFwiLi9tZXNzYWdlcy5qc1wiO1xuaW1wb3J0IHsgUHJlZ2VsUnVubmVyIH0gZnJvbSBcIi4vcnVubmVyLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtV2l0aEFib3J0U2lnbmFsLCBJdGVyYWJsZVJlYWRhYmxlV3JpdGFibGVTdHJlYW0sIH0gZnJvbSBcIi4vc3RyZWFtLmpzXCI7XG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCBjaGFubmVscyBpbiB0aGUgUHJlZ2VsIHN5c3RlbS5cbiAqIFByb3ZpZGVzIHN0YXRpYyBtZXRob2RzIGZvciBzdWJzY3JpYmluZyB0byBjaGFubmVscyBhbmQgd3JpdGluZyB0byB0aGVtLlxuICpcbiAqIENoYW5uZWxzIGFyZSB0aGUgY29tbXVuaWNhdGlvbiBwYXRod2F5cyBiZXR3ZWVuIG5vZGVzIGluIGEgUHJlZ2VsIGdyYXBoLlxuICogVGhleSBlbmFibGUgbWVzc2FnZSBwYXNzaW5nIGFuZCBzdGF0ZSB1cGRhdGVzIGJldHdlZW4gZGlmZmVyZW50IHBhcnRzIG9mIHRoZSBncmFwaC5cbiAqL1xuZXhwb3J0IGNsYXNzIENoYW5uZWwge1xuICAgIHN0YXRpYyBzdWJzY3JpYmVUbyhjaGFubmVscywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGtleSwgdGFncyB9ID0ge1xuICAgICAgICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0YWdzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucyA/PyB7fSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoYW5uZWxzKSAmJiBrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3BlY2lmeSBhIGtleSB3aGVuIHN1YnNjcmliaW5nIHRvIG11bHRpcGxlIGNoYW5uZWxzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFubmVsTWFwcGluZ09yQXJyYXk7XG4gICAgICAgIGlmIChpc1N0cmluZyhjaGFubmVscykpIHtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsTWFwcGluZ09yQXJyYXkgPSB7IFtrZXldOiBjaGFubmVscyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbE1hcHBpbmdPckFycmF5ID0gW2NoYW5uZWxzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5uZWxNYXBwaW5nT3JBcnJheSA9IE9iamVjdC5mcm9tRW50cmllcyhjaGFubmVscy5tYXAoKGNoYW4pID0+IFtjaGFuLCBjaGFuXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyaWdnZXJzID0gQXJyYXkuaXNBcnJheShjaGFubmVscykgPyBjaGFubmVscyA6IFtjaGFubmVsc107XG4gICAgICAgIHJldHVybiBuZXcgUHJlZ2VsTm9kZSh7XG4gICAgICAgICAgICBjaGFubmVsczogY2hhbm5lbE1hcHBpbmdPckFycmF5LFxuICAgICAgICAgICAgdHJpZ2dlcnMsXG4gICAgICAgICAgICB0YWdzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIENoYW5uZWxXcml0ZSB0aGF0IHNwZWNpZmllcyBob3cgdG8gd3JpdGUgdmFsdWVzIHRvIGNoYW5uZWxzLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBkZWZpbmUgaG93IG5vZGVzIHNlbmQgb3V0cHV0IHRvIGNoYW5uZWxzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gV3JpdGUgdG8gbXVsdGlwbGUgY2hhbm5lbHNcbiAgICAgKiBjb25zdCB3cml0ZSA9IENoYW5uZWwud3JpdGVUbyhbXCJvdXRwdXRcIiwgXCJzdGF0ZVwiXSk7XG4gICAgICpcbiAgICAgKiAvLyBXcml0ZSB3aXRoIHNwZWNpZmljIHZhbHVlc1xuICAgICAqIGNvbnN0IHdyaXRlID0gQ2hhbm5lbC53cml0ZVRvKFtcIm91dHB1dFwiXSwge1xuICAgICAqICAgc3RhdGU6IFwiY29tcGxldGVkXCIsXG4gICAgICogICByZXN1bHQ6IGNhbGN1bGF0ZVJlc3VsdCgpXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBXcml0ZSB3aXRoIGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25cbiAgICAgKiBjb25zdCB3cml0ZSA9IENoYW5uZWwud3JpdGVUbyhbXCJvdXRwdXRcIl0sIHtcbiAgICAgKiAgIHJlc3VsdDogKHgpID0+IHByb2Nlc3NSZXN1bHQoeClcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVscyAtIEFycmF5IG9mIGNoYW5uZWwgbmFtZXMgdG8gd3JpdGUgdG9cbiAgICAgKiBAcGFyYW0gd3JpdGVzIC0gT3B0aW9uYWwgbWFwIG9mIGNoYW5uZWwgbmFtZXMgdG8gdmFsdWVzIG9yIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIEByZXR1cm5zIEEgQ2hhbm5lbFdyaXRlIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHdyaXRlIHRvIHRoZSBzcGVjaWZpZWQgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBzdGF0aWMgd3JpdGVUbyhjaGFubmVscywgd3JpdGVzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxXcml0ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIGNoYW5uZWxzKSB7XG4gICAgICAgICAgICBjaGFubmVsV3JpdGVFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNoYW5uZWwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFBBU1NUSFJPVUdILFxuICAgICAgICAgICAgICAgIHNraXBOb25lOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHdyaXRlcyA/PyB7fSkpIHtcbiAgICAgICAgICAgIGlmIChSdW5uYWJsZS5pc1J1bm5hYmxlKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWxXcml0ZUVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFBBU1NUSFJPVUdILFxuICAgICAgICAgICAgICAgICAgICBza2lwTm9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVyOiBfY29lcmNlVG9SdW5uYWJsZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsV3JpdGVFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBza2lwTm9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFubmVsV3JpdGUoY2hhbm5lbFdyaXRlRW50cmllcyk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgUHJlZ2VsIGNsYXNzIGlzIHRoZSBjb3JlIHJ1bnRpbWUgZW5naW5lIG9mIExhbmdHcmFwaCwgaW1wbGVtZW50aW5nIGEgbWVzc2FnZS1wYXNzaW5nIGdyYXBoIGNvbXB1dGF0aW9uIG1vZGVsXG4gKiBpbnNwaXJlZCBieSBbR29vZ2xlJ3MgUHJlZ2VsIHN5c3RlbV0oaHR0cHM6Ly9yZXNlYXJjaC5nb29nbGUvcHVicy9wcmVnZWwtYS1zeXN0ZW0tZm9yLWxhcmdlLXNjYWxlLWdyYXBoLXByb2Nlc3NpbmcvKS5cbiAqIEl0IHByb3ZpZGVzIHRoZSBmb3VuZGF0aW9uIGZvciBidWlsZGluZyByZWxpYWJsZSwgY29udHJvbGxhYmxlIGFnZW50IHdvcmtmbG93cyB0aGF0IGNhbiBldm9sdmUgc3RhdGUgb3ZlciB0aW1lLlxuICpcbiAqIEtleSBmZWF0dXJlczpcbiAqIC0gTWVzc2FnZSBwYXNzaW5nIGJldHdlZW4gbm9kZXMgaW4gZGlzY3JldGUgXCJzdXBlcnN0ZXBzXCJcbiAqIC0gQnVpbHQtaW4gcGVyc2lzdGVuY2UgbGF5ZXIgdGhyb3VnaCBjaGVja3BvaW50ZXJzXG4gKiAtIEZpcnN0LWNsYXNzIHN0cmVhbWluZyBzdXBwb3J0IGZvciB2YWx1ZXMsIHVwZGF0ZXMsIGFuZCBldmVudHNcbiAqIC0gSHVtYW4taW4tdGhlLWxvb3AgY2FwYWJpbGl0aWVzIHZpYSBpbnRlcnJ1cHRzXG4gKiAtIFN1cHBvcnQgZm9yIHBhcmFsbGVsIG5vZGUgZXhlY3V0aW9uIHdpdGhpbiBzdXBlcnN0ZXBzXG4gKlxuICogVGhlIFByZWdlbCBjbGFzcyBpcyBub3QgaW50ZW5kZWQgdG8gYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5IGJ5IGNvbnN1bWVycy4gSW5zdGVhZCwgdXNlIHRoZSBmb2xsb3dpbmcgaGlnaGVyLWxldmVsIEFQSXM6XG4gKiAtIHtAbGluayBTdGF0ZUdyYXBofTogVGhlIG1haW4gZ3JhcGggY2xhc3MgZm9yIGJ1aWxkaW5nIGFnZW50IHdvcmtmbG93c1xuICogICAtIENvbXBpbGluZyBhIHtAbGluayBTdGF0ZUdyYXBofSB3aWxsIHJldHVybiBhIHtAbGluayBDb21waWxlZEdyYXBofSBpbnN0YW5jZSwgd2hpY2ggZXh0ZW5kcyBgUHJlZ2VsYFxuICogLSBGdW5jdGlvbmFsIEFQSTogQSBkZWNsYXJhdGl2ZSBhcHByb2FjaCB1c2luZyB0YXNrcyBhbmQgZW50cnlwb2ludHNcbiAqICAgLSBBIGBQcmVnZWxgIGluc3RhbmNlIGlzIHJldHVybmVkIGJ5IHRoZSB7QGxpbmsgZW50cnlwb2ludH0gZnVuY3Rpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gVXNpbmcgU3RhdGVHcmFwaCBBUElcbiAqIGNvbnN0IGdyYXBoID0gbmV3IFN0YXRlR3JhcGgoYW5ub3RhdGlvbilcbiAqICAgLmFkZE5vZGUoXCJub2RlQVwiLCBteU5vZGVGdW5jdGlvbilcbiAqICAgLmFkZEVkZ2UoXCJub2RlQVwiLCBcIm5vZGVCXCIpXG4gKiAgIC5jb21waWxlKCk7XG4gKlxuICogLy8gVGhlIGNvbXBpbGVkIGdyYXBoIGlzIGEgUHJlZ2VsIGluc3RhbmNlXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBncmFwaC5pbnZva2UoaW5wdXQpO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIFVzaW5nIEZ1bmN0aW9uYWwgQVBJXG4gKiBpbXBvcnQgeyB0YXNrLCBlbnRyeXBvaW50IH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoXCI7XG4gKiBpbXBvcnQgeyBNZW1vcnlTYXZlciB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaC1jaGVja3BvaW50XCI7XG4gKlxuICogLy8gRGVmaW5lIHRhc2tzIHRoYXQgY2FuIGJlIGNvbXBvc2VkXG4gKiBjb25zdCBhZGRPbmUgPSB0YXNrKFwiYWRkXCIsIGFzeW5jICh4OiBudW1iZXIpID0+IHggKyAxKTtcbiAqXG4gKiAvLyBDcmVhdGUgYSB3b3JrZmxvdyB1c2luZyB0aGUgZW50cnlwb2ludCBmdW5jdGlvblxuICogY29uc3Qgd29ya2Zsb3cgPSBlbnRyeXBvaW50KHtcbiAqICAgbmFtZTogXCJ3b3JrZmxvd1wiLFxuICogICBjaGVja3BvaW50ZXI6IG5ldyBNZW1vcnlTYXZlcigpXG4gKiB9LCBhc3luYyAobnVtYmVyczogbnVtYmVyW10pID0+IHtcbiAqICAgLy8gVGFza3MgY2FuIGJlIHJ1biBpbiBwYXJhbGxlbFxuICogICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwobnVtYmVycy5tYXAobiA9PiBhZGRPbmUobikpKTtcbiAqICAgcmV0dXJuIHJlc3VsdHM7XG4gKiB9KTtcbiAqXG4gKiAvLyBUaGUgd29ya2Zsb3cgaXMgYSBQcmVnZWwgaW5zdGFuY2VcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdvcmtmbG93Lmludm9rZShbMSwgMiwgM10pOyAvLyBSZXR1cm5zIFsyLCAzLCA0XVxuICogYGBgXG4gKlxuICogQHR5cGVQYXJhbSBOb2RlcyAtIE1hcHBpbmcgb2Ygbm9kZSBuYW1lcyB0byB0aGVpciB7QGxpbmsgUHJlZ2VsTm9kZX0gaW1wbGVtZW50YXRpb25zXG4gKiBAdHlwZVBhcmFtIENoYW5uZWxzIC0gTWFwcGluZyBvZiBjaGFubmVsIG5hbWVzIHRvIHRoZWlyIHtAbGluayBCYXNlQ2hhbm5lbH0gb3Ige0BsaW5rIE1hbmFnZWRWYWx1ZVNwZWN9IGltcGxlbWVudGF0aW9uc1xuICogQHR5cGVQYXJhbSBDb25maWd1cmFibGVGaWVsZFR5cGUgLSBUeXBlIG9mIGNvbmZpZ3VyYWJsZSBmaWVsZHMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBncmFwaFxuICogQHR5cGVQYXJhbSBJbnB1dFR5cGUgLSBUeXBlIG9mIGlucHV0IHZhbHVlcyBhY2NlcHRlZCBieSB0aGUgZ3JhcGhcbiAqIEB0eXBlUGFyYW0gT3V0cHV0VHlwZSAtIFR5cGUgb2Ygb3V0cHV0IHZhbHVlcyBwcm9kdWNlZCBieSB0aGUgZ3JhcGhcbiAqL1xuZXhwb3J0IGNsYXNzIFByZWdlbCBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBjbGFzcyB3aGVuIHNlcmlhbGl6ZWRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiTGFuZ0dyYXBoXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBQcmVnZWwgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBMYW5nQ2hhaW4gbmFtZXNwYWNlIGZvciBzZXJpYWxpemF0aW9uIG5lY2Vzc2FyeSBiZWNhdXNlIFByZWdlbCBleHRlbmRzIFJ1bm5hYmxlICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2dyYXBoXCIsIFwicHJlZ2VsXCJdXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsIEZsYWcgaW5kaWNhdGluZyB0aGlzIGlzIGEgUHJlZ2VsIGluc3RhbmNlIC0gbmVjZXNzYXJ5IGZvciBzZXJpYWxpemF0aW9uICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxnX2lzX3ByZWdlbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBub2RlcyBpbiB0aGUgZ3JhcGgsIG1hcHBpbmcgbm9kZSBuYW1lcyB0byB0aGVpciBQcmVnZWxOb2RlIGluc3RhbmNlcyAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2Rlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogVGhlIGNoYW5uZWxzIGluIHRoZSBncmFwaCwgbWFwcGluZyBjaGFubmVsIG5hbWVzIHRvIHRoZWlyIEJhc2VDaGFubmVsIG9yIE1hbmFnZWRWYWx1ZVNwZWMgaW5zdGFuY2VzICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5wdXQgY2hhbm5lbHMgZm9yIHRoZSBncmFwaC4gVGhlc2UgY2hhbm5lbHMgcmVjZWl2ZSB0aGUgaW5pdGlhbCBpbnB1dCB3aGVuIHRoZSBncmFwaCBpcyBpbnZva2VkLlxuICAgICAgICAgKiBDYW4gYmUgYSBzaW5nbGUgY2hhbm5lbCBrZXkgb3IgYW4gYXJyYXkgb2YgY2hhbm5lbCBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRDaGFubmVsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG91dHB1dCBjaGFubmVscyBmb3IgdGhlIGdyYXBoLiBUaGVzZSBjaGFubmVscyBjb250YWluIHRoZSBmaW5hbCBvdXRwdXQgd2hlbiB0aGUgZ3JhcGggY29tcGxldGVzLlxuICAgICAgICAgKiBDYW4gYmUgYSBzaW5nbGUgY2hhbm5lbCBrZXkgb3IgYW4gYXJyYXkgb2YgY2hhbm5lbCBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3V0cHV0Q2hhbm5lbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSB2YWxpZGF0ZSB0aGUgZ3JhcGggc3RydWN0dXJlIHdoZW4gaXQgaXMgY29tcGlsZWQuIERlZmF1bHRzIHRvIHRydWUuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9WYWxpZGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdHJlYW1pbmcgbW9kZXMgZW5hYmxlZCBmb3IgdGhpcyBncmFwaC4gRGVmYXVsdHMgdG8gW1widmFsdWVzXCJdLlxuICAgICAgICAgKiBTdXBwb3J0ZWQgbW9kZXM6XG4gICAgICAgICAqIC0gXCJ2YWx1ZXNcIjogU3RyZWFtcyB0aGUgZnVsbCBzdGF0ZSBhZnRlciBlYWNoIHN0ZXBcbiAgICAgICAgICogLSBcInVwZGF0ZXNcIjogU3RyZWFtcyBzdGF0ZSB1cGRhdGVzIGFmdGVyIGVhY2ggc3RlcFxuICAgICAgICAgKiAtIFwibWVzc2FnZXNcIjogU3RyZWFtcyBtZXNzYWdlcyBmcm9tIHdpdGhpbiBub2Rlc1xuICAgICAgICAgKiAtIFwiY3VzdG9tXCI6IFN0cmVhbXMgY3VzdG9tIGV2ZW50cyBmcm9tIHdpdGhpbiBub2Rlc1xuICAgICAgICAgKiAtIFwiZGVidWdcIjogU3RyZWFtcyBldmVudHMgcmVsYXRlZCB0byB0aGUgZXhlY3V0aW9uIG9mIHRoZSBncmFwaCAtIHVzZWZ1bCBmb3IgdHJhY2luZyAmIGRlYnVnZ2luZyBncmFwaCBleGVjdXRpb25cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbU1vZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcInZhbHVlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIGNoYW5uZWxzIHRvIHN0cmVhbS4gSWYgbm90IHNwZWNpZmllZCwgYWxsIGNoYW5uZWxzIHdpbGwgYmUgc3RyZWFtZWQuXG4gICAgICAgICAqIENhbiBiZSBhIHNpbmdsZSBjaGFubmVsIGtleSBvciBhbiBhcnJheSBvZiBjaGFubmVsIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdHJlYW1DaGFubmVsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgYXJyYXkgb2Ygbm9kZSBuYW1lcyBvciBcImFsbFwiIHRvIGludGVycnVwdCBhZnRlciBleGVjdXRpbmcgdGhlc2Ugbm9kZXMuXG4gICAgICAgICAqIFVzZWQgZm9yIGltcGxlbWVudGluZyBodW1hbi1pbi10aGUtbG9vcCB3b3JrZmxvd3MuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcnJ1cHRBZnRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgYXJyYXkgb2Ygbm9kZSBuYW1lcyBvciBcImFsbFwiIHRvIGludGVycnVwdCBiZWZvcmUgZXhlY3V0aW5nIHRoZXNlIG5vZGVzLlxuICAgICAgICAgKiBVc2VkIGZvciBpbXBsZW1lbnRpbmcgaHVtYW4taW4tdGhlLWxvb3Agd29ya2Zsb3dzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW50ZXJydXB0QmVmb3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBPcHRpb25hbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIGV4ZWN1dGlvbiBvZiBlYWNoIHN1cGVyc3RlcCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGVwVGltZW91dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogV2hldGhlciB0byBlbmFibGUgZGVidWcgbG9nZ2luZy4gRGVmYXVsdHMgdG8gZmFsc2UuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIGNoZWNrcG9pbnRlciBmb3IgcGVyc2lzdGluZyBncmFwaCBzdGF0ZS5cbiAgICAgICAgICogV2hlbiBwcm92aWRlZCwgc2F2ZXMgYSBjaGVja3BvaW50IG9mIHRoZSBncmFwaCBzdGF0ZSBhdCBldmVyeSBzdXBlcnN0ZXAuXG4gICAgICAgICAqIFdoZW4gZmFsc2Ugb3IgdW5kZWZpbmVkLCBjaGVja3BvaW50aW5nIGlzIGRpc2FibGVkLCBhbmQgdGhlIGdyYXBoIHdpbGwgbm90IGJlIGFibGUgdG8gc2F2ZSBvciByZXN0b3JlIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hlY2twb2ludGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBPcHRpb25hbCByZXRyeSBwb2xpY3kgZm9yIGhhbmRsaW5nIGZhaWx1cmVzIGluIG5vZGUgZXhlY3V0aW9uICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJldHJ5UG9saWN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciBncmFwaCBleGVjdXRpb24sIGNhbiBiZSBvdmVycmlkZGVuIG9uIGEgcGVyLWludm9jYXRpb24gYmFzaXMgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbCBsb25nLXRlcm0gbWVtb3J5IHN0b3JlIGZvciB0aGUgZ3JhcGgsIGFsbG93cyBmb3IgcGVyc2lzdGFuY2UgJiByZXRyaWV2YWwgb2YgZGF0YSBhY3Jvc3MgdGhyZWFkc1xuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHsgc3RyZWFtTW9kZSB9ID0gZmllbGRzO1xuICAgICAgICBpZiAoc3RyZWFtTW9kZSAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KHN0cmVhbU1vZGUpKSB7XG4gICAgICAgICAgICBzdHJlYW1Nb2RlID0gW3N0cmVhbU1vZGVdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZXMgPSBmaWVsZHMubm9kZXM7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBmaWVsZHMuY2hhbm5lbHM7XG4gICAgICAgIHRoaXMuYXV0b1ZhbGlkYXRlID0gZmllbGRzLmF1dG9WYWxpZGF0ZSA/PyB0aGlzLmF1dG9WYWxpZGF0ZTtcbiAgICAgICAgdGhpcy5zdHJlYW1Nb2RlID0gc3RyZWFtTW9kZSA/PyB0aGlzLnN0cmVhbU1vZGU7XG4gICAgICAgIHRoaXMuaW5wdXRDaGFubmVscyA9IGZpZWxkcy5pbnB1dENoYW5uZWxzO1xuICAgICAgICB0aGlzLm91dHB1dENoYW5uZWxzID0gZmllbGRzLm91dHB1dENoYW5uZWxzO1xuICAgICAgICB0aGlzLnN0cmVhbUNoYW5uZWxzID0gZmllbGRzLnN0cmVhbUNoYW5uZWxzID8/IHRoaXMuc3RyZWFtQ2hhbm5lbHM7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0QWZ0ZXIgPSBmaWVsZHMuaW50ZXJydXB0QWZ0ZXI7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0QmVmb3JlID0gZmllbGRzLmludGVycnVwdEJlZm9yZTtcbiAgICAgICAgdGhpcy5zdGVwVGltZW91dCA9IGZpZWxkcy5zdGVwVGltZW91dCA/PyB0aGlzLnN0ZXBUaW1lb3V0O1xuICAgICAgICB0aGlzLmRlYnVnID0gZmllbGRzLmRlYnVnID8/IHRoaXMuZGVidWc7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludGVyID0gZmllbGRzLmNoZWNrcG9pbnRlcjtcbiAgICAgICAgdGhpcy5yZXRyeVBvbGljeSA9IGZpZWxkcy5yZXRyeVBvbGljeTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBmaWVsZHMuY29uZmlnO1xuICAgICAgICB0aGlzLnN0b3JlID0gZmllbGRzLnN0b3JlO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUHJlZ2VsIGdyYXBoIHdpdGggdXBkYXRlZCBjb25maWd1cmF0aW9uLlxuICAgICAqIFRoaXMgbWV0aG9kIGZvbGxvd3MgdGhlIGltbXV0YWJsZSBwYXR0ZXJuIC0gaW5zdGVhZCBvZiBtb2RpZnlpbmcgdGhlIGN1cnJlbnQgaW5zdGFuY2UsXG4gICAgICogaXQgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSB3aXRoIHRoZSBtZXJnZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB3aXRoIGRlYnVnIGVuYWJsZWRcbiAgICAgKiBjb25zdCBkZWJ1Z0dyYXBoID0gZ3JhcGgud2l0aENvbmZpZyh7IGRlYnVnOiB0cnVlIH0pO1xuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHdpdGggYSBzcGVjaWZpYyB0aHJlYWQgSURcbiAgICAgKiBjb25zdCB0aHJlYWRHcmFwaCA9IGdyYXBoLndpdGhDb25maWcoe1xuICAgICAqICAgY29uZmlndXJhYmxlOiB7IHRocmVhZF9pZDogXCIxMjNcIiB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gdG8gbWVyZ2Ugd2l0aCB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMgQSBuZXcgUHJlZ2VsIGluc3RhbmNlIHdpdGggdGhlIG1lcmdlZCBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmUgUmVtb3ZlIGlnbm9yZSB3aGVuIHdlIHJlbW92ZSBzdXBwb3J0IGZvciAwLjIgdmVyc2lvbnMgb2YgY29yZVxuICAgIHdpdGhDb25maWcoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZENvbmZpZyA9IG1lcmdlQ29uZmlncyh0aGlzLmNvbmZpZywgY29uZmlnKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHsgLi4udGhpcywgY29uZmlnOiBtZXJnZWRDb25maWcgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgZ3JhcGggc3RydWN0dXJlIHRvIGVuc3VyZSBpdCBpcyB3ZWxsLWZvcm1lZC5cbiAgICAgKiBDaGVja3MgZm9yOlxuICAgICAqIC0gTm8gb3JwaGFuZWQgbm9kZXNcbiAgICAgKiAtIFZhbGlkIGlucHV0L291dHB1dCBjaGFubmVsIGNvbmZpZ3VyYXRpb25zXG4gICAgICogLSBWYWxpZCBpbnRlcnJ1cHQgY29uZmlndXJhdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoaXMgLSBUaGUgUHJlZ2VsIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICAgKiBAdGhyb3dzIHtHcmFwaFZhbGlkYXRpb25FcnJvcn0gSWYgdGhlIGdyYXBoIHN0cnVjdHVyZSBpcyBpbnZhbGlkXG4gICAgICovXG4gICAgdmFsaWRhdGUoKSB7XG4gICAgICAgIHZhbGlkYXRlR3JhcGgoe1xuICAgICAgICAgICAgbm9kZXM6IHRoaXMubm9kZXMsXG4gICAgICAgICAgICBjaGFubmVsczogdGhpcy5jaGFubmVscyxcbiAgICAgICAgICAgIG91dHB1dENoYW5uZWxzOiB0aGlzLm91dHB1dENoYW5uZWxzLFxuICAgICAgICAgICAgaW5wdXRDaGFubmVsczogdGhpcy5pbnB1dENoYW5uZWxzLFxuICAgICAgICAgICAgc3RyZWFtQ2hhbm5lbHM6IHRoaXMuc3RyZWFtQ2hhbm5lbHMsXG4gICAgICAgICAgICBpbnRlcnJ1cHRBZnRlck5vZGVzOiB0aGlzLmludGVycnVwdEFmdGVyLFxuICAgICAgICAgICAgaW50ZXJydXB0QmVmb3JlTm9kZXM6IHRoaXMuaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIGFsbCBjaGFubmVscyB0aGF0IHNob3VsZCBiZSBzdHJlYW1lZC5cbiAgICAgKiBJZiBzdHJlYW1DaGFubmVscyBpcyBzcGVjaWZpZWQsIHJldHVybnMgdGhvc2UgY2hhbm5lbHMuXG4gICAgICogT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBjaGFubmVscyBpbiB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBjaGFubmVsIGtleXMgdG8gc3RyZWFtXG4gICAgICovXG4gICAgZ2V0IHN0cmVhbUNoYW5uZWxzTGlzdCgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdHJlYW1DaGFubmVscykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RyZWFtQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5zdHJlYW1DaGFubmVsc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jaGFubmVscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2hhbm5lbHMgdG8gc3RyZWFtIGluIHRoZWlyIG9yaWdpbmFsIGZvcm1hdC5cbiAgICAgKiBJZiBzdHJlYW1DaGFubmVscyBpcyBzcGVjaWZpZWQsIHJldHVybnMgaXQgYXMtaXMgKGVpdGhlciBzaW5nbGUga2V5IG9yIGFycmF5KS5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgYWxsIGNoYW5uZWxzIGluIHRoZSBncmFwaCBhcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIENoYW5uZWwga2V5cyB0byBzdHJlYW0sIGVpdGhlciBhcyBhIHNpbmdsZSBrZXkgb3IgYXJyYXlcbiAgICAgKi9cbiAgICBnZXQgc3RyZWFtQ2hhbm5lbHNBc0lzKCkge1xuICAgICAgICBpZiAodGhpcy5zdHJlYW1DaGFubmVscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2hhbm5lbHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jaGFubmVscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGRyYXdhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncmFwaCBzdHJ1Y3R1cmUuXG4gICAgICogVGhpcyBpcyBhbiBhc3luYyB2ZXJzaW9uIG9mIGdldEdyYXBoKCkgYW5kIGlzIHRoZSBwcmVmZXJyZWQgbWV0aG9kIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIGZvciBnZW5lcmF0aW5nIHRoZSBncmFwaCB2aXN1YWxpemF0aW9uXG4gICAgICogQHJldHVybnMgQSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JhcGggdGhhdCBjYW4gYmUgdmlzdWFsaXplZFxuICAgICAqL1xuICAgIGFzeW5jIGdldEdyYXBoQXN5bmMoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyYXBoKGNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHN1YmdyYXBocyB3aXRoaW4gdGhpcyBncmFwaC5cbiAgICAgKiBBIHN1YmdyYXBoIGlzIGEgUHJlZ2VsIGluc3RhbmNlIHRoYXQgaXMgbmVzdGVkIHdpdGhpbiBhIG5vZGUgb2YgdGhpcyBncmFwaC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBnZXRTdWJncmFwaHNBc3luYyBpbnN0ZWFkLiBUaGUgYXN5bmMgbWV0aG9kIHdpbGwgYmVjb21lIHRoZSBkZWZhdWx0IGluIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UuXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZSAtIE9wdGlvbmFsIG5hbWVzcGFjZSB0byBmaWx0ZXIgc3ViZ3JhcGhzXG4gICAgICogQHBhcmFtIHJlY3Vyc2UgLSBXaGV0aGVyIHRvIHJlY3Vyc2l2ZWx5IGdldCBzdWJncmFwaHMgb2Ygc3ViZ3JhcGhzXG4gICAgICogQHJldHVybnMgR2VuZXJhdG9yIHlpZWxkaW5nIHR1cGxlcyBvZiBbbmFtZSwgc3ViZ3JhcGhdXG4gICAgICovXG4gICAgKmdldFN1YmdyYXBocyhuYW1lc3BhY2UsIHJlY3Vyc2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICkge1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBub2RlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLm5vZGVzKSkge1xuICAgICAgICAgICAgLy8gZmlsdGVyIGJ5IHByZWZpeFxuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lc3BhY2Uuc3RhcnRzV2l0aChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gbm9kZS5zdWJncmFwaHM/Lmxlbmd0aCA/IG5vZGUuc3ViZ3JhcGhzIDogW25vZGUuYm91bmRdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyYXBoID0gZmluZFN1YmdyYXBoUHJlZ2VsKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyYXBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW25hbWUsIGdyYXBoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtuYW1lLCBncmFwaF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdOYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOYW1lc3BhY2UgPSBuYW1lc3BhY2Uuc2xpY2UobmFtZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3N1YmdyYXBoTmFtZSwgc3ViZ3JhcGhdIG9mIGdyYXBoLmdldFN1YmdyYXBocyhuZXdOYW1lc3BhY2UsIHJlY3Vyc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtuYW1lfSR7Q0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SfSR7c3ViZ3JhcGhOYW1lfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgc3ViZ3JhcGhzIHdpdGhpbiB0aGlzIGdyYXBoIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEEgc3ViZ3JhcGggaXMgYSBQcmVnZWwgaW5zdGFuY2UgdGhhdCBpcyBuZXN0ZWQgd2l0aGluIGEgbm9kZSBvZiB0aGlzIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZSAtIE9wdGlvbmFsIG5hbWVzcGFjZSB0byBmaWx0ZXIgc3ViZ3JhcGhzXG4gICAgICogQHBhcmFtIHJlY3Vyc2UgLSBXaGV0aGVyIHRvIHJlY3Vyc2l2ZWx5IGdldCBzdWJncmFwaHMgb2Ygc3ViZ3JhcGhzXG4gICAgICogQHJldHVybnMgQXN5bmNHZW5lcmF0b3IgeWllbGRpbmcgdHVwbGVzIG9mIFtuYW1lLCBzdWJncmFwaF1cbiAgICAgKi9cbiAgICBhc3luYyAqZ2V0U3ViZ3JhcGhzQXN5bmMobmFtZXNwYWNlLCByZWN1cnNlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgeWllbGQqIHRoaXMuZ2V0U3ViZ3JhcGhzKG5hbWVzcGFjZSwgcmVjdXJzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGEgc3RhdGUgc25hcHNob3QgZnJvbSBzYXZlZCBjaGVja3BvaW50IGRhdGEuXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm5hbCBtZXRob2QgdXNlZCBieSBnZXRTdGF0ZSBhbmQgZ2V0U3RhdGVIaXN0b3J5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gZm9yIHByZXBhcmluZyB0aGUgc25hcHNob3RcbiAgICAgKiBAcGFyYW0gc2F2ZWQgLSBPcHRpb25hbCBzYXZlZCBjaGVja3BvaW50IGRhdGFcbiAgICAgKiBAcGFyYW0gc3ViZ3JhcGhDaGVja3BvaW50ZXIgLSBPcHRpb25hbCBjaGVja3BvaW50ZXIgZm9yIHN1YmdyYXBoc1xuICAgICAqIEBwYXJhbSBhcHBseVBlbmRpbmdXcml0ZXMgLSBXaGV0aGVyIHRvIGFwcGx5IHBlbmRpbmcgd3JpdGVzIHRvIHRhc2tzIGFuZCB0aGVuIHRvIGNoYW5uZWxzXG4gICAgICogQHJldHVybnMgQSBzbmFwc2hvdCBvZiB0aGUgZ3JhcGggc3RhdGVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfcHJlcGFyZVN0YXRlU25hcHNob3QoeyBjb25maWcsIHNhdmVkLCBzdWJncmFwaENoZWNrcG9pbnRlciwgYXBwbHlQZW5kaW5nV3JpdGVzID0gZmFsc2UsIH0pIHtcbiAgICAgICAgaWYgKHNhdmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB7fSxcbiAgICAgICAgICAgICAgICBuZXh0OiBbXSxcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgdGFza3M6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYWxsIGNoYW5uZWxzXG4gICAgICAgIGNvbnN0IHsgbWFuYWdlZCB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlU3BlY3MoY29uZmlnLCB7XG4gICAgICAgICAgICBza2lwTWFuYWdlZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gZW1wdHlDaGFubmVscyh0aGlzLmNoYW5uZWxzLCBzYXZlZC5jaGVja3BvaW50KTtcbiAgICAgICAgLy8gQXBwbHkgbnVsbCB3cml0ZXMgZmlyc3QgKGZyb20gTlVMTF9UQVNLX0lEKVxuICAgICAgICBpZiAoc2F2ZWQucGVuZGluZ1dyaXRlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBudWxsV3JpdGVzID0gc2F2ZWQucGVuZGluZ1dyaXRlc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFt0YXNrSWQsIF9dKSA9PiB0YXNrSWQgPT09IE5VTExfVEFTS19JRClcbiAgICAgICAgICAgICAgICAubWFwKChbXywgY2hhbm5lbCwgdmFsdWVdKSA9PiBbU3RyaW5nKGNoYW5uZWwpLCB2YWx1ZV0pO1xuICAgICAgICAgICAgaWYgKG51bGxXcml0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIF9hcHBseVdyaXRlcyhzYXZlZC5jaGVja3BvaW50LCBjaGFubmVscywgW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBJTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlczogbnVsbFdyaXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVwYXJlIG5leHQgdGFza3NcbiAgICAgICAgY29uc3QgbmV4dFRhc2tzID0gT2JqZWN0LnZhbHVlcyhfcHJlcGFyZU5leHRUYXNrcyhzYXZlZC5jaGVja3BvaW50LCBzYXZlZC5wZW5kaW5nV3JpdGVzLCB0aGlzLm5vZGVzLCBjaGFubmVscywgbWFuYWdlZCwgc2F2ZWQuY29uZmlnLCB0cnVlLCB7IHN0ZXA6IChzYXZlZC5tZXRhZGF0YT8uc3RlcCA/PyAtMSkgKyAxLCBzdG9yZTogdGhpcy5zdG9yZSB9KSk7XG4gICAgICAgIC8vIEZpbmQgc3ViZ3JhcGhzXG4gICAgICAgIGNvbnN0IHN1YmdyYXBocyA9IGF3YWl0IGdhdGhlckl0ZXJhdG9yKHRoaXMuZ2V0U3ViZ3JhcGhzQXN5bmMoKSk7XG4gICAgICAgIGNvbnN0IHBhcmVudE5hbWVzcGFjZSA9IHNhdmVkLmNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfbnMgPz8gXCJcIjtcbiAgICAgICAgY29uc3QgdGFza1N0YXRlcyA9IHt9O1xuICAgICAgICAvLyBQcmVwYXJlIHRhc2sgc3RhdGVzIGZvciBzdWJncmFwaHNcbiAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIG5leHRUYXNrcykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdTdWJncmFwaCA9IHN1YmdyYXBocy5maW5kKChbbmFtZV0pID0+IG5hbWUgPT09IHRhc2submFtZSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoaW5nU3ViZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFzc2VtYmxlIGNoZWNrcG9pbnRfbnMgZm9yIHRoaXMgdGFza1xuICAgICAgICAgICAgbGV0IHRhc2tOcyA9IGAke1N0cmluZyh0YXNrLm5hbWUpfSR7Q0hFQ0tQT0lOVF9OQU1FU1BBQ0VfRU5EfSR7dGFzay5pZH1gO1xuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIHRhc2tOcyA9IGAke3BhcmVudE5hbWVzcGFjZX0ke0NIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUn0ke3Rhc2tOc31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YmdyYXBoQ2hlY2twb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgY29uZmlnIGFzIHNpZ25hbCB0aGF0IHN1YmdyYXBoIGNoZWNrcG9pbnRzIGV4aXN0XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocmVhZF9pZDogc2F2ZWQuY29uZmlnLmNvbmZpZ3VyYWJsZT8udGhyZWFkX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9uczogdGFza05zLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGFza1N0YXRlc1t0YXNrLmlkXSA9IGNvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgc3RhdGUgb2YgdGhlIHN1YmdyYXBoXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViZ3JhcGhDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXTogc3ViZ3JhcGhDaGVja3BvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJlYWRfaWQ6IHNhdmVkLmNvbmZpZy5jb25maWd1cmFibGU/LnRocmVhZF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfbnM6IHRhc2tOcyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWdlbCA9IG1hdGNoaW5nU3ViZ3JhcGhbMV07XG4gICAgICAgICAgICAgICAgdGFza1N0YXRlc1t0YXNrLmlkXSA9IGF3YWl0IHByZWdlbC5nZXRTdGF0ZShzdWJncmFwaENvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBzdWJncmFwaHM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwbHkgcGVuZGluZyB3cml0ZXMgdG8gdGFza3MgYW5kIHRoZW4gdG8gY2hhbm5lbHMgaWYgYXBwbHlQZW5kaW5nV3JpdGVzIGlzIHRydWVcbiAgICAgICAgaWYgKGFwcGx5UGVuZGluZ1dyaXRlcyAmJiBzYXZlZC5wZW5kaW5nV3JpdGVzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIE1hcCB0YXNrIElEcyB0byB0YXNrIG9iamVjdHMgZm9yIGVhc3kgbG9va3VwXG4gICAgICAgICAgICBjb25zdCBuZXh0VGFza0J5SWQgPSBPYmplY3QuZnJvbUVudHJpZXMobmV4dFRhc2tzLm1hcCgodGFzaykgPT4gW3Rhc2suaWQsIHRhc2tdKSk7XG4gICAgICAgICAgICAvLyBBcHBseSBwZW5kaW5nIHdyaXRlcyB0byB0aGUgYXBwcm9wcmlhdGUgdGFza3NcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3Rhc2tJZCwgY2hhbm5lbCwgdmFsdWVdIG9mIHNhdmVkLnBlbmRpbmdXcml0ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHNwZWNpYWwgY2hhbm5lbHMgYW5kIHRhc2tzIG5vdCBpbiBuZXh0VGFza3NcbiAgICAgICAgICAgICAgICBpZiAoW0VSUk9SLCBJTlRFUlJVUFQsIFNDSEVEVUxFRF0uaW5jbHVkZXMoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKHRhc2tJZCBpbiBuZXh0VGFza0J5SWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHdyaXRlIHRvIHRoZSB0YXNrXG4gICAgICAgICAgICAgICAgbmV4dFRhc2tCeUlkW3Rhc2tJZF0ud3JpdGVzLnB1c2goW1N0cmluZyhjaGFubmVsKSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGx5IHdyaXRlcyBmcm9tIHRhc2tzIHRoYXQgaGF2ZSB3cml0ZXNcbiAgICAgICAgICAgIGNvbnN0IHRhc2tzV2l0aFdyaXRlcyA9IG5leHRUYXNrcy5maWx0ZXIoKHRhc2spID0+IHRhc2sud3JpdGVzLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgaWYgKHRhc2tzV2l0aFdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgX2FwcGx5V3JpdGVzKHNhdmVkLmNoZWNrcG9pbnQsIGNoYW5uZWxzLCB0YXNrc1dpdGhXcml0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFByZXNlcnZlIHRocmVhZF9pZCBmcm9tIHRoZSBjb25maWcgaW4gbWV0YWRhdGFcbiAgICAgICAgbGV0IG1ldGFkYXRhID0gc2F2ZWQ/Lm1ldGFkYXRhO1xuICAgICAgICBpZiAobWV0YWRhdGEgJiYgc2F2ZWQ/LmNvbmZpZz8uY29uZmlndXJhYmxlPy50aHJlYWRfaWQpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHRocmVhZF9pZDogc2F2ZWQuY29uZmlnLmNvbmZpZ3VyYWJsZS50aHJlYWRfaWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbHRlciBuZXh0IHRhc2tzIC0gb25seSBpbmNsdWRlIHRhc2tzIHdpdGhvdXQgd3JpdGVzXG4gICAgICAgIGNvbnN0IG5leHRMaXN0ID0gbmV4dFRhc2tzXG4gICAgICAgICAgICAuZmlsdGVyKCh0YXNrKSA9PiB0YXNrLndyaXRlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAubWFwKCh0YXNrKSA9PiB0YXNrLm5hbWUpO1xuICAgICAgICAvLyBhc3NlbWJsZSB0aGUgc3RhdGUgc25hcHNob3RcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlczogcmVhZENoYW5uZWxzKGNoYW5uZWxzLCB0aGlzLnN0cmVhbUNoYW5uZWxzQXNJcyksXG4gICAgICAgICAgICBuZXh0OiBuZXh0TGlzdCxcbiAgICAgICAgICAgIHRhc2tzOiB0YXNrc1dpdGhXcml0ZXMobmV4dFRhc2tzLCBzYXZlZD8ucGVuZGluZ1dyaXRlcyA/PyBbXSwgdGFza1N0YXRlcyksXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIGNvbmZpZzogcGF0Y2hDaGVja3BvaW50TWFwKHNhdmVkLmNvbmZpZywgc2F2ZWQubWV0YWRhdGEpLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBzYXZlZC5jaGVja3BvaW50LnRzLFxuICAgICAgICAgICAgcGFyZW50Q29uZmlnOiBzYXZlZC5wYXJlbnRDb25maWcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGdyYXBoLlxuICAgICAqIFJlcXVpcmVzIGEgY2hlY2twb2ludGVyIHRvIGJlIGNvbmZpZ3VyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgc3RhdGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIEEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgZ3JhcGggc3RhdGVcbiAgICAgKiBAdGhyb3dzIHtHcmFwaFZhbHVlRXJyb3J9IElmIG5vIGNoZWNrcG9pbnRlciBpcyBjb25maWd1cmVkXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3RhdGUoY29uZmlnLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnRlciA9IGNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl0gPz8gdGhpcy5jaGVja3BvaW50ZXI7XG4gICAgICAgIGlmICghY2hlY2twb2ludGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhWYWx1ZUVycm9yKFwiTm8gY2hlY2twb2ludGVyIHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja3BvaW50TmFtZXNwYWNlID0gY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9ucyA/PyBcIlwiO1xuICAgICAgICBpZiAoY2hlY2twb2ludE5hbWVzcGFjZSAhPT0gXCJcIiAmJlxuICAgICAgICAgICAgY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGFza19pZHMgZnJvbSBjaGVja3BvaW50X25zXG4gICAgICAgICAgICBjb25zdCByZWNhc3ROYW1lc3BhY2UgPSByZWNhc3RDaGVja3BvaW50TmFtZXNwYWNlKGNoZWNrcG9pbnROYW1lc3BhY2UpO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBbbmFtZSwgc3ViZ3JhcGhdIG9mIHRoaXMuZ2V0U3ViZ3JhcGhzQXN5bmMocmVjYXN0TmFtZXNwYWNlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSByZWNhc3ROYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN1YmdyYXBoLmdldFN0YXRlKHBhdGNoQ29uZmlndXJhYmxlKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXTogY2hlY2twb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICB9KSwgeyBzdWJncmFwaHM6IG9wdGlvbnM/LnN1YmdyYXBocyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1YmdyYXBoIHdpdGggbmFtZXNwYWNlIFwiJHtyZWNhc3ROYW1lc3BhY2V9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lcmdlZENvbmZpZyA9IG1lcmdlQ29uZmlncyh0aGlzLmNvbmZpZywgY29uZmlnKTtcbiAgICAgICAgY29uc3Qgc2F2ZWQgPSBhd2FpdCBjaGVja3BvaW50ZXIuZ2V0VHVwbGUoY29uZmlnKTtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCB0aGlzLl9wcmVwYXJlU3RhdGVTbmFwc2hvdCh7XG4gICAgICAgICAgICBjb25maWc6IG1lcmdlZENvbmZpZyxcbiAgICAgICAgICAgIHNhdmVkLFxuICAgICAgICAgICAgc3ViZ3JhcGhDaGVja3BvaW50ZXI6IG9wdGlvbnM/LnN1YmdyYXBocyA/IGNoZWNrcG9pbnRlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFwcGx5UGVuZGluZ1dyaXRlczogIWNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfaWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhpc3Rvcnkgb2YgZ3JhcGggc3RhdGVzLlxuICAgICAqIFJlcXVpcmVzIGEgY2hlY2twb2ludGVyIHRvIGJlIGNvbmZpZ3VyZWQuXG4gICAgICogVXNlZnVsIGZvcjpcbiAgICAgKiAtIERlYnVnZ2luZyBleGVjdXRpb24gaGlzdG9yeVxuICAgICAqIC0gSW1wbGVtZW50aW5nIHRpbWUgdHJhdmVsXG4gICAgICogLSBBbmFseXppbmcgZ3JhcGggYmVoYXZpb3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIGZvciByZXRyaWV2aW5nIHRoZSBoaXN0b3J5XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBmaWx0ZXJpbmcgdGhlIGhpc3RvcnlcbiAgICAgKiBAcmV0dXJucyBBbiBhc3luYyBpdGVyYXRvciBvZiBzdGF0ZSBzbmFwc2hvdHNcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgbm8gY2hlY2twb2ludGVyIGlzIGNvbmZpZ3VyZWRcbiAgICAgKi9cbiAgICBhc3luYyAqZ2V0U3RhdGVIaXN0b3J5KGNvbmZpZywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjaGVja3BvaW50ZXIgPSBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9DSEVDS1BPSU5URVJdID8/IHRoaXMuY2hlY2twb2ludGVyO1xuICAgICAgICBpZiAoIWNoZWNrcG9pbnRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hlY2twb2ludGVyIHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja3BvaW50TmFtZXNwYWNlID0gY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9ucyA/PyBcIlwiO1xuICAgICAgICBpZiAoY2hlY2twb2ludE5hbWVzcGFjZSAhPT0gXCJcIiAmJlxuICAgICAgICAgICAgY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByZWNhc3ROYW1lc3BhY2UgPSByZWNhc3RDaGVja3BvaW50TmFtZXNwYWNlKGNoZWNrcG9pbnROYW1lc3BhY2UpO1xuICAgICAgICAgICAgLy8gZmluZCB0aGUgc3ViZ3JhcGggd2l0aCB0aGUgbWF0Y2hpbmcgbmFtZVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBbbmFtZSwgcHJlZ2VsXSBvZiB0aGlzLmdldFN1YmdyYXBoc0FzeW5jKHJlY2FzdE5hbWVzcGFjZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gcmVjYXN0TmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiBwcmVnZWwuZ2V0U3RhdGVIaXN0b3J5KHBhdGNoQ29uZmlndXJhYmxlKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXTogY2hlY2twb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICB9KSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1YmdyYXBoIHdpdGggbmFtZXNwYWNlIFwiJHtyZWNhc3ROYW1lc3BhY2V9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lcmdlZENvbmZpZyA9IG1lcmdlQ29uZmlncyh0aGlzLmNvbmZpZywgY29uZmlnLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHsgY2hlY2twb2ludF9uczogY2hlY2twb2ludE5hbWVzcGFjZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaGVja3BvaW50VHVwbGUgb2YgY2hlY2twb2ludGVyLmxpc3QobWVyZ2VkQ29uZmlnLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5fcHJlcGFyZVN0YXRlU25hcHNob3Qoe1xuICAgICAgICAgICAgICAgIGNvbmZpZzogY2hlY2twb2ludFR1cGxlLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBzYXZlZDogY2hlY2twb2ludFR1cGxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgdXBkYXRlcyB0byB0aGUgZ3JhcGggc3RhdGUgaW4gYnVsay5cbiAgICAgKiBSZXF1aXJlcyBhIGNoZWNrcG9pbnRlciB0byBiZSBjb25maWd1cmVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciByZWNyZWF0aW5nIGEgdGhyZWFkXG4gICAgICogZnJvbSBhIGxpc3Qgb2YgdXBkYXRlcywgZXNwZWNpYWxseSBpZiBhIGNoZWNrcG9pbnRcbiAgICAgKiBpcyBjcmVhdGVkIGFzIGEgcmVzdWx0IG9mIG11bHRpcGxlIHRhc2tzLlxuICAgICAqXG4gICAgICogQGludGVybmFsIFRoZSBBUEkgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnRDb25maWcgLSBDb25maWd1cmF0aW9uIGZvciB0aGUgdXBkYXRlXG4gICAgICogQHBhcmFtIHVwZGF0ZXMgLSBUaGUgbGlzdCBvZiB1cGRhdGVzIHRvIGFwcGx5IHRvIGdyYXBoIHN0YXRlXG4gICAgICogQHJldHVybnMgVXBkYXRlZCBjb25maWd1cmF0aW9uXG4gICAgICogQHRocm93cyB7R3JhcGhWYWx1ZUVycm9yfSBJZiBubyBjaGVja3BvaW50ZXIgaXMgY29uZmlndXJlZFxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRVcGRhdGVFcnJvcn0gSWYgdGhlIHVwZGF0ZSBjYW5ub3QgYmUgYXR0cmlidXRlZCB0byBhIG5vZGUgb3IgYW4gdXBkYXRlIGNhbiBiZSBvbmx5IGFwcGxpZWQgaW4gc2VxdWVuY2UuXG4gICAgICovXG4gICAgYXN5bmMgYnVsa1VwZGF0ZVN0YXRlKHN0YXJ0Q29uZmlnLCBzdXBlcnN0ZXBzKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnRlciA9IHN0YXJ0Q29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXSA/PyB0aGlzLmNoZWNrcG9pbnRlcjtcbiAgICAgICAgaWYgKCFjaGVja3BvaW50ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcmFwaFZhbHVlRXJyb3IoXCJObyBjaGVja3BvaW50ZXIgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXBlcnN0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VwZXJzdGVwcyBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VwZXJzdGVwcy5zb21lKChzKSA9PiBzLnVwZGF0ZXMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXBkYXRlcyBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWxlZ2F0ZSB0byBzdWJncmFwaFxuICAgICAgICBjb25zdCBjaGVja3BvaW50TmFtZXNwYWNlID0gc3RhcnRDb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zID8/IFwiXCI7XG4gICAgICAgIGlmIChjaGVja3BvaW50TmFtZXNwYWNlICE9PSBcIlwiICYmXG4gICAgICAgICAgICBzdGFydENvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRhc2tfaWRzIGZyb20gY2hlY2twb2ludF9uc1xuICAgICAgICAgICAgY29uc3QgcmVjYXN0TmFtZXNwYWNlID0gcmVjYXN0Q2hlY2twb2ludE5hbWVzcGFjZShjaGVja3BvaW50TmFtZXNwYWNlKTtcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIHN1YmdyYXBoIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZS1sb29wXG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IFssIHByZWdlbF0gb2YgdGhpcy5nZXRTdWJncmFwaHNBc3luYyhyZWNhc3ROYW1lc3BhY2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByZWdlbC5idWxrVXBkYXRlU3RhdGUocGF0Y2hDb25maWd1cmFibGUoc3RhcnRDb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXTogY2hlY2twb2ludGVyLFxuICAgICAgICAgICAgICAgIH0pLCBzdXBlcnN0ZXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3ViZ3JhcGggXCIke3JlY2FzdE5hbWVzcGFjZX1cIiBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVTdXBlclN0ZXAgPSBhc3luYyAoaW5wdXRDb25maWcsIHVwZGF0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGdldCBsYXN0IGNoZWNrcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnXG4gICAgICAgICAgICAgICAgPyBtZXJnZUNvbmZpZ3ModGhpcy5jb25maWcsIGlucHV0Q29uZmlnKVxuICAgICAgICAgICAgICAgIDogaW5wdXRDb25maWc7XG4gICAgICAgICAgICBjb25zdCBzYXZlZCA9IGF3YWl0IGNoZWNrcG9pbnRlci5nZXRUdXBsZShjb25maWcpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2twb2ludCA9IHNhdmVkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGNvcHlDaGVja3BvaW50KHNhdmVkLmNoZWNrcG9pbnQpXG4gICAgICAgICAgICAgICAgOiBlbXB0eUNoZWNrcG9pbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrcG9pbnRQcmV2aW91c1ZlcnNpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnNhdmVkPy5jaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHNhdmVkPy5tZXRhZGF0YT8uc3RlcCA/PyAtMTtcbiAgICAgICAgICAgIC8vIG1lcmdlIGNvbmZpZ3VyYWJsZSBmaWVsZHMgd2l0aCBwcmV2aW91cyBjaGVja3BvaW50IGNvbmZpZ1xuICAgICAgICAgICAgbGV0IGNoZWNrcG9pbnRDb25maWcgPSBwYXRjaENvbmZpZ3VyYWJsZShjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zOiBjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zID8/IFwiXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBjaGVja3BvaW50TWV0YWRhdGEgPSBjb25maWcubWV0YWRhdGEgPz8ge307XG4gICAgICAgICAgICBpZiAoc2F2ZWQ/LmNvbmZpZy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50Q29uZmlnID0gcGF0Y2hDb25maWd1cmFibGUoY29uZmlnLCBzYXZlZC5jb25maWcuY29uZmlndXJhYmxlKTtcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50TWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnNhdmVkLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAuLi5jaGVja3BvaW50TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgbGFzdCBub2RlIHRoYXQgdXBkYXRlZCB0aGUgc3RhdGUsIGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZXMsIGFzTm9kZSB9ID0gdXBkYXRlc1swXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMgPT0gbnVsbCAmJiBhc05vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcGRhdGVFcnJvcihgQ2Fubm90IGNyZWF0ZSBlbXB0eSBjaGVja3BvaW50IHdpdGggbXVsdGlwbGUgdXBkYXRlc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q29uZmlnID0gYXdhaXQgY2hlY2twb2ludGVyLnB1dChjaGVja3BvaW50Q29uZmlnLCBjcmVhdGVDaGVja3BvaW50KGNoZWNrcG9pbnQsIHVuZGVmaW5lZCwgc3RlcCksIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBcInVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBzdGVwOiBzdGVwICsgMSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50czogc2F2ZWQ/Lm1ldGFkYXRhPy5wYXJlbnRzID8/IHt9LFxuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hDaGVja3BvaW50TWFwKG5leHRDb25maWcsIHNhdmVkID8gc2F2ZWQubWV0YWRhdGEgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXBkYXRlIGNoYW5uZWxzXG4gICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IGVtcHR5Q2hhbm5lbHModGhpcy5jaGFubmVscywgY2hlY2twb2ludCk7XG4gICAgICAgICAgICAvLyBQYXNzIGBza2lwTWFuYWdlZDogdHJ1ZWAgYXMgbWFuYWdlZCB2YWx1ZXMgYXJlIG5vdCB1c2VkL3JlbGV2YW50IGluIHVwZGF0ZSBzdGF0ZSBjYWxscy5cbiAgICAgICAgICAgIGNvbnN0IHsgbWFuYWdlZCB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlU3BlY3MoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgc2tpcE1hbmFnZWQ6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMgPT09IG51bGwgJiYgYXNOb2RlID09PSBFTkQpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoYENhbm5vdCBhcHBseSBtdWx0aXBsZSB1cGRhdGVzIHdoZW4gY2xlYXJpbmcgc3RhdGVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNhdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRhc2tzIGZvciB0aGlzIGNoZWNrcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRhc2tzID0gX3ByZXBhcmVOZXh0VGFza3MoY2hlY2twb2ludCwgc2F2ZWQucGVuZGluZ1dyaXRlcyB8fCBbXSwgdGhpcy5ub2RlcywgY2hhbm5lbHMsIG1hbmFnZWQsIHNhdmVkLmNvbmZpZywgdHJ1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogKHNhdmVkLm1ldGFkYXRhPy5zdGVwID8/IC0xKSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50ZXI6IHRoaXMuY2hlY2twb2ludGVyIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlOiB0aGlzLnN0b3JlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgbnVsbCB3cml0ZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVsbFdyaXRlcyA9IChzYXZlZC5wZW5kaW5nV3JpdGVzIHx8IFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodykgPT4gd1swXSA9PT0gTlVMTF9UQVNLX0lEKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgodykgPT4gdy5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsV3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hcHBseVdyaXRlcyhzYXZlZC5jaGVja3BvaW50LCBjaGFubmVscywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlczogbnVsbFdyaXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSB3cml0ZXMgZnJvbSB0YXNrcyB0aGF0IGFscmVhZHkgcmFuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3Rhc2tJZCwgaywgdl0gb2Ygc2F2ZWQucGVuZGluZ1dyaXRlcyB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFtFUlJPUiwgSU5URVJSVVBULCBTQ0hFRFVMRURdLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0YXNrSWQgaW4gbmV4dFRhc2tzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFRhc2tzW3Rhc2tJZF0ud3JpdGVzLnB1c2goW2ssIHZdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBhbGwgY3VycmVudCB0YXNrc1xuICAgICAgICAgICAgICAgICAgICBfYXBwbHlXcml0ZXMoY2hlY2twb2ludCwgY2hhbm5lbHMsIE9iamVjdC52YWx1ZXMobmV4dFRhc2tzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNhdmUgY2hlY2twb2ludFxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDb25maWcgPSBhd2FpdCBjaGVja3BvaW50ZXIucHV0KGNoZWNrcG9pbnRDb25maWcsIGNyZWF0ZUNoZWNrcG9pbnQoY2hlY2twb2ludCwgdW5kZWZpbmVkLCBzdGVwKSwge1xuICAgICAgICAgICAgICAgICAgICAuLi5jaGVja3BvaW50TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcCArIDEsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlczoge30sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHM6IHNhdmVkPy5tZXRhZGF0YT8ucGFyZW50cyA/PyB7fSxcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGNoQ2hlY2twb2ludE1hcChuZXh0Q29uZmlnLCBzYXZlZCA/IHNhdmVkLm1ldGFkYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMgPT0gbnVsbCAmJiBhc05vZGUgPT09IENPUFkpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoYENhbm5vdCBjb3B5IGNoZWNrcG9pbnQgd2l0aCBtdWx0aXBsZSB1cGRhdGVzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDb25maWcgPSBhd2FpdCBjaGVja3BvaW50ZXIucHV0KHNhdmVkPy5wYXJlbnRDb25maWcgPz8gY2hlY2twb2ludENvbmZpZywgY3JlYXRlQ2hlY2twb2ludChjaGVja3BvaW50LCB1bmRlZmluZWQsIHN0ZXApLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogXCJmb3JrXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHN0ZXAgKyAxLFxuICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzOiBzYXZlZD8ubWV0YWRhdGE/LnBhcmVudHMgPz8ge30sXG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaENoZWNrcG9pbnRNYXAobmV4dENvbmZpZywgc2F2ZWQgPyBzYXZlZC5tZXRhZGF0YSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXNOb2RlID09PSBJTlBVVCkge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcGRhdGVFcnJvcihgQ2Fubm90IGFwcGx5IG11bHRpcGxlIHVwZGF0ZXMgd2hlbiB1cGRhdGluZyBhcyBpbnB1dGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dFdyaXRlcyA9IGF3YWl0IGdhdGhlckl0ZXJhdG9yKG1hcElucHV0KHRoaXMuaW5wdXRDaGFubmVscywgdmFsdWVzKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0V3JpdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBSZWNlaXZlZCBubyBpbnB1dCB3cml0ZXMgZm9yICR7SlNPTi5zdHJpbmdpZnkodGhpcy5pbnB1dENoYW5uZWxzLCBudWxsLCAyKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgdG8gY2hlY2twb2ludFxuICAgICAgICAgICAgICAgIF9hcHBseVdyaXRlcyhjaGVja3BvaW50LCBjaGFubmVscywgW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBJTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlczogaW5wdXRXcml0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSwgY2hlY2twb2ludGVyLmdldE5leHRWZXJzaW9uLmJpbmQodGhpcy5jaGVja3BvaW50ZXIpKTtcbiAgICAgICAgICAgICAgICAvLyBhcHBseSBpbnB1dCB3cml0ZSB0byBjaGFubmVsc1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTdGVwID0gc2F2ZWQ/Lm1ldGFkYXRhPy5zdGVwICE9IG51bGwgPyBzYXZlZC5tZXRhZGF0YS5zdGVwICsgMSA6IC0xO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDb25maWcgPSBhd2FpdCBjaGVja3BvaW50ZXIucHV0KGNoZWNrcG9pbnRDb25maWcsIGNyZWF0ZUNoZWNrcG9pbnQoY2hlY2twb2ludCwgY2hhbm5lbHMsIG5leHRTdGVwKSwge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogbmV4dFN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlczogT2JqZWN0LmZyb21FbnRyaWVzKGlucHV0V3JpdGVzKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50czogc2F2ZWQ/Lm1ldGFkYXRhPy5wYXJlbnRzID8/IHt9LFxuICAgICAgICAgICAgICAgIH0sIGdldE5ld0NoYW5uZWxWZXJzaW9ucyhjaGVja3BvaW50UHJldmlvdXNWZXJzaW9ucywgY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zKSk7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHdyaXRlc1xuICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrcG9pbnRlci5wdXRXcml0ZXMobmV4dENvbmZpZywgaW5wdXRXcml0ZXMsIHV1aWQ1KElOUFVULCBjaGVja3BvaW50LmlkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGNoQ2hlY2twb2ludE1hcChuZXh0Q29uZmlnLCBzYXZlZCA/IHNhdmVkLm1ldGFkYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGx5IHBlbmRpbmcgd3JpdGVzLCBpZiBub3Qgb24gc3BlY2lmaWMgY2hlY2twb2ludFxuICAgICAgICAgICAgaWYgKGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfaWQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNhdmVkPy5wZW5kaW5nV3JpdGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzYXZlZC5wZW5kaW5nV3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyB0YXNrcyBmb3IgdGhpcyBjaGVja3BvaW50XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRhc2tzID0gX3ByZXBhcmVOZXh0VGFza3MoY2hlY2twb2ludCwgc2F2ZWQucGVuZGluZ1dyaXRlcywgdGhpcy5ub2RlcywgY2hhbm5lbHMsIG1hbmFnZWQsIHNhdmVkLmNvbmZpZywgdHJ1ZSwge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZTogdGhpcy5zdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludGVyOiB0aGlzLmNoZWNrcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogKHNhdmVkLm1ldGFkYXRhPy5zdGVwID8/IC0xKSArIDEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgbnVsbCB3cml0ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBudWxsV3JpdGVzID0gKHNhdmVkLnBlbmRpbmdXcml0ZXMgPz8gW10pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHcpID0+IHdbMF0gPT09IE5VTExfVEFTS19JRClcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgodykgPT4gdy5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bGxXcml0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfYXBwbHlXcml0ZXMoc2F2ZWQuY2hlY2twb2ludCwgY2hhbm5lbHMsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBJTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IG51bGxXcml0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IHdyaXRlc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3RpZCwgaywgdl0gb2Ygc2F2ZWQucGVuZGluZ1dyaXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoW0VSUk9SLCBJTlRFUlJVUFQsIFNDSEVEVUxFRF0uaW5jbHVkZXMoaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRUYXNrc1t0aWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHRUYXNrc1t0aWRdLndyaXRlcy5wdXNoKFtrLCB2XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2tzID0gT2JqZWN0LnZhbHVlcyhuZXh0VGFza3MpLmZpbHRlcigodGFzaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzay53cml0ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfYXBwbHlXcml0ZXMoY2hlY2twb2ludCwgY2hhbm5lbHMsIHRhc2tzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub25OdWxsVmVyc2lvbiA9IE9iamVjdC52YWx1ZXMoY2hlY2twb2ludC52ZXJzaW9uc19zZWVuKVxuICAgICAgICAgICAgICAgIC5tYXAoKHNlZW5WZXJzaW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHNlZW5WZXJzaW9ucyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mbGF0KClcbiAgICAgICAgICAgICAgICAuZmluZCgodikgPT4gISF2KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkVXBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICAgICAgICAgIGxldCB7IHZhbHVlcywgYXNOb2RlIH0gPSB1cGRhdGVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChhc05vZGUgPT09IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyh0aGlzLm5vZGVzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgb25seSBvbmUgbm9kZSwgdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgIFthc05vZGVdID0gT2JqZWN0LmtleXModGhpcy5ub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFzTm9kZSA9PT0gdW5kZWZpbmVkICYmIG5vbk51bGxWZXJzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlucHV0Q2hhbm5lbHMgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbdGhpcy5pbnB1dENoYW5uZWxzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc05vZGUgPSB0aGlzLmlucHV0Q2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXNOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFNlZW5CeU5vZGUgPSBPYmplY3QuZW50cmllcyhjaGVja3BvaW50LnZlcnNpb25zX3NlZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChbbiwgc2Vlbl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHNlZW4pLm1hcCgodikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbdiwgbl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mbGF0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KChbYU51bWJlcl0sIFtiTnVtYmVyXSkgPT4gY29tcGFyZUNoYW5uZWxWZXJzaW9ucyhhTnVtYmVyLCBiTnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHR3byBub2RlcyB1cGRhdGVkIHRoZSBzdGF0ZSBhdCB0aGUgc2FtZSB0aW1lLCBpdCdzIGFtYmlndW91c1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFNlZW5CeU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U2VlbkJ5Tm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vZGUgPSBsYXN0U2VlbkJ5Tm9kZVswXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RTZWVuQnlOb2RlW2xhc3RTZWVuQnlOb2RlLmxlbmd0aCAtIDFdWzBdICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWVuQnlOb2RlW2xhc3RTZWVuQnlOb2RlLmxlbmd0aCAtIDJdWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb2RlID0gbGFzdFNlZW5CeU5vZGVbbGFzdFNlZW5CeU5vZGUubGVuZ3RoIC0gMV1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFzTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoYEFtYmlndW91cyB1cGRhdGUsIHNwZWNpZnkgXCJhc05vZGVcImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWxpZFVwZGF0ZXMucHVzaCh7IHZhbHVlcywgYXNOb2RlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGFzTm9kZSwgdmFsdWVzIH0gb2YgdXBkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXNOb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoYFwiYXNOb2RlXCIgaXMgcmVxdWlyZWQgd2hlbiBhcHBseWluZyBtdWx0aXBsZSB1cGRhdGVzYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsaWRVcGRhdGVzLnB1c2goeyB2YWx1ZXMsIGFzTm9kZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGFzTm9kZSwgdmFsdWVzIH0gb2YgdmFsaWRVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbYXNOb2RlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoYE5vZGUgXCIke2FzTm9kZS50b1N0cmluZygpfVwiIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJ1biBhbGwgd3JpdGVycyBvZiB0aGUgY2hvc2VuIG5vZGVcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXJzID0gdGhpcy5ub2Rlc1thc05vZGVdLmdldFdyaXRlcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdyaXRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoYE5vIHdyaXRlcnMgZm91bmQgZm9yIG5vZGUgXCIke2FzTm9kZS50b1N0cmluZygpfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhc2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBhc05vZGUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgIHByb2M6IHdyaXRlcnMubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJ1bm5hYmxlU2VxdWVuY2UuZnJvbSh3cml0ZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9taXRTZXF1ZW5jZVRhZ3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogd3JpdGVyc1swXSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnM6IFtJTlRFUlJVUFRdLFxuICAgICAgICAgICAgICAgICAgICBpZDogdXVpZDUoSU5URVJSVVBULCBjaGVja3BvaW50LmlkKSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyczogW10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIHRhc2tcbiAgICAgICAgICAgICAgICBhd2FpdCB0YXNrLnByb2MuaW52b2tlKHRhc2suaW5wdXQsIHBhdGNoQ29uZmlnKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZTogY29uZmlnPy5zdG9yZSA/PyB0aGlzLnN0b3JlLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuTmFtZTogY29uZmlnLnJ1bk5hbWUgPz8gYCR7dGhpcy5nZXROYW1lKCl9VXBkYXRlU3RhdGVgLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1NFTkRdOiAoaXRlbXMpID0+IHRhc2sud3JpdGVzLnB1c2goLi4uaXRlbXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfUkVBRF06IChzZWxlY3RfLCBmcmVzaF8gPSBmYWxzZSkgPT4gX2xvY2FsUmVhZChzdGVwLCBjaGVja3BvaW50LCBjaGFubmVscywgbWFuYWdlZCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXaHkgZG9lcyBrZXlvZiBTdHJSZWNvcmQgYWxsb3cgbnVtYmVyIGFuZCBzeW1ib2w/XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLCBzZWxlY3RfLCBmcmVzaF8pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFzayBvZiB0YXNrcykge1xuICAgICAgICAgICAgICAgIC8vIGNoYW5uZWwgd3JpdGVzIGFyZSBzYXZlZCB0byBjdXJyZW50IGNoZWNrcG9pbnRcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsV3JpdGVzID0gdGFzay53cml0ZXMuZmlsdGVyKCh3KSA9PiB3WzBdICE9PSBQVVNIKTtcbiAgICAgICAgICAgICAgICAvLyBzYXZlIHRhc2sgd3JpdGVzXG4gICAgICAgICAgICAgICAgaWYgKHNhdmVkICE9PSB1bmRlZmluZWQgJiYgY2hhbm5lbFdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrcG9pbnRlci5wdXRXcml0ZXMoY2hlY2twb2ludENvbmZpZywgY2hhbm5lbFdyaXRlcywgdGFzay5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwbHkgdG8gY2hlY2twb2ludFxuICAgICAgICAgICAgLy8gVE9ETzogV2h5IGRvZXMga2V5b2YgU3RyUmVjb3JkIGFsbG93IG51bWJlciBhbmQgc3ltYm9sP1xuICAgICAgICAgICAgX2FwcGx5V3JpdGVzKGNoZWNrcG9pbnQsIGNoYW5uZWxzLCB0YXNrcywgY2hlY2twb2ludGVyLmdldE5leHRWZXJzaW9uLmJpbmQodGhpcy5jaGVja3BvaW50ZXIpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZlcnNpb25zID0gZ2V0TmV3Q2hhbm5lbFZlcnNpb25zKGNoZWNrcG9pbnRQcmV2aW91c1ZlcnNpb25zLCBjaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnMpO1xuICAgICAgICAgICAgY29uc3QgbmV4dENvbmZpZyA9IGF3YWl0IGNoZWNrcG9pbnRlci5wdXQoY2hlY2twb2ludENvbmZpZywgY3JlYXRlQ2hlY2twb2ludChjaGVja3BvaW50LCBjaGFubmVscywgc3RlcCArIDEpLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBcInVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHN0ZXAgKyAxLFxuICAgICAgICAgICAgICAgIHdyaXRlczogT2JqZWN0LmZyb21FbnRyaWVzKHZhbGlkVXBkYXRlcy5tYXAoKHVwZGF0ZSkgPT4gW3VwZGF0ZS5hc05vZGUsIHVwZGF0ZS52YWx1ZXNdKSksXG4gICAgICAgICAgICAgICAgcGFyZW50czogc2F2ZWQ/Lm1ldGFkYXRhPy5wYXJlbnRzID8/IHt9LFxuICAgICAgICAgICAgfSwgbmV3VmVyc2lvbnMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgICAgICAgICAgICAgLy8gcHVzaCB3cml0ZXMgYXJlIHNhdmVkIHRvIG5leHQgY2hlY2twb2ludFxuICAgICAgICAgICAgICAgIGNvbnN0IHB1c2hXcml0ZXMgPSB0YXNrLndyaXRlcy5maWx0ZXIoKHcpID0+IHdbMF0gPT09IFBVU0gpO1xuICAgICAgICAgICAgICAgIGlmIChwdXNoV3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hlY2twb2ludGVyLnB1dFdyaXRlcyhuZXh0Q29uZmlnLCBwdXNoV3JpdGVzLCB0YXNrLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0Y2hDaGVja3BvaW50TWFwKG5leHRDb25maWcsIHNhdmVkID8gc2F2ZWQubWV0YWRhdGEgOiB1bmRlZmluZWQpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY3VycmVudENvbmZpZyA9IHN0YXJ0Q29uZmlnO1xuICAgICAgICBmb3IgKGNvbnN0IHsgdXBkYXRlcyB9IG9mIHN1cGVyc3RlcHMpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDb25maWcgPSBhd2FpdCB1cGRhdGVTdXBlclN0ZXAoY3VycmVudENvbmZpZywgdXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBncmFwaCB3aXRoIG5ldyB2YWx1ZXMuXG4gICAgICogUmVxdWlyZXMgYSBjaGVja3BvaW50ZXIgdG8gYmUgY29uZmlndXJlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvcjpcbiAgICAgKiAtIEltcGxlbWVudGluZyBodW1hbi1pbi10aGUtbG9vcCB3b3JrZmxvd3NcbiAgICAgKiAtIE1vZGlmeWluZyBncmFwaCBzdGF0ZSBkdXJpbmcgYnJlYWtwb2ludHNcbiAgICAgKiAtIEludGVncmF0aW5nIGV4dGVybmFsIGlucHV0cyBpbnRvIHRoZSBncmFwaFxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0Q29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgdGhlIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHVwZGF0ZSB0aGUgc3RhdGUgd2l0aFxuICAgICAqIEBwYXJhbSBhc05vZGUgLSBPcHRpb25hbCBub2RlIG5hbWUgdG8gYXR0cmlidXRlIHRoZSB1cGRhdGUgdG9cbiAgICAgKiBAcmV0dXJucyBVcGRhdGVkIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAdGhyb3dzIHtHcmFwaFZhbHVlRXJyb3J9IElmIG5vIGNoZWNrcG9pbnRlciBpcyBjb25maWd1cmVkXG4gICAgICogQHRocm93cyB7SW52YWxpZFVwZGF0ZUVycm9yfSBJZiB0aGUgdXBkYXRlIGNhbm5vdCBiZSBhdHRyaWJ1dGVkIHRvIGEgbm9kZVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVN0YXRlKGlucHV0Q29uZmlnLCB2YWx1ZXMsIGFzTm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWxrVXBkYXRlU3RhdGUoaW5wdXRDb25maWcsIFtcbiAgICAgICAgICAgIHsgdXBkYXRlczogW3sgdmFsdWVzLCBhc05vZGUgfV0gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdmFsdWVzIGZvciB2YXJpb3VzIGdyYXBoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZCB1c2VkIHRvIHByb2Nlc3MgYW5kIG5vcm1hbGl6ZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGlucHV0IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyBub3JtYWxpemVkIHZhbHVlcyBmb3I6XG4gICAgICogLSBkZWJ1ZyBtb2RlXG4gICAgICogLSBzdHJlYW0gbW9kZXNcbiAgICAgKiAtIGlucHV0IGtleXNcbiAgICAgKiAtIG91dHB1dCBrZXlzXG4gICAgICogLSByZW1haW5pbmcgY29uZmlnXG4gICAgICogLSBpbnRlcnJ1cHQgYmVmb3JlIG5vZGVzXG4gICAgICogLSBpbnRlcnJ1cHQgYWZ0ZXIgbm9kZXNcbiAgICAgKiAtIGNoZWNrcG9pbnRlclxuICAgICAqIC0gc3RvcmVcbiAgICAgKiAtIHdoZXRoZXIgc3RyZWFtIG1vZGUgaXMgc2luZ2xlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2RlZmF1bHRzKGNvbmZpZykge1xuICAgICAgICBjb25zdCB7IGRlYnVnLCBzdHJlYW1Nb2RlLCBpbnB1dEtleXMsIG91dHB1dEtleXMsIGludGVycnVwdEFmdGVyLCBpbnRlcnJ1cHRCZWZvcmUsIC4uLnJlc3QgfSA9IGNvbmZpZztcbiAgICAgICAgbGV0IHN0cmVhbU1vZGVTaW5nbGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBkZWZhdWx0RGVidWcgPSBkZWJ1ZyAhPT0gdW5kZWZpbmVkID8gZGVidWcgOiB0aGlzLmRlYnVnO1xuICAgICAgICBsZXQgZGVmYXVsdE91dHB1dEtleXMgPSBvdXRwdXRLZXlzO1xuICAgICAgICBpZiAoZGVmYXVsdE91dHB1dEtleXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmYXVsdE91dHB1dEtleXMgPSB0aGlzLnN0cmVhbUNoYW5uZWxzQXNJcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRlS2V5cyhkZWZhdWx0T3V0cHV0S2V5cywgdGhpcy5jaGFubmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRJbnB1dEtleXMgPSBpbnB1dEtleXM7XG4gICAgICAgIGlmIChkZWZhdWx0SW5wdXRLZXlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRJbnB1dEtleXMgPSB0aGlzLmlucHV0Q2hhbm5lbHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUtleXMoZGVmYXVsdElucHV0S2V5cywgdGhpcy5jaGFubmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdEludGVycnVwdEJlZm9yZSA9IGludGVycnVwdEJlZm9yZSA/PyB0aGlzLmludGVycnVwdEJlZm9yZSA/PyBbXTtcbiAgICAgICAgY29uc3QgZGVmYXVsdEludGVycnVwdEFmdGVyID0gaW50ZXJydXB0QWZ0ZXIgPz8gdGhpcy5pbnRlcnJ1cHRBZnRlciA/PyBbXTtcbiAgICAgICAgbGV0IGRlZmF1bHRTdHJlYW1Nb2RlO1xuICAgICAgICBpZiAoc3RyZWFtTW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWZhdWx0U3RyZWFtTW9kZSA9IEFycmF5LmlzQXJyYXkoc3RyZWFtTW9kZSkgPyBzdHJlYW1Nb2RlIDogW3N0cmVhbU1vZGVdO1xuICAgICAgICAgICAgc3RyZWFtTW9kZVNpbmdsZSA9IHR5cGVvZiBzdHJlYW1Nb2RlID09PSBcInN0cmluZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdFN0cmVhbU1vZGUgPSB0aGlzLnN0cmVhbU1vZGU7XG4gICAgICAgICAgICBzdHJlYW1Nb2RlU2luZ2xlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBiZWluZyBjYWxsZWQgYXMgYSBub2RlIGluIGFub3RoZXIgZ3JhcGgsIGFsd2F5cyB1c2UgdmFsdWVzIG1vZGVcbiAgICAgICAgaWYgKGNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX1RBU0tfSURdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTdHJlYW1Nb2RlID0gW1widmFsdWVzXCJdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0Q2hlY2twb2ludGVyO1xuICAgICAgICBpZiAodGhpcy5jaGVja3BvaW50ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2hlY2twb2ludGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9DSEVDS1BPSU5URVJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRDaGVja3BvaW50ZXIgPSBjb25maWcuY29uZmlndXJhYmxlW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRDaGVja3BvaW50ZXIgPSB0aGlzLmNoZWNrcG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0U3RvcmUgPSBjb25maWcuc3RvcmUgPz8gdGhpcy5zdG9yZTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGRlZmF1bHREZWJ1ZyxcbiAgICAgICAgICAgIGRlZmF1bHRTdHJlYW1Nb2RlLFxuICAgICAgICAgICAgZGVmYXVsdElucHV0S2V5cyxcbiAgICAgICAgICAgIGRlZmF1bHRPdXRwdXRLZXlzLFxuICAgICAgICAgICAgcmVzdCxcbiAgICAgICAgICAgIGRlZmF1bHRJbnRlcnJ1cHRCZWZvcmUsXG4gICAgICAgICAgICBkZWZhdWx0SW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICBkZWZhdWx0Q2hlY2twb2ludGVyLFxuICAgICAgICAgICAgZGVmYXVsdFN0b3JlLFxuICAgICAgICAgICAgc3RyZWFtTW9kZVNpbmdsZSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyZWFtcyB0aGUgZXhlY3V0aW9uIG9mIHRoZSBncmFwaCwgZW1pdHRpbmcgc3RhdGUgdXBkYXRlcyBhcyB0aGV5IG9jY3VyLlxuICAgICAqIFRoaXMgaXMgdGhlIHByaW1hcnkgbWV0aG9kIGZvciBvYnNlcnZpbmcgZ3JhcGggZXhlY3V0aW9uIGluIHJlYWwtdGltZS5cbiAgICAgKlxuICAgICAqIFN0cmVhbSBtb2RlczpcbiAgICAgKiAtIFwidmFsdWVzXCI6IEVtaXRzIGNvbXBsZXRlIHN0YXRlIGFmdGVyIGVhY2ggc3RlcFxuICAgICAqIC0gXCJ1cGRhdGVzXCI6IEVtaXRzIG9ubHkgc3RhdGUgY2hhbmdlcyBhZnRlciBlYWNoIHN0ZXBcbiAgICAgKiAtIFwiZGVidWdcIjogRW1pdHMgZGV0YWlsZWQgZGVidWcgaW5mb3JtYXRpb25cbiAgICAgKiAtIFwibWVzc2FnZXNcIjogRW1pdHMgbWVzc2FnZXMgZnJvbSB3aXRoaW4gbm9kZXNcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGUgW1N0cmVhbWluZyBob3ctdG8gZ3VpZGVzXSguLi8uLi9ob3ctdG9zLyNzdHJlYW1pbmdfMSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdG8gc3RhcnQgZ3JhcGggZXhlY3V0aW9uIHdpdGhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3Igc3RyZWFtaW5nXG4gICAgICogQHJldHVybnMgQW4gYXN5bmMgaXRlcmFibGUgc3RyZWFtIG9mIGdyYXBoIHN0YXRlIHVwZGF0ZXNcbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVGhlIGVuc3VyZUNvbmZpZyBtZXRob2QgY2FsbGVkIGludGVybmFsbHkgZGVmYXVsdHMgcmVjdXJzaW9uTGltaXQgdG8gMjUgaWYgbm90XG4gICAgICAgIC8vIHBhc3NlZCBkaXJlY3RseSBpbiBgb3B0aW9uc2AuXG4gICAgICAgIC8vIFRoZXJlIGlzIGN1cnJlbnRseSBubyB3YXkgaW4gX3N0cmVhbUl0ZXJhdG9yIHRvIGRldGVybWluZSB3aGV0aGVyIHRoaXMgd2FzXG4gICAgICAgIC8vIHNldCBieSBieSBlbnN1cmVDb25maWcgb3IgbWFudWFsbHkgYnkgdGhlIHVzZXIsIHNvIHdlIHNwZWNpZnkgdGhlIGJvdW5kIHZhbHVlIGhlcmVcbiAgICAgICAgLy8gYW5kIG92ZXJyaWRlIGlmIGl0IGlzIHBhc3NlZCBhcyBhbiBleHBsaWNpdCBwYXJhbSBpbiBgb3B0aW9uc2AuXG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IHRoaXMuY29uZmlnPy5yZWN1cnNpb25MaW1pdCxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbFxuICAgICAgICAgICAgICAgID8gY29tYmluZUFib3J0U2lnbmFscyhvcHRpb25zLnNpZ25hbCwgYWJvcnRDb250cm9sbGVyLnNpZ25hbClcbiAgICAgICAgICAgICAgICA6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbVdpdGhBYm9ydFNpZ25hbChhd2FpdCBzdXBlci5zdHJlYW0oaW5wdXQsIGNvbmZpZyksIGFib3J0Q29udHJvbGxlcik7XG4gICAgfVxuICAgIHN0cmVhbUV2ZW50cyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiB0aGlzLmNvbmZpZz8ucmVjdXJzaW9uTGltaXQsXG4gICAgICAgICAgICAvLyBTaW1pbGFyIHRvIGBzdHJlYW1gLCB3ZSBuZWVkIHRvIHBhc3MgdGhlIGBjb25maWcuY2FsbGJhY2tzYCBoZXJlLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgZ2V0IGxvc3QgaW4gYGVuc3VyZUxhbmdHcmFwaENvbmZpZ2AuXG4gICAgICAgICAgICBjYWxsYmFja3M6IHRoaXMuY29uZmlnPy5jYWxsYmFja3MsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWxcbiAgICAgICAgICAgICAgICA/IGNvbWJpbmVBYm9ydFNpZ25hbHMob3B0aW9ucy5zaWduYWwsIGFib3J0Q29udHJvbGxlci5zaWduYWwpXG4gICAgICAgICAgICAgICAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW1XaXRoQWJvcnRTaWduYWwoc3VwZXIuc3RyZWFtRXZlbnRzKGlucHV0LCBjb25maWcsIHN0cmVhbU9wdGlvbnMpLCBhYm9ydENvbnRyb2xsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBjaGFubmVsIHNwZWNpZmljYXRpb25zIGFuZCBtYW5hZ2VkIHZhbHVlcyBmb3IgZ3JhcGggZXhlY3V0aW9uLlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gc2V0IHVwIHRoZSBncmFwaCdzIGNvbW11bmljYXRpb24gY2hhbm5lbHNcbiAgICAgKiBhbmQgbWFuYWdlZCBzdGF0ZSBiZWZvcmUgZXhlY3V0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gZm9yIHByZXBhcmluZyBzcGVjc1xuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2tpcE1hbmFnZWQgLSBXaGV0aGVyIHRvIHNraXAgaW5pdGlhbGl6YXRpb24gb2YgbWFuYWdlZCB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyBjaGFubmVsIHNwZWNzIGFuZCBtYW5hZ2VkIHZhbHVlIG1hcHBpbmdcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlU3BlY3MoY29uZmlnLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0Zvck1hbmFnZWQgPSB7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBzdG9yZTogdGhpcy5zdG9yZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hhbm5lbFNwZWNzID0ge307XG4gICAgICAgIGNvbnN0IG1hbmFnZWRTcGVjcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBzcGVjXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmNoYW5uZWxzKSkge1xuICAgICAgICAgICAgaWYgKGlzQmFzZUNoYW5uZWwoc3BlYykpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsU3BlY3NbbmFtZV0gPSBzcGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucz8uc2tpcE1hbmFnZWQpIHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkU3BlY3NbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNsczogTm9vcE1hbmFnZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7IGNvbmZpZzoge30gfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZFNwZWNzW25hbWVdID0gc3BlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYW5hZ2VkID0gbmV3IE1hbmFnZWRWYWx1ZU1hcHBpbmcoYXdhaXQgT2JqZWN0LmVudHJpZXMobWFuYWdlZFNwZWNzKS5yZWR1Y2UoYXN5bmMgKGFjY1Byb21pc2UsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWNjID0gYXdhaXQgYWNjUHJvbWlzZTtcbiAgICAgICAgICAgIGxldCBpbml0aWFsaXplZFZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzQ29uZmlndXJlZE1hbmFnZWRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJrZXlcIiBpbiB2YWx1ZS5wYXJhbXMgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUucGFyYW1zLmtleSA9PT0gQ2hhbm5lbEtleVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnBhcmFtcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkVmFsdWUgPSBhd2FpdCB2YWx1ZS5jbHMuaW5pdGlhbGl6ZShjb25maWdGb3JNYW5hZ2VkLCB2YWx1ZS5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWRWYWx1ZSA9IGF3YWl0IHZhbHVlLmluaXRpYWxpemUoY29uZmlnRm9yTWFuYWdlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5pdGlhbGl6ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goW2tleSwgaW5pdGlhbGl6ZWRWYWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKFtdKSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbm5lbFNwZWNzLFxuICAgICAgICAgICAgbWFuYWdlZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBpbnB1dCBmb3IgdGhlIGdyYXBoLlxuICAgICAqIEBwYXJhbSBpbnB1dCAtIFRoZSBpbnB1dCB0byB2YWxpZGF0ZVxuICAgICAqIEByZXR1cm5zIFRoZSB2YWxpZGF0ZWQgaW5wdXRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfdmFsaWRhdGVJbnB1dChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgY29uZmlndXJhYmxlIG9wdGlvbnMgZm9yIHRoZSBncmFwaC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYWJsZSBvcHRpb25zIHRvIHZhbGlkYXRlXG4gICAgICogQHJldHVybnMgVGhlIHZhbGlkYXRlZCBjb25maWd1cmFibGUgb3B0aW9uc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jIF92YWxpZGF0ZUNvbmZpZ3VyYWJsZShjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaXRlcmF0b3IgdXNlZCBieSBzdHJlYW0oKSB0byBnZW5lcmF0ZSBzdGF0ZSB1cGRhdGVzLlxuICAgICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIGNvcmUgbG9naWMgb2YgZ3JhcGggZXhlY3V0aW9uIGFuZCBzdHJlYW1pbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdG8gc3RhcnQgZ3JhcGggZXhlY3V0aW9uIHdpdGhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3Igc3RyZWFtaW5nXG4gICAgICogQHJldHVybnMgQXN5bmNHZW5lcmF0b3IgeWllbGRpbmcgc3RhdGUgdXBkYXRlc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtU3ViZ3JhcGhzID0gb3B0aW9ucz8uc3ViZ3JhcGhzO1xuICAgICAgICBjb25zdCBpbnB1dENvbmZpZyA9IGVuc3VyZUxhbmdHcmFwaENvbmZpZyh0aGlzLmNvbmZpZywgb3B0aW9ucyk7XG4gICAgICAgIGlmIChpbnB1dENvbmZpZy5yZWN1cnNpb25MaW1pdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBpbnB1dENvbmZpZy5yZWN1cnNpb25MaW1pdCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFzc2VkIFwicmVjdXJzaW9uTGltaXRcIiBtdXN0IGJlIGF0IGxlYXN0IDEuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hlY2twb2ludGVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuY2hlY2twb2ludGVyICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgaW5wdXRDb25maWcuY29uZmlndXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hlY2twb2ludGVyIHJlcXVpcmVzIG9uZSBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgXCJjb25maWd1cmFibGVcIiBrZXlzOiBcInRocmVhZF9pZFwiLCBcImNoZWNrcG9pbnRfbnNcIiwgXCJjaGVja3BvaW50X2lkXCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZElucHV0ID0gYXdhaXQgdGhpcy5fdmFsaWRhdGVJbnB1dChpbnB1dCk7XG4gICAgICAgIGNvbnN0IHsgcnVuSWQsIC4uLnJlc3RDb25maWcgfSA9IGlucHV0Q29uZmlnO1xuICAgICAgICAvLyBhc3NpZ24gZGVmYXVsdHNcbiAgICAgICAgY29uc3QgW2RlYnVnLCBzdHJlYW1Nb2RlLCAsIG91dHB1dEtleXMsIGNvbmZpZywgaW50ZXJydXB0QmVmb3JlLCBpbnRlcnJ1cHRBZnRlciwgY2hlY2twb2ludGVyLCBzdG9yZSwgc3RyZWFtTW9kZVNpbmdsZSxdID0gdGhpcy5fZGVmYXVsdHMocmVzdENvbmZpZyk7XG4gICAgICAgIGNvbmZpZy5jb25maWd1cmFibGUgPSBhd2FpdCB0aGlzLl92YWxpZGF0ZUNvbmZpZ3VyYWJsZShjb25maWcuY29uZmlndXJhYmxlKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IEl0ZXJhYmxlUmVhZGFibGVXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBtb2RlczogbmV3IFNldChzdHJlYW1Nb2RlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNldCB1cCBtZXNzYWdlcyBzdHJlYW0gbW9kZVxuICAgICAgICBpZiAoc3RyZWFtTW9kZS5pbmNsdWRlcyhcIm1lc3NhZ2VzXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlU3RyZWFtZXIgPSBuZXcgU3RyZWFtTWVzc2FnZXNIYW5kbGVyKChjaHVuaykgPT4gc3RyZWFtLnB1c2goY2h1bmspKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FsbGJhY2tzIH0gPSBjb25maWc7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gW21lc3NhZ2VTdHJlYW1lcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvbmNhdChtZXNzYWdlU3RyZWFtZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29waWVkQ2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvcHkoKTtcbiAgICAgICAgICAgICAgICBjb3BpZWRDYWxsYmFja3MuYWRkSGFuZGxlcihtZXNzYWdlU3RyZWFtZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjb3BpZWRDYWxsYmFja3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0dXAgY3VzdG9tIHN0cmVhbSBtb2RlXG4gICAgICAgIGlmIChzdHJlYW1Nb2RlLmluY2x1ZGVzKFwiY3VzdG9tXCIpKSB7XG4gICAgICAgICAgICBjb25maWcud3JpdGVyID0gKGNodW5rKSA9PiBzdHJlYW0ucHVzaChbW10sIFwiY3VzdG9tXCIsIGNodW5rXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgLy8gY2hhaW5cbiAgICAgICAgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgLy8gaW5wdXRzXG4gICAgICAgIHJ1bklkLCAvLyBydW5faWRcbiAgICAgICAgdW5kZWZpbmVkLCAvLyBydW5fdHlwZVxuICAgICAgICB1bmRlZmluZWQsIC8vIHRhZ3NcbiAgICAgICAgdW5kZWZpbmVkLCAvLyBtZXRhZGF0YVxuICAgICAgICBjb25maWc/LnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCkgLy8gcnVuX25hbWVcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgeyBjaGFubmVsU3BlY3MsIG1hbmFnZWQgfSA9IGF3YWl0IHRoaXMucHJlcGFyZVNwZWNzKGNvbmZpZyk7XG4gICAgICAgIGxldCBsb29wO1xuICAgICAgICBsZXQgbG9vcEVycm9yO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFByZWdlbExvb3Agd2lsbCB5aWVsZCBldmVudHMgZnJvbSBjb25jdXJyZW50IHRhc2tzIGFzIHNvb24gYXMgdGhleSBhcmVcbiAgICAgICAgICogZ2VuZXJhdGVkLiBFYWNoIHRhc2sgY2FuIHB1c2ggbXVsdGlwbGUgZXZlbnRzIG9udG8gdGhlIHN0cmVhbSBpbiBhbnkgb3JkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdlIHVzZSBhIHNlcGFyYXRlIGJhY2tncm91bmQgbWV0aG9kIGFuZCBzdHJlYW0gaGVyZSBpbiBvcmRlciB0byB5aWVsZCBldmVudHNcbiAgICAgICAgICogZnJvbSB0aGUgbG9vcCB0byB0aGUgbWFpbiBzdHJlYW0gYW5kIHRoZXJlZm9yZSBiYWNrIHRvIHRoZSB1c2VyIGFzIHNvb24gYXNcbiAgICAgICAgICogdGhleSBhcmUgYXZhaWxhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY3JlYXRlQW5kUnVuTG9vcCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbG9vcCA9IGF3YWl0IFByZWdlbExvb3AuaW5pdGlhbGl6ZSh7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB2YWxpZElucHV0LFxuICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IHRoaXMubm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxTcGVjcyxcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlZCxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0S2V5cyxcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtS2V5czogdGhpcy5zdHJlYW1DaGFubmVsc0FzSXMsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIGludGVycnVwdEFmdGVyLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHRCZWZvcmUsXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXI6IHJ1bk1hbmFnZXIsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnOiB0aGlzLmRlYnVnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBQcmVnZWxSdW5uZXIoe1xuICAgICAgICAgICAgICAgICAgICBsb29wLFxuICAgICAgICAgICAgICAgICAgICBub2RlRmluaXNoZWQ6IGNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX05PREVfRklOSVNIRURdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zPy5zdWJncmFwaHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9vcC5jb25maWcuY29uZmlndXJhYmxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubG9vcC5jb25maWcuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfU1RSRUFNXTogbG9vcC5zdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3J1bkxvb3AoeyBsb29wLCBydW5uZXIsIGRlYnVnLCBjb25maWcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvb3BFcnJvciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGAuc3RvcCgpYCBhZ2FpbiBpbmNhc2UgaXQgd2FzIG5vdCBjYWxsZWQgaW4gdGhlIGxvb3AsIGUuZyBkdWUgdG8gYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBsb29wLnN0b3JlPy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGxvb3A/LmNoZWNrcG9pbnRlclByb21pc2VzID8/IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20obWFuYWdlZC52YWx1ZXMoKSkubWFwKChtdikgPT4gbXYucHJvbWlzZXMoKSksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb29wRXJyb3IgPSBsb29wRXJyb3IgPz8gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvb3BFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBcIkNhdXNlcyBhbnkgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSB0byBlcnJvclwiLlxuICAgICAgICAgICAgICAgICAgICAvLyBXcmFwcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyI2Vycm9yOlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci9lcnJvclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZXJyb3IobG9vcEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdpbGwgZW5kIHRoZSBpdGVyYXRvciBvdXRzaWRlIG9mIHRoaXMgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwaW5nIHByZXZpb3VzbHkgZW5xdWV1ZWQgY2h1bmtzLlxuICAgICAgICAgICAgICAgICAgICAvLyBXcmFwcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyI2Nsb3NlOlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci9jbG9zZVxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJ1bkxvb3BQcm9taXNlID0gY3JlYXRlQW5kUnVuTG9vcCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHN0cnVjdHVyZSBlcnJvci5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFtuYW1lc3BhY2UsIG1vZGUsIHBheWxvYWRdID0gY2h1bms7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbU1vZGUuaW5jbHVkZXMobW9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbVN1YmdyYXBocyAmJiAhc3RyZWFtTW9kZVNpbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW25hbWVzcGFjZSwgbW9kZSwgcGF5bG9hZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXN0cmVhbU1vZGVTaW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFttb2RlLCBwYXlsb2FkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJlYW1TdWJncmFwaHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtuYW1lc3BhY2UsIHBheWxvYWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgcGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihsb29wRXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bkxvb3BQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGxvb3A/Lm91dHB1dCA/PyB7fSwgcnVuSWQsIC8vIHJ1bl9pZFxuICAgICAgICB1bmRlZmluZWQsIC8vIHJ1bl90eXBlXG4gICAgICAgIHVuZGVmaW5lZCwgLy8gdGFnc1xuICAgICAgICB1bmRlZmluZWQgLy8gbWV0YWRhdGFcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIHRoZSBncmFwaCB3aXRoIGEgc2luZ2xlIGlucHV0IGFuZCBjb25maWcuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byB0aGUgZ3JhcGguXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNvbmZpZ3VyYXRpb24gdG8gdXNlIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdHJlYW1Nb2RlID0gb3B0aW9ucz8uc3RyZWFtTW9kZSA/PyBcInZhbHVlc1wiO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgb3V0cHV0S2V5czogb3B0aW9ucz8ub3V0cHV0S2V5cyA/PyB0aGlzLm91dHB1dENoYW5uZWxzLFxuICAgICAgICAgICAgc3RyZWFtTW9kZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRoaXMuc3RyZWFtKGlucHV0LCBjb25maWcpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW1Nb2RlID09PSBcInZhbHVlc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtzO1xuICAgIH1cbiAgICBhc3luYyBfcnVuTG9vcChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyBsb29wLCBydW5uZXIsIGRlYnVnLCBjb25maWcgfSA9IHBhcmFtcztcbiAgICAgICAgbGV0IHRpY2tFcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlIChhd2FpdCBsb29wLnRpY2soe1xuICAgICAgICAgICAgICAgIGlucHV0S2V5czogdGhpcy5pbnB1dENoYW5uZWxzLFxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRTdGVwQ2hlY2twb2ludChsb29wLmNoZWNrcG9pbnRNZXRhZGF0YS5zdGVwLCBsb29wLmNoYW5uZWxzLCB0aGlzLnN0cmVhbUNoYW5uZWxzTGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBwcmludFN0ZXBUYXNrcyhsb29wLnN0ZXAsIE9iamVjdC52YWx1ZXMobG9vcC50YXNrcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBydW5uZXIudGljayh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMuc3RlcFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5UG9saWN5OiB0aGlzLnJldHJ5UG9saWN5LFxuICAgICAgICAgICAgICAgICAgICBvblN0ZXBXcml0ZTogKHN0ZXAsIHdyaXRlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRTdGVwV3JpdGVzKHN0ZXAsIHdyaXRlcywgdGhpcy5zdHJlYW1DaGFubmVsc0xpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogY29uZmlnLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNvbmZpZy5zaWduYWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9vcC5zdGF0dXMgPT09IFwib3V0X29mX3N0ZXBzXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhSZWN1cnNpb25FcnJvcihbXG4gICAgICAgICAgICAgICAgICAgIGBSZWN1cnNpb24gbGltaXQgb2YgJHtjb25maWcucmVjdXJzaW9uTGltaXR9IHJlYWNoZWRgLFxuICAgICAgICAgICAgICAgICAgICBcIndpdGhvdXQgaGl0dGluZyBhIHN0b3AgY29uZGl0aW9uLiBZb3UgY2FuIGluY3JlYXNlIHRoZVwiLFxuICAgICAgICAgICAgICAgICAgICBgbGltaXQgYnkgc2V0dGluZyB0aGUgXCJyZWN1cnNpb25MaW1pdFwiIGNvbmZpZyBrZXkuYCxcbiAgICAgICAgICAgICAgICBdLmpvaW4oXCIgXCIpLCB7XG4gICAgICAgICAgICAgICAgICAgIGxjX2Vycm9yX2NvZGU6IFwiR1JBUEhfUkVDVVJTSU9OX0xJTUlUXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRpY2tFcnJvciA9IGU7XG4gICAgICAgICAgICBjb25zdCBzdXBwcmVzcyA9IGF3YWl0IGxvb3AuZmluaXNoQW5kSGFuZGxlRXJyb3IodGlja0Vycm9yKTtcbiAgICAgICAgICAgIGlmICghc3VwcHJlc3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHRpY2tFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9vcC5maW5pc2hBbmRIYW5kbGVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/io.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/io.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mapCommand: () => (/* binding */ mapCommand),\n/* harmony export */   mapInput: () => (/* binding */ mapInput),\n/* harmony export */   mapOutputUpdates: () => (/* binding */ mapOutputUpdates),\n/* harmony export */   mapOutputValues: () => (/* binding */ mapOutputValues),\n/* harmony export */   readChannel: () => (/* binding */ readChannel),\n/* harmony export */   readChannels: () => (/* binding */ readChannels),\n/* harmony export */   single: () => (/* binding */ single)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n\n\n\nfunction readChannel(channels, chan, catchErrors = true, returnException = false) {\n    try {\n        return channels[chan].get();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError.unminifiable_name) {\n            if (returnException) {\n                return e;\n            }\n            else if (catchErrors) {\n                return null;\n            }\n        }\n        throw e;\n    }\n}\nfunction readChannels(channels, select, skipEmpty = true\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    if (Array.isArray(select)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const values = {};\n        for (const k of select) {\n            try {\n                values[k] = readChannel(channels, k, !skipEmpty);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (e) {\n                if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError.unminifiable_name) {\n                    continue;\n                }\n            }\n        }\n        return values;\n    }\n    else {\n        return readChannel(channels, select);\n    }\n}\n/**\n * Map input chunk to a sequence of pending writes in the form (channel, value).\n */\nfunction* mapCommand(cmd, pendingWrites) {\n    if (cmd.graph === _constants_js__WEBPACK_IMPORTED_MODULE_0__.Command.PARENT) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidUpdateError(\"There is no parent graph.\");\n    }\n    if (cmd.goto) {\n        let sends;\n        if (Array.isArray(cmd.goto)) {\n            sends = cmd.goto;\n        }\n        else {\n            sends = [cmd.goto];\n        }\n        for (const send of sends) {\n            if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_0__._isSend)(send)) {\n                yield [_constants_js__WEBPACK_IMPORTED_MODULE_0__.NULL_TASK_ID, _constants_js__WEBPACK_IMPORTED_MODULE_0__.TASKS, send];\n            }\n            else if (typeof send === \"string\") {\n                yield [_constants_js__WEBPACK_IMPORTED_MODULE_0__.NULL_TASK_ID, `branch:to:${send}`, \"__start__\"];\n            }\n            else {\n                throw new Error(`In Command.send, expected Send or string, got ${typeof send}`);\n            }\n        }\n    }\n    if (cmd.resume) {\n        if (typeof cmd.resume === \"object\" &&\n            Object.keys(cmd.resume).length &&\n            Object.keys(cmd.resume).every(uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])) {\n            for (const [tid, resume] of Object.entries(cmd.resume)) {\n                const existing = pendingWrites\n                    .filter((w) => w[0] === tid && w[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.RESUME)\n                    .map((w) => w[2])\n                    .slice(0, 1) ?? [];\n                existing.push(resume);\n                yield [tid, _constants_js__WEBPACK_IMPORTED_MODULE_0__.RESUME, existing];\n            }\n        }\n        else {\n            yield [_constants_js__WEBPACK_IMPORTED_MODULE_0__.NULL_TASK_ID, _constants_js__WEBPACK_IMPORTED_MODULE_0__.RESUME, cmd.resume];\n        }\n    }\n    if (cmd.update) {\n        if (typeof cmd.update !== \"object\" || !cmd.update) {\n            throw new Error(\"Expected cmd.update to be a dict mapping channel names to update values\");\n        }\n        if (Array.isArray(cmd.update)) {\n            for (const [k, v] of cmd.update) {\n                yield [_constants_js__WEBPACK_IMPORTED_MODULE_0__.NULL_TASK_ID, k, v];\n            }\n        }\n        else {\n            for (const [k, v] of Object.entries(cmd.update)) {\n                yield [_constants_js__WEBPACK_IMPORTED_MODULE_0__.NULL_TASK_ID, k, v];\n            }\n        }\n    }\n}\n/**\n * Map input chunk to a sequence of pending writes in the form [channel, value].\n */\nfunction* mapInput(inputChannels, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nchunk\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    if (chunk !== undefined && chunk !== null) {\n        if (Array.isArray(inputChannels) &&\n            typeof chunk === \"object\" &&\n            !Array.isArray(chunk)) {\n            for (const k in chunk) {\n                if (inputChannels.includes(k)) {\n                    yield [k, chunk[k]];\n                }\n            }\n        }\n        else if (Array.isArray(inputChannels)) {\n            throw new Error(`Input chunk must be an object when \"inputChannels\" is an array`);\n        }\n        else {\n            yield [inputChannels, chunk];\n        }\n    }\n}\n/**\n * Map pending writes (a sequence of tuples (channel, value)) to output chunk.\n */\nfunction* mapOutputValues(outputChannels, pendingWrites, channels\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    if (Array.isArray(outputChannels)) {\n        if (pendingWrites === true ||\n            pendingWrites.find(([chan, _]) => outputChannels.includes(chan))) {\n            yield readChannels(channels, outputChannels);\n        }\n    }\n    else {\n        if (pendingWrites === true ||\n            pendingWrites.some(([chan, _]) => chan === outputChannels)) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            yield readChannel(channels, outputChannels);\n        }\n    }\n}\n/**\n * Map pending writes (a sequence of tuples (channel, value)) to output chunk.\n * @internal\n *\n * @param outputChannels - The channels to output.\n * @param tasks - The tasks to output.\n * @param cached - Whether the output is cached.\n *\n * @returns A generator that yields the output chunk (if any).\n */\nfunction* mapOutputUpdates(outputChannels, tasks, cached) {\n    const outputTasks = tasks.filter(([task, ww]) => {\n        return ((task.config === undefined || !task.config.tags?.includes(_constants_js__WEBPACK_IMPORTED_MODULE_0__.TAG_HIDDEN)) &&\n            ww[0][0] !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR &&\n            ww[0][0] !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT);\n    });\n    if (!outputTasks.length) {\n        return;\n    }\n    let updated;\n    if (outputTasks.some(([task]) => task.writes.some(([chan, _]) => chan === _constants_js__WEBPACK_IMPORTED_MODULE_0__.RETURN))) {\n        // TODO: probably should assert that RETURN is the only \"non-special\" channel (starts with \"__\")\n        updated = outputTasks.flatMap(([task]) => task.writes\n            .filter(([chan, _]) => chan === _constants_js__WEBPACK_IMPORTED_MODULE_0__.RETURN)\n            .map(([_, value]) => [task.name, value]));\n    }\n    else if (!Array.isArray(outputChannels)) {\n        // special case where graph state is a single channel (MessageGraph)\n        // probably using this in functional API, too\n        updated = outputTasks.flatMap(([task]) => task.writes\n            .filter(([chan, _]) => chan === outputChannels)\n            .map(([_, value]) => [task.name, value]));\n    }\n    else {\n        updated = outputTasks.flatMap(([task]) => {\n            const { writes } = task;\n            const counts = {};\n            for (const [chan] of writes) {\n                if (outputChannels.includes(chan)) {\n                    counts[chan] = (counts[chan] || 0) + 1;\n                }\n            }\n            if (Object.values(counts).some((count) => count > 1)) {\n                // Multiple writes to the same channel: create separate entries\n                return writes\n                    .filter(([chan]) => outputChannels.includes(chan))\n                    .map(([chan, value]) => [task.name, { [chan]: value }]);\n            }\n            else {\n                // Single write to each channel: create a single combined entry\n                return [\n                    [\n                        task.name,\n                        Object.fromEntries(writes.filter(([chan]) => outputChannels.includes(chan))),\n                    ],\n                ];\n            }\n        });\n    }\n    const grouped = {};\n    for (const [node, value] of updated) {\n        if (!(node in grouped)) {\n            grouped[node] = [];\n        }\n        grouped[node].push(value);\n    }\n    const flattened = {};\n    for (const node in grouped) {\n        if (grouped[node].length === 1) {\n            const [write] = grouped[node];\n            flattened[node] = write;\n        }\n        else {\n            flattened[node] = grouped[node];\n        }\n    }\n    if (cached) {\n        flattened[\"__metadata__\"] = { cached };\n    }\n    yield flattened;\n}\nfunction single(iter) {\n    // eslint-disable-next-line no-unreachable-loop\n    for (const value of iter) {\n        return value;\n    }\n    return null;\n}\n//# sourceMappingURL=io.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvaW8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFnQztBQUN1RjtBQUNsRDtBQUM5RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlEQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asc0JBQXNCLGtEQUFPO0FBQzdCLGtCQUFrQiwwREFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQU87QUFDdkIsdUJBQXVCLHVEQUFZLEVBQUUsZ0RBQUs7QUFDMUM7QUFDQTtBQUNBLHVCQUF1Qix1REFBWSxlQUFlLEtBQUs7QUFDdkQ7QUFDQTtBQUNBLGlGQUFpRixZQUFZO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0Q0FBUTtBQUNsRDtBQUNBO0FBQ0EsNERBQTRELGlEQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpREFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVksRUFBRSxpREFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwwRUFBMEUscURBQVU7QUFDcEYseUJBQXlCLGdEQUFLO0FBQzlCLHlCQUF5QixvREFBUztBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsaURBQU07QUFDcEY7QUFDQTtBQUNBLDRDQUE0QyxpREFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxccHJlZ2VsXFxpby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2YWxpZGF0ZSB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBfaXNTZW5kLCBDb21tYW5kLCBFUlJPUiwgSU5URVJSVVBULCBOVUxMX1RBU0tfSUQsIFJFU1VNRSwgUkVUVVJOLCBUQUdfSElEREVOLCBUQVNLUywgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBFbXB0eUNoYW5uZWxFcnJvciwgSW52YWxpZFVwZGF0ZUVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRDaGFubmVsKGNoYW5uZWxzLCBjaGFuLCBjYXRjaEVycm9ycyA9IHRydWUsIHJldHVybkV4Y2VwdGlvbiA9IGZhbHNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWxzW2NoYW5dLmdldCgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5uYW1lID09PSBFbXB0eUNoYW5uZWxFcnJvci51bm1pbmlmaWFibGVfbmFtZSkge1xuICAgICAgICAgICAgaWYgKHJldHVybkV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2F0Y2hFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkQ2hhbm5lbHMoY2hhbm5lbHMsIHNlbGVjdCwgc2tpcEVtcHR5ID0gdHJ1ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBzZWxlY3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2tdID0gcmVhZENoYW5uZWwoY2hhbm5lbHMsIGssICFza2lwRW1wdHkpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLm5hbWUgPT09IEVtcHR5Q2hhbm5lbEVycm9yLnVubWluaWZpYWJsZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDaGFubmVsKGNoYW5uZWxzLCBzZWxlY3QpO1xuICAgIH1cbn1cbi8qKlxuICogTWFwIGlucHV0IGNodW5rIHRvIGEgc2VxdWVuY2Ugb2YgcGVuZGluZyB3cml0ZXMgaW4gdGhlIGZvcm0gKGNoYW5uZWwsIHZhbHVlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBtYXBDb21tYW5kKGNtZCwgcGVuZGluZ1dyaXRlcykge1xuICAgIGlmIChjbWQuZ3JhcGggPT09IENvbW1hbmQuUEFSRU5UKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoXCJUaGVyZSBpcyBubyBwYXJlbnQgZ3JhcGguXCIpO1xuICAgIH1cbiAgICBpZiAoY21kLmdvdG8pIHtcbiAgICAgICAgbGV0IHNlbmRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjbWQuZ290bykpIHtcbiAgICAgICAgICAgIHNlbmRzID0gY21kLmdvdG87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZW5kcyA9IFtjbWQuZ290b107XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzZW5kIG9mIHNlbmRzKSB7XG4gICAgICAgICAgICBpZiAoX2lzU2VuZChzZW5kKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIFtOVUxMX1RBU0tfSUQsIFRBU0tTLCBzZW5kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZW5kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgW05VTExfVEFTS19JRCwgYGJyYW5jaDp0bzoke3NlbmR9YCwgXCJfX3N0YXJ0X19cIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIENvbW1hbmQuc2VuZCwgZXhwZWN0ZWQgU2VuZCBvciBzdHJpbmcsIGdvdCAke3R5cGVvZiBzZW5kfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbWQucmVzdW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY21kLnJlc3VtZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY21kLnJlc3VtZSkubGVuZ3RoICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjbWQucmVzdW1lKS5ldmVyeSh2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3RpZCwgcmVzdW1lXSBvZiBPYmplY3QuZW50cmllcyhjbWQucmVzdW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcGVuZGluZ1dyaXRlc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh3KSA9PiB3WzBdID09PSB0aWQgJiYgd1sxXSA9PT0gUkVTVU1FKVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh3KSA9PiB3WzJdKVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgMSkgPz8gW107XG4gICAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZXN1bWUpO1xuICAgICAgICAgICAgICAgIHlpZWxkIFt0aWQsIFJFU1VNRSwgZXhpc3RpbmddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgW05VTExfVEFTS19JRCwgUkVTVU1FLCBjbWQucmVzdW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY21kLnVwZGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNtZC51cGRhdGUgIT09IFwib2JqZWN0XCIgfHwgIWNtZC51cGRhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGNtZC51cGRhdGUgdG8gYmUgYSBkaWN0IG1hcHBpbmcgY2hhbm5lbCBuYW1lcyB0byB1cGRhdGUgdmFsdWVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNtZC51cGRhdGUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBjbWQudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgW05VTExfVEFTS19JRCwgaywgdl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhjbWQudXBkYXRlKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIFtOVUxMX1RBU0tfSUQsIGssIHZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBNYXAgaW5wdXQgY2h1bmsgdG8gYSBzZXF1ZW5jZSBvZiBwZW5kaW5nIHdyaXRlcyBpbiB0aGUgZm9ybSBbY2hhbm5lbCwgdmFsdWVdLlxuICovXG5leHBvcnQgZnVuY3Rpb24qIG1hcElucHV0KGlucHV0Q2hhbm5lbHMsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNodW5rXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSB7XG4gICAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQgJiYgY2h1bmsgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRDaGFubmVscykgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjaHVuayA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoY2h1bmspKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gY2h1bmspIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRDaGFubmVscy5pbmNsdWRlcyhrKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgY2h1bmtba11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0Q2hhbm5lbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0IGNodW5rIG11c3QgYmUgYW4gb2JqZWN0IHdoZW4gXCJpbnB1dENoYW5uZWxzXCIgaXMgYW4gYXJyYXlgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIFtpbnB1dENoYW5uZWxzLCBjaHVua107XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIE1hcCBwZW5kaW5nIHdyaXRlcyAoYSBzZXF1ZW5jZSBvZiB0dXBsZXMgKGNoYW5uZWwsIHZhbHVlKSkgdG8gb3V0cHV0IGNodW5rLlxuICovXG5leHBvcnQgZnVuY3Rpb24qIG1hcE91dHB1dFZhbHVlcyhvdXRwdXRDaGFubmVscywgcGVuZGluZ1dyaXRlcywgY2hhbm5lbHNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXRDaGFubmVscykpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdXcml0ZXMgPT09IHRydWUgfHxcbiAgICAgICAgICAgIHBlbmRpbmdXcml0ZXMuZmluZCgoW2NoYW4sIF9dKSA9PiBvdXRwdXRDaGFubmVscy5pbmNsdWRlcyhjaGFuKSkpIHtcbiAgICAgICAgICAgIHlpZWxkIHJlYWRDaGFubmVscyhjaGFubmVscywgb3V0cHV0Q2hhbm5lbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAocGVuZGluZ1dyaXRlcyA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgcGVuZGluZ1dyaXRlcy5zb21lKChbY2hhbiwgX10pID0+IGNoYW4gPT09IG91dHB1dENoYW5uZWxzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHlpZWxkIHJlYWRDaGFubmVsKGNoYW5uZWxzLCBvdXRwdXRDaGFubmVscyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIE1hcCBwZW5kaW5nIHdyaXRlcyAoYSBzZXF1ZW5jZSBvZiB0dXBsZXMgKGNoYW5uZWwsIHZhbHVlKSkgdG8gb3V0cHV0IGNodW5rLlxuICogQGludGVybmFsXG4gKlxuICogQHBhcmFtIG91dHB1dENoYW5uZWxzIC0gVGhlIGNoYW5uZWxzIHRvIG91dHB1dC5cbiAqIEBwYXJhbSB0YXNrcyAtIFRoZSB0YXNrcyB0byBvdXRwdXQuXG4gKiBAcGFyYW0gY2FjaGVkIC0gV2hldGhlciB0aGUgb3V0cHV0IGlzIGNhY2hlZC5cbiAqXG4gKiBAcmV0dXJucyBBIGdlbmVyYXRvciB0aGF0IHlpZWxkcyB0aGUgb3V0cHV0IGNodW5rIChpZiBhbnkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24qIG1hcE91dHB1dFVwZGF0ZXMob3V0cHV0Q2hhbm5lbHMsIHRhc2tzLCBjYWNoZWQpIHtcbiAgICBjb25zdCBvdXRwdXRUYXNrcyA9IHRhc2tzLmZpbHRlcigoW3Rhc2ssIHd3XSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh0YXNrLmNvbmZpZyA9PT0gdW5kZWZpbmVkIHx8ICF0YXNrLmNvbmZpZy50YWdzPy5pbmNsdWRlcyhUQUdfSElEREVOKSkgJiZcbiAgICAgICAgICAgIHd3WzBdWzBdICE9PSBFUlJPUiAmJlxuICAgICAgICAgICAgd3dbMF1bMF0gIT09IElOVEVSUlVQVCk7XG4gICAgfSk7XG4gICAgaWYgKCFvdXRwdXRUYXNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZDtcbiAgICBpZiAob3V0cHV0VGFza3Muc29tZSgoW3Rhc2tdKSA9PiB0YXNrLndyaXRlcy5zb21lKChbY2hhbiwgX10pID0+IGNoYW4gPT09IFJFVFVSTikpKSB7XG4gICAgICAgIC8vIFRPRE86IHByb2JhYmx5IHNob3VsZCBhc3NlcnQgdGhhdCBSRVRVUk4gaXMgdGhlIG9ubHkgXCJub24tc3BlY2lhbFwiIGNoYW5uZWwgKHN0YXJ0cyB3aXRoIFwiX19cIilcbiAgICAgICAgdXBkYXRlZCA9IG91dHB1dFRhc2tzLmZsYXRNYXAoKFt0YXNrXSkgPT4gdGFzay53cml0ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKFtjaGFuLCBfXSkgPT4gY2hhbiA9PT0gUkVUVVJOKVxuICAgICAgICAgICAgLm1hcCgoW18sIHZhbHVlXSkgPT4gW3Rhc2submFtZSwgdmFsdWVdKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG91dHB1dENoYW5uZWxzKSkge1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugd2hlcmUgZ3JhcGggc3RhdGUgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTWVzc2FnZUdyYXBoKVxuICAgICAgICAvLyBwcm9iYWJseSB1c2luZyB0aGlzIGluIGZ1bmN0aW9uYWwgQVBJLCB0b29cbiAgICAgICAgdXBkYXRlZCA9IG91dHB1dFRhc2tzLmZsYXRNYXAoKFt0YXNrXSkgPT4gdGFzay53cml0ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKFtjaGFuLCBfXSkgPT4gY2hhbiA9PT0gb3V0cHV0Q2hhbm5lbHMpXG4gICAgICAgICAgICAubWFwKChbXywgdmFsdWVdKSA9PiBbdGFzay5uYW1lLCB2YWx1ZV0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVwZGF0ZWQgPSBvdXRwdXRUYXNrcy5mbGF0TWFwKChbdGFza10pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgd3JpdGVzIH0gPSB0YXNrO1xuICAgICAgICAgICAgY29uc3QgY291bnRzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjaGFuXSBvZiB3cml0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0Q2hhbm5lbHMuaW5jbHVkZXMoY2hhbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRzW2NoYW5dID0gKGNvdW50c1tjaGFuXSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoY291bnRzKS5zb21lKChjb3VudCkgPT4gY291bnQgPiAxKSkge1xuICAgICAgICAgICAgICAgIC8vIE11bHRpcGxlIHdyaXRlcyB0byB0aGUgc2FtZSBjaGFubmVsOiBjcmVhdGUgc2VwYXJhdGUgZW50cmllc1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoW2NoYW5dKSA9PiBvdXRwdXRDaGFubmVscy5pbmNsdWRlcyhjaGFuKSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2NoYW4sIHZhbHVlXSkgPT4gW3Rhc2submFtZSwgeyBbY2hhbl06IHZhbHVlIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNpbmdsZSB3cml0ZSB0byBlYWNoIGNoYW5uZWw6IGNyZWF0ZSBhIHNpbmdsZSBjb21iaW5lZCBlbnRyeVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2submFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcm9tRW50cmllcyh3cml0ZXMuZmlsdGVyKChbY2hhbl0pID0+IG91dHB1dENoYW5uZWxzLmluY2x1ZGVzKGNoYW4pKSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtub2RlLCB2YWx1ZV0gb2YgdXBkYXRlZCkge1xuICAgICAgICBpZiAoIShub2RlIGluIGdyb3VwZWQpKSB7XG4gICAgICAgICAgICBncm91cGVkW25vZGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBlZFtub2RlXS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgZmxhdHRlbmVkID0ge307XG4gICAgZm9yIChjb25zdCBub2RlIGluIGdyb3VwZWQpIHtcbiAgICAgICAgaWYgKGdyb3VwZWRbbm9kZV0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBbd3JpdGVdID0gZ3JvdXBlZFtub2RlXTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZFtub2RlXSA9IHdyaXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmxhdHRlbmVkW25vZGVdID0gZ3JvdXBlZFtub2RlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIGZsYXR0ZW5lZFtcIl9fbWV0YWRhdGFfX1wiXSA9IHsgY2FjaGVkIH07XG4gICAgfVxuICAgIHlpZWxkIGZsYXR0ZW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGUoaXRlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZS1sb29wXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pby5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/io.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/loop.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/loop.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PregelLoop: () => (/* binding */ PregelLoop)\n/* harmony export */ });\n/* harmony import */ var _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/langgraph-checkpoint */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/index.js\");\n/* harmony import */ var _channels_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../channels/base.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/base.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _algo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./algo.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/algo.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./io.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/io.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/index.js\");\n/* harmony import */ var _debug_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./debug.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/debug.js\");\n/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./stream.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/stream.js\");\n\n\n\n\n\n\n\n\n\n\nconst INPUT_DONE = Symbol.for(\"INPUT_DONE\");\nconst INPUT_RESUMING = Symbol.for(\"INPUT_RESUMING\");\nconst DEFAULT_LOOP_LIMIT = 25;\nfunction createDuplexStream(...streams) {\n    return new _stream_js__WEBPACK_IMPORTED_MODULE_9__.IterableReadableWritableStream({\n        passthroughFn: (value) => {\n            for (const stream of streams) {\n                if (stream.modes.has(value[1])) {\n                    stream.push(value);\n                }\n            }\n        },\n        modes: new Set(streams.flatMap((s) => Array.from(s.modes))),\n    });\n}\nclass PregelLoop {\n    get isResuming() {\n        const hasChannelVersions = Object.keys(this.checkpoint.channel_versions).length !== 0;\n        const configHasResumingFlag = this.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING] !== undefined;\n        const configIsResuming = configHasResumingFlag && this.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING];\n        const inputIsNullOrUndefined = this.input === null || this.input === undefined;\n        const inputIsCommandResuming = (0,_constants_js__WEBPACK_IMPORTED_MODULE_2__.isCommand)(this.input) && this.input.resume != null;\n        const inputIsResuming = this.input === INPUT_RESUMING;\n        return (hasChannelVersions &&\n            (configIsResuming ||\n                inputIsNullOrUndefined ||\n                inputIsCommandResuming ||\n                inputIsResuming));\n    }\n    constructor(params) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"input\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointerGetNextVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"channels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"managed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpoint\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointNamespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointPendingWrites\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"checkpointPreviousVersions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"step\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"stop\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputKeys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamKeys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"skipDoneTasks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"prevCheckpointConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"pending\"\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"tasks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"stream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointerPromises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"isNested\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_checkpointerChainedPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: Promise.resolve()\n        });\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"manager\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"interruptAfter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"interruptBefore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"toInterrupt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.input = params.input;\n        this.checkpointer = params.checkpointer;\n        // TODO: if managed values no longer needs graph we can replace with\n        // managed_specs, channel_specs\n        if (this.checkpointer !== undefined) {\n            this.checkpointerGetNextVersion = this.checkpointer.getNextVersion.bind(this.checkpointer);\n        }\n        else {\n            this.checkpointerGetNextVersion = _algo_js__WEBPACK_IMPORTED_MODULE_3__.increment;\n        }\n        this.checkpoint = params.checkpoint;\n        this.checkpointMetadata = params.checkpointMetadata;\n        this.checkpointPreviousVersions = params.checkpointPreviousVersions;\n        this.channels = params.channels;\n        this.managed = params.managed;\n        this.checkpointPendingWrites = params.checkpointPendingWrites;\n        this.step = params.step;\n        this.stop = params.stop;\n        this.config = params.config;\n        this.checkpointConfig = params.checkpointConfig;\n        this.isNested = params.isNested;\n        this.manager = params.manager;\n        this.outputKeys = params.outputKeys;\n        this.streamKeys = params.streamKeys;\n        this.nodes = params.nodes;\n        this.skipDoneTasks = params.skipDoneTasks;\n        this.store = params.store;\n        this.stream = params.stream;\n        this.checkpointNamespace = params.checkpointNamespace;\n        this.prevCheckpointConfig = params.prevCheckpointConfig;\n        this.interruptAfter = params.interruptAfter;\n        this.interruptBefore = params.interruptBefore;\n        this.debug = params.debug;\n    }\n    static async initialize(params) {\n        let { config, stream } = params;\n        if (stream !== undefined &&\n            config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_STREAM] !== undefined) {\n            stream = createDuplexStream(stream, config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_STREAM]);\n        }\n        const skipDoneTasks = config.configurable\n            ? !(\"checkpoint_id\" in config.configurable)\n            : true;\n        const scratchpad = config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SCRATCHPAD];\n        if (config.configurable && scratchpad) {\n            if (scratchpad.subgraphCounter > 0) {\n                config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.patchConfigurable)(config, {\n                    [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_NS]: [\n                        config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_NS],\n                        scratchpad.subgraphCounter.toString(),\n                    ].join(_constants_js__WEBPACK_IMPORTED_MODULE_2__.CHECKPOINT_NAMESPACE_SEPARATOR),\n                });\n            }\n            scratchpad.subgraphCounter += 1;\n        }\n        const isNested = _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_READ in (config.configurable ?? {});\n        if (!isNested &&\n            config.configurable?.checkpoint_ns !== undefined &&\n            config.configurable?.checkpoint_ns !== \"\") {\n            config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.patchConfigurable)(config, {\n                checkpoint_ns: \"\",\n                checkpoint_id: undefined,\n            });\n        }\n        let checkpointConfig = config;\n        if (config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_MAP] !== undefined &&\n            config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_MAP]?.[config.configurable?.checkpoint_ns]) {\n            checkpointConfig = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.patchConfigurable)(config, {\n                checkpoint_id: config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_MAP][config.configurable?.checkpoint_ns],\n            });\n        }\n        const checkpointNamespace = config.configurable?.checkpoint_ns?.split(_constants_js__WEBPACK_IMPORTED_MODULE_2__.CHECKPOINT_NAMESPACE_SEPARATOR) ?? [];\n        const saved = (await params.checkpointer?.getTuple(checkpointConfig)) ?? {\n            config,\n            checkpoint: (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.emptyCheckpoint)(),\n            metadata: {\n                source: \"input\",\n                step: -2,\n                writes: null,\n                parents: {},\n            },\n            pendingWrites: [],\n        };\n        checkpointConfig = {\n            ...config,\n            ...saved.config,\n            configurable: {\n                checkpoint_ns: \"\",\n                ...config.configurable,\n                ...saved.config.configurable,\n            },\n        };\n        const prevCheckpointConfig = saved.parentConfig;\n        const checkpoint = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.copyCheckpoint)(saved.checkpoint);\n        const checkpointMetadata = { ...saved.metadata };\n        const checkpointPendingWrites = saved.pendingWrites ?? [];\n        const channels = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_1__.emptyChannels)(params.channelSpecs, checkpoint);\n        const step = (checkpointMetadata.step ?? 0) + 1;\n        const stop = step + (config.recursionLimit ?? DEFAULT_LOOP_LIMIT) + 1;\n        const checkpointPreviousVersions = { ...checkpoint.channel_versions };\n        const store = params.store\n            ? new _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.AsyncBatchedStore(params.store)\n            : undefined;\n        if (store) {\n            // Start the store. This is a batch store, so it will run continuously\n            store.start();\n        }\n        return new PregelLoop({\n            input: params.input,\n            config,\n            checkpointer: params.checkpointer,\n            checkpoint,\n            checkpointMetadata,\n            checkpointConfig,\n            prevCheckpointConfig,\n            checkpointNamespace,\n            channels,\n            managed: params.managed,\n            isNested,\n            manager: params.manager,\n            skipDoneTasks,\n            step,\n            stop,\n            checkpointPreviousVersions,\n            checkpointPendingWrites,\n            outputKeys: params.outputKeys ?? [],\n            streamKeys: params.streamKeys ?? [],\n            nodes: params.nodes,\n            stream,\n            store,\n            interruptAfter: params.interruptAfter,\n            interruptBefore: params.interruptBefore,\n            debug: params.debug,\n        });\n    }\n    _checkpointerPutAfterPrevious(input) {\n        this._checkpointerChainedPromise = this._checkpointerChainedPromise.then(() => {\n            return this.checkpointer?.put(input.config, input.checkpoint, input.metadata, input.newVersions);\n        });\n        this.checkpointerPromises.push(this._checkpointerChainedPromise);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async updateManagedValues(key, values) {\n        const mv = this.managed.get(key);\n        if (mv && \"update\" in mv && typeof mv.update === \"function\") {\n            await mv.update(values);\n        }\n    }\n    /**\n     * Put writes for a task, to be read by the next tick.\n     * @param taskId\n     * @param writes\n     */\n    putWrites(taskId, writes) {\n        let writesCopy = writes;\n        if (writesCopy.length === 0) {\n            return;\n        }\n        // deduplicate writes to special channels, last write wins\n        if (writesCopy.every(([key]) => key in _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.WRITES_IDX_MAP)) {\n            writesCopy = Array.from(new Map(writesCopy.map((w) => [w[0], w])).values());\n        }\n        // save writes\n        for (const [c, v] of writesCopy) {\n            const idx = this.checkpointPendingWrites.findIndex((w) => w[0] === taskId && w[1] === c);\n            if (c in _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.WRITES_IDX_MAP && idx !== -1) {\n                this.checkpointPendingWrites[idx] = [taskId, c, v];\n            }\n            else {\n                this.checkpointPendingWrites.push([taskId, c, v]);\n            }\n        }\n        const putWritePromise = this.checkpointer?.putWrites({\n            ...this.checkpointConfig,\n            configurable: {\n                ...this.checkpointConfig.configurable,\n                checkpoint_ns: this.config.configurable?.checkpoint_ns ?? \"\",\n                checkpoint_id: this.checkpoint.id,\n            },\n        }, writesCopy, taskId);\n        if (putWritePromise !== undefined) {\n            this.checkpointerPromises.push(putWritePromise);\n        }\n        if (this.tasks) {\n            this._outputWrites(taskId, writesCopy);\n        }\n    }\n    _outputWrites(taskId, writes, cached = false) {\n        const task = this.tasks[taskId];\n        if (task !== undefined) {\n            if (task.config !== undefined &&\n                (task.config.tags ?? []).includes(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TAG_HIDDEN)) {\n                return;\n            }\n            if (writes.length > 0 &&\n                writes[0][0] !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR &&\n                writes[0][0] !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT) {\n                this._emit((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIteratorSync)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapOutputUpdates)(this.outputKeys, [[task, writes]], cached), \"updates\")));\n            }\n            if (!cached) {\n                this._emit((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIteratorSync)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_debug_js__WEBPACK_IMPORTED_MODULE_8__.mapDebugTaskResults)(this.step, [[task, writes]], this.streamKeys), \"debug\")));\n            }\n        }\n    }\n    /**\n     * Execute a single iteration of the Pregel loop.\n     * Returns true if more iterations are needed.\n     * @param params\n     */\n    async tick(params) {\n        if (this.store && !this.store.isRunning) {\n            this.store?.start();\n        }\n        const { inputKeys = [] } = params;\n        if (this.status !== \"pending\") {\n            throw new Error(`Cannot tick when status is no longer \"pending\". Current status: \"${this.status}\"`);\n        }\n        if (![INPUT_DONE, INPUT_RESUMING].includes(this.input)) {\n            await this._first(inputKeys);\n        }\n        else if (this.toInterrupt.length > 0) {\n            this.status = \"interrupt_before\";\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.GraphInterrupt();\n        }\n        else if (Object.values(this.tasks).every((task) => task.writes.length > 0)) {\n            // finish superstep\n            const writes = Object.values(this.tasks).flatMap((t) => t.writes);\n            // All tasks have finished\n            const managedValueWrites = (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._applyWrites)(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion);\n            for (const [key, values] of Object.entries(managedValueWrites)) {\n                await this.updateManagedValues(key, values);\n            }\n            // produce values output\n            const valuesOutput = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIterator)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapOutputValues)(this.outputKeys, writes, this.channels), \"values\"));\n            this._emit(valuesOutput);\n            // clear pending writes\n            this.checkpointPendingWrites = [];\n            await this._putCheckpoint({\n                source: \"loop\",\n                writes: (0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapOutputUpdates)(this.outputKeys, Object.values(this.tasks).map((task) => [task, task.writes])).next().value ?? null,\n            });\n            // after execution, check if we should interrupt\n            if ((0,_algo_js__WEBPACK_IMPORTED_MODULE_3__.shouldInterrupt)(this.checkpoint, this.interruptAfter, Object.values(this.tasks))) {\n                this.status = \"interrupt_after\";\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.GraphInterrupt();\n            }\n            // unset resuming flag\n            if (this.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING] !== undefined) {\n                delete this.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING];\n            }\n        }\n        else {\n            return false;\n        }\n        if (this.step > this.stop) {\n            this.status = \"out_of_steps\";\n            return false;\n        }\n        const nextTasks = (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._prepareNextTasks)(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, this.config, true, {\n            step: this.step,\n            checkpointer: this.checkpointer,\n            isResuming: this.isResuming,\n            manager: this.manager,\n            store: this.store,\n            stream: this.stream,\n        });\n        this.tasks = nextTasks;\n        // Produce debug output\n        if (this.checkpointer) {\n            this._emit(await (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIterator)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_debug_js__WEBPACK_IMPORTED_MODULE_8__.mapDebugCheckpoint)(this.step - 1, // printing checkpoint for previous step\n            this.checkpointConfig, this.channels, this.streamKeys, this.checkpointMetadata, Object.values(this.tasks), this.checkpointPendingWrites, this.prevCheckpointConfig), \"debug\")));\n        }\n        if (Object.values(this.tasks).length === 0) {\n            this.status = \"done\";\n            return false;\n        }\n        // if there are pending writes from a previous loop, apply them\n        if (this.skipDoneTasks && this.checkpointPendingWrites.length > 0) {\n            for (const [tid, k, v] of this.checkpointPendingWrites) {\n                if (k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR || k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT || k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.RESUME) {\n                    continue;\n                }\n                const task = Object.values(this.tasks).find((t) => t.id === tid);\n                if (task) {\n                    task.writes.push([k, v]);\n                }\n            }\n            for (const task of Object.values(this.tasks)) {\n                if (task.writes.length > 0) {\n                    this._outputWrites(task.id, task.writes, true);\n                }\n            }\n        }\n        // if all tasks have finished, re-tick\n        if (Object.values(this.tasks).every((task) => task.writes.length > 0)) {\n            return this.tick({ inputKeys });\n        }\n        // Before execution, check if we should interrupt\n        if ((0,_algo_js__WEBPACK_IMPORTED_MODULE_3__.shouldInterrupt)(this.checkpoint, this.interruptBefore, Object.values(this.tasks))) {\n            this.status = \"interrupt_before\";\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.GraphInterrupt();\n        }\n        // Produce debug output\n        const debugOutput = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIterator)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_debug_js__WEBPACK_IMPORTED_MODULE_8__.mapDebugTasks)(this.step, Object.values(this.tasks)), \"debug\"));\n        this._emit(debugOutput);\n        return true;\n    }\n    async finishAndHandleError(error) {\n        const suppress = this._suppressInterrupt(error);\n        if (suppress || error === undefined) {\n            this.output = (0,_io_js__WEBPACK_IMPORTED_MODULE_5__.readChannels)(this.channels, this.outputKeys);\n        }\n        if (suppress) {\n            // emit one last \"values\" event, with pending writes applied\n            if (this.tasks !== undefined &&\n                this.checkpointPendingWrites.length > 0 &&\n                Object.values(this.tasks).some((task) => task.writes.length > 0)) {\n                const managedValueWrites = (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._applyWrites)(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion);\n                for (const [key, values] of Object.entries(managedValueWrites)) {\n                    await this.updateManagedValues(key, values);\n                }\n                this._emit((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIteratorSync)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapOutputValues)(this.outputKeys, Object.values(this.tasks).flatMap((t) => t.writes), this.channels), \"values\")));\n            }\n            // Emit INTERRUPT event\n            this._emit([\n                [\n                    \"updates\",\n                    {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT]: error.interrupts,\n                    },\n                ],\n            ]);\n        }\n        return suppress;\n    }\n    acceptPush(task, writeIdx, call) {\n        if (this.interruptAfter?.length > 0 &&\n            (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__.shouldInterrupt)(this.checkpoint, this.interruptAfter, [task])) {\n            this.toInterrupt.push(task);\n            return;\n        }\n        const pushed = (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._prepareSingleTask)([_constants_js__WEBPACK_IMPORTED_MODULE_2__.PUSH, task.path ?? [], writeIdx, task.id, call], this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, task.config ?? {}, true, {\n            step: this.step,\n            checkpointer: this.checkpointer,\n            manager: this.manager,\n            store: this.store,\n            stream: this.stream,\n        });\n        if (pushed) {\n            if (this.interruptBefore?.length > 0 &&\n                (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__.shouldInterrupt)(this.checkpoint, this.interruptBefore, [pushed])) {\n                this.toInterrupt.push(pushed);\n                return;\n            }\n            this._emit((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIteratorSync)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_debug_js__WEBPACK_IMPORTED_MODULE_8__.mapDebugTasks)(this.step, [pushed]), \"debug\")));\n            if (this.debug) {\n                (0,_debug_js__WEBPACK_IMPORTED_MODULE_8__.printStepTasks)(this.step, [pushed]);\n            }\n            this.tasks[pushed.id] = pushed;\n            if (this.skipDoneTasks) {\n                this._matchWrites({ [pushed.id]: pushed });\n            }\n            return pushed;\n        }\n    }\n    _suppressInterrupt(e) {\n        return (0,_errors_js__WEBPACK_IMPORTED_MODULE_6__.isGraphInterrupt)(e) && !this.isNested;\n    }\n    async _first(inputKeys) {\n        /*\n         * Resuming from previous checkpoint requires\n         * - finding a previous checkpoint\n         * - receiving null input (outer graph) or RESUMING flag (subgraph)\n         */\n        const { configurable } = this.config;\n        // take resume value from parent\n        const scratchpad = configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SCRATCHPAD];\n        if (scratchpad && scratchpad.nullResume !== undefined) {\n            this.putWrites(_constants_js__WEBPACK_IMPORTED_MODULE_2__.NULL_TASK_ID, [[_constants_js__WEBPACK_IMPORTED_MODULE_2__.RESUME, scratchpad.nullResume]]);\n        }\n        if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_2__.isCommand)(this.input)) {\n            const hasResume = this.input.resume != null;\n            if (hasResume && this.checkpointer == null) {\n                throw new Error(\"Cannot use Command(resume=...) without checkpointer\");\n            }\n            const writes = {};\n            // group writes by task id\n            for (const [tid, key, value] of (0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapCommand)(this.input, this.checkpointPendingWrites)) {\n                if (writes[tid] === undefined) {\n                    writes[tid] = [];\n                }\n                writes[tid].push([key, value]);\n            }\n            if (Object.keys(writes).length === 0) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyInputError(\"Received empty Command input\");\n            }\n            // save writes\n            for (const [tid, ws] of Object.entries(writes)) {\n                this.putWrites(tid, ws);\n            }\n        }\n        // apply null writes\n        const nullWrites = (this.checkpointPendingWrites ?? [])\n            .filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_2__.NULL_TASK_ID)\n            .map((w) => w.slice(1));\n        if (nullWrites.length > 0) {\n            (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._applyWrites)(this.checkpoint, this.channels, [\n                {\n                    name: _constants_js__WEBPACK_IMPORTED_MODULE_2__.INPUT,\n                    writes: nullWrites,\n                    triggers: [],\n                },\n            ], this.checkpointerGetNextVersion);\n        }\n        const isCommandUpdateOrGoto = (0,_constants_js__WEBPACK_IMPORTED_MODULE_2__.isCommand)(this.input) && nullWrites.length > 0;\n        if (this.isResuming || isCommandUpdateOrGoto) {\n            for (const channelName of Object.keys(this.channels)) {\n                if (this.checkpoint.channel_versions[channelName] !== undefined) {\n                    const version = this.checkpoint.channel_versions[channelName];\n                    this.checkpoint.versions_seen[_constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT] = {\n                        ...this.checkpoint.versions_seen[_constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT],\n                        [channelName]: version,\n                    };\n                }\n            }\n            // produce values output\n            const valuesOutput = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIterator)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapOutputValues)(this.outputKeys, true, this.channels), \"values\"));\n            this._emit(valuesOutput);\n        }\n        if (this.isResuming) {\n            this.input = INPUT_RESUMING;\n        }\n        else if (isCommandUpdateOrGoto) {\n            // we need to create a new checkpoint for Command(update=...) or Command(goto=...)\n            // in case the result of Command(goto=...) is an interrupt.\n            // If not done, the checkpoint containing the interrupt will be lost.\n            await this._putCheckpoint({ source: \"input\", writes: {} });\n            this.input = INPUT_DONE;\n        }\n        else {\n            // map inputs to channel updates\n            const inputWrites = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIterator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapInput)(inputKeys, this.input));\n            if (inputWrites.length > 0) {\n                const discardTasks = (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._prepareNextTasks)(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, this.config, true, { step: this.step });\n                (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._applyWrites)(this.checkpoint, this.channels, Object.values(discardTasks).concat([\n                    {\n                        name: _constants_js__WEBPACK_IMPORTED_MODULE_2__.INPUT,\n                        writes: inputWrites,\n                        triggers: [],\n                    },\n                ]), this.checkpointerGetNextVersion);\n                // save input checkpoint\n                await this._putCheckpoint({\n                    source: \"input\",\n                    writes: Object.fromEntries(inputWrites),\n                });\n                this.input = INPUT_DONE;\n            }\n            else if (!(_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING in (this.config.configurable ?? {}))) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyInputError(`Received no input writes for ${JSON.stringify(inputKeys, null, 2)}`);\n            }\n            else {\n                // done with input\n                this.input = INPUT_DONE;\n            }\n        }\n        if (!this.isNested) {\n            this.config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.patchConfigurable)(this.config, {\n                [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING]: this.isResuming,\n            });\n        }\n    }\n    _emit(values) {\n        for (const chunk of values) {\n            if (this.stream.modes.has(chunk[0])) {\n                this.stream.push([this.checkpointNamespace, ...chunk]);\n            }\n        }\n    }\n    async _putCheckpoint(inputMetadata) {\n        // Assign step\n        const metadata = {\n            ...inputMetadata,\n            step: this.step,\n            parents: this.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_MAP] ?? {},\n        };\n        // Bail if no checkpointer\n        if (this.checkpointer !== undefined) {\n            // store the previous checkpoint config for debug events\n            this.prevCheckpointConfig = this.checkpointConfig?.configurable\n                ?.checkpoint_id\n                ? this.checkpointConfig\n                : undefined;\n            // create new checkpoint\n            this.checkpointMetadata = metadata;\n            // child graphs keep at most one checkpoint per parent checkpoint\n            // this is achieved by writing child checkpoints as progress is made\n            // (so that error recovery / resuming from interrupt don't lose work)\n            // but doing so always with an id equal to that of the parent checkpoint\n            this.checkpoint = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_1__.createCheckpoint)(this.checkpoint, this.channels, this.step);\n            this.checkpointConfig = {\n                ...this.checkpointConfig,\n                configurable: {\n                    ...this.checkpointConfig.configurable,\n                    checkpoint_ns: this.config.configurable?.checkpoint_ns ?? \"\",\n                },\n            };\n            const channelVersions = { ...this.checkpoint.channel_versions };\n            const newVersions = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.getNewChannelVersions)(this.checkpointPreviousVersions, channelVersions);\n            this.checkpointPreviousVersions = channelVersions;\n            // save it, without blocking\n            // if there's a previous checkpoint save in progress, wait for it\n            // ensuring checkpointers receive checkpoints in order\n            void this._checkpointerPutAfterPrevious({\n                config: { ...this.checkpointConfig },\n                checkpoint: (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.copyCheckpoint)(this.checkpoint),\n                metadata: { ...this.checkpointMetadata },\n                newVersions,\n            });\n            this.checkpointConfig = {\n                ...this.checkpointConfig,\n                configurable: {\n                    ...this.checkpointConfig.configurable,\n                    checkpoint_id: this.checkpoint.id,\n                },\n            };\n        }\n        this.step += 1;\n    }\n    _matchWrites(tasks) {\n        for (const [tid, k, v] of this.checkpointPendingWrites) {\n            if (k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR || k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT || k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.RESUME) {\n                continue;\n            }\n            const task = Object.values(tasks).find((t) => t.id === tid);\n            if (task) {\n                task.writes.push([k, v]);\n            }\n        }\n        for (const task of Object.values(tasks)) {\n            if (task.writes.length > 0) {\n                this._outputWrites(task.id, task.writes, true);\n            }\n        }\n    }\n}\n//# sourceMappingURL=loop.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvbG9vcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFzSDtBQUMvQztBQUM0TTtBQUN0SztBQUMxQjtBQUNjO0FBQ2Y7QUFDTjtBQUN5QjtBQUN4QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0VBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGlFQUFpRSw4REFBbUI7QUFDcEYscUZBQXFGLDhEQUFtQjtBQUN4RztBQUNBLHVDQUF1Qyx3REFBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrQ0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQSxrQ0FBa0MsNERBQWlCO0FBQ25ELG9FQUFvRSw0REFBaUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0VBQXFCO0FBQ3RFO0FBQ0E7QUFDQSx5QkFBeUIsa0VBQWlCO0FBQzFDLHFCQUFxQixtRUFBd0I7QUFDN0MsNENBQTRDLG1FQUF3QjtBQUNwRTtBQUNBLDJCQUEyQix5RUFBOEI7QUFDekQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwREFBZSw4QkFBOEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtFQUFpQjtBQUN0QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxrQ0FBa0Msb0VBQXlCO0FBQzNELGtDQUFrQyxvRUFBeUI7QUFDM0QsK0JBQStCLGtFQUFpQjtBQUNoRCxtREFBbUQsb0VBQXlCO0FBQzVFLGFBQWE7QUFDYjtBQUNBLDhFQUE4RSx5RUFBOEI7QUFDNUc7QUFDQTtBQUNBLHdCQUF3QixnRkFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQkFBMkIsK0VBQWM7QUFDekMscUNBQXFDO0FBQ3JDO0FBQ0EseUJBQXlCLGdFQUFhO0FBQ3RDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxrQkFBa0IsOEVBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMkVBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyRUFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscURBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdEQUFLO0FBQ3RDLGlDQUFpQyxvREFBUztBQUMxQywyQkFBMkIsNkRBQWtCLENBQUMsMERBQWUsQ0FBQyx3REFBZ0I7QUFDOUU7QUFDQTtBQUNBLDJCQUEyQiw2REFBa0IsQ0FBQywwREFBZSxDQUFDLDhEQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsZ0dBQWdHLFlBQVk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0RBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseURBQWMsQ0FBQywwREFBZSxDQUFDLHVEQUFlO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQWdCO0FBQ3hDLGFBQWE7QUFDYjtBQUNBLGdCQUFnQix5REFBZTtBQUMvQjtBQUNBLDBCQUEwQixzREFBYztBQUN4QztBQUNBO0FBQ0EsMkNBQTJDLDhEQUFtQjtBQUM5RCxrREFBa0QsOERBQW1CO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5REFBYyxDQUFDLDBEQUFlLENBQUMsNkRBQWtCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnREFBSyxVQUFVLG9EQUFTLFVBQVUsaURBQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBLFlBQVkseURBQWU7QUFDM0I7QUFDQSxzQkFBc0Isc0RBQWM7QUFDcEM7QUFDQTtBQUNBLGtDQUFrQyx5REFBYyxDQUFDLDBEQUFlLENBQUMsd0RBQWE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzREFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkRBQWtCLENBQUMsMERBQWUsQ0FBQyx1REFBZTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQVM7QUFDbEMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQWtCLEVBQUUsK0NBQUksc0pBQXNKO0FBQ3JNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQix5REFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQWtCLENBQUMsMERBQWUsQ0FBQyx3REFBYTtBQUN2RTtBQUNBLGdCQUFnQix5REFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDREQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0EsMENBQTBDLGdFQUFxQjtBQUMvRDtBQUNBLDJCQUEyQix1REFBWSxJQUFJLGlEQUFNO0FBQ2pEO0FBQ0EsWUFBWSx3REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0RBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdURBQVk7QUFDaEQ7QUFDQTtBQUNBLFlBQVksc0RBQVk7QUFDeEI7QUFDQSwwQkFBMEIsZ0RBQUs7QUFDL0I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0NBQXNDLHdEQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9EQUFTO0FBQzNELHlEQUF5RCxvREFBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHlEQUFjLENBQUMsMERBQWUsQ0FBQyx1REFBZTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlEQUFjLENBQUMsZ0RBQVE7QUFDN0Q7QUFDQSxxQ0FBcUMsMkRBQWlCLDhHQUE4RyxpQkFBaUI7QUFDckwsZ0JBQWdCLHNEQUFZO0FBQzVCO0FBQ0EsOEJBQThCLGdEQUFLO0FBQ25DO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdUJBQXVCLDhEQUFtQixtQ0FBbUM7QUFDN0UsMEJBQTBCLHVEQUFlLGlDQUFpQyxtQ0FBbUM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0VBQWlCO0FBQzNDLGlCQUFpQiw4REFBbUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsb0VBQXlCLE9BQU87QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtRUFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHNDQUFzQztBQUN0QyxnQ0FBZ0Msc0VBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BELDRCQUE0QiwrRUFBYztBQUMxQyw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFLLFVBQVUsb0RBQVMsVUFBVSxpREFBTTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxwcmVnZWxcXGxvb3AuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29weUNoZWNrcG9pbnQsIGVtcHR5Q2hlY2twb2ludCwgQXN5bmNCYXRjaGVkU3RvcmUsIFdSSVRFU19JRFhfTUFQLCB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaC1jaGVja3BvaW50XCI7XG5pbXBvcnQgeyBjcmVhdGVDaGVja3BvaW50LCBlbXB0eUNoYW5uZWxzLCB9IGZyb20gXCIuLi9jaGFubmVscy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBpc0NvbW1hbmQsIENIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUiwgQ09ORklHX0tFWV9DSEVDS1BPSU5UX01BUCwgQ09ORklHX0tFWV9SRUFELCBDT05GSUdfS0VZX1JFU1VNSU5HLCBDT05GSUdfS0VZX1NUUkVBTSwgRVJST1IsIElOUFVULCBJTlRFUlJVUFQsIE5VTExfVEFTS19JRCwgUkVTVU1FLCBUQUdfSElEREVOLCBQVVNILCBDT05GSUdfS0VZX1NDUkFUQ0hQQUQsIENPTkZJR19LRVlfQ0hFQ0tQT0lOVF9OUywgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBfYXBwbHlXcml0ZXMsIF9wcmVwYXJlTmV4dFRhc2tzLCBfcHJlcGFyZVNpbmdsZVRhc2ssIGluY3JlbWVudCwgc2hvdWxkSW50ZXJydXB0LCB9IGZyb20gXCIuL2FsZ28uanNcIjtcbmltcG9ydCB7IGdhdGhlckl0ZXJhdG9yLCBnYXRoZXJJdGVyYXRvclN5bmMsIHByZWZpeEdlbmVyYXRvciwgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IG1hcENvbW1hbmQsIG1hcElucHV0LCBtYXBPdXRwdXRVcGRhdGVzLCBtYXBPdXRwdXRWYWx1ZXMsIHJlYWRDaGFubmVscywgfSBmcm9tIFwiLi9pby5qc1wiO1xuaW1wb3J0IHsgRW1wdHlJbnB1dEVycm9yLCBHcmFwaEludGVycnVwdCwgaXNHcmFwaEludGVycnVwdCwgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXROZXdDaGFubmVsVmVyc2lvbnMsIHBhdGNoQ29uZmlndXJhYmxlIH0gZnJvbSBcIi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IG1hcERlYnVnVGFza3MsIG1hcERlYnVnQ2hlY2twb2ludCwgbWFwRGVidWdUYXNrUmVzdWx0cywgcHJpbnRTdGVwVGFza3MsIH0gZnJvbSBcIi4vZGVidWcuanNcIjtcbmltcG9ydCB7IEl0ZXJhYmxlUmVhZGFibGVXcml0YWJsZVN0cmVhbSB9IGZyb20gXCIuL3N0cmVhbS5qc1wiO1xuY29uc3QgSU5QVVRfRE9ORSA9IFN5bWJvbC5mb3IoXCJJTlBVVF9ET05FXCIpO1xuY29uc3QgSU5QVVRfUkVTVU1JTkcgPSBTeW1ib2wuZm9yKFwiSU5QVVRfUkVTVU1JTkdcIik7XG5jb25zdCBERUZBVUxUX0xPT1BfTElNSVQgPSAyNTtcbmZ1bmN0aW9uIGNyZWF0ZUR1cGxleFN0cmVhbSguLi5zdHJlYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICBwYXNzdGhyb3VnaEZuOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3RyZWFtIG9mIHN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLm1vZGVzLmhhcyh2YWx1ZVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW9kZXM6IG5ldyBTZXQoc3RyZWFtcy5mbGF0TWFwKChzKSA9PiBBcnJheS5mcm9tKHMubW9kZXMpKSksXG4gICAgfSk7XG59XG5leHBvcnQgY2xhc3MgUHJlZ2VsTG9vcCB7XG4gICAgZ2V0IGlzUmVzdW1pbmcoKSB7XG4gICAgICAgIGNvbnN0IGhhc0NoYW5uZWxWZXJzaW9ucyA9IE9iamVjdC5rZXlzKHRoaXMuY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zKS5sZW5ndGggIT09IDA7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0hhc1Jlc3VtaW5nRmxhZyA9IHRoaXMuY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfUkVTVU1JTkddICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0lzUmVzdW1pbmcgPSBjb25maWdIYXNSZXN1bWluZ0ZsYWcgJiYgdGhpcy5jb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9SRVNVTUlOR107XG4gICAgICAgIGNvbnN0IGlucHV0SXNOdWxsT3JVbmRlZmluZWQgPSB0aGlzLmlucHV0ID09PSBudWxsIHx8IHRoaXMuaW5wdXQgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaW5wdXRJc0NvbW1hbmRSZXN1bWluZyA9IGlzQ29tbWFuZCh0aGlzLmlucHV0KSAmJiB0aGlzLmlucHV0LnJlc3VtZSAhPSBudWxsO1xuICAgICAgICBjb25zdCBpbnB1dElzUmVzdW1pbmcgPSB0aGlzLmlucHV0ID09PSBJTlBVVF9SRVNVTUlORztcbiAgICAgICAgcmV0dXJuIChoYXNDaGFubmVsVmVyc2lvbnMgJiZcbiAgICAgICAgICAgIChjb25maWdJc1Jlc3VtaW5nIHx8XG4gICAgICAgICAgICAgICAgaW5wdXRJc051bGxPclVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIGlucHV0SXNDb21tYW5kUmVzdW1pbmcgfHxcbiAgICAgICAgICAgICAgICBpbnB1dElzUmVzdW1pbmcpKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hlY2twb2ludGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoZWNrcG9pbnRlckdldE5leHRWZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hbmFnZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hlY2twb2ludFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGVja3BvaW50Q29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoZWNrcG9pbnRNZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGVja3BvaW50TmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hlY2twb2ludFByZXZpb3VzVmVyc2lvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RlcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9wXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dEtleXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtS2V5c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2Rlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJza2lwRG9uZVRhc2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByZXZDaGVja3BvaW50Q29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJwZW5kaW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhc2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoZWNrcG9pbnRlclByb21pc2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNOZXN0ZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NoZWNrcG9pbnRlckNoYWluZWRQcm9taXNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWFuYWdlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcnJ1cHRBZnRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcnJ1cHRCZWZvcmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9JbnRlcnJ1cHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBwYXJhbXMuaW5wdXQ7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludGVyID0gcGFyYW1zLmNoZWNrcG9pbnRlcjtcbiAgICAgICAgLy8gVE9ETzogaWYgbWFuYWdlZCB2YWx1ZXMgbm8gbG9uZ2VyIG5lZWRzIGdyYXBoIHdlIGNhbiByZXBsYWNlIHdpdGhcbiAgICAgICAgLy8gbWFuYWdlZF9zcGVjcywgY2hhbm5lbF9zcGVjc1xuICAgICAgICBpZiAodGhpcy5jaGVja3BvaW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50ZXJHZXROZXh0VmVyc2lvbiA9IHRoaXMuY2hlY2twb2ludGVyLmdldE5leHRWZXJzaW9uLmJpbmQodGhpcy5jaGVja3BvaW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50ZXJHZXROZXh0VmVyc2lvbiA9IGluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrcG9pbnQgPSBwYXJhbXMuY2hlY2twb2ludDtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50TWV0YWRhdGEgPSBwYXJhbXMuY2hlY2twb2ludE1ldGFkYXRhO1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnRQcmV2aW91c1ZlcnNpb25zID0gcGFyYW1zLmNoZWNrcG9pbnRQcmV2aW91c1ZlcnNpb25zO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gcGFyYW1zLmNoYW5uZWxzO1xuICAgICAgICB0aGlzLm1hbmFnZWQgPSBwYXJhbXMubWFuYWdlZDtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50UGVuZGluZ1dyaXRlcyA9IHBhcmFtcy5jaGVja3BvaW50UGVuZGluZ1dyaXRlcztcbiAgICAgICAgdGhpcy5zdGVwID0gcGFyYW1zLnN0ZXA7XG4gICAgICAgIHRoaXMuc3RvcCA9IHBhcmFtcy5zdG9wO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHBhcmFtcy5jb25maWc7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludENvbmZpZyA9IHBhcmFtcy5jaGVja3BvaW50Q29uZmlnO1xuICAgICAgICB0aGlzLmlzTmVzdGVkID0gcGFyYW1zLmlzTmVzdGVkO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBwYXJhbXMubWFuYWdlcjtcbiAgICAgICAgdGhpcy5vdXRwdXRLZXlzID0gcGFyYW1zLm91dHB1dEtleXM7XG4gICAgICAgIHRoaXMuc3RyZWFtS2V5cyA9IHBhcmFtcy5zdHJlYW1LZXlzO1xuICAgICAgICB0aGlzLm5vZGVzID0gcGFyYW1zLm5vZGVzO1xuICAgICAgICB0aGlzLnNraXBEb25lVGFza3MgPSBwYXJhbXMuc2tpcERvbmVUYXNrcztcbiAgICAgICAgdGhpcy5zdG9yZSA9IHBhcmFtcy5zdG9yZTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBwYXJhbXMuc3RyZWFtO1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnROYW1lc3BhY2UgPSBwYXJhbXMuY2hlY2twb2ludE5hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5wcmV2Q2hlY2twb2ludENvbmZpZyA9IHBhcmFtcy5wcmV2Q2hlY2twb2ludENvbmZpZztcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRBZnRlciA9IHBhcmFtcy5pbnRlcnJ1cHRBZnRlcjtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRCZWZvcmUgPSBwYXJhbXMuaW50ZXJydXB0QmVmb3JlO1xuICAgICAgICB0aGlzLmRlYnVnID0gcGFyYW1zLmRlYnVnO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgaW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICAgICAgbGV0IHsgY29uZmlnLCBzdHJlYW0gfSA9IHBhcmFtcztcbiAgICAgICAgaWYgKHN0cmVhbSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9TVFJFQU1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IGNyZWF0ZUR1cGxleFN0cmVhbShzdHJlYW0sIGNvbmZpZy5jb25maWd1cmFibGVbQ09ORklHX0tFWV9TVFJFQU1dKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBza2lwRG9uZVRhc2tzID0gY29uZmlnLmNvbmZpZ3VyYWJsZVxuICAgICAgICAgICAgPyAhKFwiY2hlY2twb2ludF9pZFwiIGluIGNvbmZpZy5jb25maWd1cmFibGUpXG4gICAgICAgICAgICA6IHRydWU7XG4gICAgICAgIGNvbnN0IHNjcmF0Y2hwYWQgPSBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9TQ1JBVENIUEFEXTtcbiAgICAgICAgaWYgKGNvbmZpZy5jb25maWd1cmFibGUgJiYgc2NyYXRjaHBhZCkge1xuICAgICAgICAgICAgaWYgKHNjcmF0Y2hwYWQuc3ViZ3JhcGhDb3VudGVyID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHBhdGNoQ29uZmlndXJhYmxlKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9DSEVDS1BPSU5UX05TXTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmNvbmZpZ3VyYWJsZVtDT05GSUdfS0VZX0NIRUNLUE9JTlRfTlNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyYXRjaHBhZC5zdWJncmFwaENvdW50ZXIudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKENIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUiksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY3JhdGNocGFkLnN1YmdyYXBoQ291bnRlciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTmVzdGVkID0gQ09ORklHX0tFWV9SRUFEIGluIChjb25maWcuY29uZmlndXJhYmxlID8/IHt9KTtcbiAgICAgICAgaWYgKCFpc05lc3RlZCAmJlxuICAgICAgICAgICAgY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBjb25maWcgPSBwYXRjaENvbmZpZ3VyYWJsZShjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zOiBcIlwiLFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGVja3BvaW50Q29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAoY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVBdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQXT8uW2NvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfbnNdKSB7XG4gICAgICAgICAgICBjaGVja3BvaW50Q29uZmlnID0gcGF0Y2hDb25maWd1cmFibGUoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2hlY2twb2ludF9pZDogY29uZmlnLmNvbmZpZ3VyYWJsZVtDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQXVtjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnROYW1lc3BhY2UgPSBjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zPy5zcGxpdChDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IpID8/IFtdO1xuICAgICAgICBjb25zdCBzYXZlZCA9IChhd2FpdCBwYXJhbXMuY2hlY2twb2ludGVyPy5nZXRUdXBsZShjaGVja3BvaW50Q29uZmlnKSkgPz8ge1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgY2hlY2twb2ludDogZW1wdHlDaGVja3BvaW50KCksXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgIHN0ZXA6IC0yLFxuICAgICAgICAgICAgICAgIHdyaXRlczogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJlbnRzOiB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwZW5kaW5nV3JpdGVzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2twb2ludENvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIC4uLnNhdmVkLmNvbmZpZyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZToge1xuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfbnM6IFwiXCIsXG4gICAgICAgICAgICAgICAgLi4uY29uZmlnLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgICAuLi5zYXZlZC5jb25maWcuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJldkNoZWNrcG9pbnRDb25maWcgPSBzYXZlZC5wYXJlbnRDb25maWc7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBjb3B5Q2hlY2twb2ludChzYXZlZC5jaGVja3BvaW50KTtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludE1ldGFkYXRhID0geyAuLi5zYXZlZC5tZXRhZGF0YSB9O1xuICAgICAgICBjb25zdCBjaGVja3BvaW50UGVuZGluZ1dyaXRlcyA9IHNhdmVkLnBlbmRpbmdXcml0ZXMgPz8gW107XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gZW1wdHlDaGFubmVscyhwYXJhbXMuY2hhbm5lbFNwZWNzLCBjaGVja3BvaW50KTtcbiAgICAgICAgY29uc3Qgc3RlcCA9IChjaGVja3BvaW50TWV0YWRhdGEuc3RlcCA/PyAwKSArIDE7XG4gICAgICAgIGNvbnN0IHN0b3AgPSBzdGVwICsgKGNvbmZpZy5yZWN1cnNpb25MaW1pdCA/PyBERUZBVUxUX0xPT1BfTElNSVQpICsgMTtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludFByZXZpb3VzVmVyc2lvbnMgPSB7IC4uLmNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucyB9O1xuICAgICAgICBjb25zdCBzdG9yZSA9IHBhcmFtcy5zdG9yZVxuICAgICAgICAgICAgPyBuZXcgQXN5bmNCYXRjaGVkU3RvcmUocGFyYW1zLnN0b3JlKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzdG9yZSkge1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHN0b3JlLiBUaGlzIGlzIGEgYmF0Y2ggc3RvcmUsIHNvIGl0IHdpbGwgcnVuIGNvbnRpbnVvdXNseVxuICAgICAgICAgICAgc3RvcmUuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByZWdlbExvb3Aoe1xuICAgICAgICAgICAgaW5wdXQ6IHBhcmFtcy5pbnB1dCxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRlcjogcGFyYW1zLmNoZWNrcG9pbnRlcixcbiAgICAgICAgICAgIGNoZWNrcG9pbnQsXG4gICAgICAgICAgICBjaGVja3BvaW50TWV0YWRhdGEsXG4gICAgICAgICAgICBjaGVja3BvaW50Q29uZmlnLFxuICAgICAgICAgICAgcHJldkNoZWNrcG9pbnRDb25maWcsXG4gICAgICAgICAgICBjaGVja3BvaW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgY2hhbm5lbHMsXG4gICAgICAgICAgICBtYW5hZ2VkOiBwYXJhbXMubWFuYWdlZCxcbiAgICAgICAgICAgIGlzTmVzdGVkLFxuICAgICAgICAgICAgbWFuYWdlcjogcGFyYW1zLm1hbmFnZXIsXG4gICAgICAgICAgICBza2lwRG9uZVRhc2tzLFxuICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgIHN0b3AsXG4gICAgICAgICAgICBjaGVja3BvaW50UHJldmlvdXNWZXJzaW9ucyxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzLFxuICAgICAgICAgICAgb3V0cHV0S2V5czogcGFyYW1zLm91dHB1dEtleXMgPz8gW10sXG4gICAgICAgICAgICBzdHJlYW1LZXlzOiBwYXJhbXMuc3RyZWFtS2V5cyA/PyBbXSxcbiAgICAgICAgICAgIG5vZGVzOiBwYXJhbXMubm9kZXMsXG4gICAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgIGludGVycnVwdEFmdGVyOiBwYXJhbXMuaW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICBpbnRlcnJ1cHRCZWZvcmU6IHBhcmFtcy5pbnRlcnJ1cHRCZWZvcmUsXG4gICAgICAgICAgICBkZWJ1ZzogcGFyYW1zLmRlYnVnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NoZWNrcG9pbnRlclB1dEFmdGVyUHJldmlvdXMoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5fY2hlY2twb2ludGVyQ2hhaW5lZFByb21pc2UgPSB0aGlzLl9jaGVja3BvaW50ZXJDaGFpbmVkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrcG9pbnRlcj8ucHV0KGlucHV0LmNvbmZpZywgaW5wdXQuY2hlY2twb2ludCwgaW5wdXQubWV0YWRhdGEsIGlucHV0Lm5ld1ZlcnNpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludGVyUHJvbWlzZXMucHVzaCh0aGlzLl9jaGVja3BvaW50ZXJDaGFpbmVkUHJvbWlzZSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgdXBkYXRlTWFuYWdlZFZhbHVlcyhrZXksIHZhbHVlcykge1xuICAgICAgICBjb25zdCBtdiA9IHRoaXMubWFuYWdlZC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG12ICYmIFwidXBkYXRlXCIgaW4gbXYgJiYgdHlwZW9mIG12LnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhd2FpdCBtdi51cGRhdGUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXQgd3JpdGVzIGZvciBhIHRhc2ssIHRvIGJlIHJlYWQgYnkgdGhlIG5leHQgdGljay5cbiAgICAgKiBAcGFyYW0gdGFza0lkXG4gICAgICogQHBhcmFtIHdyaXRlc1xuICAgICAqL1xuICAgIHB1dFdyaXRlcyh0YXNrSWQsIHdyaXRlcykge1xuICAgICAgICBsZXQgd3JpdGVzQ29weSA9IHdyaXRlcztcbiAgICAgICAgaWYgKHdyaXRlc0NvcHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVkdXBsaWNhdGUgd3JpdGVzIHRvIHNwZWNpYWwgY2hhbm5lbHMsIGxhc3Qgd3JpdGUgd2luc1xuICAgICAgICBpZiAod3JpdGVzQ29weS5ldmVyeSgoW2tleV0pID0+IGtleSBpbiBXUklURVNfSURYX01BUCkpIHtcbiAgICAgICAgICAgIHdyaXRlc0NvcHkgPSBBcnJheS5mcm9tKG5ldyBNYXAod3JpdGVzQ29weS5tYXAoKHcpID0+IFt3WzBdLCB3XSkpLnZhbHVlcygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzYXZlIHdyaXRlc1xuICAgICAgICBmb3IgKGNvbnN0IFtjLCB2XSBvZiB3cml0ZXNDb3B5KSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLmNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzLmZpbmRJbmRleCgodykgPT4gd1swXSA9PT0gdGFza0lkICYmIHdbMV0gPT09IGMpO1xuICAgICAgICAgICAgaWYgKGMgaW4gV1JJVEVTX0lEWF9NQVAgJiYgaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXNbaWR4XSA9IFt0YXNrSWQsIGMsIHZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50UGVuZGluZ1dyaXRlcy5wdXNoKFt0YXNrSWQsIGMsIHZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdXRXcml0ZVByb21pc2UgPSB0aGlzLmNoZWNrcG9pbnRlcj8ucHV0V3JpdGVzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuY2hlY2twb2ludENvbmZpZyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZToge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuY2hlY2twb2ludENvbmZpZy5jb25maWd1cmFibGUsXG4gICAgICAgICAgICAgICAgY2hlY2twb2ludF9uczogdGhpcy5jb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zID8/IFwiXCIsXG4gICAgICAgICAgICAgICAgY2hlY2twb2ludF9pZDogdGhpcy5jaGVja3BvaW50LmlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgd3JpdGVzQ29weSwgdGFza0lkKTtcbiAgICAgICAgaWYgKHB1dFdyaXRlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRlclByb21pc2VzLnB1c2gocHV0V3JpdGVQcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50YXNrcykge1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0V3JpdGVzKHRhc2tJZCwgd3JpdGVzQ29weSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX291dHB1dFdyaXRlcyh0YXNrSWQsIHdyaXRlcywgY2FjaGVkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdGFzayA9IHRoaXMudGFza3NbdGFza0lkXTtcbiAgICAgICAgaWYgKHRhc2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRhc2suY29uZmlnICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAodGFzay5jb25maWcudGFncyA/PyBbXSkuaW5jbHVkZXMoVEFHX0hJRERFTikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod3JpdGVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICB3cml0ZXNbMF1bMF0gIT09IEVSUk9SICYmXG4gICAgICAgICAgICAgICAgd3JpdGVzWzBdWzBdICE9PSBJTlRFUlJVUFQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KGdhdGhlckl0ZXJhdG9yU3luYyhwcmVmaXhHZW5lcmF0b3IobWFwT3V0cHV0VXBkYXRlcyh0aGlzLm91dHB1dEtleXMsIFtbdGFzaywgd3JpdGVzXV0sIGNhY2hlZCksIFwidXBkYXRlc1wiKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KGdhdGhlckl0ZXJhdG9yU3luYyhwcmVmaXhHZW5lcmF0b3IobWFwRGVidWdUYXNrUmVzdWx0cyh0aGlzLnN0ZXAsIFtbdGFzaywgd3JpdGVzXV0sIHRoaXMuc3RyZWFtS2V5cyksIFwiZGVidWdcIikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGEgc2luZ2xlIGl0ZXJhdGlvbiBvZiB0aGUgUHJlZ2VsIGxvb3AuXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG1vcmUgaXRlcmF0aW9ucyBhcmUgbmVlZGVkLlxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBhc3luYyB0aWNrKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5zdG9yZSAmJiAhdGhpcy5zdG9yZS5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmU/LnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnB1dEtleXMgPSBbXSB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB0aWNrIHdoZW4gc3RhdHVzIGlzIG5vIGxvbmdlciBcInBlbmRpbmdcIi4gQ3VycmVudCBzdGF0dXM6IFwiJHt0aGlzLnN0YXR1c31cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghW0lOUFVUX0RPTkUsIElOUFVUX1JFU1VNSU5HXS5pbmNsdWRlcyh0aGlzLmlucHV0KSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZmlyc3QoaW5wdXRLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRvSW50ZXJydXB0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJpbnRlcnJ1cHRfYmVmb3JlXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhJbnRlcnJ1cHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChPYmplY3QudmFsdWVzKHRoaXMudGFza3MpLmV2ZXJ5KCh0YXNrKSA9PiB0YXNrLndyaXRlcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgLy8gZmluaXNoIHN1cGVyc3RlcFxuICAgICAgICAgICAgY29uc3Qgd3JpdGVzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKS5mbGF0TWFwKCh0KSA9PiB0LndyaXRlcyk7XG4gICAgICAgICAgICAvLyBBbGwgdGFza3MgaGF2ZSBmaW5pc2hlZFxuICAgICAgICAgICAgY29uc3QgbWFuYWdlZFZhbHVlV3JpdGVzID0gX2FwcGx5V3JpdGVzKHRoaXMuY2hlY2twb2ludCwgdGhpcy5jaGFubmVscywgT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKSwgdGhpcy5jaGVja3BvaW50ZXJHZXROZXh0VmVyc2lvbik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMobWFuYWdlZFZhbHVlV3JpdGVzKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlTWFuYWdlZFZhbHVlcyhrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9kdWNlIHZhbHVlcyBvdXRwdXRcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlc091dHB1dCA9IGF3YWl0IGdhdGhlckl0ZXJhdG9yKHByZWZpeEdlbmVyYXRvcihtYXBPdXRwdXRWYWx1ZXModGhpcy5vdXRwdXRLZXlzLCB3cml0ZXMsIHRoaXMuY2hhbm5lbHMpLCBcInZhbHVlc1wiKSk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KHZhbHVlc091dHB1dCk7XG4gICAgICAgICAgICAvLyBjbGVhciBwZW5kaW5nIHdyaXRlc1xuICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50UGVuZGluZ1dyaXRlcyA9IFtdO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHV0Q2hlY2twb2ludCh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBcImxvb3BcIixcbiAgICAgICAgICAgICAgICB3cml0ZXM6IG1hcE91dHB1dFVwZGF0ZXModGhpcy5vdXRwdXRLZXlzLCBPYmplY3QudmFsdWVzKHRoaXMudGFza3MpLm1hcCgodGFzaykgPT4gW3Rhc2ssIHRhc2sud3JpdGVzXSkpLm5leHQoKS52YWx1ZSA/PyBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBhZnRlciBleGVjdXRpb24sIGNoZWNrIGlmIHdlIHNob3VsZCBpbnRlcnJ1cHRcbiAgICAgICAgICAgIGlmIChzaG91bGRJbnRlcnJ1cHQodGhpcy5jaGVja3BvaW50LCB0aGlzLmludGVycnVwdEFmdGVyLCBPYmplY3QudmFsdWVzKHRoaXMudGFza3MpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJpbnRlcnJ1cHRfYWZ0ZXJcIjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhJbnRlcnJ1cHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVuc2V0IHJlc3VtaW5nIGZsYWdcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX1JFU1VNSU5HXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfUkVTVU1JTkddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0ZXAgPiB0aGlzLnN0b3ApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJvdXRfb2Zfc3RlcHNcIjtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VGFza3MgPSBfcHJlcGFyZU5leHRUYXNrcyh0aGlzLmNoZWNrcG9pbnQsIHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXMsIHRoaXMubm9kZXMsIHRoaXMuY2hhbm5lbHMsIHRoaXMubWFuYWdlZCwgdGhpcy5jb25maWcsIHRydWUsIHtcbiAgICAgICAgICAgIHN0ZXA6IHRoaXMuc3RlcCxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRlcjogdGhpcy5jaGVja3BvaW50ZXIsXG4gICAgICAgICAgICBpc1Jlc3VtaW5nOiB0aGlzLmlzUmVzdW1pbmcsXG4gICAgICAgICAgICBtYW5hZ2VyOiB0aGlzLm1hbmFnZXIsXG4gICAgICAgICAgICBzdG9yZTogdGhpcy5zdG9yZSxcbiAgICAgICAgICAgIHN0cmVhbTogdGhpcy5zdHJlYW0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRhc2tzID0gbmV4dFRhc2tzO1xuICAgICAgICAvLyBQcm9kdWNlIGRlYnVnIG91dHB1dFxuICAgICAgICBpZiAodGhpcy5jaGVja3BvaW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoYXdhaXQgZ2F0aGVySXRlcmF0b3IocHJlZml4R2VuZXJhdG9yKG1hcERlYnVnQ2hlY2twb2ludCh0aGlzLnN0ZXAgLSAxLCAvLyBwcmludGluZyBjaGVja3BvaW50IGZvciBwcmV2aW91cyBzdGVwXG4gICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRDb25maWcsIHRoaXMuY2hhbm5lbHMsIHRoaXMuc3RyZWFtS2V5cywgdGhpcy5jaGVja3BvaW50TWV0YWRhdGEsIE9iamVjdC52YWx1ZXModGhpcy50YXNrcyksIHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXMsIHRoaXMucHJldkNoZWNrcG9pbnRDb25maWcpLCBcImRlYnVnXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXModGhpcy50YXNrcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwiZG9uZVwiO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBwZW5kaW5nIHdyaXRlcyBmcm9tIGEgcHJldmlvdXMgbG9vcCwgYXBwbHkgdGhlbVxuICAgICAgICBpZiAodGhpcy5za2lwRG9uZVRhc2tzICYmIHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdGlkLCBrLCB2XSBvZiB0aGlzLmNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsgPT09IEVSUk9SIHx8IGsgPT09IElOVEVSUlVQVCB8fCBrID09PSBSRVNVTUUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBPYmplY3QudmFsdWVzKHRoaXMudGFza3MpLmZpbmQoKHQpID0+IHQuaWQgPT09IHRpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay53cml0ZXMucHVzaChbaywgdl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFzayBvZiBPYmplY3QudmFsdWVzKHRoaXMudGFza3MpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2sud3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0V3JpdGVzKHRhc2suaWQsIHRhc2sud3JpdGVzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWxsIHRhc2tzIGhhdmUgZmluaXNoZWQsIHJlLXRpY2tcbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXModGhpcy50YXNrcykuZXZlcnkoKHRhc2spID0+IHRhc2sud3JpdGVzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aWNrKHsgaW5wdXRLZXlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlZm9yZSBleGVjdXRpb24sIGNoZWNrIGlmIHdlIHNob3VsZCBpbnRlcnJ1cHRcbiAgICAgICAgaWYgKHNob3VsZEludGVycnVwdCh0aGlzLmNoZWNrcG9pbnQsIHRoaXMuaW50ZXJydXB0QmVmb3JlLCBPYmplY3QudmFsdWVzKHRoaXMudGFza3MpKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBcImludGVycnVwdF9iZWZvcmVcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcmFwaEludGVycnVwdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2R1Y2UgZGVidWcgb3V0cHV0XG4gICAgICAgIGNvbnN0IGRlYnVnT3V0cHV0ID0gYXdhaXQgZ2F0aGVySXRlcmF0b3IocHJlZml4R2VuZXJhdG9yKG1hcERlYnVnVGFza3ModGhpcy5zdGVwLCBPYmplY3QudmFsdWVzKHRoaXMudGFza3MpKSwgXCJkZWJ1Z1wiKSk7XG4gICAgICAgIHRoaXMuX2VtaXQoZGVidWdPdXRwdXQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgZmluaXNoQW5kSGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgc3VwcHJlc3MgPSB0aGlzLl9zdXBwcmVzc0ludGVycnVwdChlcnJvcik7XG4gICAgICAgIGlmIChzdXBwcmVzcyB8fCBlcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dCA9IHJlYWRDaGFubmVscyh0aGlzLmNoYW5uZWxzLCB0aGlzLm91dHB1dEtleXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXBwcmVzcykge1xuICAgICAgICAgICAgLy8gZW1pdCBvbmUgbGFzdCBcInZhbHVlc1wiIGV2ZW50LCB3aXRoIHBlbmRpbmcgd3JpdGVzIGFwcGxpZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnRhc2tzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMudGFza3MpLnNvbWUoKHRhc2spID0+IHRhc2sud3JpdGVzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFuYWdlZFZhbHVlV3JpdGVzID0gX2FwcGx5V3JpdGVzKHRoaXMuY2hlY2twb2ludCwgdGhpcy5jaGFubmVscywgT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKSwgdGhpcy5jaGVja3BvaW50ZXJHZXROZXh0VmVyc2lvbik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKG1hbmFnZWRWYWx1ZVdyaXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVNYW5hZ2VkVmFsdWVzKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdChnYXRoZXJJdGVyYXRvclN5bmMocHJlZml4R2VuZXJhdG9yKG1hcE91dHB1dFZhbHVlcyh0aGlzLm91dHB1dEtleXMsIE9iamVjdC52YWx1ZXModGhpcy50YXNrcykuZmxhdE1hcCgodCkgPT4gdC53cml0ZXMpLCB0aGlzLmNoYW5uZWxzKSwgXCJ2YWx1ZXNcIikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVtaXQgSU5URVJSVVBUIGV2ZW50XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFtcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIFwidXBkYXRlc1wiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbSU5URVJSVVBUXTogZXJyb3IuaW50ZXJydXB0cyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cHByZXNzO1xuICAgIH1cbiAgICBhY2NlcHRQdXNoKHRhc2ssIHdyaXRlSWR4LCBjYWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVycnVwdEFmdGVyPy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBzaG91bGRJbnRlcnJ1cHQodGhpcy5jaGVja3BvaW50LCB0aGlzLmludGVycnVwdEFmdGVyLCBbdGFza10pKSB7XG4gICAgICAgICAgICB0aGlzLnRvSW50ZXJydXB0LnB1c2godGFzayk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVzaGVkID0gX3ByZXBhcmVTaW5nbGVUYXNrKFtQVVNILCB0YXNrLnBhdGggPz8gW10sIHdyaXRlSWR4LCB0YXNrLmlkLCBjYWxsXSwgdGhpcy5jaGVja3BvaW50LCB0aGlzLmNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzLCB0aGlzLm5vZGVzLCB0aGlzLmNoYW5uZWxzLCB0aGlzLm1hbmFnZWQsIHRhc2suY29uZmlnID8/IHt9LCB0cnVlLCB7XG4gICAgICAgICAgICBzdGVwOiB0aGlzLnN0ZXAsXG4gICAgICAgICAgICBjaGVja3BvaW50ZXI6IHRoaXMuY2hlY2twb2ludGVyLFxuICAgICAgICAgICAgbWFuYWdlcjogdGhpcy5tYW5hZ2VyLFxuICAgICAgICAgICAgc3RvcmU6IHRoaXMuc3RvcmUsXG4gICAgICAgICAgICBzdHJlYW06IHRoaXMuc3RyZWFtLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHB1c2hlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJydXB0QmVmb3JlPy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJydXB0KHRoaXMuY2hlY2twb2ludCwgdGhpcy5pbnRlcnJ1cHRCZWZvcmUsIFtwdXNoZWRdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9JbnRlcnJ1cHQucHVzaChwdXNoZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2VtaXQoZ2F0aGVySXRlcmF0b3JTeW5jKHByZWZpeEdlbmVyYXRvcihtYXBEZWJ1Z1Rhc2tzKHRoaXMuc3RlcCwgW3B1c2hlZF0pLCBcImRlYnVnXCIpKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHByaW50U3RlcFRhc2tzKHRoaXMuc3RlcCwgW3B1c2hlZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50YXNrc1twdXNoZWQuaWRdID0gcHVzaGVkO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcERvbmVUYXNrcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoV3JpdGVzKHsgW3B1c2hlZC5pZF06IHB1c2hlZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdXNoZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3N1cHByZXNzSW50ZXJydXB0KGUpIHtcbiAgICAgICAgcmV0dXJuIGlzR3JhcGhJbnRlcnJ1cHQoZSkgJiYgIXRoaXMuaXNOZXN0ZWQ7XG4gICAgfVxuICAgIGFzeW5jIF9maXJzdChpbnB1dEtleXMpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogUmVzdW1pbmcgZnJvbSBwcmV2aW91cyBjaGVja3BvaW50IHJlcXVpcmVzXG4gICAgICAgICAqIC0gZmluZGluZyBhIHByZXZpb3VzIGNoZWNrcG9pbnRcbiAgICAgICAgICogLSByZWNlaXZpbmcgbnVsbCBpbnB1dCAob3V0ZXIgZ3JhcGgpIG9yIFJFU1VNSU5HIGZsYWcgKHN1YmdyYXBoKVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyBjb25maWd1cmFibGUgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAvLyB0YWtlIHJlc3VtZSB2YWx1ZSBmcm9tIHBhcmVudFxuICAgICAgICBjb25zdCBzY3JhdGNocGFkID0gY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9TQ1JBVENIUEFEXTtcbiAgICAgICAgaWYgKHNjcmF0Y2hwYWQgJiYgc2NyYXRjaHBhZC5udWxsUmVzdW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHV0V3JpdGVzKE5VTExfVEFTS19JRCwgW1tSRVNVTUUsIHNjcmF0Y2hwYWQubnVsbFJlc3VtZV1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb21tYW5kKHRoaXMuaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNSZXN1bWUgPSB0aGlzLmlucHV0LnJlc3VtZSAhPSBudWxsO1xuICAgICAgICAgICAgaWYgKGhhc1Jlc3VtZSAmJiB0aGlzLmNoZWNrcG9pbnRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBDb21tYW5kKHJlc3VtZT0uLi4pIHdpdGhvdXQgY2hlY2twb2ludGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd3JpdGVzID0ge307XG4gICAgICAgICAgICAvLyBncm91cCB3cml0ZXMgYnkgdGFzayBpZFxuICAgICAgICAgICAgZm9yIChjb25zdCBbdGlkLCBrZXksIHZhbHVlXSBvZiBtYXBDb21tYW5kKHRoaXMuaW5wdXQsIHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdyaXRlc1t0aWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVzW3RpZF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVzW3RpZF0ucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHdyaXRlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVtcHR5SW5wdXRFcnJvcihcIlJlY2VpdmVkIGVtcHR5IENvbW1hbmQgaW5wdXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzYXZlIHdyaXRlc1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdGlkLCB3c10gb2YgT2JqZWN0LmVudHJpZXMod3JpdGVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHV0V3JpdGVzKHRpZCwgd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGx5IG51bGwgd3JpdGVzXG4gICAgICAgIGNvbnN0IG51bGxXcml0ZXMgPSAodGhpcy5jaGVja3BvaW50UGVuZGluZ1dyaXRlcyA/PyBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHcpID0+IHdbMF0gPT09IE5VTExfVEFTS19JRClcbiAgICAgICAgICAgIC5tYXAoKHcpID0+IHcuc2xpY2UoMSkpO1xuICAgICAgICBpZiAobnVsbFdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBfYXBwbHlXcml0ZXModGhpcy5jaGVja3BvaW50LCB0aGlzLmNoYW5uZWxzLCBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBJTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVzOiBudWxsV3JpdGVzLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyczogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sIHRoaXMuY2hlY2twb2ludGVyR2V0TmV4dFZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQ29tbWFuZFVwZGF0ZU9yR290byA9IGlzQ29tbWFuZCh0aGlzLmlucHV0KSAmJiBudWxsV3JpdGVzLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzdW1pbmcgfHwgaXNDb21tYW5kVXBkYXRlT3JHb3RvKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoYW5uZWxOYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuY2hhbm5lbHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zW2NoYW5uZWxOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLmNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9uc1tjaGFubmVsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2twb2ludC52ZXJzaW9uc19zZWVuW0lOVEVSUlVQVF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmNoZWNrcG9pbnQudmVyc2lvbnNfc2VlbltJTlRFUlJVUFRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW2NoYW5uZWxOYW1lXTogdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9kdWNlIHZhbHVlcyBvdXRwdXRcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlc091dHB1dCA9IGF3YWl0IGdhdGhlckl0ZXJhdG9yKHByZWZpeEdlbmVyYXRvcihtYXBPdXRwdXRWYWx1ZXModGhpcy5vdXRwdXRLZXlzLCB0cnVlLCB0aGlzLmNoYW5uZWxzKSwgXCJ2YWx1ZXNcIikpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCh2YWx1ZXNPdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzUmVzdW1pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBJTlBVVF9SRVNVTUlORztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NvbW1hbmRVcGRhdGVPckdvdG8pIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGNoZWNrcG9pbnQgZm9yIENvbW1hbmQodXBkYXRlPS4uLikgb3IgQ29tbWFuZChnb3RvPS4uLilcbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIHJlc3VsdCBvZiBDb21tYW5kKGdvdG89Li4uKSBpcyBhbiBpbnRlcnJ1cHQuXG4gICAgICAgICAgICAvLyBJZiBub3QgZG9uZSwgdGhlIGNoZWNrcG9pbnQgY29udGFpbmluZyB0aGUgaW50ZXJydXB0IHdpbGwgYmUgbG9zdC5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3B1dENoZWNrcG9pbnQoeyBzb3VyY2U6IFwiaW5wdXRcIiwgd3JpdGVzOiB7fSB9KTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBJTlBVVF9ET05FO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbWFwIGlucHV0cyB0byBjaGFubmVsIHVwZGF0ZXNcbiAgICAgICAgICAgIGNvbnN0IGlucHV0V3JpdGVzID0gYXdhaXQgZ2F0aGVySXRlcmF0b3IobWFwSW5wdXQoaW5wdXRLZXlzLCB0aGlzLmlucHV0KSk7XG4gICAgICAgICAgICBpZiAoaW5wdXRXcml0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2NhcmRUYXNrcyA9IF9wcmVwYXJlTmV4dFRhc2tzKHRoaXMuY2hlY2twb2ludCwgdGhpcy5jaGVja3BvaW50UGVuZGluZ1dyaXRlcywgdGhpcy5ub2RlcywgdGhpcy5jaGFubmVscywgdGhpcy5tYW5hZ2VkLCB0aGlzLmNvbmZpZywgdHJ1ZSwgeyBzdGVwOiB0aGlzLnN0ZXAgfSk7XG4gICAgICAgICAgICAgICAgX2FwcGx5V3JpdGVzKHRoaXMuY2hlY2twb2ludCwgdGhpcy5jaGFubmVscywgT2JqZWN0LnZhbHVlcyhkaXNjYXJkVGFza3MpLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IElOUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVzOiBpbnB1dFdyaXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdKSwgdGhpcy5jaGVja3BvaW50ZXJHZXROZXh0VmVyc2lvbik7XG4gICAgICAgICAgICAgICAgLy8gc2F2ZSBpbnB1dCBjaGVja3BvaW50XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHV0Q2hlY2twb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IE9iamVjdC5mcm9tRW50cmllcyhpbnB1dFdyaXRlcyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dCA9IElOUFVUX0RPTkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKENPTkZJR19LRVlfUkVTVU1JTkcgaW4gKHRoaXMuY29uZmlnLmNvbmZpZ3VyYWJsZSA/PyB7fSkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVtcHR5SW5wdXRFcnJvcihgUmVjZWl2ZWQgbm8gaW5wdXQgd3JpdGVzIGZvciAke0pTT04uc3RyaW5naWZ5KGlucHV0S2V5cywgbnVsbCwgMil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkb25lIHdpdGggaW5wdXRcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0ID0gSU5QVVRfRE9ORTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNOZXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0gcGF0Y2hDb25maWd1cmFibGUodGhpcy5jb25maWcsIHtcbiAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9SRVNVTUlOR106IHRoaXMuaXNSZXN1bWluZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbWl0KHZhbHVlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLm1vZGVzLmhhcyhjaHVua1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5wdXNoKFt0aGlzLmNoZWNrcG9pbnROYW1lc3BhY2UsIC4uLmNodW5rXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3B1dENoZWNrcG9pbnQoaW5wdXRNZXRhZGF0YSkge1xuICAgICAgICAvLyBBc3NpZ24gc3RlcFxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmlucHV0TWV0YWRhdGEsXG4gICAgICAgICAgICBzdGVwOiB0aGlzLnN0ZXAsXG4gICAgICAgICAgICBwYXJlbnRzOiB0aGlzLmNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQXSA/PyB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQmFpbCBpZiBubyBjaGVja3BvaW50ZXJcbiAgICAgICAgaWYgKHRoaXMuY2hlY2twb2ludGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBwcmV2aW91cyBjaGVja3BvaW50IGNvbmZpZyBmb3IgZGVidWcgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLnByZXZDaGVja3BvaW50Q29uZmlnID0gdGhpcy5jaGVja3BvaW50Q29uZmlnPy5jb25maWd1cmFibGVcbiAgICAgICAgICAgICAgICA/LmNoZWNrcG9pbnRfaWRcbiAgICAgICAgICAgICAgICA/IHRoaXMuY2hlY2twb2ludENvbmZpZ1xuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBjaGVja3BvaW50XG4gICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgLy8gY2hpbGQgZ3JhcGhzIGtlZXAgYXQgbW9zdCBvbmUgY2hlY2twb2ludCBwZXIgcGFyZW50IGNoZWNrcG9pbnRcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYWNoaWV2ZWQgYnkgd3JpdGluZyBjaGlsZCBjaGVja3BvaW50cyBhcyBwcm9ncmVzcyBpcyBtYWRlXG4gICAgICAgICAgICAvLyAoc28gdGhhdCBlcnJvciByZWNvdmVyeSAvIHJlc3VtaW5nIGZyb20gaW50ZXJydXB0IGRvbid0IGxvc2Ugd29yaylcbiAgICAgICAgICAgIC8vIGJ1dCBkb2luZyBzbyBhbHdheXMgd2l0aCBhbiBpZCBlcXVhbCB0byB0aGF0IG9mIHRoZSBwYXJlbnQgY2hlY2twb2ludFxuICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50ID0gY3JlYXRlQ2hlY2twb2ludCh0aGlzLmNoZWNrcG9pbnQsIHRoaXMuY2hhbm5lbHMsIHRoaXMuc3RlcCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5jaGVja3BvaW50Q29uZmlnLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZToge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmNoZWNrcG9pbnRDb25maWcuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zOiB0aGlzLmNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfbnMgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxWZXJzaW9ucyA9IHsgLi4udGhpcy5jaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZlcnNpb25zID0gZ2V0TmV3Q2hhbm5lbFZlcnNpb25zKHRoaXMuY2hlY2twb2ludFByZXZpb3VzVmVyc2lvbnMsIGNoYW5uZWxWZXJzaW9ucyk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRQcmV2aW91c1ZlcnNpb25zID0gY2hhbm5lbFZlcnNpb25zO1xuICAgICAgICAgICAgLy8gc2F2ZSBpdCwgd2l0aG91dCBibG9ja2luZ1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHByZXZpb3VzIGNoZWNrcG9pbnQgc2F2ZSBpbiBwcm9ncmVzcywgd2FpdCBmb3IgaXRcbiAgICAgICAgICAgIC8vIGVuc3VyaW5nIGNoZWNrcG9pbnRlcnMgcmVjZWl2ZSBjaGVja3BvaW50cyBpbiBvcmRlclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9jaGVja3BvaW50ZXJQdXRBZnRlclByZXZpb3VzKHtcbiAgICAgICAgICAgICAgICBjb25maWc6IHsgLi4udGhpcy5jaGVja3BvaW50Q29uZmlnIH0sXG4gICAgICAgICAgICAgICAgY2hlY2twb2ludDogY29weUNoZWNrcG9pbnQodGhpcy5jaGVja3BvaW50KSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogeyAuLi50aGlzLmNoZWNrcG9pbnRNZXRhZGF0YSB9LFxuICAgICAgICAgICAgICAgIG5ld1ZlcnNpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5jaGVja3BvaW50Q29uZmlnLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZToge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmNoZWNrcG9pbnRDb25maWcuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50X2lkOiB0aGlzLmNoZWNrcG9pbnQuaWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGVwICs9IDE7XG4gICAgfVxuICAgIF9tYXRjaFdyaXRlcyh0YXNrcykge1xuICAgICAgICBmb3IgKGNvbnN0IFt0aWQsIGssIHZdIG9mIHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXMpIHtcbiAgICAgICAgICAgIGlmIChrID09PSBFUlJPUiB8fCBrID09PSBJTlRFUlJVUFQgfHwgayA9PT0gUkVTVU1FKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gT2JqZWN0LnZhbHVlcyh0YXNrcykuZmluZCgodCkgPT4gdC5pZCA9PT0gdGlkKTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgdGFzay53cml0ZXMucHVzaChbaywgdl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFzayBvZiBPYmplY3QudmFsdWVzKHRhc2tzKSkge1xuICAgICAgICAgICAgaWYgKHRhc2sud3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXRXcml0ZXModGFzay5pZCwgdGFzay53cml0ZXMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9vcC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/loop.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/messages.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/messages.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StreamMessagesHandler: () => (/* binding */ StreamMessagesHandler)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_callbacks_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/callbacks/base */ \"(rsc)/./node_modules/@langchain/core/callbacks/base.js\");\n/* harmony import */ var _langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n\n\n\nfunction isChatGenerationChunk(x) {\n    return (0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(x?.message);\n}\n/**\n * A callback handler that implements stream_mode=messages.\n * Collects messages from (1) chat model stream events and (2) node outputs.\n */\n// TODO: Make this import and explicitly implement the\n// CallbackHandlerPrefersStreaming interface once we drop support for core 0.2\nclass StreamMessagesHandler extends _langchain_core_callbacks_base__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler {\n    constructor(streamFn) {\n        super();\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"StreamMessagesHandler\"\n        });\n        Object.defineProperty(this, \"streamFn\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadatas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"seen\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"emittedChatModelRunIds\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"stableMessageIdMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"lc_prefer_streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.streamFn = streamFn;\n    }\n    _emit(meta, message, runId, dedupe = false) {\n        if (dedupe &&\n            message.id !== undefined &&\n            this.seen[message.id] !== undefined) {\n            return;\n        }\n        let messageId = message.id;\n        if (runId != null) {\n            if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isToolMessage)(message)) {\n                // Distinguish tool messages by tool call ID.\n                messageId ??= `run-${runId}-tool-${message.tool_call_id}`;\n            }\n            else {\n                // For instance in ChatAnthropic, the first chunk has an message ID\n                // but the subsequent chunks do not. To avoid clients seeing two messages\n                // we rename the message ID if it's being auto-set to `run-${runId}`\n                // (see https://github.com/langchain-ai/langchainjs/pull/6646).\n                if (messageId == null || messageId === `run-${runId}`) {\n                    messageId =\n                        this.stableMessageIdMap[runId] ?? messageId ?? `run-${runId}`;\n                }\n                this.stableMessageIdMap[runId] ??= messageId;\n            }\n        }\n        if (messageId !== message.id) {\n            // eslint-disable-next-line no-param-reassign\n            message.id = messageId;\n            // eslint-disable-next-line no-param-reassign\n            message.lc_kwargs.id = messageId;\n        }\n        if (message.id != null)\n            this.seen[message.id] = message;\n        this.streamFn([meta[0], \"messages\", [message, meta[1]]]);\n    }\n    handleChatModelStart(_llm, _messages, runId, _parentRunId, _extraParams, tags, metadata, name) {\n        if (metadata &&\n            // Include legacy LangGraph SDK tag\n            (!tags || (!tags.includes(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TAG_NOSTREAM) && !tags.includes(\"nostream\")))) {\n            this.metadatas[runId] = [\n                metadata.langgraph_checkpoint_ns.split(\"|\"),\n                { tags, name, ...metadata },\n            ];\n        }\n    }\n    handleLLMNewToken(token, _idx, runId, _parentRunId, _tags, fields) {\n        const chunk = fields?.chunk;\n        this.emittedChatModelRunIds[runId] = true;\n        if (this.metadatas[runId] !== undefined) {\n            if (isChatGenerationChunk(chunk)) {\n                this._emit(this.metadatas[runId], chunk.message, runId);\n            }\n            else {\n                this._emit(this.metadatas[runId], new _langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.AIMessageChunk({ content: token }), runId);\n            }\n        }\n    }\n    handleLLMEnd(output, runId) {\n        // In JS, non-streaming runs do not call handleLLMNewToken at the model level\n        if (!this.emittedChatModelRunIds[runId]) {\n            const chatGeneration = output.generations?.[0]?.[0];\n            if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(chatGeneration?.message)) {\n                this._emit(this.metadatas[runId], chatGeneration?.message, runId, true);\n            }\n            delete this.emittedChatModelRunIds[runId];\n        }\n        delete this.metadatas[runId];\n        delete this.stableMessageIdMap[runId];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    handleLLMError(_err, runId) {\n        delete this.metadatas[runId];\n    }\n    handleChainStart(_chain, inputs, runId, _parentRunId, tags, metadata, _runType, name) {\n        if (metadata !== undefined &&\n            name === metadata.langgraph_node &&\n            (tags === undefined || !tags.includes(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TAG_HIDDEN))) {\n            this.metadatas[runId] = [\n                metadata.langgraph_checkpoint_ns.split(\"|\"),\n                { tags, name, ...metadata },\n            ];\n            if (typeof inputs === \"object\") {\n                for (const value of Object.values(inputs)) {\n                    if (((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(value) || (0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessageChunk)(value)) &&\n                        value.id !== undefined) {\n                        this.seen[value.id] = value;\n                    }\n                    else if (Array.isArray(value)) {\n                        for (const item of value) {\n                            if (((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(item) || (0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessageChunk)(item)) &&\n                                item.id !== undefined) {\n                                this.seen[item.id] = item;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    handleChainEnd(outputs, runId) {\n        const metadata = this.metadatas[runId];\n        delete this.metadatas[runId];\n        if (metadata !== undefined) {\n            if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(outputs)) {\n                this._emit(metadata, outputs, runId, true);\n            }\n            else if (Array.isArray(outputs)) {\n                for (const value of outputs) {\n                    if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(value)) {\n                        this._emit(metadata, value, runId, true);\n                    }\n                }\n            }\n            else if (outputs != null && typeof outputs === \"object\") {\n                for (const value of Object.values(outputs)) {\n                    if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(value)) {\n                        this._emit(metadata, value, runId, true);\n                    }\n                    else if (Array.isArray(value)) {\n                        for (const item of value) {\n                            if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(item)) {\n                                this._emit(metadata, item, runId, true);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    handleChainError(_err, runId) {\n        delete this.metadatas[runId];\n    }\n}\n//# sourceMappingURL=messages.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzRTtBQUN1QztBQUNsRDtBQUMzRDtBQUNBLFdBQVcsdUVBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvQ0FBb0MsK0VBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVFQUFhO0FBQzdCO0FBQ0EscUNBQXFDLE1BQU0sUUFBUSxxQkFBcUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsTUFBTTtBQUNuRjtBQUNBLDhEQUE4RCxNQUFNO0FBQ3BFO0FBQ0EsOEVBQThFLE1BQU07QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1REFBWTtBQUNsRDtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG9FQUFjLEdBQUcsZ0JBQWdCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVFQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscURBQVU7QUFDNUQ7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVFQUFhLFdBQVcsNEVBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUVBQWEsVUFBVSw0RUFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUVBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVFQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVFQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxwcmVnZWxcXG1lc3NhZ2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDYWxsYmFja0hhbmRsZXIsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9jYWxsYmFja3MvYmFzZVwiO1xuaW1wb3J0IHsgQUlNZXNzYWdlQ2h1bmssIGlzQmFzZU1lc3NhZ2UsIGlzQmFzZU1lc3NhZ2VDaHVuaywgaXNUb29sTWVzc2FnZSwgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBUQUdfSElEREVOLCBUQUdfTk9TVFJFQU0gfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5mdW5jdGlvbiBpc0NoYXRHZW5lcmF0aW9uQ2h1bmsoeCkge1xuICAgIHJldHVybiBpc0Jhc2VNZXNzYWdlKHg/Lm1lc3NhZ2UpO1xufVxuLyoqXG4gKiBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBpbXBsZW1lbnRzIHN0cmVhbV9tb2RlPW1lc3NhZ2VzLlxuICogQ29sbGVjdHMgbWVzc2FnZXMgZnJvbSAoMSkgY2hhdCBtb2RlbCBzdHJlYW0gZXZlbnRzIGFuZCAoMikgbm9kZSBvdXRwdXRzLlxuICovXG4vLyBUT0RPOiBNYWtlIHRoaXMgaW1wb3J0IGFuZCBleHBsaWNpdGx5IGltcGxlbWVudCB0aGVcbi8vIENhbGxiYWNrSGFuZGxlclByZWZlcnNTdHJlYW1pbmcgaW50ZXJmYWNlIG9uY2Ugd2UgZHJvcCBzdXBwb3J0IGZvciBjb3JlIDAuMlxuZXhwb3J0IGNsYXNzIFN0cmVhbU1lc3NhZ2VzSGFuZGxlciBleHRlbmRzIEJhc2VDYWxsYmFja0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbUZuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiU3RyZWFtTWVzc2FnZXNIYW5kbGVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbUZuXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlZW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbWl0dGVkQ2hhdE1vZGVsUnVuSWRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhYmxlTWVzc2FnZUlkTWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfcHJlZmVyX3N0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW1GbiA9IHN0cmVhbUZuO1xuICAgIH1cbiAgICBfZW1pdChtZXRhLCBtZXNzYWdlLCBydW5JZCwgZGVkdXBlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRlZHVwZSAmJlxuICAgICAgICAgICAgbWVzc2FnZS5pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLnNlZW5bbWVzc2FnZS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlSWQgPSBtZXNzYWdlLmlkO1xuICAgICAgICBpZiAocnVuSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzVG9vbE1lc3NhZ2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBEaXN0aW5ndWlzaCB0b29sIG1lc3NhZ2VzIGJ5IHRvb2wgY2FsbCBJRC5cbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQgPz89IGBydW4tJHtydW5JZH0tdG9vbC0ke21lc3NhZ2UudG9vbF9jYWxsX2lkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UgaW4gQ2hhdEFudGhyb3BpYywgdGhlIGZpcnN0IGNodW5rIGhhcyBhbiBtZXNzYWdlIElEXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoZSBzdWJzZXF1ZW50IGNodW5rcyBkbyBub3QuIFRvIGF2b2lkIGNsaWVudHMgc2VlaW5nIHR3byBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIC8vIHdlIHJlbmFtZSB0aGUgbWVzc2FnZSBJRCBpZiBpdCdzIGJlaW5nIGF1dG8tc2V0IHRvIGBydW4tJHtydW5JZH1gXG4gICAgICAgICAgICAgICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vbGFuZ2NoYWluLWFpL2xhbmdjaGFpbmpzL3B1bGwvNjY0NikuXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VJZCA9PSBudWxsIHx8IG1lc3NhZ2VJZCA9PT0gYHJ1bi0ke3J1bklkfWApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhYmxlTWVzc2FnZUlkTWFwW3J1bklkXSA/PyBtZXNzYWdlSWQgPz8gYHJ1bi0ke3J1bklkfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhYmxlTWVzc2FnZUlkTWFwW3J1bklkXSA/Pz0gbWVzc2FnZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlSWQgIT09IG1lc3NhZ2UuaWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgbWVzc2FnZS5pZCA9IG1lc3NhZ2VJZDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgbWVzc2FnZS5sY19rd2FyZ3MuaWQgPSBtZXNzYWdlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWQgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2VlblttZXNzYWdlLmlkXSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuc3RyZWFtRm4oW21ldGFbMF0sIFwibWVzc2FnZXNcIiwgW21lc3NhZ2UsIG1ldGFbMV1dXSk7XG4gICAgfVxuICAgIGhhbmRsZUNoYXRNb2RlbFN0YXJ0KF9sbG0sIF9tZXNzYWdlcywgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX2V4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBpZiAobWV0YWRhdGEgJiZcbiAgICAgICAgICAgIC8vIEluY2x1ZGUgbGVnYWN5IExhbmdHcmFwaCBTREsgdGFnXG4gICAgICAgICAgICAoIXRhZ3MgfHwgKCF0YWdzLmluY2x1ZGVzKFRBR19OT1NUUkVBTSkgJiYgIXRhZ3MuaW5jbHVkZXMoXCJub3N0cmVhbVwiKSkpKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhc1tydW5JZF0gPSBbXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEubGFuZ2dyYXBoX2NoZWNrcG9pbnRfbnMuc3BsaXQoXCJ8XCIpLFxuICAgICAgICAgICAgICAgIHsgdGFncywgbmFtZSwgLi4ubWV0YWRhdGEgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlTExNTmV3VG9rZW4odG9rZW4sIF9pZHgsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBmaWVsZHM/LmNodW5rO1xuICAgICAgICB0aGlzLmVtaXR0ZWRDaGF0TW9kZWxSdW5JZHNbcnVuSWRdID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGFzW3J1bklkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNDaGF0R2VuZXJhdGlvbkNodW5rKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQodGhpcy5tZXRhZGF0YXNbcnVuSWRdLCBjaHVuay5tZXNzYWdlLCBydW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KHRoaXMubWV0YWRhdGFzW3J1bklkXSwgbmV3IEFJTWVzc2FnZUNodW5rKHsgY29udGVudDogdG9rZW4gfSksIHJ1bklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVMTE1FbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICAvLyBJbiBKUywgbm9uLXN0cmVhbWluZyBydW5zIGRvIG5vdCBjYWxsIGhhbmRsZUxMTU5ld1Rva2VuIGF0IHRoZSBtb2RlbCBsZXZlbFxuICAgICAgICBpZiAoIXRoaXMuZW1pdHRlZENoYXRNb2RlbFJ1bklkc1tydW5JZF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXRHZW5lcmF0aW9uID0gb3V0cHV0LmdlbmVyYXRpb25zPy5bMF0/LlswXTtcbiAgICAgICAgICAgIGlmIChpc0Jhc2VNZXNzYWdlKGNoYXRHZW5lcmF0aW9uPy5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQodGhpcy5tZXRhZGF0YXNbcnVuSWRdLCBjaGF0R2VuZXJhdGlvbj8ubWVzc2FnZSwgcnVuSWQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZW1pdHRlZENoYXRNb2RlbFJ1bklkc1tydW5JZF07XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMubWV0YWRhdGFzW3J1bklkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RhYmxlTWVzc2FnZUlkTWFwW3J1bklkXTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBoYW5kbGVMTE1FcnJvcihfZXJyLCBydW5JZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5tZXRhZGF0YXNbcnVuSWRdO1xuICAgIH1cbiAgICBoYW5kbGVDaGFpblN0YXJ0KF9jaGFpbiwgaW5wdXRzLCBydW5JZCwgX3BhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgX3J1blR5cGUsIG5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIG5hbWUgPT09IG1ldGFkYXRhLmxhbmdncmFwaF9ub2RlICYmXG4gICAgICAgICAgICAodGFncyA9PT0gdW5kZWZpbmVkIHx8ICF0YWdzLmluY2x1ZGVzKFRBR19ISURERU4pKSkge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YXNbcnVuSWRdID0gW1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmxhbmdncmFwaF9jaGVja3BvaW50X25zLnNwbGl0KFwifFwiKSxcbiAgICAgICAgICAgICAgICB7IHRhZ3MsIG5hbWUsIC4uLm1ldGFkYXRhIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIE9iamVjdC52YWx1ZXMoaW5wdXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGlzQmFzZU1lc3NhZ2UodmFsdWUpIHx8IGlzQmFzZU1lc3NhZ2VDaHVuayh2YWx1ZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlZW5bdmFsdWUuaWRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXNCYXNlTWVzc2FnZShpdGVtKSB8fCBpc0Jhc2VNZXNzYWdlQ2h1bmsoaXRlbSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlZW5baXRlbS5pZF0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGFpbkVuZChvdXRwdXRzLCBydW5JZCkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFzW3J1bklkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMubWV0YWRhdGFzW3J1bklkXTtcbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0Jhc2VNZXNzYWdlKG91dHB1dHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdChtZXRhZGF0YSwgb3V0cHV0cywgcnVuSWQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXRzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygb3V0cHV0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYXNlTWVzc2FnZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQobWV0YWRhdGEsIHZhbHVlLCBydW5JZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdXRwdXRzICE9IG51bGwgJiYgdHlwZW9mIG91dHB1dHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIE9iamVjdC52YWx1ZXMob3V0cHV0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmFzZU1lc3NhZ2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KG1ldGFkYXRhLCB2YWx1ZSwgcnVuSWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYXNlTWVzc2FnZShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KG1ldGFkYXRhLCBpdGVtLCBydW5JZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaGFuZGxlQ2hhaW5FcnJvcihfZXJyLCBydW5JZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5tZXRhZGF0YXNbcnVuSWRdO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/read.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/read.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelRead: () => (/* binding */ ChannelRead),\n/* harmony export */   PregelNode: () => (/* binding */ PregelNode)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _write_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./write.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/write.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/utils.js\");\n\n\n\n\nclass ChannelRead extends _utils_js__WEBPACK_IMPORTED_MODULE_3__.RunnableCallable {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(channel, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    mapper, fresh = false) {\n        super({\n            func: (_, config) => ChannelRead.doRead(config, this.channel, this.fresh, this.mapper),\n        });\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"ChannelRead\"\n        });\n        Object.defineProperty(this, \"channel\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fresh\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.fresh = fresh;\n        this.mapper = mapper;\n        this.channel = channel;\n        this.name = Array.isArray(channel)\n            ? `ChannelRead<${channel.join(\",\")}>`\n            : `ChannelRead<${channel}>`;\n    }\n    static doRead(config, channel, fresh, mapper) {\n        const read = config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONFIG_KEY_READ];\n        if (!read) {\n            throw new Error(\"Runnable is not configured with a read function. Make sure to call in the context of a Pregel process\");\n        }\n        if (mapper) {\n            return mapper(read(channel, fresh));\n        }\n        else {\n            return read(channel, fresh);\n        }\n    }\n}\nconst defaultRunnableBound = \n/* #__PURE__ */ new _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnablePassthrough();\nclass PregelNode extends _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnableBinding {\n    constructor(fields) {\n        const { channels, triggers, mapper, writers, bound, kwargs, metadata, retryPolicy, tags, subgraphs, ends, } = fields;\n        const mergedTags = [\n            ...(fields.config?.tags ? fields.config.tags : []),\n            ...(tags ?? []),\n        ];\n        super({\n            ...fields,\n            bound: fields.bound ??\n                defaultRunnableBound,\n            config: {\n                ...(fields.config ? fields.config : {}),\n                tags: mergedTags,\n            },\n        });\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PregelNode\"\n        });\n        Object.defineProperty(this, \"channels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"triggers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: defaultRunnableBound\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"retryPolicy\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"subgraphs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ends\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.channels = channels;\n        this.triggers = triggers;\n        this.mapper = mapper;\n        this.writers = writers ?? this.writers;\n        this.bound = bound ?? this.bound;\n        this.kwargs = kwargs ?? this.kwargs;\n        this.metadata = metadata ?? this.metadata;\n        this.tags = mergedTags;\n        this.retryPolicy = retryPolicy;\n        this.subgraphs = subgraphs;\n        this.ends = ends;\n    }\n    getWriters() {\n        const newWriters = [...this.writers];\n        while (newWriters.length > 1 &&\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            newWriters[newWriters.length - 1] instanceof _write_js__WEBPACK_IMPORTED_MODULE_2__.ChannelWrite &&\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            newWriters[newWriters.length - 2] instanceof _write_js__WEBPACK_IMPORTED_MODULE_2__.ChannelWrite) {\n            // we can combine writes if they are consecutive\n            // careful to not modify the original writers list or ChannelWrite\n            const endWriters = newWriters.slice(-2);\n            const combinedWrites = endWriters[0].writes.concat(endWriters[1].writes);\n            newWriters[newWriters.length - 2] = new _write_js__WEBPACK_IMPORTED_MODULE_2__.ChannelWrite(combinedWrites, endWriters[0].config?.tags);\n            newWriters.pop();\n        }\n        return newWriters;\n    }\n    getNode() {\n        const writers = this.getWriters();\n        if (this.bound === defaultRunnableBound && writers.length === 0) {\n            return undefined;\n        }\n        else if (this.bound === defaultRunnableBound && writers.length === 1) {\n            return writers[0];\n        }\n        else if (this.bound === defaultRunnableBound) {\n            return new _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnableSequence({\n                first: writers[0],\n                middle: writers.slice(1, writers.length - 1),\n                last: writers[writers.length - 1],\n                omitSequenceTags: true,\n            });\n        }\n        else if (writers.length > 0) {\n            return new _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnableSequence({\n                first: this.bound,\n                middle: writers.slice(0, writers.length - 1),\n                last: writers[writers.length - 1],\n                omitSequenceTags: true,\n            });\n        }\n        else {\n            return this.bound;\n        }\n    }\n    join(channels) {\n        if (!Array.isArray(channels)) {\n            throw new Error(\"channels must be a list\");\n        }\n        if (typeof this.channels !== \"object\") {\n            throw new Error(\"all channels must be named when using .join()\");\n        }\n        return new PregelNode({\n            channels: {\n                ...this.channels,\n                ...Object.fromEntries(channels.map((chan) => [chan, chan])),\n            },\n            triggers: this.triggers,\n            mapper: this.mapper,\n            writers: this.writers,\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            retryPolicy: this.retryPolicy,\n        });\n    }\n    pipe(coerceable) {\n        if (_write_js__WEBPACK_IMPORTED_MODULE_2__.ChannelWrite.isWriter(coerceable)) {\n            return new PregelNode({\n                channels: this.channels,\n                triggers: this.triggers,\n                mapper: this.mapper,\n                writers: [...this.writers, coerceable],\n                bound: this.bound,\n                config: this.config,\n                kwargs: this.kwargs,\n                retryPolicy: this.retryPolicy,\n            });\n        }\n        else if (this.bound === defaultRunnableBound) {\n            return new PregelNode({\n                channels: this.channels,\n                triggers: this.triggers,\n                mapper: this.mapper,\n                writers: this.writers,\n                bound: (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(coerceable),\n                config: this.config,\n                kwargs: this.kwargs,\n                retryPolicy: this.retryPolicy,\n            });\n        }\n        else {\n            return new PregelNode({\n                channels: this.channels,\n                triggers: this.triggers,\n                mapper: this.mapper,\n                writers: this.writers,\n                bound: this.bound.pipe(coerceable),\n                config: this.config,\n                kwargs: this.kwargs,\n                retryPolicy: this.retryPolicy,\n            });\n        }\n    }\n}\n//# sourceMappingURL=read.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvcmVhZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBdUg7QUFDckU7QUFDUjtBQUNLO0FBQ3hDLDBCQUEwQix1REFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0MsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBLDJDQUEyQywwREFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEVBQW1CO0FBQ2hDLHlCQUF5QixzRUFBZTtBQUMvQztBQUNBLGdCQUFnQixvR0FBb0c7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsbURBQVk7QUFDckU7QUFDQSx5REFBeUQsbURBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsbURBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1QkFBdUIsdUVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZLG1EQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0RUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxwcmVnZWxcXHJlYWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUnVubmFibGVCaW5kaW5nLCBSdW5uYWJsZVBhc3N0aHJvdWdoLCBSdW5uYWJsZVNlcXVlbmNlLCBfY29lcmNlVG9SdW5uYWJsZSwgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuaW1wb3J0IHsgQ09ORklHX0tFWV9SRUFEIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgQ2hhbm5lbFdyaXRlIH0gZnJvbSBcIi4vd3JpdGUuanNcIjtcbmltcG9ydCB7IFJ1bm5hYmxlQ2FsbGFibGUgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmV4cG9ydCBjbGFzcyBDaGFubmVsUmVhZCBleHRlbmRzIFJ1bm5hYmxlQ2FsbGFibGUge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBtYXBwZXIsIGZyZXNoID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZnVuYzogKF8sIGNvbmZpZykgPT4gQ2hhbm5lbFJlYWQuZG9SZWFkKGNvbmZpZywgdGhpcy5jaGFubmVsLCB0aGlzLmZyZXNoLCB0aGlzLm1hcHBlciksXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19ncmFwaF9uYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIkNoYW5uZWxSZWFkXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnJlc2hcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXBwZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mcmVzaCA9IGZyZXNoO1xuICAgICAgICB0aGlzLm1hcHBlciA9IG1hcHBlcjtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5uYW1lID0gQXJyYXkuaXNBcnJheShjaGFubmVsKVxuICAgICAgICAgICAgPyBgQ2hhbm5lbFJlYWQ8JHtjaGFubmVsLmpvaW4oXCIsXCIpfT5gXG4gICAgICAgICAgICA6IGBDaGFubmVsUmVhZDwke2NoYW5uZWx9PmA7XG4gICAgfVxuICAgIHN0YXRpYyBkb1JlYWQoY29uZmlnLCBjaGFubmVsLCBmcmVzaCwgbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IHJlYWQgPSBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9SRUFEXTtcbiAgICAgICAgaWYgKCFyZWFkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uYWJsZSBpcyBub3QgY29uZmlndXJlZCB3aXRoIGEgcmVhZCBmdW5jdGlvbi4gTWFrZSBzdXJlIHRvIGNhbGwgaW4gdGhlIGNvbnRleHQgb2YgYSBQcmVnZWwgcHJvY2Vzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwcGVyKHJlYWQoY2hhbm5lbCwgZnJlc2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkKGNoYW5uZWwsIGZyZXNoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRSdW5uYWJsZUJvdW5kID0gXG4vKiAjX19QVVJFX18gKi8gbmV3IFJ1bm5hYmxlUGFzc3Rocm91Z2goKTtcbmV4cG9ydCBjbGFzcyBQcmVnZWxOb2RlIGV4dGVuZHMgUnVubmFibGVCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgeyBjaGFubmVscywgdHJpZ2dlcnMsIG1hcHBlciwgd3JpdGVycywgYm91bmQsIGt3YXJncywgbWV0YWRhdGEsIHJldHJ5UG9saWN5LCB0YWdzLCBzdWJncmFwaHMsIGVuZHMsIH0gPSBmaWVsZHM7XG4gICAgICAgIGNvbnN0IG1lcmdlZFRhZ3MgPSBbXG4gICAgICAgICAgICAuLi4oZmllbGRzLmNvbmZpZz8udGFncyA/IGZpZWxkcy5jb25maWcudGFncyA6IFtdKSxcbiAgICAgICAgICAgIC4uLih0YWdzID8/IFtdKSxcbiAgICAgICAgXTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgYm91bmQ6IGZpZWxkcy5ib3VuZCA/P1xuICAgICAgICAgICAgICAgIGRlZmF1bHRSdW5uYWJsZUJvdW5kLFxuICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgICAgLi4uKGZpZWxkcy5jb25maWcgPyBmaWVsZHMuY29uZmlnIDoge30pLFxuICAgICAgICAgICAgICAgIHRhZ3M6IG1lcmdlZFRhZ3MsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZ3JhcGhfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJQcmVnZWxOb2RlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyaWdnZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWFwcGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndyaXRlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJib3VuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZGVmYXVsdFJ1bm5hYmxlQm91bmRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImt3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJldHJ5UG9saWN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN1YmdyYXBoc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBjaGFubmVscztcbiAgICAgICAgdGhpcy50cmlnZ2VycyA9IHRyaWdnZXJzO1xuICAgICAgICB0aGlzLm1hcHBlciA9IG1hcHBlcjtcbiAgICAgICAgdGhpcy53cml0ZXJzID0gd3JpdGVycyA/PyB0aGlzLndyaXRlcnM7XG4gICAgICAgIHRoaXMuYm91bmQgPSBib3VuZCA/PyB0aGlzLmJvdW5kO1xuICAgICAgICB0aGlzLmt3YXJncyA9IGt3YXJncyA/PyB0aGlzLmt3YXJncztcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhID8/IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIHRoaXMudGFncyA9IG1lcmdlZFRhZ3M7XG4gICAgICAgIHRoaXMucmV0cnlQb2xpY3kgPSByZXRyeVBvbGljeTtcbiAgICAgICAgdGhpcy5zdWJncmFwaHMgPSBzdWJncmFwaHM7XG4gICAgICAgIHRoaXMuZW5kcyA9IGVuZHM7XG4gICAgfVxuICAgIGdldFdyaXRlcnMoKSB7XG4gICAgICAgIGNvbnN0IG5ld1dyaXRlcnMgPSBbLi4udGhpcy53cml0ZXJzXTtcbiAgICAgICAgd2hpbGUgKG5ld1dyaXRlcnMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgbmV3V3JpdGVyc1tuZXdXcml0ZXJzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgQ2hhbm5lbFdyaXRlICYmXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBuZXdXcml0ZXJzW25ld1dyaXRlcnMubGVuZ3RoIC0gMl0gaW5zdGFuY2VvZiBDaGFubmVsV3JpdGUpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjb21iaW5lIHdyaXRlcyBpZiB0aGV5IGFyZSBjb25zZWN1dGl2ZVxuICAgICAgICAgICAgLy8gY2FyZWZ1bCB0byBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCB3cml0ZXJzIGxpc3Qgb3IgQ2hhbm5lbFdyaXRlXG4gICAgICAgICAgICBjb25zdCBlbmRXcml0ZXJzID0gbmV3V3JpdGVycy5zbGljZSgtMik7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFdyaXRlcyA9IGVuZFdyaXRlcnNbMF0ud3JpdGVzLmNvbmNhdChlbmRXcml0ZXJzWzFdLndyaXRlcyk7XG4gICAgICAgICAgICBuZXdXcml0ZXJzW25ld1dyaXRlcnMubGVuZ3RoIC0gMl0gPSBuZXcgQ2hhbm5lbFdyaXRlKGNvbWJpbmVkV3JpdGVzLCBlbmRXcml0ZXJzWzBdLmNvbmZpZz8udGFncyk7XG4gICAgICAgICAgICBuZXdXcml0ZXJzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdXcml0ZXJzO1xuICAgIH1cbiAgICBnZXROb2RlKCkge1xuICAgICAgICBjb25zdCB3cml0ZXJzID0gdGhpcy5nZXRXcml0ZXJzKCk7XG4gICAgICAgIGlmICh0aGlzLmJvdW5kID09PSBkZWZhdWx0UnVubmFibGVCb3VuZCAmJiB3cml0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmJvdW5kID09PSBkZWZhdWx0UnVubmFibGVCb3VuZCAmJiB3cml0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ib3VuZCA9PT0gZGVmYXVsdFJ1bm5hYmxlQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IHdyaXRlcnNbMF0sXG4gICAgICAgICAgICAgICAgbWlkZGxlOiB3cml0ZXJzLnNsaWNlKDEsIHdyaXRlcnMubGVuZ3RoIC0gMSksXG4gICAgICAgICAgICAgICAgbGFzdDogd3JpdGVyc1t3cml0ZXJzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIG9taXRTZXF1ZW5jZVRhZ3M6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3cml0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IHRoaXMuYm91bmQsXG4gICAgICAgICAgICAgICAgbWlkZGxlOiB3cml0ZXJzLnNsaWNlKDAsIHdyaXRlcnMubGVuZ3RoIC0gMSksXG4gICAgICAgICAgICAgICAgbGFzdDogd3JpdGVyc1t3cml0ZXJzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIG9taXRTZXF1ZW5jZVRhZ3M6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGpvaW4oY2hhbm5lbHMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNoYW5uZWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbHMgbXVzdCBiZSBhIGxpc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNoYW5uZWxzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbGwgY2hhbm5lbHMgbXVzdCBiZSBuYW1lZCB3aGVuIHVzaW5nIC5qb2luKClcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcmVnZWxOb2RlKHtcbiAgICAgICAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5jaGFubmVscyxcbiAgICAgICAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoY2hhbm5lbHMubWFwKChjaGFuKSA9PiBbY2hhbiwgY2hhbl0pKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmlnZ2VyczogdGhpcy50cmlnZ2VycyxcbiAgICAgICAgICAgIG1hcHBlcjogdGhpcy5tYXBwZXIsXG4gICAgICAgICAgICB3cml0ZXJzOiB0aGlzLndyaXRlcnMsXG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgcmV0cnlQb2xpY3k6IHRoaXMucmV0cnlQb2xpY3ksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaXBlKGNvZXJjZWFibGUpIHtcbiAgICAgICAgaWYgKENoYW5uZWxXcml0ZS5pc1dyaXRlcihjb2VyY2VhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVnZWxOb2RlKHtcbiAgICAgICAgICAgICAgICBjaGFubmVsczogdGhpcy5jaGFubmVscyxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyczogdGhpcy50cmlnZ2VycyxcbiAgICAgICAgICAgICAgICBtYXBwZXI6IHRoaXMubWFwcGVyLFxuICAgICAgICAgICAgICAgIHdyaXRlcnM6IFsuLi50aGlzLndyaXRlcnMsIGNvZXJjZWFibGVdLFxuICAgICAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgICAgICByZXRyeVBvbGljeTogdGhpcy5yZXRyeVBvbGljeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYm91bmQgPT09IGRlZmF1bHRSdW5uYWJsZUJvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByZWdlbE5vZGUoe1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzOiB0aGlzLmNoYW5uZWxzLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJzOiB0aGlzLnRyaWdnZXJzLFxuICAgICAgICAgICAgICAgIG1hcHBlcjogdGhpcy5tYXBwZXIsXG4gICAgICAgICAgICAgICAgd3JpdGVyczogdGhpcy53cml0ZXJzLFxuICAgICAgICAgICAgICAgIGJvdW5kOiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICAgICAgcmV0cnlQb2xpY3k6IHRoaXMucmV0cnlQb2xpY3ksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJlZ2VsTm9kZSh7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHM6IHRoaXMuY2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcnM6IHRoaXMudHJpZ2dlcnMsXG4gICAgICAgICAgICAgICAgbWFwcGVyOiB0aGlzLm1hcHBlcixcbiAgICAgICAgICAgICAgICB3cml0ZXJzOiB0aGlzLndyaXRlcnMsXG4gICAgICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQucGlwZShjb2VyY2VhYmxlKSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICAgICAgcmV0cnlQb2xpY3k6IHRoaXMucmV0cnlQb2xpY3ksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/read.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/retry.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/retry.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_BACKOFF_FACTOR: () => (/* binding */ DEFAULT_BACKOFF_FACTOR),\n/* harmony export */   DEFAULT_INITIAL_INTERVAL: () => (/* binding */ DEFAULT_INITIAL_INTERVAL),\n/* harmony export */   DEFAULT_MAX_INTERVAL: () => (/* binding */ DEFAULT_MAX_INTERVAL),\n/* harmony export */   DEFAULT_MAX_RETRIES: () => (/* binding */ DEFAULT_MAX_RETRIES),\n/* harmony export */   _runWithRetry: () => (/* binding */ _runWithRetry)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _utils_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/config.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/config.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/index.js\");\n\n\n\n\nconst DEFAULT_INITIAL_INTERVAL = 500;\nconst DEFAULT_BACKOFF_FACTOR = 2;\nconst DEFAULT_MAX_INTERVAL = 128000;\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    402, // Payment Required\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst DEFAULT_RETRY_ON_HANDLER = (error) => {\n    if (error.message.startsWith(\"Cancel\") ||\n        error.message.startsWith(\"AbortError\") ||\n        error.name === \"AbortError\") {\n        return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.code === \"ECONNABORTED\") {\n        return false;\n    }\n    const status = \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error?.response?.status ?? error?.status;\n    if (status && DEFAULT_STATUS_NO_RETRY.includes(+status)) {\n        return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.error?.code === \"insufficient_quota\") {\n        return false;\n    }\n    return true;\n};\nasync function _runWithRetry(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\npregelTask, retryPolicy, configurable, signal) {\n    const resolvedRetryPolicy = pregelTask.retry_policy ?? retryPolicy;\n    let interval = resolvedRetryPolicy !== undefined\n        ? resolvedRetryPolicy.initialInterval ?? DEFAULT_INITIAL_INTERVAL\n        : 0;\n    let attempts = 0;\n    let error;\n    let result;\n    let { config } = pregelTask;\n    if (configurable) {\n        config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.patchConfigurable)(config, configurable);\n    }\n    config = {\n        ...config,\n        signal,\n    };\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (signal?.aborted) {\n            // no need to throw here - we'll throw from the runner, instead.\n            // there's just no point in retrying if the user has requested an abort.\n            break;\n        }\n        // Clear any writes from previous attempts\n        pregelTask.writes.splice(0, pregelTask.writes.length);\n        error = undefined;\n        try {\n            result = await pregelTask.proc.invoke(pregelTask.input, config);\n            break;\n        }\n        catch (e) {\n            error = e;\n            error.pregelTaskId = pregelTask.id;\n            if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.isParentCommand)(error)) {\n                const ns = config?.configurable?.checkpoint_ns;\n                const cmd = error.command;\n                if (cmd.graph === ns) {\n                    // this command is for the current graph, handle it\n                    for (const writer of pregelTask.writers) {\n                        await writer.invoke(cmd, config);\n                    }\n                    error = undefined;\n                    break;\n                }\n                else if (cmd.graph === _constants_js__WEBPACK_IMPORTED_MODULE_0__.Command.PARENT) {\n                    // this command is for the parent graph, assign it to the parent\n                    const parentNs = (0,_utils_config_js__WEBPACK_IMPORTED_MODULE_2__.getParentCheckpointNamespace)(ns);\n                    error.command = new _constants_js__WEBPACK_IMPORTED_MODULE_0__.Command({\n                        ...error.command,\n                        graph: parentNs,\n                    });\n                }\n            }\n            if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.isGraphBubbleUp)(error)) {\n                break;\n            }\n            if (resolvedRetryPolicy === undefined) {\n                break;\n            }\n            attempts += 1;\n            // check if we should give up\n            if (attempts >= (resolvedRetryPolicy.maxAttempts ?? DEFAULT_MAX_RETRIES)) {\n                break;\n            }\n            const retryOn = resolvedRetryPolicy.retryOn ?? DEFAULT_RETRY_ON_HANDLER;\n            if (!retryOn(error)) {\n                break;\n            }\n            interval = Math.min(resolvedRetryPolicy.maxInterval ?? DEFAULT_MAX_INTERVAL, interval * (resolvedRetryPolicy.backoffFactor ?? DEFAULT_BACKOFF_FACTOR));\n            const intervalWithJitter = resolvedRetryPolicy.jitter\n                ? Math.floor(interval + Math.random() * 1000)\n                : interval;\n            // sleep before retrying\n            // eslint-disable-next-line no-promise-executor-return\n            await new Promise((resolve) => setTimeout(resolve, intervalWithJitter));\n            // log the retry\n            const errorName = error.name ??\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                error.constructor.unminifiable_name ??\n                error.constructor.name;\n            if (resolvedRetryPolicy?.logWarning ?? true) {\n                console.log(`Retrying task \"${String(pregelTask.name)}\" after ${interval.toFixed(2)}ms (attempt ${attempts}) after ${errorName}: ${error}`);\n            }\n            // signal subgraphs to resume (if available)\n            config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.patchConfigurable)(config, { [_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONFIG_KEY_RESUMING]: true });\n        }\n    }\n    return {\n        task: pregelTask,\n        result,\n        error: error,\n        signalAborted: signal?.aborted,\n    };\n}\n//# sourceMappingURL=retry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvcmV0cnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQStEO0FBQ0M7QUFDQztBQUNaO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBLGlCQUFpQixrRUFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQU87QUFDOUM7QUFDQSxxQ0FBcUMsOEVBQTRCO0FBQ2pFLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdCQUF3QixVQUFVLG9CQUFvQixjQUFjLFNBQVMsVUFBVSxVQUFVLElBQUksTUFBTTtBQUN6SjtBQUNBO0FBQ0EscUJBQXFCLGtFQUFpQixXQUFXLENBQUMsOERBQW1CLFNBQVM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxwcmVnZWxcXHJldHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1hbmQsIENPTkZJR19LRVlfUkVTVU1JTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBpc0dyYXBoQnViYmxlVXAsIGlzUGFyZW50Q29tbWFuZCB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGdldFBhcmVudENoZWNrcG9pbnROYW1lc3BhY2UgfSBmcm9tIFwiLi91dGlscy9jb25maWcuanNcIjtcbmltcG9ydCB7IHBhdGNoQ29uZmlndXJhYmxlIH0gZnJvbSBcIi4vdXRpbHMvaW5kZXguanNcIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0lOSVRJQUxfSU5URVJWQUwgPSA1MDA7XG5leHBvcnQgY29uc3QgREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiA9IDI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfSU5URVJWQUwgPSAxMjgwMDA7XG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfUkVUUklFUyA9IDM7XG5jb25zdCBERUZBVUxUX1NUQVRVU19OT19SRVRSWSA9IFtcbiAgICA0MDAsIC8vIEJhZCBSZXF1ZXN0XG4gICAgNDAxLCAvLyBVbmF1dGhvcml6ZWRcbiAgICA0MDIsIC8vIFBheW1lbnQgUmVxdWlyZWRcbiAgICA0MDMsIC8vIEZvcmJpZGRlblxuICAgIDQwNCwgLy8gTm90IEZvdW5kXG4gICAgNDA1LCAvLyBNZXRob2QgTm90IEFsbG93ZWRcbiAgICA0MDYsIC8vIE5vdCBBY2NlcHRhYmxlXG4gICAgNDA3LCAvLyBQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFxuICAgIDQwOSwgLy8gQ29uZmxpY3Rcbl07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgREVGQVVMVF9SRVRSWV9PTl9IQU5ETEVSID0gKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkNhbmNlbFwiKSB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJBYm9ydEVycm9yXCIpIHx8XG4gICAgICAgIGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAoZXJyb3I/LmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVycm9yPy5yZXNwb25zZT8uc3RhdHVzID8/IGVycm9yPy5zdGF0dXM7XG4gICAgaWYgKHN0YXR1cyAmJiBERUZBVUxUX1NUQVRVU19OT19SRVRSWS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGVycm9yPy5lcnJvcj8uY29kZSA9PT0gXCJpbnN1ZmZpY2llbnRfcXVvdGFcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcnVuV2l0aFJldHJ5KFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnByZWdlbFRhc2ssIHJldHJ5UG9saWN5LCBjb25maWd1cmFibGUsIHNpZ25hbCkge1xuICAgIGNvbnN0IHJlc29sdmVkUmV0cnlQb2xpY3kgPSBwcmVnZWxUYXNrLnJldHJ5X3BvbGljeSA/PyByZXRyeVBvbGljeTtcbiAgICBsZXQgaW50ZXJ2YWwgPSByZXNvbHZlZFJldHJ5UG9saWN5ICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyByZXNvbHZlZFJldHJ5UG9saWN5LmluaXRpYWxJbnRlcnZhbCA/PyBERUZBVUxUX0lOSVRJQUxfSU5URVJWQUxcbiAgICAgICAgOiAwO1xuICAgIGxldCBhdHRlbXB0cyA9IDA7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IHsgY29uZmlnIH0gPSBwcmVnZWxUYXNrO1xuICAgIGlmIChjb25maWd1cmFibGUpIHtcbiAgICAgICAgY29uZmlnID0gcGF0Y2hDb25maWd1cmFibGUoY29uZmlnLCBjb25maWd1cmFibGUpO1xuICAgIH1cbiAgICBjb25maWcgPSB7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgc2lnbmFsLFxuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdGhyb3cgaGVyZSAtIHdlJ2xsIHRocm93IGZyb20gdGhlIHJ1bm5lciwgaW5zdGVhZC5cbiAgICAgICAgICAgIC8vIHRoZXJlJ3MganVzdCBubyBwb2ludCBpbiByZXRyeWluZyBpZiB0aGUgdXNlciBoYXMgcmVxdWVzdGVkIGFuIGFib3J0LlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgYW55IHdyaXRlcyBmcm9tIHByZXZpb3VzIGF0dGVtcHRzXG4gICAgICAgIHByZWdlbFRhc2sud3JpdGVzLnNwbGljZSgwLCBwcmVnZWxUYXNrLndyaXRlcy5sZW5ndGgpO1xuICAgICAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHByZWdlbFRhc2sucHJvYy5pbnZva2UocHJlZ2VsVGFzay5pbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICBlcnJvci5wcmVnZWxUYXNrSWQgPSBwcmVnZWxUYXNrLmlkO1xuICAgICAgICAgICAgaWYgKGlzUGFyZW50Q29tbWFuZChlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBucyA9IGNvbmZpZz8uY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNtZCA9IGVycm9yLmNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgaWYgKGNtZC5ncmFwaCA9PT0gbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb21tYW5kIGlzIGZvciB0aGUgY3VycmVudCBncmFwaCwgaGFuZGxlIGl0XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgd3JpdGVyIG9mIHByZWdlbFRhc2sud3JpdGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVyLmludm9rZShjbWQsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbWQuZ3JhcGggPT09IENvbW1hbmQuUEFSRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29tbWFuZCBpcyBmb3IgdGhlIHBhcmVudCBncmFwaCwgYXNzaWduIGl0IHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50TnMgPSBnZXRQYXJlbnRDaGVja3BvaW50TmFtZXNwYWNlKG5zKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29tbWFuZCA9IG5ldyBDb21tYW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmVycm9yLmNvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaDogcGFyZW50TnMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0dyYXBoQnViYmxlVXAoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRSZXRyeVBvbGljeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRlbXB0cyArPSAxO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2Ugc2hvdWxkIGdpdmUgdXBcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+PSAocmVzb2x2ZWRSZXRyeVBvbGljeS5tYXhBdHRlbXB0cyA/PyBERUZBVUxUX01BWF9SRVRSSUVTKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmV0cnlPbiA9IHJlc29sdmVkUmV0cnlQb2xpY3kucmV0cnlPbiA/PyBERUZBVUxUX1JFVFJZX09OX0hBTkRMRVI7XG4gICAgICAgICAgICBpZiAoIXJldHJ5T24oZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcnZhbCA9IE1hdGgubWluKHJlc29sdmVkUmV0cnlQb2xpY3kubWF4SW50ZXJ2YWwgPz8gREVGQVVMVF9NQVhfSU5URVJWQUwsIGludGVydmFsICogKHJlc29sdmVkUmV0cnlQb2xpY3kuYmFja29mZkZhY3RvciA/PyBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SKSk7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbFdpdGhKaXR0ZXIgPSByZXNvbHZlZFJldHJ5UG9saWN5LmppdHRlclxuICAgICAgICAgICAgICAgID8gTWF0aC5mbG9vcihpbnRlcnZhbCArIE1hdGgucmFuZG9tKCkgKiAxMDAwKVxuICAgICAgICAgICAgICAgIDogaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyBzbGVlcCBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9taXNlLWV4ZWN1dG9yLXJldHVyblxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWxXaXRoSml0dGVyKSk7XG4gICAgICAgICAgICAvLyBsb2cgdGhlIHJldHJ5XG4gICAgICAgICAgICBjb25zdCBlcnJvck5hbWUgPSBlcnJvci5uYW1lID8/XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBlcnJvci5jb25zdHJ1Y3Rvci51bm1pbmlmaWFibGVfbmFtZSA/P1xuICAgICAgICAgICAgICAgIGVycm9yLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRSZXRyeVBvbGljeT8ubG9nV2FybmluZyA/PyB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJldHJ5aW5nIHRhc2sgXCIke1N0cmluZyhwcmVnZWxUYXNrLm5hbWUpfVwiIGFmdGVyICR7aW50ZXJ2YWwudG9GaXhlZCgyKX1tcyAoYXR0ZW1wdCAke2F0dGVtcHRzfSkgYWZ0ZXIgJHtlcnJvck5hbWV9OiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2lnbmFsIHN1YmdyYXBocyB0byByZXN1bWUgKGlmIGF2YWlsYWJsZSlcbiAgICAgICAgICAgIGNvbmZpZyA9IHBhdGNoQ29uZmlndXJhYmxlKGNvbmZpZywgeyBbQ09ORklHX0tFWV9SRVNVTUlOR106IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFzazogcHJlZ2VsVGFzayxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIHNpZ25hbEFib3J0ZWQ6IHNpZ25hbD8uYWJvcnRlZCxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/retry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/runner.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/runner.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PregelRunner: () => (/* binding */ PregelRunner)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/types.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _retry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./retry.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/retry.js\");\n\n\n\n\n\nconst PROMISE_ADDED_SYMBOL = Symbol.for(\"promiseAdded\");\nfunction createPromiseBarrier() {\n    const barrier = {\n        next: () => void 0,\n        wait: Promise.resolve(PROMISE_ADDED_SYMBOL),\n    };\n    function waitHandler(resolve) {\n        barrier.next = () => {\n            barrier.wait = new Promise(waitHandler);\n            resolve(PROMISE_ADDED_SYMBOL);\n        };\n    }\n    barrier.wait = new Promise(waitHandler);\n    return barrier;\n}\n/**\n * Responsible for handling task execution on each tick of the {@link PregelLoop}.\n */\nclass PregelRunner {\n    /**\n     * Construct a new PregelRunner, which executes tasks from the provided PregelLoop.\n     * @param loop - The PregelLoop that produces tasks for this runner to execute.\n     */\n    constructor({ loop, nodeFinished, }) {\n        Object.defineProperty(this, \"nodeFinished\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"loop\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.loop = loop;\n        this.nodeFinished = nodeFinished;\n    }\n    /**\n     * Execute tasks from the current step of the PregelLoop.\n     *\n     * Note: this method does NOT call {@link PregelLoop}#tick. That must be handled externally.\n     * @param options - Options for the execution.\n     */\n    async tick(options = {}) {\n        const { timeout, retryPolicy, onStepWrite, maxConcurrency } = options;\n        const nodeErrors = new Set();\n        let graphBubbleUp;\n        const exceptionSignalController = new AbortController();\n        // Start task execution\n        const pendingTasks = Object.values(this.loop.tasks).filter((t) => t.writes.length === 0);\n        const currentSignals = this._initializeAbortSignals({\n            exceptionSignalController,\n            timeout,\n            signal: options.signal,\n        });\n        const taskStream = this._executeTasksWithRetry(pendingTasks, {\n            signals: currentSignals,\n            retryPolicy,\n            maxConcurrency,\n        });\n        for await (const { task, error, signalAborted } of taskStream) {\n            this._commit(task, error);\n            if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphInterrupt)(error)) {\n                graphBubbleUp = error;\n            }\n            else if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphBubbleUp)(error) && !(0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphInterrupt)(graphBubbleUp)) {\n                graphBubbleUp = error;\n            }\n            else if (error && (nodeErrors.size === 0 || !signalAborted)) {\n                /*\n                 * The goal here is to capture the exception that causes the graph to terminate early. In\n                 * theory it's possible for multiple nodes to throw, so this also handles the edge case of\n                 * capturing concurrent exceptions thrown before the node saw an abort. This is checked via\n                 * the signalAborted flag, which records the state of the abort signal at the time the node\n                 * execution finished.\n                 *\n                 * There is a case however where one node throws some error causing us to trigger an abort,\n                 * which then causes other concurrently executing nodes to throw their own AbortErrors. In\n                 * this case we don't care about reporting the abort errors thrown by the other nodes,\n                 * because they don't tell the user anything about what caused the graph execution to\n                 * terminate early, so we ignore them (and any other errors that occur after the node sees\n                 * an abort signal).\n                 */\n                exceptionSignalController.abort();\n                nodeErrors.add(error);\n            }\n        }\n        onStepWrite?.(this.loop.step, Object.values(this.loop.tasks)\n            .map((task) => task.writes)\n            .flat());\n        if (nodeErrors.size === 1) {\n            throw Array.from(nodeErrors)[0];\n        }\n        else if (nodeErrors.size > 1) {\n            throw new AggregateError(Array.from(nodeErrors), `Multiple errors occurred during superstep ${this.loop.step}. See the \"errors\" field of this exception for more details.`);\n        }\n        if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphInterrupt)(graphBubbleUp)) {\n            throw graphBubbleUp;\n        }\n        if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphBubbleUp)(graphBubbleUp) && this.loop.isNested) {\n            throw graphBubbleUp;\n        }\n    }\n    /**\n     * Initializes the current AbortSignals for the PregelRunner, handling the various ways that\n     * AbortSignals must be chained together so that the PregelLoop can be interrupted if necessary\n     * while still allowing nodes to gracefully exit.\n     *\n     * This method must only be called once per PregelRunner#tick. It has the side effect of updating\n     * the PregelLoop#config with the new AbortSignals so they may be propagated correctly to future\n     * ticks and subgraph calls.\n     *\n     * @param options - Options for the initialization.\n     * @returns The current abort signals.\n     * @internal\n     */\n    _initializeAbortSignals({ exceptionSignalController, timeout, signal, }) {\n        const previousSignals = this.loop.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_ABORT_SIGNALS] ?? {};\n        // This is true when a node calls a subgraph and, rather than forwarding its own AbortSignal,\n        // it creates a new AbortSignal and passes that along instead.\n        const subgraphCalledWithSignalCreatedByNode = signal &&\n            previousSignals.composedAbortSignal &&\n            signal !== previousSignals.composedAbortSignal;\n        const externalAbortSignal = subgraphCalledWithSignalCreatedByNode\n            ? // Chain the signals here to make sure that the subgraph receives the external abort signal in\n                // addition to the signal created by the node.\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.combineAbortSignals)(previousSignals.externalAbortSignal, signal)\n            : // Otherwise, just keep using the external abort signal, or initialize it if it hasn't been\n                // assigned yet\n                previousSignals.externalAbortSignal ?? signal;\n        const errorAbortSignal = previousSignals.errorAbortSignal\n            ? // Chaining here rather than always using a fresh one handles the case where a subgraph is\n                // called in a parallel branch to some other node in the parent graph.\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.combineAbortSignals)(previousSignals.errorAbortSignal, exceptionSignalController.signal)\n            : exceptionSignalController.signal;\n        const timeoutAbortSignal = timeout\n            ? AbortSignal.timeout(timeout)\n            : undefined;\n        const composedAbortSignal = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.combineAbortSignals)(...(externalAbortSignal ? [externalAbortSignal] : []), ...(timeoutAbortSignal ? [timeoutAbortSignal] : []), errorAbortSignal);\n        const currentSignals = {\n            externalAbortSignal,\n            errorAbortSignal,\n            timeoutAbortSignal,\n            composedAbortSignal,\n        };\n        this.loop.config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.patchConfigurable)(this.loop.config, {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_ABORT_SIGNALS]: currentSignals,\n        });\n        return currentSignals;\n    }\n    /**\n     * Concurrently executes tasks with the requested retry policy, yielding a {@link SettledPregelTask} for each task as it completes.\n     * @param tasks - The tasks to execute.\n     * @param options - Options for the execution.\n     */\n    async *_executeTasksWithRetry(tasks, options) {\n        const { retryPolicy, maxConcurrency, signals } = options ?? {};\n        const barrier = createPromiseBarrier();\n        const executingTasksMap = {};\n        const thisCall = {\n            executingTasksMap,\n            barrier,\n            retryPolicy,\n            scheduleTask: async (task, writeIdx, call) => this.loop.acceptPush(task, writeIdx, call),\n        };\n        if (signals?.composedAbortSignal?.aborted) {\n            // note: don't use throwIfAborted here because it throws a DOMException,\n            // which isn't consistent with how we throw on abort below.\n            throw new Error(\"Abort\");\n        }\n        let startedTasksCount = 0;\n        let listener;\n        const timeoutOrCancelSignal = signals?.externalAbortSignal || signals?.timeoutAbortSignal\n            ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.combineAbortSignals)(...(signals.externalAbortSignal\n                ? [signals.externalAbortSignal]\n                : []), ...(signals.timeoutAbortSignal ? [signals.timeoutAbortSignal] : []))\n            : undefined;\n        const abortPromise = timeoutOrCancelSignal\n            ? new Promise((_resolve, reject) => {\n                listener = () => reject(new Error(\"Abort\"));\n                timeoutOrCancelSignal.addEventListener(\"abort\", listener, {\n                    once: true,\n                });\n            })\n            : undefined;\n        while ((startedTasksCount === 0 || Object.keys(executingTasksMap).length > 0) &&\n            tasks.length) {\n            for (; Object.values(executingTasksMap).length <\n                (maxConcurrency ?? tasks.length) && startedTasksCount < tasks.length; startedTasksCount += 1) {\n                const task = tasks[startedTasksCount];\n                executingTasksMap[task.id] = (0,_retry_js__WEBPACK_IMPORTED_MODULE_4__._runWithRetry)(task, retryPolicy, { [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CALL]: call?.bind(thisCall, this, task) }, signals?.composedAbortSignal).catch((error) => {\n                    return {\n                        task,\n                        error,\n                        signalAborted: signals?.composedAbortSignal?.aborted,\n                    };\n                });\n            }\n            const settledTask = await Promise.race([\n                ...Object.values(executingTasksMap),\n                ...(abortPromise ? [abortPromise] : []),\n                barrier.wait,\n            ]);\n            if (settledTask === PROMISE_ADDED_SYMBOL) {\n                continue;\n            }\n            yield settledTask;\n            delete executingTasksMap[settledTask.task.id];\n        }\n    }\n    /**\n     * Determines what writes to apply based on whether the task completed successfully, and what type of error occurred.\n     *\n     * Throws an error if the error is a {@link GraphBubbleUp} error and {@link PregelLoop}#isNested is true.\n     *\n     * @param task - The task to commit.\n     * @param error - The error that occurred, if any.\n     */\n    _commit(task, error) {\n        if (error !== undefined) {\n            if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphInterrupt)(error)) {\n                if (error.interrupts.length) {\n                    const interrupts = error.interrupts.map((interrupt) => [_constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT, interrupt]);\n                    const resumes = task.writes.filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_2__.RESUME);\n                    if (resumes.length) {\n                        interrupts.push(...resumes);\n                    }\n                    this.loop.putWrites(task.id, interrupts);\n                }\n            }\n            else if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphBubbleUp)(error) && task.writes.length) {\n                this.loop.putWrites(task.id, task.writes);\n            }\n            else {\n                this.loop.putWrites(task.id, [\n                    [_constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR, { message: error.message, name: error.name }],\n                ]);\n            }\n        }\n        else {\n            if (this.nodeFinished &&\n                (task.config?.tags == null || !task.config.tags.includes(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TAG_HIDDEN))) {\n                this.nodeFinished(String(task.name));\n            }\n            if (task.writes.length === 0) {\n                // Add no writes marker\n                task.writes.push([_constants_js__WEBPACK_IMPORTED_MODULE_2__.NO_WRITES, null]);\n            }\n            // Save task writes to checkpointer\n            this.loop.putWrites(task.id, task.writes);\n        }\n    }\n}\nasync function call(runner, task, func, name, input, options = {}) {\n    // Schedule PUSH tasks, collect promises\n    const scratchpad = task.config?.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SCRATCHPAD];\n    if (!scratchpad) {\n        throw new Error(`BUG: No scratchpad found on task ${task.name}__${task.id}`);\n    }\n    const cnt = scratchpad.callCounter;\n    scratchpad.callCounter += 1;\n    // schedule the next task, if the callback returns one\n    const wcall = new _types_js__WEBPACK_IMPORTED_MODULE_0__.Call({\n        func,\n        name,\n        input,\n        retry: options.retry,\n        callbacks: options.callbacks,\n    });\n    const nextTask = await this.scheduleTask(task, cnt, wcall);\n    if (!nextTask)\n        return undefined;\n    // Check if this task is already running\n    const existingPromise = this.executingTasksMap[nextTask.id];\n    if (existingPromise !== undefined) {\n        // If the parent task was retried, the next task might already be running\n        return existingPromise;\n    }\n    if (nextTask.writes.length > 0) {\n        // If it already ran, return the result\n        const returns = nextTask.writes.filter(([c]) => c === _constants_js__WEBPACK_IMPORTED_MODULE_2__.RETURN);\n        const errors = nextTask.writes.filter(([c]) => c === _constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR);\n        if (returns.length > 0) {\n            // Task completed successfully\n            if (returns.length === 1)\n                return Promise.resolve(returns[0][1]);\n            // should be unreachable\n            throw new Error(`BUG: multiple returns found for task ${nextTask.name}__${nextTask.id}`);\n        }\n        if (errors.length > 0) {\n            // Task failed\n            if (errors.length === 1) {\n                const errorValue = errors[0][1];\n                const error = \n                // eslint-disable-next-line no-instanceof/no-instanceof\n                errorValue instanceof Error\n                    ? errorValue\n                    : new Error(String(errorValue));\n                return Promise.reject(error);\n            }\n            // the only way this should happen is if the task executes multiple times and writes aren't cleared\n            throw new Error(`BUG: multiple errors found for task ${nextTask.name}__${nextTask.id}`);\n        }\n        return undefined;\n    }\n    else {\n        // Schedule the next task with retry\n        const prom = (0,_retry_js__WEBPACK_IMPORTED_MODULE_4__._runWithRetry)(nextTask, options.retry, {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CALL]: call.bind(this, runner, nextTask),\n        });\n        this.executingTasksMap[nextTask.id] = prom;\n        this.barrier.next();\n        return prom.then(({ result, error }) => {\n            if (error)\n                return Promise.reject(error);\n            return result;\n        });\n    }\n}\n//# sourceMappingURL=runner.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvcnVubmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtQztBQUN3QztBQUNrRjtBQUM1RjtBQUN0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxpQkFBaUI7QUFDakY7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGdCQUFnQixvREFBb0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQSxnQkFBZ0IsNERBQWdCO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQWUsWUFBWSw0REFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsZUFBZTtBQUN6SDtBQUNBLFlBQVksNERBQWdCO0FBQzVCO0FBQ0E7QUFDQSxZQUFZLDJEQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRSxnRUFBZ0UsbUVBQXdCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0VBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0VBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrRUFBaUI7QUFDNUMsYUFBYSxtRUFBd0I7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRix5QkFBeUI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvRUFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHNGQUFzRjtBQUN0RjtBQUNBLDZDQUE2Qyx3REFBYSxzQkFBc0IsQ0FBQywwREFBZSxxQ0FBcUM7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUIsV0FBVyxpQkFBaUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFnQjtBQUNoQztBQUNBLDRFQUE0RSxvREFBUztBQUNyRix1RUFBdUUsaURBQU07QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUFLLElBQUksMENBQTBDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUscURBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0EsbURBQW1ELGdFQUFxQjtBQUN4RTtBQUNBLDREQUE0RCxVQUFVLElBQUksUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaURBQU07QUFDcEUsNkRBQTZELGdEQUFLO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsY0FBYyxJQUFJLFlBQVk7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsY0FBYyxJQUFJLFlBQVk7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBYTtBQUNsQyxhQUFhLDBEQUFlO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXGRpc3RcXHByZWdlbFxccnVubmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhbGwsIH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcbmltcG9ydCB7IGNvbWJpbmVBYm9ydFNpZ25hbHMsIHBhdGNoQ29uZmlndXJhYmxlLCB9IGZyb20gXCIuL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDT05GSUdfS0VZX1NDUkFUQ0hQQUQsIEVSUk9SLCBJTlRFUlJVUFQsIFJFU1VNRSwgTk9fV1JJVEVTLCBUQUdfSElEREVOLCBSRVRVUk4sIENPTkZJR19LRVlfQ0FMTCwgQ09ORklHX0tFWV9BQk9SVF9TSUdOQUxTLCB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IGlzR3JhcGhCdWJibGVVcCwgaXNHcmFwaEludGVycnVwdCB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IF9ydW5XaXRoUmV0cnkgfSBmcm9tIFwiLi9yZXRyeS5qc1wiO1xuY29uc3QgUFJPTUlTRV9BRERFRF9TWU1CT0wgPSBTeW1ib2wuZm9yKFwicHJvbWlzZUFkZGVkXCIpO1xuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZUJhcnJpZXIoKSB7XG4gICAgY29uc3QgYmFycmllciA9IHtcbiAgICAgICAgbmV4dDogKCkgPT4gdm9pZCAwLFxuICAgICAgICB3YWl0OiBQcm9taXNlLnJlc29sdmUoUFJPTUlTRV9BRERFRF9TWU1CT0wpLFxuICAgIH07XG4gICAgZnVuY3Rpb24gd2FpdEhhbmRsZXIocmVzb2x2ZSkge1xuICAgICAgICBiYXJyaWVyLm5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBiYXJyaWVyLndhaXQgPSBuZXcgUHJvbWlzZSh3YWl0SGFuZGxlcik7XG4gICAgICAgICAgICByZXNvbHZlKFBST01JU0VfQURERURfU1lNQk9MKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYmFycmllci53YWl0ID0gbmV3IFByb21pc2Uod2FpdEhhbmRsZXIpO1xuICAgIHJldHVybiBiYXJyaWVyO1xufVxuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGFzayBleGVjdXRpb24gb24gZWFjaCB0aWNrIG9mIHRoZSB7QGxpbmsgUHJlZ2VsTG9vcH0uXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmVnZWxSdW5uZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBQcmVnZWxSdW5uZXIsIHdoaWNoIGV4ZWN1dGVzIHRhc2tzIGZyb20gdGhlIHByb3ZpZGVkIFByZWdlbExvb3AuXG4gICAgICogQHBhcmFtIGxvb3AgLSBUaGUgUHJlZ2VsTG9vcCB0aGF0IHByb2R1Y2VzIHRhc2tzIGZvciB0aGlzIHJ1bm5lciB0byBleGVjdXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbG9vcCwgbm9kZUZpbmlzaGVkLCB9KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5vZGVGaW5pc2hlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsb29wXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgIHRoaXMubm9kZUZpbmlzaGVkID0gbm9kZUZpbmlzaGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRhc2tzIGZyb20gdGhlIGN1cnJlbnQgc3RlcCBvZiB0aGUgUHJlZ2VsTG9vcC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGRvZXMgTk9UIGNhbGwge0BsaW5rIFByZWdlbExvb3B9I3RpY2suIFRoYXQgbXVzdCBiZSBoYW5kbGVkIGV4dGVybmFsbHkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHRpY2sob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCwgcmV0cnlQb2xpY3ksIG9uU3RlcFdyaXRlLCBtYXhDb25jdXJyZW5jeSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgbm9kZUVycm9ycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGdyYXBoQnViYmxlVXA7XG4gICAgICAgIGNvbnN0IGV4Y2VwdGlvblNpZ25hbENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIC8vIFN0YXJ0IHRhc2sgZXhlY3V0aW9uXG4gICAgICAgIGNvbnN0IHBlbmRpbmdUYXNrcyA9IE9iamVjdC52YWx1ZXModGhpcy5sb29wLnRhc2tzKS5maWx0ZXIoKHQpID0+IHQud3JpdGVzLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaWduYWxzID0gdGhpcy5faW5pdGlhbGl6ZUFib3J0U2lnbmFscyh7XG4gICAgICAgICAgICBleGNlcHRpb25TaWduYWxDb250cm9sbGVyLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0YXNrU3RyZWFtID0gdGhpcy5fZXhlY3V0ZVRhc2tzV2l0aFJldHJ5KHBlbmRpbmdUYXNrcywge1xuICAgICAgICAgICAgc2lnbmFsczogY3VycmVudFNpZ25hbHMsXG4gICAgICAgICAgICByZXRyeVBvbGljeSxcbiAgICAgICAgICAgIG1heENvbmN1cnJlbmN5LFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHRhc2ssIGVycm9yLCBzaWduYWxBYm9ydGVkIH0gb2YgdGFza1N0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5fY29tbWl0KHRhc2ssIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0dyYXBoSW50ZXJydXB0KGVycm9yKSkge1xuICAgICAgICAgICAgICAgIGdyYXBoQnViYmxlVXAgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzR3JhcGhCdWJibGVVcChlcnJvcikgJiYgIWlzR3JhcGhJbnRlcnJ1cHQoZ3JhcGhCdWJibGVVcCkpIHtcbiAgICAgICAgICAgICAgICBncmFwaEJ1YmJsZVVwID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiAobm9kZUVycm9ycy5zaXplID09PSAwIHx8ICFzaWduYWxBYm9ydGVkKSkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogVGhlIGdvYWwgaGVyZSBpcyB0byBjYXB0dXJlIHRoZSBleGNlcHRpb24gdGhhdCBjYXVzZXMgdGhlIGdyYXBoIHRvIHRlcm1pbmF0ZSBlYXJseS4gSW5cbiAgICAgICAgICAgICAgICAgKiB0aGVvcnkgaXQncyBwb3NzaWJsZSBmb3IgbXVsdGlwbGUgbm9kZXMgdG8gdGhyb3csIHNvIHRoaXMgYWxzbyBoYW5kbGVzIHRoZSBlZGdlIGNhc2Ugb2ZcbiAgICAgICAgICAgICAgICAgKiBjYXB0dXJpbmcgY29uY3VycmVudCBleGNlcHRpb25zIHRocm93biBiZWZvcmUgdGhlIG5vZGUgc2F3IGFuIGFib3J0LiBUaGlzIGlzIGNoZWNrZWQgdmlhXG4gICAgICAgICAgICAgICAgICogdGhlIHNpZ25hbEFib3J0ZWQgZmxhZywgd2hpY2ggcmVjb3JkcyB0aGUgc3RhdGUgb2YgdGhlIGFib3J0IHNpZ25hbCBhdCB0aGUgdGltZSB0aGUgbm9kZVxuICAgICAgICAgICAgICAgICAqIGV4ZWN1dGlvbiBmaW5pc2hlZC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlIGlzIGEgY2FzZSBob3dldmVyIHdoZXJlIG9uZSBub2RlIHRocm93cyBzb21lIGVycm9yIGNhdXNpbmcgdXMgdG8gdHJpZ2dlciBhbiBhYm9ydCxcbiAgICAgICAgICAgICAgICAgKiB3aGljaCB0aGVuIGNhdXNlcyBvdGhlciBjb25jdXJyZW50bHkgZXhlY3V0aW5nIG5vZGVzIHRvIHRocm93IHRoZWlyIG93biBBYm9ydEVycm9ycy4gSW5cbiAgICAgICAgICAgICAgICAgKiB0aGlzIGNhc2Ugd2UgZG9uJ3QgY2FyZSBhYm91dCByZXBvcnRpbmcgdGhlIGFib3J0IGVycm9ycyB0aHJvd24gYnkgdGhlIG90aGVyIG5vZGVzLFxuICAgICAgICAgICAgICAgICAqIGJlY2F1c2UgdGhleSBkb24ndCB0ZWxsIHRoZSB1c2VyIGFueXRoaW5nIGFib3V0IHdoYXQgY2F1c2VkIHRoZSBncmFwaCBleGVjdXRpb24gdG9cbiAgICAgICAgICAgICAgICAgKiB0ZXJtaW5hdGUgZWFybHksIHNvIHdlIGlnbm9yZSB0aGVtIChhbmQgYW55IG90aGVyIGVycm9ycyB0aGF0IG9jY3VyIGFmdGVyIHRoZSBub2RlIHNlZXNcbiAgICAgICAgICAgICAgICAgKiBhbiBhYm9ydCBzaWduYWwpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGV4Y2VwdGlvblNpZ25hbENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICBub2RlRXJyb3JzLmFkZChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25TdGVwV3JpdGU/Lih0aGlzLmxvb3Auc3RlcCwgT2JqZWN0LnZhbHVlcyh0aGlzLmxvb3AudGFza3MpXG4gICAgICAgICAgICAubWFwKCh0YXNrKSA9PiB0YXNrLndyaXRlcylcbiAgICAgICAgICAgIC5mbGF0KCkpO1xuICAgICAgICBpZiAobm9kZUVycm9ycy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBBcnJheS5mcm9tKG5vZGVFcnJvcnMpWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVFcnJvcnMuc2l6ZSA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZ2dyZWdhdGVFcnJvcihBcnJheS5mcm9tKG5vZGVFcnJvcnMpLCBgTXVsdGlwbGUgZXJyb3JzIG9jY3VycmVkIGR1cmluZyBzdXBlcnN0ZXAgJHt0aGlzLmxvb3Auc3RlcH0uIFNlZSB0aGUgXCJlcnJvcnNcIiBmaWVsZCBvZiB0aGlzIGV4Y2VwdGlvbiBmb3IgbW9yZSBkZXRhaWxzLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0dyYXBoSW50ZXJydXB0KGdyYXBoQnViYmxlVXApKSB7XG4gICAgICAgICAgICB0aHJvdyBncmFwaEJ1YmJsZVVwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0dyYXBoQnViYmxlVXAoZ3JhcGhCdWJibGVVcCkgJiYgdGhpcy5sb29wLmlzTmVzdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBncmFwaEJ1YmJsZVVwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjdXJyZW50IEFib3J0U2lnbmFscyBmb3IgdGhlIFByZWdlbFJ1bm5lciwgaGFuZGxpbmcgdGhlIHZhcmlvdXMgd2F5cyB0aGF0XG4gICAgICogQWJvcnRTaWduYWxzIG11c3QgYmUgY2hhaW5lZCB0b2dldGhlciBzbyB0aGF0IHRoZSBQcmVnZWxMb29wIGNhbiBiZSBpbnRlcnJ1cHRlZCBpZiBuZWNlc3NhcnlcbiAgICAgKiB3aGlsZSBzdGlsbCBhbGxvd2luZyBub2RlcyB0byBncmFjZWZ1bGx5IGV4aXQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIG9uY2UgcGVyIFByZWdlbFJ1bm5lciN0aWNrLiBJdCBoYXMgdGhlIHNpZGUgZWZmZWN0IG9mIHVwZGF0aW5nXG4gICAgICogdGhlIFByZWdlbExvb3AjY29uZmlnIHdpdGggdGhlIG5ldyBBYm9ydFNpZ25hbHMgc28gdGhleSBtYXkgYmUgcHJvcGFnYXRlZCBjb3JyZWN0bHkgdG8gZnV0dXJlXG4gICAgICogdGlja3MgYW5kIHN1YmdyYXBoIGNhbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgaW5pdGlhbGl6YXRpb24uXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgYWJvcnQgc2lnbmFscy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZUFib3J0U2lnbmFscyh7IGV4Y2VwdGlvblNpZ25hbENvbnRyb2xsZXIsIHRpbWVvdXQsIHNpZ25hbCwgfSkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1NpZ25hbHMgPSB0aGlzLmxvb3AuY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfQUJPUlRfU0lHTkFMU10gPz8ge307XG4gICAgICAgIC8vIFRoaXMgaXMgdHJ1ZSB3aGVuIGEgbm9kZSBjYWxscyBhIHN1YmdyYXBoIGFuZCwgcmF0aGVyIHRoYW4gZm9yd2FyZGluZyBpdHMgb3duIEFib3J0U2lnbmFsLFxuICAgICAgICAvLyBpdCBjcmVhdGVzIGEgbmV3IEFib3J0U2lnbmFsIGFuZCBwYXNzZXMgdGhhdCBhbG9uZyBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBzdWJncmFwaENhbGxlZFdpdGhTaWduYWxDcmVhdGVkQnlOb2RlID0gc2lnbmFsICYmXG4gICAgICAgICAgICBwcmV2aW91c1NpZ25hbHMuY29tcG9zZWRBYm9ydFNpZ25hbCAmJlxuICAgICAgICAgICAgc2lnbmFsICE9PSBwcmV2aW91c1NpZ25hbHMuY29tcG9zZWRBYm9ydFNpZ25hbDtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxBYm9ydFNpZ25hbCA9IHN1YmdyYXBoQ2FsbGVkV2l0aFNpZ25hbENyZWF0ZWRCeU5vZGVcbiAgICAgICAgICAgID8gLy8gQ2hhaW4gdGhlIHNpZ25hbHMgaGVyZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgc3ViZ3JhcGggcmVjZWl2ZXMgdGhlIGV4dGVybmFsIGFib3J0IHNpZ25hbCBpblxuICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBzaWduYWwgY3JlYXRlZCBieSB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICBjb21iaW5lQWJvcnRTaWduYWxzKHByZXZpb3VzU2lnbmFscy5leHRlcm5hbEFib3J0U2lnbmFsLCBzaWduYWwpXG4gICAgICAgICAgICA6IC8vIE90aGVyd2lzZSwganVzdCBrZWVwIHVzaW5nIHRoZSBleHRlcm5hbCBhYm9ydCBzaWduYWwsIG9yIGluaXRpYWxpemUgaXQgaWYgaXQgaGFzbid0IGJlZW5cbiAgICAgICAgICAgICAgICAvLyBhc3NpZ25lZCB5ZXRcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NpZ25hbHMuZXh0ZXJuYWxBYm9ydFNpZ25hbCA/PyBzaWduYWw7XG4gICAgICAgIGNvbnN0IGVycm9yQWJvcnRTaWduYWwgPSBwcmV2aW91c1NpZ25hbHMuZXJyb3JBYm9ydFNpZ25hbFxuICAgICAgICAgICAgPyAvLyBDaGFpbmluZyBoZXJlIHJhdGhlciB0aGFuIGFsd2F5cyB1c2luZyBhIGZyZXNoIG9uZSBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIGEgc3ViZ3JhcGggaXNcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQgaW4gYSBwYXJhbGxlbCBicmFuY2ggdG8gc29tZSBvdGhlciBub2RlIGluIHRoZSBwYXJlbnQgZ3JhcGguXG4gICAgICAgICAgICAgICAgY29tYmluZUFib3J0U2lnbmFscyhwcmV2aW91c1NpZ25hbHMuZXJyb3JBYm9ydFNpZ25hbCwgZXhjZXB0aW9uU2lnbmFsQ29udHJvbGxlci5zaWduYWwpXG4gICAgICAgICAgICA6IGV4Y2VwdGlvblNpZ25hbENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICBjb25zdCB0aW1lb3V0QWJvcnRTaWduYWwgPSB0aW1lb3V0XG4gICAgICAgICAgICA/IEFib3J0U2lnbmFsLnRpbWVvdXQodGltZW91dClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBjb21wb3NlZEFib3J0U2lnbmFsID0gY29tYmluZUFib3J0U2lnbmFscyguLi4oZXh0ZXJuYWxBYm9ydFNpZ25hbCA/IFtleHRlcm5hbEFib3J0U2lnbmFsXSA6IFtdKSwgLi4uKHRpbWVvdXRBYm9ydFNpZ25hbCA/IFt0aW1lb3V0QWJvcnRTaWduYWxdIDogW10pLCBlcnJvckFib3J0U2lnbmFsKTtcbiAgICAgICAgY29uc3QgY3VycmVudFNpZ25hbHMgPSB7XG4gICAgICAgICAgICBleHRlcm5hbEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgZXJyb3JBYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIHRpbWVvdXRBYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGNvbXBvc2VkQWJvcnRTaWduYWwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9vcC5jb25maWcgPSBwYXRjaENvbmZpZ3VyYWJsZSh0aGlzLmxvb3AuY29uZmlnLCB7XG4gICAgICAgICAgICBbQ09ORklHX0tFWV9BQk9SVF9TSUdOQUxTXTogY3VycmVudFNpZ25hbHMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VycmVudFNpZ25hbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmN1cnJlbnRseSBleGVjdXRlcyB0YXNrcyB3aXRoIHRoZSByZXF1ZXN0ZWQgcmV0cnkgcG9saWN5LCB5aWVsZGluZyBhIHtAbGluayBTZXR0bGVkUHJlZ2VsVGFza30gZm9yIGVhY2ggdGFzayBhcyBpdCBjb21wbGV0ZXMuXG4gICAgICogQHBhcmFtIHRhc2tzIC0gVGhlIHRhc2tzIHRvIGV4ZWN1dGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jICpfZXhlY3V0ZVRhc2tzV2l0aFJldHJ5KHRhc2tzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgcmV0cnlQb2xpY3ksIG1heENvbmN1cnJlbmN5LCBzaWduYWxzIH0gPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBjb25zdCBiYXJyaWVyID0gY3JlYXRlUHJvbWlzZUJhcnJpZXIoKTtcbiAgICAgICAgY29uc3QgZXhlY3V0aW5nVGFza3NNYXAgPSB7fTtcbiAgICAgICAgY29uc3QgdGhpc0NhbGwgPSB7XG4gICAgICAgICAgICBleGVjdXRpbmdUYXNrc01hcCxcbiAgICAgICAgICAgIGJhcnJpZXIsXG4gICAgICAgICAgICByZXRyeVBvbGljeSxcbiAgICAgICAgICAgIHNjaGVkdWxlVGFzazogYXN5bmMgKHRhc2ssIHdyaXRlSWR4LCBjYWxsKSA9PiB0aGlzLmxvb3AuYWNjZXB0UHVzaCh0YXNrLCB3cml0ZUlkeCwgY2FsbCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaWduYWxzPy5jb21wb3NlZEFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlOiBkb24ndCB1c2UgdGhyb3dJZkFib3J0ZWQgaGVyZSBiZWNhdXNlIGl0IHRocm93cyBhIERPTUV4Y2VwdGlvbixcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzbid0IGNvbnNpc3RlbnQgd2l0aCBob3cgd2UgdGhyb3cgb24gYWJvcnQgYmVsb3cuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRlZFRhc2tzQ291bnQgPSAwO1xuICAgICAgICBsZXQgbGlzdGVuZXI7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRPckNhbmNlbFNpZ25hbCA9IHNpZ25hbHM/LmV4dGVybmFsQWJvcnRTaWduYWwgfHwgc2lnbmFscz8udGltZW91dEFib3J0U2lnbmFsXG4gICAgICAgICAgICA/IGNvbWJpbmVBYm9ydFNpZ25hbHMoLi4uKHNpZ25hbHMuZXh0ZXJuYWxBYm9ydFNpZ25hbFxuICAgICAgICAgICAgICAgID8gW3NpZ25hbHMuZXh0ZXJuYWxBYm9ydFNpZ25hbF1cbiAgICAgICAgICAgICAgICA6IFtdKSwgLi4uKHNpZ25hbHMudGltZW91dEFib3J0U2lnbmFsID8gW3NpZ25hbHMudGltZW91dEFib3J0U2lnbmFsXSA6IFtdKSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBhYm9ydFByb21pc2UgPSB0aW1lb3V0T3JDYW5jZWxTaWduYWxcbiAgICAgICAgICAgID8gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydFwiKSk7XG4gICAgICAgICAgICAgICAgdGltZW91dE9yQ2FuY2VsU2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lciwge1xuICAgICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB3aGlsZSAoKHN0YXJ0ZWRUYXNrc0NvdW50ID09PSAwIHx8IE9iamVjdC5rZXlzKGV4ZWN1dGluZ1Rhc2tzTWFwKS5sZW5ndGggPiAwKSAmJlxuICAgICAgICAgICAgdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKDsgT2JqZWN0LnZhbHVlcyhleGVjdXRpbmdUYXNrc01hcCkubGVuZ3RoIDxcbiAgICAgICAgICAgICAgICAobWF4Q29uY3VycmVuY3kgPz8gdGFza3MubGVuZ3RoKSAmJiBzdGFydGVkVGFza3NDb3VudCA8IHRhc2tzLmxlbmd0aDsgc3RhcnRlZFRhc2tzQ291bnQgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB0YXNrc1tzdGFydGVkVGFza3NDb3VudF07XG4gICAgICAgICAgICAgICAgZXhlY3V0aW5nVGFza3NNYXBbdGFzay5pZF0gPSBfcnVuV2l0aFJldHJ5KHRhc2ssIHJldHJ5UG9saWN5LCB7IFtDT05GSUdfS0VZX0NBTExdOiBjYWxsPy5iaW5kKHRoaXNDYWxsLCB0aGlzLCB0YXNrKSB9LCBzaWduYWxzPy5jb21wb3NlZEFib3J0U2lnbmFsKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbEFib3J0ZWQ6IHNpZ25hbHM/LmNvbXBvc2VkQWJvcnRTaWduYWw/LmFib3J0ZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXR0bGVkVGFzayA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LnZhbHVlcyhleGVjdXRpbmdUYXNrc01hcCksXG4gICAgICAgICAgICAgICAgLi4uKGFib3J0UHJvbWlzZSA/IFthYm9ydFByb21pc2VdIDogW10pLFxuICAgICAgICAgICAgICAgIGJhcnJpZXIud2FpdCxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHNldHRsZWRUYXNrID09PSBQUk9NSVNFX0FEREVEX1NZTUJPTCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgc2V0dGxlZFRhc2s7XG4gICAgICAgICAgICBkZWxldGUgZXhlY3V0aW5nVGFza3NNYXBbc2V0dGxlZFRhc2sudGFzay5pZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGF0IHdyaXRlcyB0byBhcHBseSBiYXNlZCBvbiB3aGV0aGVyIHRoZSB0YXNrIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIGFuZCB3aGF0IHR5cGUgb2YgZXJyb3Igb2NjdXJyZWQuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGVycm9yIGlzIGEge0BsaW5rIEdyYXBoQnViYmxlVXB9IGVycm9yIGFuZCB7QGxpbmsgUHJlZ2VsTG9vcH0jaXNOZXN0ZWQgaXMgdHJ1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXNrIC0gVGhlIHRhc2sgdG8gY29tbWl0LlxuICAgICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0aGF0IG9jY3VycmVkLCBpZiBhbnkuXG4gICAgICovXG4gICAgX2NvbW1pdCh0YXNrLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGlzR3JhcGhJbnRlcnJ1cHQoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmludGVycnVwdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVycnVwdHMgPSBlcnJvci5pbnRlcnJ1cHRzLm1hcCgoaW50ZXJydXB0KSA9PiBbSU5URVJSVVBULCBpbnRlcnJ1cHRdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdW1lcyA9IHRhc2sud3JpdGVzLmZpbHRlcigodykgPT4gd1swXSA9PT0gUkVTVU1FKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHRzLnB1c2goLi4ucmVzdW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb29wLnB1dFdyaXRlcyh0YXNrLmlkLCBpbnRlcnJ1cHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0dyYXBoQnViYmxlVXAoZXJyb3IpICYmIHRhc2sud3JpdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9vcC5wdXRXcml0ZXModGFzay5pZCwgdGFzay53cml0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb29wLnB1dFdyaXRlcyh0YXNrLmlkLCBbXG4gICAgICAgICAgICAgICAgICAgIFtFUlJPUiwgeyBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLCBuYW1lOiBlcnJvci5uYW1lIH1dLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZUZpbmlzaGVkICYmXG4gICAgICAgICAgICAgICAgKHRhc2suY29uZmlnPy50YWdzID09IG51bGwgfHwgIXRhc2suY29uZmlnLnRhZ3MuaW5jbHVkZXMoVEFHX0hJRERFTikpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlRmluaXNoZWQoU3RyaW5nKHRhc2submFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhc2sud3JpdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBubyB3cml0ZXMgbWFya2VyXG4gICAgICAgICAgICAgICAgdGFzay53cml0ZXMucHVzaChbTk9fV1JJVEVTLCBudWxsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYXZlIHRhc2sgd3JpdGVzIHRvIGNoZWNrcG9pbnRlclxuICAgICAgICAgICAgdGhpcy5sb29wLnB1dFdyaXRlcyh0YXNrLmlkLCB0YXNrLndyaXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsKHJ1bm5lciwgdGFzaywgZnVuYywgbmFtZSwgaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIFNjaGVkdWxlIFBVU0ggdGFza3MsIGNvbGxlY3QgcHJvbWlzZXNcbiAgICBjb25zdCBzY3JhdGNocGFkID0gdGFzay5jb25maWc/LmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfU0NSQVRDSFBBRF07XG4gICAgaWYgKCFzY3JhdGNocGFkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiBObyBzY3JhdGNocGFkIGZvdW5kIG9uIHRhc2sgJHt0YXNrLm5hbWV9X18ke3Rhc2suaWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNudCA9IHNjcmF0Y2hwYWQuY2FsbENvdW50ZXI7XG4gICAgc2NyYXRjaHBhZC5jYWxsQ291bnRlciArPSAxO1xuICAgIC8vIHNjaGVkdWxlIHRoZSBuZXh0IHRhc2ssIGlmIHRoZSBjYWxsYmFjayByZXR1cm5zIG9uZVxuICAgIGNvbnN0IHdjYWxsID0gbmV3IENhbGwoe1xuICAgICAgICBmdW5jLFxuICAgICAgICBuYW1lLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcmV0cnk6IG9wdGlvbnMucmV0cnksXG4gICAgICAgIGNhbGxiYWNrczogb3B0aW9ucy5jYWxsYmFja3MsXG4gICAgfSk7XG4gICAgY29uc3QgbmV4dFRhc2sgPSBhd2FpdCB0aGlzLnNjaGVkdWxlVGFzayh0YXNrLCBjbnQsIHdjYWxsKTtcbiAgICBpZiAoIW5leHRUYXNrKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIC8vIENoZWNrIGlmIHRoaXMgdGFzayBpcyBhbHJlYWR5IHJ1bm5pbmdcbiAgICBjb25zdCBleGlzdGluZ1Byb21pc2UgPSB0aGlzLmV4ZWN1dGluZ1Rhc2tzTWFwW25leHRUYXNrLmlkXTtcbiAgICBpZiAoZXhpc3RpbmdQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmVudCB0YXNrIHdhcyByZXRyaWVkLCB0aGUgbmV4dCB0YXNrIG1pZ2h0IGFscmVhZHkgYmUgcnVubmluZ1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdQcm9taXNlO1xuICAgIH1cbiAgICBpZiAobmV4dFRhc2sud3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gSWYgaXQgYWxyZWFkeSByYW4sIHJldHVybiB0aGUgcmVzdWx0XG4gICAgICAgIGNvbnN0IHJldHVybnMgPSBuZXh0VGFzay53cml0ZXMuZmlsdGVyKChbY10pID0+IGMgPT09IFJFVFVSTik7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IG5leHRUYXNrLndyaXRlcy5maWx0ZXIoKFtjXSkgPT4gYyA9PT0gRVJST1IpO1xuICAgICAgICBpZiAocmV0dXJucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBUYXNrIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAgIGlmIChyZXR1cm5zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJldHVybnNbMF1bMV0pO1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJVRzogbXVsdGlwbGUgcmV0dXJucyBmb3VuZCBmb3IgdGFzayAke25leHRUYXNrLm5hbWV9X18ke25leHRUYXNrLmlkfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gVGFzayBmYWlsZWRcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JWYWx1ZSA9IGVycm9yc1swXVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBlcnJvclZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IEVycm9yKFN0cmluZyhlcnJvclZhbHVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IHdheSB0aGlzIHNob3VsZCBoYXBwZW4gaXMgaWYgdGhlIHRhc2sgZXhlY3V0ZXMgbXVsdGlwbGUgdGltZXMgYW5kIHdyaXRlcyBhcmVuJ3QgY2xlYXJlZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCVUc6IG11bHRpcGxlIGVycm9ycyBmb3VuZCBmb3IgdGFzayAke25leHRUYXNrLm5hbWV9X18ke25leHRUYXNrLmlkfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBTY2hlZHVsZSB0aGUgbmV4dCB0YXNrIHdpdGggcmV0cnlcbiAgICAgICAgY29uc3QgcHJvbSA9IF9ydW5XaXRoUmV0cnkobmV4dFRhc2ssIG9wdGlvbnMucmV0cnksIHtcbiAgICAgICAgICAgIFtDT05GSUdfS0VZX0NBTExdOiBjYWxsLmJpbmQodGhpcywgcnVubmVyLCBuZXh0VGFzayksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4ZWN1dGluZ1Rhc2tzTWFwW25leHRUYXNrLmlkXSA9IHByb207XG4gICAgICAgIHRoaXMuYmFycmllci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBwcm9tLnRoZW4oKHsgcmVzdWx0LCBlcnJvciB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bm5lci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/runner.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/stream.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/stream.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IterableReadableStreamWithAbortSignal: () => (/* binding */ IterableReadableStreamWithAbortSignal),\n/* harmony export */   IterableReadableWritableStream: () => (/* binding */ IterableReadableWritableStream)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_utils_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/utils/stream */ \"(rsc)/./node_modules/@langchain/core/utils/stream.js\");\n\n/**\n * A wrapper around an IterableReadableStream that allows for aborting the stream when\n * {@link cancel} is called.\n */\nclass IterableReadableStreamWithAbortSignal extends _langchain_core_utils_stream__WEBPACK_IMPORTED_MODULE_0__.IterableReadableStream {\n    /**\n     * @param readableStream - The stream to wrap.\n     * @param abortController - The abort controller to use. Optional. One will be created if not provided.\n     */\n    constructor(readableStream, abortController) {\n        const reader = readableStream.getReader();\n        const ac = abortController ?? new AbortController();\n        super({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n        });\n        Object.defineProperty(this, \"_abortController\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._abortController = ac;\n        this._reader = reader;\n    }\n    /**\n     * Aborts the stream, abandoning any pending operations in progress. Calling this triggers an\n     * {@link AbortSignal} that is propagated to the tasks that are producing the data for this stream.\n     * @param reason - The reason for aborting the stream. Optional.\n     */\n    async cancel(reason) {\n        this._abortController.abort(reason);\n        this._reader.releaseLock();\n    }\n    /**\n     * The {@link AbortSignal} for the stream. Aborted when {@link cancel} is called.\n     */\n    get signal() {\n        return this._abortController.signal;\n    }\n}\nclass IterableReadableWritableStream extends _langchain_core_utils_stream__WEBPACK_IMPORTED_MODULE_0__.IterableReadableStream {\n    get closed() {\n        return this._closed;\n    }\n    constructor(params) {\n        let streamControllerPromiseResolver;\n        const streamControllerPromise = new Promise((resolve) => {\n            streamControllerPromiseResolver = resolve;\n        });\n        super({\n            start: (controller) => {\n                streamControllerPromiseResolver(controller);\n            },\n        });\n        Object.defineProperty(this, \"modes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"controller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"passthroughFn\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_closed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        // .start() will always be called before the stream can be interacted\n        // with anyway\n        void streamControllerPromise.then((controller) => {\n            this.controller = controller;\n        });\n        this.passthroughFn = params.passthroughFn;\n        this.modes = params.modes;\n    }\n    push(chunk) {\n        this.passthroughFn?.(chunk);\n        this.controller.enqueue(chunk);\n    }\n    close() {\n        try {\n            this.controller.close();\n        }\n        catch (e) {\n            // pass\n        }\n        finally {\n            this._closed = true;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error(e) {\n        this.controller.error(e);\n    }\n}\n//# sourceMappingURL=stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRTtBQUN0RTtBQUNBO0FBQ0EsSUFBSSxjQUFjO0FBQ2xCO0FBQ08sb0RBQW9ELGdGQUFzQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CLDhCQUE4QixjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2Q0FBNkMsZ0ZBQXNCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxwcmVnZWxcXHN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS91dGlscy9zdHJlYW1cIjtcbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIHRoYXQgYWxsb3dzIGZvciBhYm9ydGluZyB0aGUgc3RyZWFtIHdoZW5cbiAqIHtAbGluayBjYW5jZWx9IGlzIGNhbGxlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW1XaXRoQWJvcnRTaWduYWwgZXh0ZW5kcyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcmVhZGFibGVTdHJlYW0gLSBUaGUgc3RyZWFtIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIGFib3J0Q29udHJvbGxlciAtIFRoZSBhYm9ydCBjb250cm9sbGVyIHRvIHVzZS4gT3B0aW9uYWwuIE9uZSB3aWxsIGJlIGNyZWF0ZWQgaWYgbm90IHByb3ZpZGVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlYWRhYmxlU3RyZWFtLCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IGFjID0gYWJvcnRDb250cm9sbGVyID8/IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIG5vIG1vcmUgZGF0YSBuZWVkcyB0byBiZSBjb25zdW1lZCwgY2xvc2UgdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5xdWV1ZSB0aGUgbmV4dCBkYXRhIGNodW5rIGludG8gb3VyIHRhcmdldCBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Fib3J0Q29udHJvbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmVhZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IGFjO1xuICAgICAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0cyB0aGUgc3RyZWFtLCBhYmFuZG9uaW5nIGFueSBwZW5kaW5nIG9wZXJhdGlvbnMgaW4gcHJvZ3Jlc3MuIENhbGxpbmcgdGhpcyB0cmlnZ2VycyBhblxuICAgICAqIHtAbGluayBBYm9ydFNpZ25hbH0gdGhhdCBpcyBwcm9wYWdhdGVkIHRvIHRoZSB0YXNrcyB0aGF0IGFyZSBwcm9kdWNpbmcgdGhlIGRhdGEgZm9yIHRoaXMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSByZWFzb24gLSBUaGUgcmVhc29uIGZvciBhYm9ydGluZyB0aGUgc3RyZWFtLiBPcHRpb25hbC5cbiAgICAgKi9cbiAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydChyZWFzb24pO1xuICAgICAgICB0aGlzLl9yZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBBYm9ydFNpZ25hbH0gZm9yIHRoZSBzdHJlYW0uIEFib3J0ZWQgd2hlbiB7QGxpbmsgY2FuY2VsfSBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZ2V0IHNpZ25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEl0ZXJhYmxlUmVhZGFibGVXcml0YWJsZVN0cmVhbSBleHRlbmRzIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0ge1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBsZXQgc3RyZWFtQ29udHJvbGxlclByb21pc2VSZXNvbHZlcjtcbiAgICAgICAgY29uc3Qgc3RyZWFtQ29udHJvbGxlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgc3RyZWFtQ29udHJvbGxlclByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBzdGFydDogKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyUHJvbWlzZVJlc29sdmVyKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyb2xsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFzc3Rocm91Z2hGblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2xvc2VkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gLnN0YXJ0KCkgd2lsbCBhbHdheXMgYmUgY2FsbGVkIGJlZm9yZSB0aGUgc3RyZWFtIGNhbiBiZSBpbnRlcmFjdGVkXG4gICAgICAgIC8vIHdpdGggYW55d2F5XG4gICAgICAgIHZvaWQgc3RyZWFtQ29udHJvbGxlclByb21pc2UudGhlbigoY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFzc3Rocm91Z2hGbiA9IHBhcmFtcy5wYXNzdGhyb3VnaEZuO1xuICAgICAgICB0aGlzLm1vZGVzID0gcGFyYW1zLm1vZGVzO1xuICAgIH1cbiAgICBwdXNoKGNodW5rKSB7XG4gICAgICAgIHRoaXMucGFzc3Rocm91Z2hGbj8uKGNodW5rKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBwYXNzXG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXJyb3IoZSkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuZXJyb3IoZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Call: () => (/* binding */ Call),\n/* harmony export */   isCall: () => (/* binding */ isCall)\n/* harmony export */ });\nclass Call {\n    constructor({ func, name, input, retry, callbacks }) {\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"input\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"retry\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"callbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"__lg_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"call\"\n        });\n        this.func = func;\n        this.name = name;\n        this.input = input;\n        this.retry = retry;\n        this.callbacks = callbacks;\n    }\n}\nfunction isCall(value) {\n    return (typeof value === \"object\" &&\n        value !== null &&\n        \"__lg_type\" in value &&\n        value.__lg_type === \"call\");\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQLGtCQUFrQixxQ0FBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXGRpc3RcXHByZWdlbFxcdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIENhbGwge1xuICAgIGNvbnN0cnVjdG9yKHsgZnVuYywgbmFtZSwgaW5wdXQsIHJldHJ5LCBjYWxsYmFja3MgfSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmV0cnlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fbGdfdHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJjYWxsXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yZXRyeSA9IHJldHJ5O1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDYWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgXCJfX2xnX3R5cGVcIiBpbiB2YWx1ZSAmJlxuICAgICAgICB2YWx1ZS5fX2xnX3R5cGUgPT09IFwiY2FsbFwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/config.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/utils/config.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureLangGraphConfig: () => (/* binding */ ensureLangGraphConfig),\n/* harmony export */   getConfig: () => (/* binding */ getConfig),\n/* harmony export */   getCurrentTaskInput: () => (/* binding */ getCurrentTaskInput),\n/* harmony export */   getParentCheckpointNamespace: () => (/* binding */ getParentCheckpointNamespace),\n/* harmony export */   getStore: () => (/* binding */ getStore),\n/* harmony export */   getWriter: () => (/* binding */ getWriter),\n/* harmony export */   recastCheckpointNamespace: () => (/* binding */ recastCheckpointNamespace)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/singletons */ \"(rsc)/./node_modules/@langchain/core/singletons.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n\n\nconst COPIABLE_KEYS = [\"tags\", \"metadata\", \"callbacks\", \"configurable\"];\nconst CONFIG_KEYS = [\n    \"tags\",\n    \"metadata\",\n    \"callbacks\",\n    \"runName\",\n    \"maxConcurrency\",\n    \"recursionLimit\",\n    \"configurable\",\n    \"runId\",\n    \"outputKeys\",\n    \"streamMode\",\n    \"store\",\n    \"writer\",\n    \"interruptBefore\",\n    \"interruptAfter\",\n    \"signal\",\n];\nconst DEFAULT_RECURSION_LIMIT = 25;\nfunction ensureLangGraphConfig(...configs) {\n    const empty = {\n        tags: [],\n        metadata: {},\n        callbacks: undefined,\n        recursionLimit: DEFAULT_RECURSION_LIMIT,\n        configurable: {},\n    };\n    const implicitConfig = _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    if (implicitConfig !== undefined) {\n        for (const [k, v] of Object.entries(implicitConfig)) {\n            if (v !== undefined) {\n                if (COPIABLE_KEYS.includes(k)) {\n                    let copiedValue;\n                    if (Array.isArray(v)) {\n                        copiedValue = [...v];\n                    }\n                    else if (typeof v === \"object\") {\n                        if (k === \"callbacks\" &&\n                            \"copy\" in v &&\n                            typeof v.copy === \"function\") {\n                            copiedValue = v.copy();\n                        }\n                        else {\n                            copiedValue = { ...v };\n                        }\n                    }\n                    else {\n                        copiedValue = v;\n                    }\n                    empty[k] = copiedValue;\n                }\n                else {\n                    empty[k] = v;\n                }\n            }\n        }\n    }\n    for (const config of configs) {\n        if (config === undefined) {\n            continue;\n        }\n        for (const [k, v] of Object.entries(config)) {\n            if (v !== undefined && CONFIG_KEYS.includes(k)) {\n                empty[k] = v;\n            }\n        }\n    }\n    for (const [key, value] of Object.entries(empty.configurable)) {\n        empty.metadata = empty.metadata ?? {};\n        if (!key.startsWith(\"__\") &&\n            (typeof value === \"string\" ||\n                typeof value === \"number\" ||\n                typeof value === \"boolean\") &&\n            !(key in empty.metadata)) {\n            empty.metadata[key] = value;\n        }\n    }\n    return empty;\n}\n/**\n * A helper utility function that returns the {@link BaseStore} that was set when the graph was initialized\n *\n * @returns a reference to the {@link BaseStore} that was set when the graph was initialized\n */\nfunction getStore(config) {\n    const runConfig = config ?? _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    if (runConfig === undefined) {\n        throw new Error([\n            \"Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.\",\n            \"If you're running `getStore` in such environment, pass the `config` from the node function directly.\",\n        ].join(\"\\n\"));\n    }\n    return runConfig?.store;\n}\n/**\n * A helper utility function that returns the {@link LangGraphRunnableConfig#writer} if \"custom\" stream mode is enabled, otherwise undefined.\n *\n * @returns a reference to the {@link LangGraphRunnableConfig#writer} if \"custom\" stream mode is enabled, otherwise undefined\n */\nfunction getWriter(config) {\n    const runConfig = config ?? _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    if (runConfig === undefined) {\n        throw new Error([\n            \"Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.\",\n            \"If you're running `getWriter` in such environment, pass the `config` from the node function directly.\",\n        ].join(\"\\n\"));\n    }\n    return runConfig?.configurable?.writer;\n}\n/**\n * A helper utility function that returns the {@link LangGraphRunnableConfig} that was set when the graph was initialized.\n *\n * Note: This only works when running in an environment that supports node:async_hooks and AsyncLocalStorage. If you're running this in a\n * web environment, access the LangGraphRunnableConfig from the node function directly.\n *\n * @returns the {@link LangGraphRunnableConfig} that was set when the graph was initialized\n */\nfunction getConfig() {\n    return _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n}\n/**\n * A helper utility function that returns the input for the currently executing task\n *\n * @returns the input for the currently executing task\n */\nfunction getCurrentTaskInput(config) {\n    const runConfig = config ?? _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    if (runConfig === undefined) {\n        throw new Error([\n            \"Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.\",\n            \"If you're running `getCurrentTaskInput` in such environment, pass the `config` from the node function directly.\",\n        ].join(\"\\n\"));\n    }\n    if (runConfig.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONFIG_KEY_SCRATCHPAD]?.currentTaskInput ===\n        undefined) {\n        throw new Error(\"BUG: internal scratchpad not initialized.\");\n    }\n    return runConfig.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONFIG_KEY_SCRATCHPAD].currentTaskInput;\n}\nfunction recastCheckpointNamespace(namespace) {\n    return namespace\n        .split(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_NAMESPACE_SEPARATOR)\n        .filter((part) => !part.match(/^\\d+$/))\n        .map((part) => part.split(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_NAMESPACE_END)[0])\n        .join(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_NAMESPACE_SEPARATOR);\n}\nfunction getParentCheckpointNamespace(namespace) {\n    const parts = namespace.split(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_NAMESPACE_SEPARATOR);\n    while (parts.length > 1 && parts[parts.length - 1].match(/^\\d+$/)) {\n        parts.pop();\n    }\n    return parts.slice(0, -1).join(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_NAMESPACE_SEPARATOR);\n}\n//# sourceMappingURL=config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvdXRpbHMvY29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFnRjtBQUNzQztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMkJBQTJCLDBGQUFrQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDTztBQUNQLGdDQUFnQywwRkFBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNDQUFzQztBQUNyRjtBQUNBLGdDQUFnQyxzQ0FBc0M7QUFDdEU7QUFDTztBQUNQLGdDQUFnQywwRkFBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLCtCQUErQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDTztBQUNQLFdBQVcsMEZBQWtDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0NBQWdDLDBGQUFrQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0VBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnRUFBcUI7QUFDdkQ7QUFDTztBQUNQO0FBQ0EsZUFBZSx5RUFBOEI7QUFDN0M7QUFDQSxrQ0FBa0MsbUVBQXdCO0FBQzFELGNBQWMseUVBQThCO0FBQzVDO0FBQ087QUFDUCxrQ0FBa0MseUVBQThCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5RUFBOEI7QUFDakU7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXGRpc3RcXHByZWdlbFxcdXRpbHNcXGNvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9zaW5nbGV0b25zXCI7XG5pbXBvcnQgeyBDSEVDS1BPSU5UX05BTUVTUEFDRV9FTkQsIENIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUiwgQ09ORklHX0tFWV9TQ1JBVENIUEFELCB9IGZyb20gXCIuLi8uLi9jb25zdGFudHMuanNcIjtcbmNvbnN0IENPUElBQkxFX0tFWVMgPSBbXCJ0YWdzXCIsIFwibWV0YWRhdGFcIiwgXCJjYWxsYmFja3NcIiwgXCJjb25maWd1cmFibGVcIl07XG5jb25zdCBDT05GSUdfS0VZUyA9IFtcbiAgICBcInRhZ3NcIixcbiAgICBcIm1ldGFkYXRhXCIsXG4gICAgXCJjYWxsYmFja3NcIixcbiAgICBcInJ1bk5hbWVcIixcbiAgICBcIm1heENvbmN1cnJlbmN5XCIsXG4gICAgXCJyZWN1cnNpb25MaW1pdFwiLFxuICAgIFwiY29uZmlndXJhYmxlXCIsXG4gICAgXCJydW5JZFwiLFxuICAgIFwib3V0cHV0S2V5c1wiLFxuICAgIFwic3RyZWFtTW9kZVwiLFxuICAgIFwic3RvcmVcIixcbiAgICBcIndyaXRlclwiLFxuICAgIFwiaW50ZXJydXB0QmVmb3JlXCIsXG4gICAgXCJpbnRlcnJ1cHRBZnRlclwiLFxuICAgIFwic2lnbmFsXCIsXG5dO1xuY29uc3QgREVGQVVMVF9SRUNVUlNJT05fTElNSVQgPSAyNTtcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVMYW5nR3JhcGhDb25maWcoLi4uY29uZmlncykge1xuICAgIGNvbnN0IGVtcHR5ID0ge1xuICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgICBjYWxsYmFja3M6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVjdXJzaW9uTGltaXQ6IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlULFxuICAgICAgICBjb25maWd1cmFibGU6IHt9LFxuICAgIH07XG4gICAgY29uc3QgaW1wbGljaXRDb25maWcgPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLmdldFJ1bm5hYmxlQ29uZmlnKCk7XG4gICAgaWYgKGltcGxpY2l0Q29uZmlnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoaW1wbGljaXRDb25maWcpKSB7XG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKENPUElBQkxFX0tFWVMuaW5jbHVkZXMoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvcGllZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29waWVkVmFsdWUgPSBbLi4udl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrID09PSBcImNhbGxiYWNrc1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb3B5XCIgaW4gdiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2LmNvcHkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcGllZFZhbHVlID0gdi5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3BpZWRWYWx1ZSA9IHsgLi4udiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29waWVkVmFsdWUgPSB2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5W2tdID0gY29waWVkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhjb25maWcpKSB7XG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmIENPTkZJR19LRVlTLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICAgICAgZW1wdHlba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGVtcHR5LmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgZW1wdHkubWV0YWRhdGEgPSBlbXB0eS5tZXRhZGF0YSA/PyB7fTtcbiAgICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aChcIl9fXCIpICYmXG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikgJiZcbiAgICAgICAgICAgICEoa2V5IGluIGVtcHR5Lm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgZW1wdHkubWV0YWRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbn1cbi8qKlxuICogQSBoZWxwZXIgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHtAbGluayBCYXNlU3RvcmV9IHRoYXQgd2FzIHNldCB3aGVuIHRoZSBncmFwaCB3YXMgaW5pdGlhbGl6ZWRcbiAqXG4gKiBAcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUge0BsaW5rIEJhc2VTdG9yZX0gdGhhdCB3YXMgc2V0IHdoZW4gdGhlIGdyYXBoIHdhcyBpbml0aWFsaXplZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmUoY29uZmlnKSB7XG4gICAgY29uc3QgcnVuQ29uZmlnID0gY29uZmlnID8/IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0UnVubmFibGVDb25maWcoKTtcbiAgICBpZiAocnVuQ29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgICAgIFwiQ29uZmlnIG5vdCByZXRyaWV2YWJsZS4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSB5b3UgYXJlIHJ1bm5pbmcgaW4gYW4gZW52aXJvbm1lbnQgd2l0aG91dCBzdXBwb3J0IGZvciBBc3luY0xvY2FsU3RvcmFnZS5cIixcbiAgICAgICAgICAgIFwiSWYgeW91J3JlIHJ1bm5pbmcgYGdldFN0b3JlYCBpbiBzdWNoIGVudmlyb25tZW50LCBwYXNzIHRoZSBgY29uZmlnYCBmcm9tIHRoZSBub2RlIGZ1bmN0aW9uIGRpcmVjdGx5LlwiLFxuICAgICAgICBdLmpvaW4oXCJcXG5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcnVuQ29uZmlnPy5zdG9yZTtcbn1cbi8qKlxuICogQSBoZWxwZXIgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHtAbGluayBMYW5nR3JhcGhSdW5uYWJsZUNvbmZpZyN3cml0ZXJ9IGlmIFwiY3VzdG9tXCIgc3RyZWFtIG1vZGUgaXMgZW5hYmxlZCwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAqXG4gKiBAcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUge0BsaW5rIExhbmdHcmFwaFJ1bm5hYmxlQ29uZmlnI3dyaXRlcn0gaWYgXCJjdXN0b21cIiBzdHJlYW0gbW9kZSBpcyBlbmFibGVkLCBvdGhlcndpc2UgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXcml0ZXIoY29uZmlnKSB7XG4gICAgY29uc3QgcnVuQ29uZmlnID0gY29uZmlnID8/IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0UnVubmFibGVDb25maWcoKTtcbiAgICBpZiAocnVuQ29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgICAgIFwiQ29uZmlnIG5vdCByZXRyaWV2YWJsZS4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSB5b3UgYXJlIHJ1bm5pbmcgaW4gYW4gZW52aXJvbm1lbnQgd2l0aG91dCBzdXBwb3J0IGZvciBBc3luY0xvY2FsU3RvcmFnZS5cIixcbiAgICAgICAgICAgIFwiSWYgeW91J3JlIHJ1bm5pbmcgYGdldFdyaXRlcmAgaW4gc3VjaCBlbnZpcm9ubWVudCwgcGFzcyB0aGUgYGNvbmZpZ2AgZnJvbSB0aGUgbm9kZSBmdW5jdGlvbiBkaXJlY3RseS5cIixcbiAgICAgICAgXS5qb2luKFwiXFxuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bkNvbmZpZz8uY29uZmlndXJhYmxlPy53cml0ZXI7XG59XG4vKipcbiAqIEEgaGVscGVyIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB7QGxpbmsgTGFuZ0dyYXBoUnVubmFibGVDb25maWd9IHRoYXQgd2FzIHNldCB3aGVuIHRoZSBncmFwaCB3YXMgaW5pdGlhbGl6ZWQuXG4gKlxuICogTm90ZTogVGhpcyBvbmx5IHdvcmtzIHdoZW4gcnVubmluZyBpbiBhbiBlbnZpcm9ubWVudCB0aGF0IHN1cHBvcnRzIG5vZGU6YXN5bmNfaG9va3MgYW5kIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB5b3UncmUgcnVubmluZyB0aGlzIGluIGFcbiAqIHdlYiBlbnZpcm9ubWVudCwgYWNjZXNzIHRoZSBMYW5nR3JhcGhSdW5uYWJsZUNvbmZpZyBmcm9tIHRoZSBub2RlIGZ1bmN0aW9uIGRpcmVjdGx5LlxuICpcbiAqIEByZXR1cm5zIHRoZSB7QGxpbmsgTGFuZ0dyYXBoUnVubmFibGVDb25maWd9IHRoYXQgd2FzIHNldCB3aGVuIHRoZSBncmFwaCB3YXMgaW5pdGlhbGl6ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbmZpZygpIHtcbiAgICByZXR1cm4gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRSdW5uYWJsZUNvbmZpZygpO1xufVxuLyoqXG4gKiBBIGhlbHBlciB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgaW5wdXQgZm9yIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHRhc2tcbiAqXG4gKiBAcmV0dXJucyB0aGUgaW5wdXQgZm9yIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHRhc2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRUYXNrSW5wdXQoY29uZmlnKSB7XG4gICAgY29uc3QgcnVuQ29uZmlnID0gY29uZmlnID8/IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0UnVubmFibGVDb25maWcoKTtcbiAgICBpZiAocnVuQ29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgICAgIFwiQ29uZmlnIG5vdCByZXRyaWV2YWJsZS4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSB5b3UgYXJlIHJ1bm5pbmcgaW4gYW4gZW52aXJvbm1lbnQgd2l0aG91dCBzdXBwb3J0IGZvciBBc3luY0xvY2FsU3RvcmFnZS5cIixcbiAgICAgICAgICAgIFwiSWYgeW91J3JlIHJ1bm5pbmcgYGdldEN1cnJlbnRUYXNrSW5wdXRgIGluIHN1Y2ggZW52aXJvbm1lbnQsIHBhc3MgdGhlIGBjb25maWdgIGZyb20gdGhlIG5vZGUgZnVuY3Rpb24gZGlyZWN0bHkuXCIsXG4gICAgICAgIF0uam9pbihcIlxcblwiKSk7XG4gICAgfVxuICAgIGlmIChydW5Db25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9TQ1JBVENIUEFEXT8uY3VycmVudFRhc2tJbnB1dCA9PT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogaW50ZXJuYWwgc2NyYXRjaHBhZCBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcnVuQ29uZmlnLmNvbmZpZ3VyYWJsZVtDT05GSUdfS0VZX1NDUkFUQ0hQQURdLmN1cnJlbnRUYXNrSW5wdXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjYXN0Q2hlY2twb2ludE5hbWVzcGFjZShuYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gbmFtZXNwYWNlXG4gICAgICAgIC5zcGxpdChDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IpXG4gICAgICAgIC5maWx0ZXIoKHBhcnQpID0+ICFwYXJ0Lm1hdGNoKC9eXFxkKyQvKSlcbiAgICAgICAgLm1hcCgocGFydCkgPT4gcGFydC5zcGxpdChDSEVDS1BPSU5UX05BTUVTUEFDRV9FTkQpWzBdKVxuICAgICAgICAuam9pbihDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmVudENoZWNrcG9pbnROYW1lc3BhY2UobmFtZXNwYWNlKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lc3BhY2Uuc3BsaXQoQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SKTtcbiAgICB3aGlsZSAocGFydHMubGVuZ3RoID4gMSAmJiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5zbGljZSgwLCAtMSkuam9pbihDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/utils/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _coerceToDict: () => (/* binding */ _coerceToDict),\n/* harmony export */   combineAbortSignals: () => (/* binding */ combineAbortSignals),\n/* harmony export */   getNewChannelVersions: () => (/* binding */ getNewChannelVersions),\n/* harmony export */   getNullChannelVersion: () => (/* binding */ getNullChannelVersion),\n/* harmony export */   patchCheckpointMap: () => (/* binding */ patchCheckpointMap),\n/* harmony export */   patchConfigurable: () => (/* binding */ patchConfigurable)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n\nfunction getNullChannelVersion(currentVersions) {\n    const versionValues = Object.values(currentVersions);\n    const versionType = versionValues.length > 0 ? typeof versionValues[0] : undefined;\n    let nullVersion;\n    if (versionType === \"number\") {\n        nullVersion = 0;\n    }\n    else if (versionType === \"string\") {\n        nullVersion = \"\";\n    }\n    return nullVersion;\n}\nfunction getNewChannelVersions(previousVersions, currentVersions) {\n    // Get new channel versions\n    if (Object.keys(previousVersions).length > 0) {\n        const nullVersion = getNullChannelVersion(currentVersions);\n        return Object.fromEntries(Object.entries(currentVersions).filter(([k, v]) => v > (previousVersions[k] ?? nullVersion)));\n    }\n    else {\n        return currentVersions;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nfunction patchConfigurable(config, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\npatch) {\n    if (config === null) {\n        return { configurable: patch };\n    }\n    else if (config?.configurable === undefined) {\n        return { ...config, configurable: patch };\n    }\n    else {\n        return {\n            ...config,\n            configurable: { ...config.configurable, ...patch },\n        };\n    }\n}\nfunction patchCheckpointMap(config, metadata) {\n    const parents = metadata?.parents ?? {};\n    if (Object.keys(parents).length > 0) {\n        return patchConfigurable(config, {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONFIG_KEY_CHECKPOINT_MAP]: {\n                ...parents,\n                [config.configurable?.checkpoint_ns ?? \"\"]: config.configurable?.checkpoint_id,\n            },\n        });\n    }\n    else {\n        return config;\n    }\n}\n/**\n * Combine multiple abort signals into a single abort signal.\n * @param signals - The abort signals to combine.\n * @returns A single abort signal that is aborted if any of the input signals are aborted.\n */\nfunction combineAbortSignals(...signals) {\n    if (signals.length === 1) {\n        return signals[0];\n    }\n    // AbortSignal.any() does seem to suffer from memory leaks\n    // @see https://github.com/nodejs/node/issues/55328\n    // if (\"any\" in AbortSignal) {\n    //   // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    //   return (AbortSignal as any).any(signals);\n    // }\n    const combinedController = new AbortController();\n    const listener = () => {\n        combinedController.abort();\n        signals.forEach((s) => s.removeEventListener(\"abort\", listener));\n    };\n    signals.forEach((s) => s.addEventListener(\"abort\", listener));\n    if (signals.some((s) => s.aborted)) {\n        combinedController.abort();\n    }\n    return combinedController.signal;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUErRDtBQUN4RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtDQUFrQztBQUM5RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQXlCO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxwcmVnZWxcXHV0aWxzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50cy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGdldE51bGxDaGFubmVsVmVyc2lvbihjdXJyZW50VmVyc2lvbnMpIHtcbiAgICBjb25zdCB2ZXJzaW9uVmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjdXJyZW50VmVyc2lvbnMpO1xuICAgIGNvbnN0IHZlcnNpb25UeXBlID0gdmVyc2lvblZhbHVlcy5sZW5ndGggPiAwID8gdHlwZW9mIHZlcnNpb25WYWx1ZXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgbGV0IG51bGxWZXJzaW9uO1xuICAgIGlmICh2ZXJzaW9uVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBudWxsVmVyc2lvbiA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZlcnNpb25UeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG51bGxWZXJzaW9uID0gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGxWZXJzaW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5ld0NoYW5uZWxWZXJzaW9ucyhwcmV2aW91c1ZlcnNpb25zLCBjdXJyZW50VmVyc2lvbnMpIHtcbiAgICAvLyBHZXQgbmV3IGNoYW5uZWwgdmVyc2lvbnNcbiAgICBpZiAoT2JqZWN0LmtleXMocHJldmlvdXNWZXJzaW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBudWxsVmVyc2lvbiA9IGdldE51bGxDaGFubmVsVmVyc2lvbihjdXJyZW50VmVyc2lvbnMpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGN1cnJlbnRWZXJzaW9ucykuZmlsdGVyKChbaywgdl0pID0+IHYgPiAocHJldmlvdXNWZXJzaW9uc1trXSA/PyBudWxsVmVyc2lvbikpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmVyc2lvbnM7XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoQ29uZmlndXJhYmxlKGNvbmZpZywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucGF0Y2gpIHtcbiAgICBpZiAoY29uZmlnID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7IGNvbmZpZ3VyYWJsZTogcGF0Y2ggfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29uZmlnPy5jb25maWd1cmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4geyAuLi5jb25maWcsIGNvbmZpZ3VyYWJsZTogcGF0Y2ggfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHsgLi4uY29uZmlnLmNvbmZpZ3VyYWJsZSwgLi4ucGF0Y2ggfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDaGVja3BvaW50TWFwKGNvbmZpZywgbWV0YWRhdGEpIHtcbiAgICBjb25zdCBwYXJlbnRzID0gbWV0YWRhdGE/LnBhcmVudHMgPz8ge307XG4gICAgaWYgKE9iamVjdC5rZXlzKHBhcmVudHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHBhdGNoQ29uZmlndXJhYmxlKGNvbmZpZywge1xuICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVBdOiB7XG4gICAgICAgICAgICAgICAgLi4ucGFyZW50cyxcbiAgICAgICAgICAgICAgICBbY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9ucyA/PyBcIlwiXTogY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9pZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59XG4vKipcbiAqIENvbWJpbmUgbXVsdGlwbGUgYWJvcnQgc2lnbmFscyBpbnRvIGEgc2luZ2xlIGFib3J0IHNpZ25hbC5cbiAqIEBwYXJhbSBzaWduYWxzIC0gVGhlIGFib3J0IHNpZ25hbHMgdG8gY29tYmluZS5cbiAqIEByZXR1cm5zIEEgc2luZ2xlIGFib3J0IHNpZ25hbCB0aGF0IGlzIGFib3J0ZWQgaWYgYW55IG9mIHRoZSBpbnB1dCBzaWduYWxzIGFyZSBhYm9ydGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUFib3J0U2lnbmFscyguLi5zaWduYWxzKSB7XG4gICAgaWYgKHNpZ25hbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzaWduYWxzWzBdO1xuICAgIH1cbiAgICAvLyBBYm9ydFNpZ25hbC5hbnkoKSBkb2VzIHNlZW0gdG8gc3VmZmVyIGZyb20gbWVtb3J5IGxlYWtzXG4gICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzU1MzI4XG4gICAgLy8gaWYgKFwiYW55XCIgaW4gQWJvcnRTaWduYWwpIHtcbiAgICAvLyAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgLy8gICByZXR1cm4gKEFib3J0U2lnbmFsIGFzIGFueSkuYW55KHNpZ25hbHMpO1xuICAgIC8vIH1cbiAgICBjb25zdCBjb21iaW5lZENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbWJpbmVkQ29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICBzaWduYWxzLmZvckVhY2goKHMpID0+IHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKSk7XG4gICAgfTtcbiAgICBzaWduYWxzLmZvckVhY2goKHMpID0+IHMuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKSk7XG4gICAgaWYgKHNpZ25hbHMuc29tZSgocykgPT4gcy5hYm9ydGVkKSkge1xuICAgICAgICBjb21iaW5lZENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmVkQ29udHJvbGxlci5zaWduYWw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findSubgraphPregel: () => (/* binding */ findSubgraphPregel),\n/* harmony export */   isPregelLike: () => (/* binding */ isPregelLike)\n/* harmony export */ });\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableSequence(x) {\n    return \"steps\" in x && Array.isArray(x.steps);\n}\nfunction isPregelLike(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nx\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    return \"lg_is_pregel\" in x && x.lg_is_pregel === true;\n}\nfunction findSubgraphPregel(candidate\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const candidates = [candidate];\n    for (const candidate of candidates) {\n        if (isPregelLike(candidate)) {\n            return candidate;\n        }\n        else if (isRunnableSequence(candidate)) {\n            candidates.push(...candidate.steps);\n        }\n    }\n    return undefined;\n}\n//# sourceMappingURL=subgraph.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvdXRpbHMvc3ViZ3JhcGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxccHJlZ2VsXFx1dGlsc1xcc3ViZ3JhcGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGlzUnVubmFibGVTZXF1ZW5jZSh4KSB7XG4gICAgcmV0dXJuIFwic3RlcHNcIiBpbiB4ICYmIEFycmF5LmlzQXJyYXkoeC5zdGVwcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQcmVnZWxMaWtlKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICByZXR1cm4gXCJsZ19pc19wcmVnZWxcIiBpbiB4ICYmIHgubGdfaXNfcHJlZ2VsID09PSB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRTdWJncmFwaFByZWdlbChjYW5kaWRhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gW2NhbmRpZGF0ZV07XG4gICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgICBpZiAoaXNQcmVnZWxMaWtlKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSdW5uYWJsZVNlcXVlbmNlKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5jYW5kaWRhdGUuc3RlcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJncmFwaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/validate.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/validate.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GraphValidationError: () => (/* binding */ GraphValidationError),\n/* harmony export */   validateGraph: () => (/* binding */ validateGraph),\n/* harmony export */   validateKeys: () => (/* binding */ validateKeys)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _read_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./read.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/read.js\");\n\n\nclass GraphValidationError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"GraphValidationError\";\n    }\n}\nfunction validateGraph({ nodes, channels, inputChannels, outputChannels, streamChannels, interruptAfterNodes, interruptBeforeNodes, }) {\n    if (!channels) {\n        throw new GraphValidationError(\"Channels not provided\");\n    }\n    const subscribedChannels = new Set();\n    const allOutputChannels = new Set();\n    for (const [name, node] of Object.entries(nodes)) {\n        if (name === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT) {\n            throw new GraphValidationError(`\"Node name ${_constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT} is reserved\"`);\n        }\n        if (node.constructor === _read_js__WEBPACK_IMPORTED_MODULE_1__.PregelNode) {\n            node.triggers.forEach((trigger) => subscribedChannels.add(trigger));\n        }\n        else {\n            throw new GraphValidationError(`Invalid node type ${typeof node}, expected PregelNode`);\n        }\n    }\n    // side effect: update channels\n    for (const chan of subscribedChannels) {\n        if (!(chan in channels)) {\n            throw new GraphValidationError(`Subcribed channel '${String(chan)}' not in channels`);\n        }\n    }\n    if (!Array.isArray(inputChannels)) {\n        if (!subscribedChannels.has(inputChannels)) {\n            throw new GraphValidationError(`Input channel ${String(inputChannels)} is not subscribed to by any node`);\n        }\n    }\n    else {\n        if (inputChannels.every((channel) => !subscribedChannels.has(channel))) {\n            throw new GraphValidationError(`None of the input channels ${inputChannels} are subscribed to by any node`);\n        }\n    }\n    if (!Array.isArray(outputChannels)) {\n        allOutputChannels.add(outputChannels);\n    }\n    else {\n        outputChannels.forEach((chan) => allOutputChannels.add(chan));\n    }\n    if (streamChannels && !Array.isArray(streamChannels)) {\n        allOutputChannels.add(streamChannels);\n    }\n    else if (Array.isArray(streamChannels)) {\n        streamChannels.forEach((chan) => allOutputChannels.add(chan));\n    }\n    for (const chan of allOutputChannels) {\n        if (!(chan in channels)) {\n            throw new GraphValidationError(`Output channel '${String(chan)}' not in channels`);\n        }\n    }\n    // validate interrupt before/after\n    if (interruptAfterNodes && interruptAfterNodes !== \"*\") {\n        for (const node of interruptAfterNodes) {\n            if (!(node in nodes)) {\n                throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n            }\n        }\n    }\n    if (interruptBeforeNodes && interruptBeforeNodes !== \"*\") {\n        for (const node of interruptBeforeNodes) {\n            if (!(node in nodes)) {\n                throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n            }\n        }\n    }\n}\nfunction validateKeys(keys, channels) {\n    if (Array.isArray(keys)) {\n        for (const key of keys) {\n            if (!(key in channels)) {\n                throw new Error(`Key ${String(key)} not found in channels`);\n            }\n        }\n    }\n    else {\n        if (!(keys in channels)) {\n            throw new Error(`Key ${String(keys)} not found in channels`);\n        }\n    }\n}\n//# sourceMappingURL=validate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEM7QUFDTDtBQUNoQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIsNEdBQTRHO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBUztBQUM5Qix5REFBeUQsb0RBQVMsRUFBRTtBQUNwRTtBQUNBLGlDQUFpQyxnREFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsWUFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGFBQWE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsdUJBQXVCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsYUFBYTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxc5bel5L2c55uu5b2VXFxkcm9uZXdvcmtmbG93XFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGxhbmdncmFwaFxcZGlzdFxccHJlZ2VsXFx2YWxpZGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJTlRFUlJVUFQgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBQcmVnZWxOb2RlIH0gZnJvbSBcIi4vcmVhZC5qc1wiO1xuZXhwb3J0IGNsYXNzIEdyYXBoVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiR3JhcGhWYWxpZGF0aW9uRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVHcmFwaCh7IG5vZGVzLCBjaGFubmVscywgaW5wdXRDaGFubmVscywgb3V0cHV0Q2hhbm5lbHMsIHN0cmVhbUNoYW5uZWxzLCBpbnRlcnJ1cHRBZnRlck5vZGVzLCBpbnRlcnJ1cHRCZWZvcmVOb2RlcywgfSkge1xuICAgIGlmICghY2hhbm5lbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEdyYXBoVmFsaWRhdGlvbkVycm9yKFwiQ2hhbm5lbHMgbm90IHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdWJzY3JpYmVkQ2hhbm5lbHMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgYWxsT3V0cHV0Q2hhbm5lbHMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgbm9kZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZXMpKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBJTlRFUlJVUFQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcmFwaFZhbGlkYXRpb25FcnJvcihgXCJOb2RlIG5hbWUgJHtJTlRFUlJVUFR9IGlzIHJlc2VydmVkXCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5jb25zdHJ1Y3RvciA9PT0gUHJlZ2VsTm9kZSkge1xuICAgICAgICAgICAgbm9kZS50cmlnZ2Vycy5mb3JFYWNoKCh0cmlnZ2VyKSA9PiBzdWJzY3JpYmVkQ2hhbm5lbHMuYWRkKHRyaWdnZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcmFwaFZhbGlkYXRpb25FcnJvcihgSW52YWxpZCBub2RlIHR5cGUgJHt0eXBlb2Ygbm9kZX0sIGV4cGVjdGVkIFByZWdlbE5vZGVgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzaWRlIGVmZmVjdDogdXBkYXRlIGNoYW5uZWxzXG4gICAgZm9yIChjb25zdCBjaGFuIG9mIHN1YnNjcmliZWRDaGFubmVscykge1xuICAgICAgICBpZiAoIShjaGFuIGluIGNoYW5uZWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoVmFsaWRhdGlvbkVycm9yKGBTdWJjcmliZWQgY2hhbm5lbCAnJHtTdHJpbmcoY2hhbil9JyBub3QgaW4gY2hhbm5lbHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXRDaGFubmVscykpIHtcbiAgICAgICAgaWYgKCFzdWJzY3JpYmVkQ2hhbm5lbHMuaGFzKGlucHV0Q2hhbm5lbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhWYWxpZGF0aW9uRXJyb3IoYElucHV0IGNoYW5uZWwgJHtTdHJpbmcoaW5wdXRDaGFubmVscyl9IGlzIG5vdCBzdWJzY3JpYmVkIHRvIGJ5IGFueSBub2RlYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpbnB1dENoYW5uZWxzLmV2ZXJ5KChjaGFubmVsKSA9PiAhc3Vic2NyaWJlZENoYW5uZWxzLmhhcyhjaGFubmVsKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcmFwaFZhbGlkYXRpb25FcnJvcihgTm9uZSBvZiB0aGUgaW5wdXQgY2hhbm5lbHMgJHtpbnB1dENoYW5uZWxzfSBhcmUgc3Vic2NyaWJlZCB0byBieSBhbnkgbm9kZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvdXRwdXRDaGFubmVscykpIHtcbiAgICAgICAgYWxsT3V0cHV0Q2hhbm5lbHMuYWRkKG91dHB1dENoYW5uZWxzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG91dHB1dENoYW5uZWxzLmZvckVhY2goKGNoYW4pID0+IGFsbE91dHB1dENoYW5uZWxzLmFkZChjaGFuKSk7XG4gICAgfVxuICAgIGlmIChzdHJlYW1DaGFubmVscyAmJiAhQXJyYXkuaXNBcnJheShzdHJlYW1DaGFubmVscykpIHtcbiAgICAgICAgYWxsT3V0cHV0Q2hhbm5lbHMuYWRkKHN0cmVhbUNoYW5uZWxzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1DaGFubmVscykpIHtcbiAgICAgICAgc3RyZWFtQ2hhbm5lbHMuZm9yRWFjaCgoY2hhbikgPT4gYWxsT3V0cHV0Q2hhbm5lbHMuYWRkKGNoYW4pKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaGFuIG9mIGFsbE91dHB1dENoYW5uZWxzKSB7XG4gICAgICAgIGlmICghKGNoYW4gaW4gY2hhbm5lbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhWYWxpZGF0aW9uRXJyb3IoYE91dHB1dCBjaGFubmVsICcke1N0cmluZyhjaGFuKX0nIG5vdCBpbiBjaGFubmVsc2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHZhbGlkYXRlIGludGVycnVwdCBiZWZvcmUvYWZ0ZXJcbiAgICBpZiAoaW50ZXJydXB0QWZ0ZXJOb2RlcyAmJiBpbnRlcnJ1cHRBZnRlck5vZGVzICE9PSBcIipcIikge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaW50ZXJydXB0QWZ0ZXJOb2Rlcykge1xuICAgICAgICAgICAgaWYgKCEobm9kZSBpbiBub2RlcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhWYWxpZGF0aW9uRXJyb3IoYE5vZGUgJHtTdHJpbmcobm9kZSl9IG5vdCBpbiBub2Rlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbnRlcnJ1cHRCZWZvcmVOb2RlcyAmJiBpbnRlcnJ1cHRCZWZvcmVOb2RlcyAhPT0gXCIqXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGludGVycnVwdEJlZm9yZU5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoIShub2RlIGluIG5vZGVzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHcmFwaFZhbGlkYXRpb25FcnJvcihgTm9kZSAke1N0cmluZyhub2RlKX0gbm90IGluIG5vZGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVLZXlzKGtleXMsIGNoYW5uZWxzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGNoYW5uZWxzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICR7U3RyaW5nKGtleSl9IG5vdCBmb3VuZCBpbiBjaGFubmVsc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIShrZXlzIGluIGNoYW5uZWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJHtTdHJpbmcoa2V5cyl9IG5vdCBmb3VuZCBpbiBjaGFubmVsc2ApO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/pregel/write.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/pregel/write.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelWrite: () => (/* binding */ ChannelWrite),\n/* harmony export */   PASSTHROUGH: () => (/* binding */ PASSTHROUGH),\n/* harmony export */   SKIP_WRITE: () => (/* binding */ SKIP_WRITE)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n\n\n\n\nconst SKIP_WRITE = {\n    [Symbol.for(\"LG_SKIP_WRITE\")]: true,\n};\nfunction _isSkipWrite(x) {\n    return (typeof x === \"object\" &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        x?.[Symbol.for(\"LG_SKIP_WRITE\")] !== undefined);\n}\nconst PASSTHROUGH = {\n    [Symbol.for(\"LG_PASSTHROUGH\")]: true,\n};\nfunction _isPassthrough(x) {\n    return (typeof x === \"object\" &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        x?.[Symbol.for(\"LG_PASSTHROUGH\")] !== undefined);\n}\nconst IS_WRITER = Symbol(\"IS_WRITER\");\n/**\n * Mapping of write channels to Runnables that return the value to be written,\n * or None to skip writing.\n */\nclass ChannelWrite extends _utils_js__WEBPACK_IMPORTED_MODULE_2__.RunnableCallable {\n    constructor(writes, tags) {\n        const name = `ChannelWrite<${writes\n            .map((packet) => {\n            if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_1__._isSend)(packet)) {\n                return packet.node;\n            }\n            else if (\"channel\" in packet) {\n                return packet.channel;\n            }\n            return \"...\";\n        })\n            .join(\",\")}>`;\n        super({\n            ...{ writes, name, tags },\n            func: async (input, config) => {\n                return this._write(input, config ?? {});\n            },\n        });\n        Object.defineProperty(this, \"writes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.writes = writes;\n    }\n    async _write(input, config) {\n        const writes = this.writes.map((write) => {\n            if (_isChannelWriteTupleEntry(write) && _isPassthrough(write.value)) {\n                return {\n                    mapper: write.mapper,\n                    value: input,\n                };\n            }\n            else if (_isChannelWriteEntry(write) && _isPassthrough(write.value)) {\n                return {\n                    channel: write.channel,\n                    value: input,\n                    skipNone: write.skipNone,\n                    mapper: write.mapper,\n                };\n            }\n            else {\n                return write;\n            }\n        });\n        await ChannelWrite.doWrite(config, writes);\n        return input;\n    }\n    // TODO: Support requireAtLeastOneOf\n    static async doWrite(config, writes) {\n        // validate\n        for (const w of writes) {\n            if (_isChannelWriteEntry(w)) {\n                if (w.channel === _constants_js__WEBPACK_IMPORTED_MODULE_1__.TASKS) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidUpdateError(\"Cannot write to the reserved channel TASKS\");\n                }\n                if (_isPassthrough(w.value)) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n                }\n            }\n            if (_isChannelWriteTupleEntry(w)) {\n                if (_isPassthrough(w.value)) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n                }\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const writeEntries = [];\n        for (const w of writes) {\n            if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_1__._isSend)(w)) {\n                writeEntries.push([_constants_js__WEBPACK_IMPORTED_MODULE_1__.TASKS, w]);\n            }\n            else if (_isChannelWriteTupleEntry(w)) {\n                const mappedResult = await w.mapper.invoke(w.value, config);\n                if (mappedResult != null && mappedResult.length > 0) {\n                    writeEntries.push(...mappedResult);\n                }\n            }\n            else if (_isChannelWriteEntry(w)) {\n                const mappedValue = w.mapper !== undefined\n                    ? await w.mapper.invoke(w.value, config)\n                    : w.value;\n                if (_isSkipWrite(mappedValue)) {\n                    continue;\n                }\n                if (w.skipNone && mappedValue === undefined) {\n                    continue;\n                }\n                writeEntries.push([w.channel, mappedValue]);\n            }\n            else {\n                throw new Error(`Invalid write entry: ${JSON.stringify(w)}`);\n            }\n        }\n        const write = config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONFIG_KEY_SEND];\n        write(writeEntries);\n    }\n    static isWriter(runnable) {\n        return (\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        runnable instanceof ChannelWrite ||\n            (IS_WRITER in runnable && !!runnable[IS_WRITER]));\n    }\n    static registerWriter(runnable) {\n        return Object.defineProperty(runnable, IS_WRITER, { value: true });\n    }\n}\nfunction _isChannelWriteEntry(x) {\n    return (x !== undefined && typeof x.channel === \"string\");\n}\nfunction _isChannelWriteTupleEntry(x) {\n    return (x !== undefined &&\n        !_isChannelWriteEntry(x) &&\n        _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(x.mapper));\n}\n//# sourceMappingURL=write.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvd3JpdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzRDtBQUNZO0FBQ25CO0FBQ0c7QUFDM0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLHVEQUFnQjtBQUNsRDtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGdCQUFnQixzREFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBLHNEQUFzRDtBQUN0RCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0RBQUs7QUFDdkMsOEJBQThCLDBEQUFrQjtBQUNoRDtBQUNBO0FBQ0EsOEJBQThCLDBEQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwREFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFPO0FBQ3ZCLG1DQUFtQyxnREFBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0EsNENBQTRDLDBEQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxhQUFhO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFRO0FBQ2hCO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFxwcmVnZWxcXHdyaXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJ1bm5hYmxlLCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG5pbXBvcnQgeyBfaXNTZW5kLCBDT05GSUdfS0VZX1NFTkQsIFRBU0tTIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgUnVubmFibGVDYWxsYWJsZSB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgSW52YWxpZFVwZGF0ZUVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuZXhwb3J0IGNvbnN0IFNLSVBfV1JJVEUgPSB7XG4gICAgW1N5bWJvbC5mb3IoXCJMR19TS0lQX1dSSVRFXCIpXTogdHJ1ZSxcbn07XG5mdW5jdGlvbiBfaXNTa2lwV3JpdGUoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgeD8uW1N5bWJvbC5mb3IoXCJMR19TS0lQX1dSSVRFXCIpXSAhPT0gdW5kZWZpbmVkKTtcbn1cbmV4cG9ydCBjb25zdCBQQVNTVEhST1VHSCA9IHtcbiAgICBbU3ltYm9sLmZvcihcIkxHX1BBU1NUSFJPVUdIXCIpXTogdHJ1ZSxcbn07XG5mdW5jdGlvbiBfaXNQYXNzdGhyb3VnaCh4KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB4Py5bU3ltYm9sLmZvcihcIkxHX1BBU1NUSFJPVUdIXCIpXSAhPT0gdW5kZWZpbmVkKTtcbn1cbmNvbnN0IElTX1dSSVRFUiA9IFN5bWJvbChcIklTX1dSSVRFUlwiKTtcbi8qKlxuICogTWFwcGluZyBvZiB3cml0ZSBjaGFubmVscyB0byBSdW5uYWJsZXMgdGhhdCByZXR1cm4gdGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4sXG4gKiBvciBOb25lIHRvIHNraXAgd3JpdGluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIENoYW5uZWxXcml0ZSBleHRlbmRzIFJ1bm5hYmxlQ2FsbGFibGUge1xuICAgIGNvbnN0cnVjdG9yKHdyaXRlcywgdGFncykge1xuICAgICAgICBjb25zdCBuYW1lID0gYENoYW5uZWxXcml0ZTwke3dyaXRlc1xuICAgICAgICAgICAgLm1hcCgocGFja2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAoX2lzU2VuZChwYWNrZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldC5ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXCJjaGFubmVsXCIgaW4gcGFja2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldC5jaGFubmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiLi4uXCI7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihcIixcIil9PmA7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIC4uLnsgd3JpdGVzLCBuYW1lLCB0YWdzIH0sXG4gICAgICAgICAgICBmdW5jOiBhc3luYyAoaW5wdXQsIGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0ZShpbnB1dCwgY29uZmlnID8/IHt9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53cml0ZXMgPSB3cml0ZXM7XG4gICAgfVxuICAgIGFzeW5jIF93cml0ZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHdyaXRlcyA9IHRoaXMud3JpdGVzLm1hcCgod3JpdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChfaXNDaGFubmVsV3JpdGVUdXBsZUVudHJ5KHdyaXRlKSAmJiBfaXNQYXNzdGhyb3VnaCh3cml0ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtYXBwZXI6IHdyaXRlLm1hcHBlcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfaXNDaGFubmVsV3JpdGVFbnRyeSh3cml0ZSkgJiYgX2lzUGFzc3Rocm91Z2god3JpdGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogd3JpdGUuY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBza2lwTm9uZTogd3JpdGUuc2tpcE5vbmUsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlcjogd3JpdGUubWFwcGVyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBDaGFubmVsV3JpdGUuZG9Xcml0ZShjb25maWcsIHdyaXRlcyk7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgLy8gVE9ETzogU3VwcG9ydCByZXF1aXJlQXRMZWFzdE9uZU9mXG4gICAgc3RhdGljIGFzeW5jIGRvV3JpdGUoY29uZmlnLCB3cml0ZXMpIHtcbiAgICAgICAgLy8gdmFsaWRhdGVcbiAgICAgICAgZm9yIChjb25zdCB3IG9mIHdyaXRlcykge1xuICAgICAgICAgICAgaWYgKF9pc0NoYW5uZWxXcml0ZUVudHJ5KHcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHcuY2hhbm5lbCA9PT0gVEFTS1MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcGRhdGVFcnJvcihcIkNhbm5vdCB3cml0ZSB0byB0aGUgcmVzZXJ2ZWQgY2hhbm5lbCBUQVNLU1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9pc1Bhc3N0aHJvdWdoKHcudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoXCJQQVNTVEhST1VHSCB2YWx1ZSBtdXN0IGJlIHJlcGxhY2VkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfaXNDaGFubmVsV3JpdGVUdXBsZUVudHJ5KHcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9pc1Bhc3N0aHJvdWdoKHcudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoXCJQQVNTVEhST1VHSCB2YWx1ZSBtdXN0IGJlIHJlcGxhY2VkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCB3cml0ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB3IG9mIHdyaXRlcykge1xuICAgICAgICAgICAgaWYgKF9pc1NlbmQodykpIHtcbiAgICAgICAgICAgICAgICB3cml0ZUVudHJpZXMucHVzaChbVEFTS1MsIHddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF9pc0NoYW5uZWxXcml0ZVR1cGxlRW50cnkodykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWRSZXN1bHQgPSBhd2FpdCB3Lm1hcHBlci5pbnZva2Uody52YWx1ZSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkUmVzdWx0ICE9IG51bGwgJiYgbWFwcGVkUmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVFbnRyaWVzLnB1c2goLi4ubWFwcGVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfaXNDaGFubmVsV3JpdGVFbnRyeSh3KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZFZhbHVlID0gdy5tYXBwZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IHcubWFwcGVyLmludm9rZSh3LnZhbHVlLCBjb25maWcpXG4gICAgICAgICAgICAgICAgICAgIDogdy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoX2lzU2tpcFdyaXRlKG1hcHBlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHcuc2tpcE5vbmUgJiYgbWFwcGVkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVFbnRyaWVzLnB1c2goW3cuY2hhbm5lbCwgbWFwcGVkVmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3cml0ZSBlbnRyeTogJHtKU09OLnN0cmluZ2lmeSh3KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cml0ZSA9IGNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX1NFTkRdO1xuICAgICAgICB3cml0ZSh3cml0ZUVudHJpZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNXcml0ZXIocnVubmFibGUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICBydW5uYWJsZSBpbnN0YW5jZW9mIENoYW5uZWxXcml0ZSB8fFxuICAgICAgICAgICAgKElTX1dSSVRFUiBpbiBydW5uYWJsZSAmJiAhIXJ1bm5hYmxlW0lTX1dSSVRFUl0pKTtcbiAgICB9XG4gICAgc3RhdGljIHJlZ2lzdGVyV3JpdGVyKHJ1bm5hYmxlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocnVubmFibGUsIElTX1dSSVRFUiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBfaXNDaGFubmVsV3JpdGVFbnRyeSh4KSB7XG4gICAgcmV0dXJuICh4ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHguY2hhbm5lbCA9PT0gXCJzdHJpbmdcIik7XG59XG5mdW5jdGlvbiBfaXNDaGFubmVsV3JpdGVUdXBsZUVudHJ5KHgpIHtcbiAgICByZXR1cm4gKHggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhX2lzQ2hhbm5lbFdyaXRlRW50cnkoeCkgJiZcbiAgICAgICAgUnVubmFibGUuaXNSdW5uYWJsZSh4Lm1hcHBlcikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JpdGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/pregel/write.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/setup/async_local_storage.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/setup/async_local_storage.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeAsyncLocalStorageSingleton: () => (/* binding */ initializeAsyncLocalStorageSingleton)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/singletons */ \"(rsc)/./node_modules/@langchain/core/singletons.js\");\n/* harmony import */ var node_async_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\n\n\nfunction initializeAsyncLocalStorageSingleton() {\n    _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.initializeGlobalInstance(new node_async_hooks__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorage());\n}\n//# sourceMappingURL=async_local_storage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9zZXR1cC9hc3luY19sb2NhbF9zdG9yYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnRjtBQUMzQjtBQUM5QztBQUNQLElBQUksMEZBQWtDLDhCQUE4QiwrREFBaUI7QUFDckY7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXGRpc3RcXHNldHVwXFxhc3luY19sb2NhbF9zdG9yYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3NpbmdsZXRvbnNcIjtcbmltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlIH0gZnJvbSBcIm5vZGU6YXN5bmNfaG9va3NcIjtcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQXN5bmNMb2NhbFN0b3JhZ2VTaW5nbGV0b24oKSB7XG4gICAgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5pbml0aWFsaXplR2xvYmFsSW5zdGFuY2UobmV3IEFzeW5jTG9jYWxTdG9yYWdlKCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmNfbG9jYWxfc3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/setup/async_local_storage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunnableCallable: () => (/* binding */ RunnableCallable),\n/* harmony export */   gatherIterator: () => (/* binding */ gatherIterator),\n/* harmony export */   gatherIteratorSync: () => (/* binding */ gatherIteratorSync),\n/* harmony export */   isAsyncGeneratorFunction: () => (/* binding */ isAsyncGeneratorFunction),\n/* harmony export */   isGeneratorFunction: () => (/* binding */ isGeneratorFunction),\n/* harmony export */   patchConfigurable: () => (/* binding */ patchConfigurable),\n/* harmony export */   prefixGenerator: () => (/* binding */ prefixGenerator)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/singletons */ \"(rsc)/./node_modules/@langchain/core/singletons.js\");\n/* harmony import */ var _pregel_utils_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pregel/utils/config.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/pregel/utils/config.js\");\n\n\n\nclass RunnableCallable extends _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    constructor(fields) {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langgraph\"]\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"recurse\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.name = fields.name ?? fields.func.name;\n        this.func = fields.func;\n        this.config = fields.tags ? { tags: fields.tags } : undefined;\n        this.trace = fields.trace ?? this.trace;\n        this.recurse = fields.recurse ?? this.recurse;\n    }\n    async _tracedInvoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.patchConfig)(config, {\n                callbacks: runManager?.getChild(),\n            });\n            void _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n                try {\n                    const output = await this.func(input, childConfig);\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnValue;\n        const config = (0,_pregel_utils_config_js__WEBPACK_IMPORTED_MODULE_2__.ensureLangGraphConfig)(options);\n        const mergedConfig = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(this.config, config);\n        if (this.trace) {\n            returnValue = await this._callWithConfig(this._tracedInvoke, input, mergedConfig);\n        }\n        else {\n            returnValue = await _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.runWithConfig(mergedConfig, async () => this.func(input, mergedConfig));\n        }\n        if (_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(returnValue) && this.recurse) {\n            return await _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.runWithConfig(mergedConfig, async () => returnValue.invoke(input, mergedConfig));\n        }\n        return returnValue;\n    }\n}\nfunction* prefixGenerator(generator, prefix) {\n    if (prefix === undefined) {\n        yield* generator;\n    }\n    else {\n        for (const value of generator) {\n            yield [prefix, value];\n        }\n    }\n}\n// https://github.com/tc39/proposal-array-from-async\nasync function gatherIterator(i) {\n    const out = [];\n    for await (const item of await i) {\n        out.push(item);\n    }\n    return out;\n}\nfunction gatherIteratorSync(i) {\n    const out = [];\n    for (const item of i) {\n        out.push(item);\n    }\n    return out;\n}\nfunction patchConfigurable(config, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\npatch) {\n    if (!config) {\n        return {\n            configurable: patch,\n        };\n    }\n    else if (!(\"configurable\" in config)) {\n        return {\n            ...config,\n            configurable: patch,\n        };\n    }\n    else {\n        return {\n            ...config,\n            configurable: {\n                ...config.configurable,\n                ...patch,\n            },\n        };\n    }\n}\nfunction isAsyncGeneratorFunction(val) {\n    return (val != null &&\n        typeof val === \"function\" &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        val instanceof Object.getPrototypeOf(async function* () { }).constructor);\n}\nfunction isGeneratorFunction(val) {\n    return (val != null &&\n        typeof val === \"function\" &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        val instanceof Object.getPrototypeOf(function* () { }).constructor);\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWlGO0FBQ0Q7QUFDZjtBQUMxRCwrQkFBK0IsK0RBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzRUFBVztBQUMzQztBQUNBLGFBQWE7QUFDYixpQkFBaUIsMEZBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhFQUFxQjtBQUM1Qyw2QkFBNkIsdUVBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEZBQWtDO0FBQ2xFO0FBQ0EsWUFBWSwrREFBUTtBQUNwQix5QkFBeUIsMEZBQWtDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXGRpc3RcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1lcmdlQ29uZmlncywgcGF0Y2hDb25maWcsIFJ1bm5hYmxlLCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9zaW5nbGV0b25zXCI7XG5pbXBvcnQgeyBlbnN1cmVMYW5nR3JhcGhDb25maWcgfSBmcm9tIFwiLi9wcmVnZWwvdXRpbHMvY29uZmlnLmpzXCI7XG5leHBvcnQgY2xhc3MgUnVubmFibGVDYWxsYWJsZSBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nZ3JhcGhcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlY3Vyc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lID8/IGZpZWxkcy5mdW5jLm5hbWU7XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGZpZWxkcy50YWdzID8geyB0YWdzOiBmaWVsZHMudGFncyB9IDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRyYWNlID0gZmllbGRzLnRyYWNlID8/IHRoaXMudHJhY2U7XG4gICAgICAgIHRoaXMucmVjdXJzZSA9IGZpZWxkcy5yZWN1cnNlID8/IHRoaXMucmVjdXJzZTtcbiAgICB9XG4gICAgYXN5bmMgX3RyYWNlZEludm9rZShpbnB1dCwgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENvbmZpZyA9IHBhdGNoQ29uZmlnKGNvbmZpZywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdm9pZCBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcoY2hpbGRDb25maWcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCB0aGlzLmZ1bmMoaW5wdXQsIGNoaWxkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpbnB1dCwgb3B0aW9uc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlTGFuZ0dyYXBoQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtZXJnZWRDb25maWcgPSBtZXJnZUNvbmZpZ3ModGhpcy5jb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGF3YWl0IHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX3RyYWNlZEludm9rZSwgaW5wdXQsIG1lcmdlZENvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGF3YWl0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhtZXJnZWRDb25maWcsIGFzeW5jICgpID0+IHRoaXMuZnVuYyhpbnB1dCwgbWVyZ2VkQ29uZmlnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJ1bm5hYmxlLmlzUnVubmFibGUocmV0dXJuVmFsdWUpICYmIHRoaXMucmVjdXJzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhtZXJnZWRDb25maWcsIGFzeW5jICgpID0+IHJldHVyblZhbHVlLmludm9rZShpbnB1dCwgbWVyZ2VkQ29uZmlnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiogcHJlZml4R2VuZXJhdG9yKGdlbmVyYXRvciwgcHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHlpZWxkKiBnZW5lcmF0b3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgeWllbGQgW3ByZWZpeCwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZnJvbS1hc3luY1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdhdGhlckl0ZXJhdG9yKGkpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgYXdhaXQgaSkge1xuICAgICAgICBvdXQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnYXRoZXJJdGVyYXRvclN5bmMoaSkge1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpKSB7XG4gICAgICAgIG91dC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoQ29uZmlndXJhYmxlKGNvbmZpZywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucGF0Y2gpIHtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBwYXRjaCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIShcImNvbmZpZ3VyYWJsZVwiIGluIGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogcGF0Y2gsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB7XG4gICAgICAgICAgICAgICAgLi4uY29uZmlnLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgICAuLi5wYXRjaCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNHZW5lcmF0b3JGdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gKHZhbCAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIHZhbCBpbnN0YW5jZW9mIE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbiogKCkgeyB9KS5jb25zdHJ1Y3Rvcik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gKHZhbCAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIHZhbCBpbnN0YW5jZW9mIE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiogKCkgeyB9KS5jb25zdHJ1Y3Rvcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/dist/web.js":
/*!*******************************************************!*\
  !*** ./node_modules/@langchain/langgraph/dist/web.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.Annotation),\n/* harmony export */   AsyncBatchedStore: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.AsyncBatchedStore),\n/* harmony export */   BaseChannel: () => (/* reexport safe */ _channels_index_js__WEBPACK_IMPORTED_MODULE_2__.BaseChannel),\n/* harmony export */   BaseCheckpointSaver: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.BaseCheckpointSaver),\n/* harmony export */   BaseLangGraphError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.BaseLangGraphError),\n/* harmony export */   BaseStore: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.BaseStore),\n/* harmony export */   BinaryOperatorAggregate: () => (/* reexport safe */ _channels_index_js__WEBPACK_IMPORTED_MODULE_2__.BinaryOperatorAggregate),\n/* harmony export */   ChannelKeyPlaceholder: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.ChannelKeyPlaceholder),\n/* harmony export */   Command: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_3__.Command),\n/* harmony export */   CompiledStateGraph: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.CompiledStateGraph),\n/* harmony export */   END: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_3__.END),\n/* harmony export */   EmptyChannelError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError),\n/* harmony export */   EmptyInputError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyInputError),\n/* harmony export */   Graph: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.Graph),\n/* harmony export */   GraphBubbleUp: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.GraphBubbleUp),\n/* harmony export */   GraphInterrupt: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.GraphInterrupt),\n/* harmony export */   GraphRecursionError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.GraphRecursionError),\n/* harmony export */   GraphValueError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.GraphValueError),\n/* harmony export */   InMemoryStore: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.InMemoryStore),\n/* harmony export */   InvalidUpdateError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidUpdateError),\n/* harmony export */   IsLastStepManager: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.IsLastStepManager),\n/* harmony export */   ManagedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.ManagedValue),\n/* harmony export */   ManagedValueMapping: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.ManagedValueMapping),\n/* harmony export */   MemorySaver: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.MemorySaver),\n/* harmony export */   MessageGraph: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.MessageGraph),\n/* harmony export */   MessagesAnnotation: () => (/* reexport safe */ _graph_messages_annotation_js__WEBPACK_IMPORTED_MODULE_7__.MessagesAnnotation),\n/* harmony export */   MessagesZodState: () => (/* reexport safe */ _graph_messages_annotation_js__WEBPACK_IMPORTED_MODULE_7__.MessagesZodState),\n/* harmony export */   MultipleSubgraphsError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.MultipleSubgraphsError),\n/* harmony export */   NodeInterrupt: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.NodeInterrupt),\n/* harmony export */   NoopManagedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.NoopManagedValue),\n/* harmony export */   ParentCommand: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.ParentCommand),\n/* harmony export */   REMOVE_ALL_MESSAGES: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.REMOVE_ALL_MESSAGES),\n/* harmony export */   RemoteException: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.RemoteException),\n/* harmony export */   START: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_3__.START),\n/* harmony export */   Send: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_3__.Send),\n/* harmony export */   SharedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.SharedValue),\n/* harmony export */   StateGraph: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.StateGraph),\n/* harmony export */   UnreachableNodeError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.UnreachableNodeError),\n/* harmony export */   WritableManagedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.WritableManagedValue),\n/* harmony export */   addMessages: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.messagesStateReducer),\n/* harmony export */   copyCheckpoint: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.copyCheckpoint),\n/* harmony export */   emptyCheckpoint: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.emptyCheckpoint),\n/* harmony export */   entrypoint: () => (/* reexport safe */ _func_index_js__WEBPACK_IMPORTED_MODULE_6__.entrypoint),\n/* harmony export */   getSubgraphsSeenSet: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.getSubgraphsSeenSet),\n/* harmony export */   isCommand: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_3__.isCommand),\n/* harmony export */   isConfiguredManagedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.isConfiguredManagedValue),\n/* harmony export */   isGraphBubbleUp: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.isGraphBubbleUp),\n/* harmony export */   isGraphInterrupt: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.isGraphInterrupt),\n/* harmony export */   isManagedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.isManagedValue),\n/* harmony export */   isParentCommand: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.isParentCommand),\n/* harmony export */   messagesStateReducer: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.messagesStateReducer),\n/* harmony export */   task: () => (/* reexport safe */ _func_index_js__WEBPACK_IMPORTED_MODULE_6__.task)\n/* harmony export */ });\n/* harmony import */ var _graph_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _channels_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./channels/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/channels/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @langchain/langgraph-checkpoint */ \"(rsc)/./node_modules/@langchain/langgraph-checkpoint/index.js\");\n/* harmony import */ var _managed_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./managed/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/managed/index.js\");\n/* harmony import */ var _func_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./func/index.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/func/index.js\");\n/* harmony import */ var _graph_messages_annotation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./graph/messages_annotation.js */ \"(rsc)/./node_modules/@langchain/langgraph/dist/graph/messages_annotation.js\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=web.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC93ZWIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9MO0FBQ3hKO0FBQ2dEO0FBQ0w7QUFDMkY7QUFDL0g7QUFDaUI7QUFDbUM7QUFDdkYiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxkaXN0XFx3ZWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgR3JhcGgsIFN0YXRlR3JhcGgsIENvbXBpbGVkU3RhdGVHcmFwaCwgTWVzc2FnZUdyYXBoLCBtZXNzYWdlc1N0YXRlUmVkdWNlciwgbWVzc2FnZXNTdGF0ZVJlZHVjZXIgYXMgYWRkTWVzc2FnZXMsIFJFTU9WRV9BTExfTUVTU0FHRVMsIEFubm90YXRpb24sIH0gZnJvbSBcIi4vZ3JhcGgvaW5kZXguanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZXhwb3J0IHsgQmFzZUNoYW5uZWwsIEJpbmFyeU9wZXJhdG9yQWdncmVnYXRlLCB9IGZyb20gXCIuL2NoYW5uZWxzL2luZGV4LmpzXCI7XG5leHBvcnQgeyBTZW5kLCBDb21tYW5kLCBpc0NvbW1hbmQsIFNUQVJULCBFTkQsIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5leHBvcnQgeyBNZW1vcnlTYXZlciwgY29weUNoZWNrcG9pbnQsIGVtcHR5Q2hlY2twb2ludCwgQmFzZUNoZWNrcG9pbnRTYXZlciwgQmFzZVN0b3JlLCBBc3luY0JhdGNoZWRTdG9yZSwgSW5NZW1vcnlTdG9yZSwgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWFuYWdlZC9pbmRleC5qc1wiO1xuZXhwb3J0IHsgZW50cnlwb2ludCwgdGFzaywgfSBmcm9tIFwiLi9mdW5jL2luZGV4LmpzXCI7XG5leHBvcnQgeyBNZXNzYWdlc0Fubm90YXRpb24sIE1lc3NhZ2VzWm9kU3RhdGUsIH0gZnJvbSBcIi4vZ3JhcGgvbWVzc2FnZXNfYW5ub3RhdGlvbi5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/dist/web.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/langgraph/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Annotation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Annotation),
/* harmony export */   AsyncBatchedStore: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncBatchedStore),
/* harmony export */   BaseChannel: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseChannel),
/* harmony export */   BaseCheckpointSaver: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseCheckpointSaver),
/* harmony export */   BaseLangGraphError: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseLangGraphError),
/* harmony export */   BaseStore: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseStore),
/* harmony export */   BinaryOperatorAggregate: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.BinaryOperatorAggregate),
/* harmony export */   ChannelKeyPlaceholder: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.ChannelKeyPlaceholder),
/* harmony export */   Command: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Command),
/* harmony export */   CompiledStateGraph: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.CompiledStateGraph),
/* harmony export */   END: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.END),
/* harmony export */   EmptyChannelError: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError),
/* harmony export */   EmptyInputError: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.EmptyInputError),
/* harmony export */   Graph: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Graph),
/* harmony export */   GraphBubbleUp: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.GraphBubbleUp),
/* harmony export */   GraphInterrupt: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.GraphInterrupt),
/* harmony export */   GraphRecursionError: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.GraphRecursionError),
/* harmony export */   GraphValueError: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.GraphValueError),
/* harmony export */   InMemoryStore: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.InMemoryStore),
/* harmony export */   InvalidUpdateError: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUpdateError),
/* harmony export */   IsLastStepManager: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.IsLastStepManager),
/* harmony export */   ManagedValue: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.ManagedValue),
/* harmony export */   ManagedValueMapping: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.ManagedValueMapping),
/* harmony export */   MemorySaver: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.MemorySaver),
/* harmony export */   MessageGraph: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.MessageGraph),
/* harmony export */   MessagesAnnotation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.MessagesAnnotation),
/* harmony export */   MessagesZodState: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.MessagesZodState),
/* harmony export */   MultipleSubgraphsError: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.MultipleSubgraphsError),
/* harmony export */   NodeInterrupt: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.NodeInterrupt),
/* harmony export */   NoopManagedValue: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.NoopManagedValue),
/* harmony export */   ParentCommand: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.ParentCommand),
/* harmony export */   REMOVE_ALL_MESSAGES: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.REMOVE_ALL_MESSAGES),
/* harmony export */   RemoteException: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RemoteException),
/* harmony export */   START: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.START),
/* harmony export */   Send: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Send),
/* harmony export */   SharedValue: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.SharedValue),
/* harmony export */   StateGraph: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.StateGraph),
/* harmony export */   UnreachableNodeError: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.UnreachableNodeError),
/* harmony export */   WritableManagedValue: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.WritableManagedValue),
/* harmony export */   addMessages: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.addMessages),
/* harmony export */   copyCheckpoint: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.copyCheckpoint),
/* harmony export */   emptyCheckpoint: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.emptyCheckpoint),
/* harmony export */   entrypoint: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.entrypoint),
/* harmony export */   getConfig: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getConfig),
/* harmony export */   getCurrentTaskInput: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTaskInput),
/* harmony export */   getPreviousState: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getPreviousState),
/* harmony export */   getStore: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getStore),
/* harmony export */   getSubgraphsSeenSet: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getSubgraphsSeenSet),
/* harmony export */   getWriter: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getWriter),
/* harmony export */   interrupt: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.interrupt),
/* harmony export */   isCommand: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isCommand),
/* harmony export */   isConfiguredManagedValue: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isConfiguredManagedValue),
/* harmony export */   isGraphBubbleUp: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isGraphBubbleUp),
/* harmony export */   isGraphInterrupt: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isGraphInterrupt),
/* harmony export */   isManagedValue: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isManagedValue),
/* harmony export */   isParentCommand: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isParentCommand),
/* harmony export */   messagesStateReducer: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.messagesStateReducer),
/* harmony export */   task: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.task)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "(rsc)/./node_modules/@langchain/langgraph/dist/index.js");


/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/native.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/native.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uYXRpdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlDO0FBQ2pDLGlFQUFlO0FBQ2YsY0FBYywrREFBaUI7QUFDL0IsQ0FBQyIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXG5hdGl2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmFuZG9tVVVJRDogY3J5cHRvLnJhbmRvbVVVSURcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/regex.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/regex.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYyxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxHQUFHLDhFQUE4RSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXHJlZ2V4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtOF1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwfGZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZikkL2k7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/rng.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/rng.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9ybmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlDO0FBQ2pDLHVDQUF1QztBQUN2QztBQUNlO0FBQ2Y7QUFDQSxJQUFJLGlFQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXHJuZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmNvbnN0IHJuZHM4UG9vbCA9IG5ldyBVaW50OEFycmF5KDI1Nik7IC8vICMgb2YgcmFuZG9tIHZhbHVlcyB0byBwcmUtYWxsb2NhdGVcbmxldCBwb29sUHRyID0gcm5kczhQb29sLmxlbmd0aDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgaWYgKHBvb2xQdHIgPiBybmRzOFBvb2wubGVuZ3RoIC0gMTYpIHtcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocm5kczhQb29sKTtcbiAgICBwb29sUHRyID0gMDtcbiAgfVxuICByZXR1cm4gcm5kczhQb29sLnNsaWNlKHBvb2xQdHIsIHBvb2xQdHIgKz0gMTYpO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/stringify.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/stringify.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sd0RBQVE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLFNBQVMiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1ub2RlXFxzdHJpbmdpZnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc2xpY2UoMSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIC8vXG4gIC8vIE5vdGUgdG8gZnV0dXJlLXNlbGY6IE5vLCB5b3UgY2FuJ3QgcmVtb3ZlIHRoZSBgdG9Mb3dlckNhc2UoKWAgY2FsbC5cbiAgLy8gUkVGOiBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC82NzcjaXNzdWVjb21tZW50LTE3NTczNTEzNTFcbiAgcmV0dXJuIChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7XG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgcmV0dXJuIHV1aWQ7XG59XG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/v4.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/v4.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlDO0FBQ047QUFDc0I7QUFDakQ7QUFDQSxNQUFNLGtEQUFNO0FBQ1osV0FBVyxrREFBTTtBQUNqQjtBQUNBO0FBQ0EsaURBQWlELCtDQUFHOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFlO0FBQ3hCO0FBQ0EsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsiRDpcXOW3peS9nOebruW9lVxcZHJvbmV3b3JrZmxvd1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxsYW5nZ3JhcGhcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXHY0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuYXRpdmUgZnJvbSAnLi9uYXRpdmUuanMnO1xuaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHY0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/validate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/validate.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92YWxpZGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQUMvQjtBQUNBLHFDQUFxQyxpREFBSztBQUMxQztBQUNBLGlFQUFlLFFBQVEiLCJzb3VyY2VzIjpbIkQ6XFzlt6XkvZznm67lvZVcXGRyb25ld29ya2Zsb3dcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcbGFuZ2dyYXBoXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1ub2RlXFx2YWxpZGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ })

};
;